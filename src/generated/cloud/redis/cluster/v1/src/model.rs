// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for [CreateCluster][CloudRedis.CreateCluster].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The resource name of the cluster location using the form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Required. The logical name of the Redis cluster in the customer project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the customer project / location
    pub cluster_id: std::string::String,

    /// Required. The cluster that is to be created.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cluster_id,
            __cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClusterRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [ListClusters][CloudRedis.ListClusters].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The resource name of the cluster location using the form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListClustersResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListClustersResponse.next_page_token]: crate::model::ListClustersResponse::next_page_token
    pub page_size: i32,

    /// The `next_page_token` value returned from a previous
    /// [ListClusters][CloudRedis.ListClusters] request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for [ListClusters][CloudRedis.ListClusters].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// A list of Redis clusters in the project in the specified location,
    /// or across all locations.
    ///
    /// If the `location_id` in the parent field of the request is "-", all regions
    /// available to the project are queried, and the results aggregated.
    /// If in such an aggregated query a location is unavailable, a placeholder
    /// Redis entry is included in the response with the `name` field set to a
    /// value of the form
    /// `projects/{project_id}/locations/{location_id}/clusters/`- and the
    /// `status` field set to ERROR and `status_message` field set to "location not
    /// available for ListClusters".
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersResponse");
        debug_struct.field("clusters", &self.clusters);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [UpdateCluster][CloudRedis.UpdateCluster].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field may only include these
    /// fields from [Cluster][google.cloud.redis.cluster.v1.Cluster]:
    ///
    /// * `size_gb`
    /// * `replica_count`
    ///
    /// [google.cloud.redis.cluster.v1.Cluster]: crate::model::Cluster
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in update_mask are updated.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.UpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateClusterRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [GetCluster][CloudRedis.GetCluster].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [DeleteCluster][CloudRedis.DeleteCluster].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteClusterRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for
/// [GetClusterCertificateAuthorityRequest][CloudRedis.GetClusterCertificateAuthorityRequest].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterCertificateAuthorityRequest {
    /// Required. Redis cluster certificate authority resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}/certificateAuthority`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetClusterCertificateAuthorityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterCertificateAuthorityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for GetClusterCertificateAuthorityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterCertificateAuthorityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterCertificateAuthorityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterCertificateAuthorityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetClusterCertificateAuthorityRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterCertificateAuthorityRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [ListBackupCollections]
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupCollectionsRequest {
    /// Required. The resource name of the backupCollection location using the
    /// form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListBackupCollectionsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListBackupCollectionsResponse.next_page_token]: crate::model::ListBackupCollectionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupCollectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupCollectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupCollectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupCollectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupCollectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupCollectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupCollectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupCollectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupCollectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupCollectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupCollectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupCollectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for [ListBackupCollections].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupCollectionsResponse {
    /// A list of backupCollections in the project.
    ///
    /// If the `location_id` in the parent field of the request is "-", all regions
    /// available to the project are queried, and the results aggregated.
    /// If in such an aggregated query a location is unavailable, a placeholder
    /// backupCollection entry is included in the response with the `name` field
    /// set to a value of the form
    /// `projects/{project_id}/locations/{location_id}/backupCollections/`- and the
    /// `status` field set to ERROR and `status_message` field set to "location not
    /// available for ListBackupCollections".
    pub backup_collections: std::vec::Vec<crate::model::BackupCollection>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupCollectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backup_collections][crate::model::ListBackupCollectionsResponse::backup_collections].
    pub fn set_backup_collections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupCollection>,
    {
        use std::iter::Iterator;
        self.backup_collections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupCollectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupCollectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupCollectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupCollectionsResponse {
    type PageItem = crate::model::BackupCollection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_collections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupCollectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backup_collections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupCollectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backupCollections" => Ok(__FieldTag::__backup_collections),
                            "backup_collections" => Ok(__FieldTag::__backup_collections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupCollectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupCollectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backup_collections => {
                            if !fields.insert(__FieldTag::__backup_collections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_collections",
                                ));
                            }
                            result.backup_collections =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::BackupCollection>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupCollectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backup_collections.is_empty() {
            state.serialize_entry("backupCollections", &self.backup_collections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupCollectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupCollectionsResponse");
        debug_struct.field("backup_collections", &self.backup_collections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [GetBackupCollection].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupCollectionRequest {
    /// Required. Redis backupCollection resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupCollectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupCollectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupCollectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetBackupCollectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupCollectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupCollectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupCollectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupCollectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupCollectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBackupCollectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupCollectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [ListBackups].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The resource name of the backupCollection using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListBackupsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response for [ListBackups].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project.
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Backups that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListBackupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __backups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListBackupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "backups" => Ok(__FieldTag::__backups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListBackupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListBackupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__backups => {
                            if !fields.insert(__FieldTag::__backups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backups",
                                ));
                            }
                            result.backups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Backup>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListBackupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.backups.is_empty() {
            state.serialize_entry("backups", &self.backups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListBackupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListBackupsResponse");
        debug_struct.field("backups", &self.backups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [GetBackup].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetBackupRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [DeleteBackup].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    pub name: std::string::String,

    /// Optional. Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DeleteBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request for [ExportBackup].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExportBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    pub name: std::string::String,

    /// Required. Specify destination to export a backup.
    pub destination: std::option::Option<crate::model::export_backup_request::Destination>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExportBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [destination][crate::model::ExportBackupRequest::destination].
    ///
    /// Note that all the setters affecting `destination` are mutually
    /// exclusive.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_backup_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportBackupRequest::destination]
    /// if it holds a `GcsBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_bucket(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_backup_request::Destination::GcsBucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportBackupRequest::destination]
    /// to hold a `GcsBucket`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_backup_request::Destination::GcsBucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ExportBackupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExportBackupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_bucket,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExportBackupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsBucket" => Ok(__FieldTag::__gcs_bucket),
                            "gcs_bucket" => Ok(__FieldTag::__gcs_bucket),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExportBackupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExportBackupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_bucket => {
                            if !fields.insert(__FieldTag::__gcs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_bucket",
                                ));
                            }
                            if result.destination.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `destination`, a oneof with full ID .google.cloud.redis.cluster.v1.ExportBackupRequest.gcs_bucket, latest field was gcsBucket",
                                ));
                            }
                            result.destination = std::option::Option::Some(
                                crate::model::export_backup_request::Destination::GcsBucket(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExportBackupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_bucket() {
            state.serialize_entry("gcsBucket", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExportBackupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExportBackupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("destination", &self.destination);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ExportBackupRequest].
pub mod export_backup_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify destination to export a backup.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage bucket, like "my-bucket".
        GcsBucket(std::string::String),
    }
}

/// Request for [BackupCluster].
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Optional. TTL for the backup to expire. Value range is 1 day to 100 years.
    /// If not specified, the default value is 100 years.
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. The id of the backup to be created. If not specified, the
    /// default value ([YYYYMMDDHHMMSS]_[Shortened Cluster UID] is used.
    pub backup_id: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::BackupClusterRequest::ttl].
    pub fn set_ttl<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [ttl][crate::model::BackupClusterRequest::ttl].
    pub fn set_or_clear_ttl<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.ttl = v.map(|x| x.into());
        self
    }

    /// Sets the value of [backup_id][crate::model::BackupClusterRequest::backup_id].
    pub fn set_backup_id<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_id = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_id][crate::model::BackupClusterRequest::backup_id].
    pub fn set_or_clear_backup_id<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_id = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __ttl,
            __backup_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "backupId" => Ok(__FieldTag::__backup_id),
                            "backup_id" => Ok(__FieldTag::__backup_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            result.ttl = map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__backup_id => {
                            if !fields.insert(__FieldTag::__backup_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_id",
                                ));
                            }
                            result.backup_id =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.ttl.is_some() {
            state.serialize_entry("ttl", &self.ttl)?;
        }
        if self.backup_id.is_some() {
            state.serialize_entry("backupId", &self.backup_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupClusterRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("ttl", &self.ttl);
        debug_struct.field("backup_id", &self.backup_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A cluster instance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// Required. Identifier. Unique name of the resource in this scope including
    /// project and location using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    pub name: std::string::String,

    /// Output only. The timestamp associated with the cluster creation request.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this cluster.
    /// Can be CREATING, READY, UPDATING, DELETING and SUSPENDED
    pub state: crate::model::cluster::State,

    /// Output only. System assigned, unique identifier for the cluster.
    pub uid: std::string::String,

    /// Optional. The number of replica nodes per shard.
    pub replica_count: std::option::Option<i32>,

    /// Optional. The authorization mode of the Redis cluster.
    /// If not provided, auth feature is disabled for the cluster.
    pub authorization_mode: crate::model::AuthorizationMode,

    /// Optional. The in-transit encryption for the Redis cluster.
    /// If not provided, encryption  is disabled for the cluster.
    pub transit_encryption_mode: crate::model::TransitEncryptionMode,

    /// Output only. Redis memory size in GB for the entire cluster rounded up to
    /// the next integer.
    pub size_gb: std::option::Option<i32>,

    /// Optional. Number of shards for the Redis cluster.
    pub shard_count: std::option::Option<i32>,

    /// Optional. Each PscConfig configures the consumer network where IPs will
    /// be designated to the cluster for client access through Private Service
    /// Connect Automation. Currently, only one PscConfig is supported.
    pub psc_configs: std::vec::Vec<crate::model::PscConfig>,

    /// Output only. Endpoints created on each given network, for Redis clients to
    /// connect to the cluster. Currently only one discovery endpoint is supported.
    pub discovery_endpoints: std::vec::Vec<crate::model::DiscoveryEndpoint>,

    /// Output only. The list of PSC connections that are auto-created through
    /// service connectivity automation.
    pub psc_connections: std::vec::Vec<crate::model::PscConnection>,

    /// Output only. Additional information about the current state of the cluster.
    pub state_info: std::option::Option<crate::model::cluster::StateInfo>,

    /// Optional. The type of a redis node in the cluster. NodeType determines the
    /// underlying machine-type of a redis node.
    pub node_type: crate::model::NodeType,

    /// Optional. Persistence config (RDB, AOF) for the cluster.
    pub persistence_config: std::option::Option<crate::model::ClusterPersistenceConfig>,

    /// Optional. Key/Value pairs of customer overrides for mutable Redis Configs
    pub redis_configs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Precise value of redis memory size in GB for the entire
    /// cluster.
    pub precise_size_gb: std::option::Option<f64>,

    /// Optional. This config will be used to determine how the customer wants us
    /// to distribute cluster resources within the region.
    pub zone_distribution_config: std::option::Option<crate::model::ZoneDistributionConfig>,

    /// Optional. Cross cluster replication config.
    pub cross_cluster_replication_config:
        std::option::Option<crate::model::CrossClusterReplicationConfig>,

    /// Optional. The delete operation will fail when the value is set to true.
    pub deletion_protection_enabled: std::option::Option<bool>,

    /// Optional. ClusterMaintenancePolicy determines when to allow or deny
    /// updates.
    pub maintenance_policy: std::option::Option<crate::model::ClusterMaintenancePolicy>,

    /// Output only. ClusterMaintenanceSchedule Output only Published maintenance
    /// schedule.
    pub maintenance_schedule: std::option::Option<crate::model::ClusterMaintenanceSchedule>,

    /// Output only. Service attachment details to configure Psc connections
    pub psc_service_attachments: std::vec::Vec<crate::model::PscServiceAttachment>,

    /// Optional. A list of cluster enpoints.
    pub cluster_endpoints: std::vec::Vec<crate::model::ClusterEndpoint>,

    /// Optional. Output only. The backup collection full resource name. Example:
    /// projects/{project}/locations/{location}/backupCollections/{collection}
    pub backup_collection: std::option::Option<std::string::String>,

    /// Optional. The KMS key used to encrypt the at-rest data of the cluster.
    pub kms_key: std::option::Option<std::string::String>,

    /// Optional. The automated backup config for the cluster.
    pub automated_backup_config: std::option::Option<crate::model::AutomatedBackupConfig>,

    /// Output only. Encryption information of the data at rest of the cluster.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// The source to import from.
    pub import_sources: std::option::Option<crate::model::cluster::ImportSources>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Cluster::replica_count].
    pub fn set_replica_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.replica_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [replica_count][crate::model::Cluster::replica_count].
    pub fn set_or_clear_replica_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.replica_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization_mode][crate::model::Cluster::authorization_mode].
    pub fn set_authorization_mode<T: std::convert::Into<crate::model::AuthorizationMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_mode = v.into();
        self
    }

    /// Sets the value of [transit_encryption_mode][crate::model::Cluster::transit_encryption_mode].
    pub fn set_transit_encryption_mode<
        T: std::convert::Into<crate::model::TransitEncryptionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transit_encryption_mode = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Cluster::size_gb].
    pub fn set_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [size_gb][crate::model::Cluster::size_gb].
    pub fn set_or_clear_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [shard_count][crate::model::Cluster::shard_count].
    pub fn set_shard_count<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.shard_count = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shard_count][crate::model::Cluster::shard_count].
    pub fn set_or_clear_shard_count<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<i32>,
    {
        self.shard_count = v.map(|x| x.into());
        self
    }

    /// Sets the value of [psc_configs][crate::model::Cluster::psc_configs].
    pub fn set_psc_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscConfig>,
    {
        use std::iter::Iterator;
        self.psc_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [discovery_endpoints][crate::model::Cluster::discovery_endpoints].
    pub fn set_discovery_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryEndpoint>,
    {
        use std::iter::Iterator;
        self.discovery_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_connections][crate::model::Cluster::psc_connections].
    pub fn set_psc_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscConnection>,
    {
        use std::iter::Iterator;
        self.psc_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state_info][crate::model::Cluster::state_info].
    pub fn set_state_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::StateInfo>,
    {
        self.state_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_info][crate::model::Cluster::state_info].
    pub fn set_or_clear_state_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::StateInfo>,
    {
        self.state_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_type][crate::model::Cluster::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::NodeType>>(mut self, v: T) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [persistence_config][crate::model::Cluster::persistence_config].
    pub fn set_persistence_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterPersistenceConfig>,
    {
        self.persistence_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [persistence_config][crate::model::Cluster::persistence_config].
    pub fn set_or_clear_persistence_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterPersistenceConfig>,
    {
        self.persistence_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [redis_configs][crate::model::Cluster::redis_configs].
    pub fn set_redis_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.redis_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [precise_size_gb][crate::model::Cluster::precise_size_gb].
    pub fn set_precise_size_gb<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.precise_size_gb = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [precise_size_gb][crate::model::Cluster::precise_size_gb].
    pub fn set_or_clear_precise_size_gb<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<f64>,
    {
        self.precise_size_gb = v.map(|x| x.into());
        self
    }

    /// Sets the value of [zone_distribution_config][crate::model::Cluster::zone_distribution_config].
    pub fn set_zone_distribution_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ZoneDistributionConfig>,
    {
        self.zone_distribution_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [zone_distribution_config][crate::model::Cluster::zone_distribution_config].
    pub fn set_or_clear_zone_distribution_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ZoneDistributionConfig>,
    {
        self.zone_distribution_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cross_cluster_replication_config][crate::model::Cluster::cross_cluster_replication_config].
    pub fn set_cross_cluster_replication_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CrossClusterReplicationConfig>,
    {
        self.cross_cluster_replication_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cross_cluster_replication_config][crate::model::Cluster::cross_cluster_replication_config].
    pub fn set_or_clear_cross_cluster_replication_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::CrossClusterReplicationConfig>,
    {
        self.cross_cluster_replication_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Cluster::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection_enabled = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [deletion_protection_enabled][crate::model::Cluster::deletion_protection_enabled].
    pub fn set_or_clear_deletion_protection_enabled<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<bool>,
    {
        self.deletion_protection_enabled = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMaintenancePolicy>,
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMaintenancePolicy>,
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_maintenance_schedule<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMaintenanceSchedule>,
    {
        self.maintenance_schedule = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_or_clear_maintenance_schedule<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterMaintenanceSchedule>,
    {
        self.maintenance_schedule = v.map(|x| x.into());
        self
    }

    /// Sets the value of [psc_service_attachments][crate::model::Cluster::psc_service_attachments].
    pub fn set_psc_service_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscServiceAttachment>,
    {
        use std::iter::Iterator;
        self.psc_service_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_endpoints][crate::model::Cluster::cluster_endpoints].
    pub fn set_cluster_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterEndpoint>,
    {
        use std::iter::Iterator;
        self.cluster_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [backup_collection][crate::model::Cluster::backup_collection].
    pub fn set_backup_collection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_collection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [backup_collection][crate::model::Cluster::backup_collection].
    pub fn set_or_clear_backup_collection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.backup_collection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [kms_key][crate::model::Cluster::kms_key].
    pub fn set_kms_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [kms_key][crate::model::Cluster::kms_key].
    pub fn set_or_clear_kms_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.kms_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [automated_backup_config][crate::model::Cluster::automated_backup_config].
    pub fn set_automated_backup_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupConfig>,
    {
        self.automated_backup_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [automated_backup_config][crate::model::Cluster::automated_backup_config].
    pub fn set_or_clear_automated_backup_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AutomatedBackupConfig>,
    {
        self.automated_backup_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [import_sources][crate::model::Cluster::import_sources].
    ///
    /// Note that all the setters affecting `import_sources` are mutually
    /// exclusive.
    pub fn set_import_sources<
        T: std::convert::Into<std::option::Option<crate::model::cluster::ImportSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = v.into();
        self
    }

    /// The value of [import_sources][crate::model::Cluster::import_sources]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::GcsBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::cluster::ImportSources::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_sources][crate::model::Cluster::import_sources]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::cluster::GcsBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources =
            std::option::Option::Some(crate::model::cluster::ImportSources::GcsSource(v.into()));
        self
    }

    /// The value of [import_sources][crate::model::Cluster::import_sources]
    /// if it holds a `ManagedBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::ManagedBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::cluster::ImportSources::ManagedBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_sources][crate::model::Cluster::import_sources]
    /// to hold a `ManagedBackupSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_managed_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::cluster::ManagedBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = std::option::Option::Some(
            crate::model::cluster::ImportSources::ManagedBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_source,
            __managed_backup_source,
            __name,
            __create_time,
            __state,
            __uid,
            __replica_count,
            __authorization_mode,
            __transit_encryption_mode,
            __size_gb,
            __shard_count,
            __psc_configs,
            __discovery_endpoints,
            __psc_connections,
            __state_info,
            __node_type,
            __persistence_config,
            __redis_configs,
            __precise_size_gb,
            __zone_distribution_config,
            __cross_cluster_replication_config,
            __deletion_protection_enabled,
            __maintenance_policy,
            __maintenance_schedule,
            __psc_service_attachments,
            __cluster_endpoints,
            __backup_collection,
            __kms_key,
            __automated_backup_config,
            __encryption_info,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsSource" => Ok(__FieldTag::__gcs_source),
                            "gcs_source" => Ok(__FieldTag::__gcs_source),
                            "managedBackupSource" => Ok(__FieldTag::__managed_backup_source),
                            "managed_backup_source" => Ok(__FieldTag::__managed_backup_source),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "state" => Ok(__FieldTag::__state),
                            "uid" => Ok(__FieldTag::__uid),
                            "replicaCount" => Ok(__FieldTag::__replica_count),
                            "replica_count" => Ok(__FieldTag::__replica_count),
                            "authorizationMode" => Ok(__FieldTag::__authorization_mode),
                            "authorization_mode" => Ok(__FieldTag::__authorization_mode),
                            "transitEncryptionMode" => Ok(__FieldTag::__transit_encryption_mode),
                            "transit_encryption_mode" => Ok(__FieldTag::__transit_encryption_mode),
                            "sizeGb" => Ok(__FieldTag::__size_gb),
                            "size_gb" => Ok(__FieldTag::__size_gb),
                            "shardCount" => Ok(__FieldTag::__shard_count),
                            "shard_count" => Ok(__FieldTag::__shard_count),
                            "pscConfigs" => Ok(__FieldTag::__psc_configs),
                            "psc_configs" => Ok(__FieldTag::__psc_configs),
                            "discoveryEndpoints" => Ok(__FieldTag::__discovery_endpoints),
                            "discovery_endpoints" => Ok(__FieldTag::__discovery_endpoints),
                            "pscConnections" => Ok(__FieldTag::__psc_connections),
                            "psc_connections" => Ok(__FieldTag::__psc_connections),
                            "stateInfo" => Ok(__FieldTag::__state_info),
                            "state_info" => Ok(__FieldTag::__state_info),
                            "nodeType" => Ok(__FieldTag::__node_type),
                            "node_type" => Ok(__FieldTag::__node_type),
                            "persistenceConfig" => Ok(__FieldTag::__persistence_config),
                            "persistence_config" => Ok(__FieldTag::__persistence_config),
                            "redisConfigs" => Ok(__FieldTag::__redis_configs),
                            "redis_configs" => Ok(__FieldTag::__redis_configs),
                            "preciseSizeGb" => Ok(__FieldTag::__precise_size_gb),
                            "precise_size_gb" => Ok(__FieldTag::__precise_size_gb),
                            "zoneDistributionConfig" => Ok(__FieldTag::__zone_distribution_config),
                            "zone_distribution_config" => {
                                Ok(__FieldTag::__zone_distribution_config)
                            }
                            "crossClusterReplicationConfig" => {
                                Ok(__FieldTag::__cross_cluster_replication_config)
                            }
                            "cross_cluster_replication_config" => {
                                Ok(__FieldTag::__cross_cluster_replication_config)
                            }
                            "deletionProtectionEnabled" => {
                                Ok(__FieldTag::__deletion_protection_enabled)
                            }
                            "deletion_protection_enabled" => {
                                Ok(__FieldTag::__deletion_protection_enabled)
                            }
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenanceSchedule" => Ok(__FieldTag::__maintenance_schedule),
                            "maintenance_schedule" => Ok(__FieldTag::__maintenance_schedule),
                            "pscServiceAttachments" => Ok(__FieldTag::__psc_service_attachments),
                            "psc_service_attachments" => Ok(__FieldTag::__psc_service_attachments),
                            "clusterEndpoints" => Ok(__FieldTag::__cluster_endpoints),
                            "cluster_endpoints" => Ok(__FieldTag::__cluster_endpoints),
                            "backupCollection" => Ok(__FieldTag::__backup_collection),
                            "backup_collection" => Ok(__FieldTag::__backup_collection),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "automatedBackupConfig" => Ok(__FieldTag::__automated_backup_config),
                            "automated_backup_config" => Ok(__FieldTag::__automated_backup_config),
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_source => {
                            if !fields.insert(__FieldTag::__gcs_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_source",
                                ));
                            }
                            if result.import_sources.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `import_sources`, a oneof with full ID .google.cloud.redis.cluster.v1.Cluster.gcs_source, latest field was gcsSource",
                                ));
                            }
                            result.import_sources = std::option::Option::Some(
                                crate::model::cluster::ImportSources::GcsSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::cluster::GcsBackupSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__managed_backup_source => {
                            if !fields.insert(__FieldTag::__managed_backup_source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_backup_source",
                                ));
                            }
                            if result.import_sources.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `import_sources`, a oneof with full ID .google.cloud.redis.cluster.v1.Cluster.managed_backup_source, latest field was managedBackupSource",
                                ));
                            }
                            result.import_sources = std::option::Option::Some(
                                crate::model::cluster::ImportSources::ManagedBackupSource(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::cluster::ManagedBackupSource>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::cluster::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_count => {
                            if !fields.insert(__FieldTag::__replica_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replica_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__authorization_mode => {
                            if !fields.insert(__FieldTag::__authorization_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization_mode",
                                ));
                            }
                            result.authorization_mode = map
                                .next_value::<std::option::Option<crate::model::AuthorizationMode>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transit_encryption_mode => {
                            if !fields.insert(__FieldTag::__transit_encryption_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transit_encryption_mode",
                                ));
                            }
                            result.transit_encryption_mode = map.next_value::<std::option::Option<crate::model::TransitEncryptionMode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__size_gb => {
                            if !fields.insert(__FieldTag::__size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gb = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__shard_count => {
                            if !fields.insert(__FieldTag::__shard_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shard_count = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__psc_configs => {
                            if !fields.insert(__FieldTag::__psc_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_configs",
                                ));
                            }
                            result.psc_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PscConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__discovery_endpoints => {
                            if !fields.insert(__FieldTag::__discovery_endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for discovery_endpoints",
                                ));
                            }
                            result.discovery_endpoints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiscoveryEndpoint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_connections => {
                            if !fields.insert(__FieldTag::__psc_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connections",
                                ));
                            }
                            result.psc_connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::PscConnection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_info => {
                            if !fields.insert(__FieldTag::__state_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_info",
                                ));
                            }
                            result.state_info = map.next_value::<std::option::Option<crate::model::cluster::StateInfo>>()?
                                ;
                        }
                        __FieldTag::__node_type => {
                            if !fields.insert(__FieldTag::__node_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_type",
                                ));
                            }
                            result.node_type = map
                                .next_value::<std::option::Option<crate::model::NodeType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__persistence_config => {
                            if !fields.insert(__FieldTag::__persistence_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for persistence_config",
                                ));
                            }
                            result.persistence_config = map.next_value::<std::option::Option<crate::model::ClusterPersistenceConfig>>()?
                                ;
                        }
                        __FieldTag::__redis_configs => {
                            if !fields.insert(__FieldTag::__redis_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for redis_configs",
                                ));
                            }
                            result.redis_configs = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__precise_size_gb => {
                            if !fields.insert(__FieldTag::__precise_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for precise_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.precise_size_gb = map.next_value::<__With>()?.0;
                        }
                        __FieldTag::__zone_distribution_config => {
                            if !fields.insert(__FieldTag::__zone_distribution_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone_distribution_config",
                                ));
                            }
                            result.zone_distribution_config = map.next_value::<std::option::Option<crate::model::ZoneDistributionConfig>>()?
                                ;
                        }
                        __FieldTag::__cross_cluster_replication_config => {
                            if !fields.insert(__FieldTag::__cross_cluster_replication_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cross_cluster_replication_config",
                                ));
                            }
                            result.cross_cluster_replication_config =
                                map.next_value::<std::option::Option<
                                    crate::model::CrossClusterReplicationConfig,
                                >>()?;
                        }
                        __FieldTag::__deletion_protection_enabled => {
                            if !fields.insert(__FieldTag::__deletion_protection_enabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for deletion_protection_enabled",
                                ));
                            }
                            result.deletion_protection_enabled =
                                map.next_value::<std::option::Option<bool>>()?;
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map.next_value::<std::option::Option<crate::model::ClusterMaintenancePolicy>>()?
                                ;
                        }
                        __FieldTag::__maintenance_schedule => {
                            if !fields.insert(__FieldTag::__maintenance_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_schedule",
                                ));
                            }
                            result.maintenance_schedule = map.next_value::<std::option::Option<crate::model::ClusterMaintenanceSchedule>>()?
                                ;
                        }
                        __FieldTag::__psc_service_attachments => {
                            if !fields.insert(__FieldTag::__psc_service_attachments) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_service_attachments",
                                ));
                            }
                            result.psc_service_attachments = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PscServiceAttachment>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_endpoints => {
                            if !fields.insert(__FieldTag::__cluster_endpoints) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_endpoints",
                                ));
                            }
                            result.cluster_endpoints =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClusterEndpoint>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_collection => {
                            if !fields.insert(__FieldTag::__backup_collection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_collection",
                                ));
                            }
                            result.backup_collection =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::__automated_backup_config => {
                            if !fields.insert(__FieldTag::__automated_backup_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_backup_config",
                                ));
                            }
                            result.automated_backup_config = map.next_value::<std::option::Option<crate::model::AutomatedBackupConfig>>()?
                                ;
                        }
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_source() {
            state.serialize_entry("gcsSource", value)?;
        }
        if let Some(value) = self.managed_backup_source() {
            state.serialize_entry("managedBackupSource", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if self.replica_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("replicaCount", &__With(&self.replica_count))?;
        }
        if !wkt::internal::is_default(&self.authorization_mode) {
            state.serialize_entry("authorizationMode", &self.authorization_mode)?;
        }
        if !wkt::internal::is_default(&self.transit_encryption_mode) {
            state.serialize_entry("transitEncryptionMode", &self.transit_encryption_mode)?;
        }
        if self.size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
        }
        if self.shard_count.is_some() {
            struct __With<'a>(&'a std::option::Option<i32>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("shardCount", &__With(&self.shard_count))?;
        }
        if !self.psc_configs.is_empty() {
            state.serialize_entry("pscConfigs", &self.psc_configs)?;
        }
        if !self.discovery_endpoints.is_empty() {
            state.serialize_entry("discoveryEndpoints", &self.discovery_endpoints)?;
        }
        if !self.psc_connections.is_empty() {
            state.serialize_entry("pscConnections", &self.psc_connections)?;
        }
        if self.state_info.is_some() {
            state.serialize_entry("stateInfo", &self.state_info)?;
        }
        if !wkt::internal::is_default(&self.node_type) {
            state.serialize_entry("nodeType", &self.node_type)?;
        }
        if self.persistence_config.is_some() {
            state.serialize_entry("persistenceConfig", &self.persistence_config)?;
        }
        if !self.redis_configs.is_empty() {
            state.serialize_entry("redisConfigs", &self.redis_configs)?;
        }
        if self.precise_size_gb.is_some() {
            struct __With<'a>(&'a std::option::Option<f64>);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<std::option::Option<wkt::internal::F64>>::serialize(
                        self.0, serializer,
                    )
                }
            }
            state.serialize_entry("preciseSizeGb", &__With(&self.precise_size_gb))?;
        }
        if self.zone_distribution_config.is_some() {
            state.serialize_entry("zoneDistributionConfig", &self.zone_distribution_config)?;
        }
        if self.cross_cluster_replication_config.is_some() {
            state.serialize_entry(
                "crossClusterReplicationConfig",
                &self.cross_cluster_replication_config,
            )?;
        }
        if self.deletion_protection_enabled.is_some() {
            state.serialize_entry(
                "deletionProtectionEnabled",
                &self.deletion_protection_enabled,
            )?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if self.maintenance_schedule.is_some() {
            state.serialize_entry("maintenanceSchedule", &self.maintenance_schedule)?;
        }
        if !self.psc_service_attachments.is_empty() {
            state.serialize_entry("pscServiceAttachments", &self.psc_service_attachments)?;
        }
        if !self.cluster_endpoints.is_empty() {
            state.serialize_entry("clusterEndpoints", &self.cluster_endpoints)?;
        }
        if self.backup_collection.is_some() {
            state.serialize_entry("backupCollection", &self.backup_collection)?;
        }
        if self.kms_key.is_some() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if self.automated_backup_config.is_some() {
            state.serialize_entry("automatedBackupConfig", &self.automated_backup_config)?;
        }
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("replica_count", &self.replica_count);
        debug_struct.field("authorization_mode", &self.authorization_mode);
        debug_struct.field("transit_encryption_mode", &self.transit_encryption_mode);
        debug_struct.field("size_gb", &self.size_gb);
        debug_struct.field("shard_count", &self.shard_count);
        debug_struct.field("psc_configs", &self.psc_configs);
        debug_struct.field("discovery_endpoints", &self.discovery_endpoints);
        debug_struct.field("psc_connections", &self.psc_connections);
        debug_struct.field("state_info", &self.state_info);
        debug_struct.field("node_type", &self.node_type);
        debug_struct.field("persistence_config", &self.persistence_config);
        debug_struct.field("redis_configs", &self.redis_configs);
        debug_struct.field("precise_size_gb", &self.precise_size_gb);
        debug_struct.field("zone_distribution_config", &self.zone_distribution_config);
        debug_struct.field(
            "cross_cluster_replication_config",
            &self.cross_cluster_replication_config,
        );
        debug_struct.field(
            "deletion_protection_enabled",
            &self.deletion_protection_enabled,
        );
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("maintenance_schedule", &self.maintenance_schedule);
        debug_struct.field("psc_service_attachments", &self.psc_service_attachments);
        debug_struct.field("cluster_endpoints", &self.cluster_endpoints);
        debug_struct.field("backup_collection", &self.backup_collection);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("automated_backup_config", &self.automated_backup_config);
        debug_struct.field("encryption_info", &self.encryption_info);
        debug_struct.field("import_sources", &self.import_sources);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Represents additional information about the state of the cluster.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct StateInfo {
        pub info: std::option::Option<crate::model::cluster::state_info::Info>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl StateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [info][crate::model::cluster::StateInfo::info].
        ///
        /// Note that all the setters affecting `info` are mutually
        /// exclusive.
        pub fn set_info<
            T: std::convert::Into<std::option::Option<crate::model::cluster::state_info::Info>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = v.into();
            self
        }

        /// The value of [info][crate::model::cluster::StateInfo::info]
        /// if it holds a `UpdateInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn update_info(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>>
        {
            #[allow(unreachable_patterns)]
            self.info.as_ref().and_then(|v| match v {
                crate::model::cluster::state_info::Info::UpdateInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [info][crate::model::cluster::StateInfo::info]
        /// to hold a `UpdateInfo`.
        ///
        /// Note that all the setters affecting `info` are
        /// mutually exclusive.
        pub fn set_update_info<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = std::option::Option::Some(
                crate::model::cluster::state_info::Info::UpdateInfo(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for StateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.StateInfo"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for StateInfo {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __update_info,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for StateInfo")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "updateInfo" => Ok(__FieldTag::__update_info),
                                "update_info" => Ok(__FieldTag::__update_info),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = StateInfo;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct StateInfo")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__update_info => {
                                if !fields.insert(__FieldTag::__update_info) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_info",
                                    ));
                                }
                                if result.info.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `info`, a oneof with full ID .google.cloud.redis.cluster.v1.Cluster.StateInfo.update_info, latest field was updateInfo",
                                    ));
                                }
                                result.info = std::option::Option::Some(
                                    crate::model::cluster::state_info::Info::UpdateInfo(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::cluster::state_info::UpdateInfo,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for StateInfo {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.update_info() {
                state.serialize_entry("updateInfo", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for StateInfo {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("StateInfo");
            debug_struct.field("info", &self.info);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [StateInfo].
    pub mod state_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents information about an updating cluster.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct UpdateInfo {
            /// Target number of shards for redis cluster
            pub target_shard_count: std::option::Option<i32>,

            /// Target number of replica nodes per shard.
            pub target_replica_count: std::option::Option<i32>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl UpdateInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target_shard_count][crate::model::cluster::state_info::UpdateInfo::target_shard_count].
            pub fn set_target_shard_count<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_shard_count = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_shard_count][crate::model::cluster::state_info::UpdateInfo::target_shard_count].
            pub fn set_or_clear_target_shard_count<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_shard_count = v.map(|x| x.into());
                self
            }

            /// Sets the value of [target_replica_count][crate::model::cluster::state_info::UpdateInfo::target_replica_count].
            pub fn set_target_replica_count<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_replica_count = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target_replica_count][crate::model::cluster::state_info::UpdateInfo::target_replica_count].
            pub fn set_or_clear_target_replica_count<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<i32>,
            {
                self.target_replica_count = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for UpdateInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for UpdateInfo {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __target_shard_count,
                    __target_replica_count,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for UpdateInfo")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "targetShardCount" => Ok(__FieldTag::__target_shard_count),
                                    "target_shard_count" => Ok(__FieldTag::__target_shard_count),
                                    "targetReplicaCount" => Ok(__FieldTag::__target_replica_count),
                                    "target_replica_count" => {
                                        Ok(__FieldTag::__target_replica_count)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = UpdateInfo;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct UpdateInfo")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__target_shard_count => {
                                    if !fields.insert(__FieldTag::__target_shard_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for target_shard_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.target_shard_count = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::__target_replica_count => {
                                    if !fields.insert(__FieldTag::__target_replica_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for target_replica_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.target_replica_count = map.next_value::<__With>()?.0;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for UpdateInfo {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.target_shard_count.is_some() {
                    struct __With<'a>(&'a std::option::Option<i32>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("targetShardCount", &__With(&self.target_shard_count))?;
                }
                if self.target_replica_count.is_some() {
                    struct __With<'a>(&'a std::option::Option<i32>);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<std::option::Option<wkt::internal::I32>>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry(
                        "targetReplicaCount",
                        &__With(&self.target_replica_count),
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for UpdateInfo {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("UpdateInfo");
                debug_struct.field("target_shard_count", &self.target_shard_count);
                debug_struct.field("target_replica_count", &self.target_replica_count);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Info {
            /// Describes ongoing update on the cluster when cluster state is UPDATING.
            UpdateInfo(std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>),
        }
    }

    /// Backups stored in Cloud Storage buckets.
    /// The Cloud Storage buckets need to be the same region as the clusters.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcsBackupSource {
        /// Optional. URIs of the GCS objects to import.
        /// Example: gs://bucket1/object1, gs://bucket2/folder2/object2
        pub uris: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcsBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uris][crate::model::cluster::GcsBackupSource::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcsBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.GcsBackupSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcsBackupSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uris,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcsBackupSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uris" => Ok(__FieldTag::__uris),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcsBackupSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcsBackupSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uris => {
                                if !fields.insert(__FieldTag::__uris) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uris",
                                    ));
                                }
                                result.uris = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcsBackupSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uris.is_empty() {
                state.serialize_entry("uris", &self.uris)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcsBackupSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcsBackupSource");
            debug_struct.field("uris", &self.uris);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Backups that generated and managed by memorystore.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ManagedBackupSource {
        /// Optional. Example:
        /// //redis.googleapis.com/projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}
        /// A shorter version (without the prefix) of the backup name is also
        /// supported, like
        /// projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup_id}
        /// In this case, it assumes the backup is under redis.googleapis.com.
        pub backup: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagedBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup][crate::model::cluster::ManagedBackupSource::backup].
        pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.backup = v.into();
            self
        }
    }

    impl wkt::message::Message for ManagedBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.ManagedBackupSource"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ManagedBackupSource {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __backup,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ManagedBackupSource")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "backup" => Ok(__FieldTag::__backup),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ManagedBackupSource;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ManagedBackupSource")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__backup => {
                                if !fields.insert(__FieldTag::__backup) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for backup",
                                    ));
                                }
                                result.backup = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ManagedBackupSource {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.backup.is_empty() {
                state.serialize_entry("backup", &self.backup)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ManagedBackupSource {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ManagedBackupSource");
            debug_struct.field("backup", &self.backup);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Represents the different states of a Redis cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// Redis cluster is being created.
        Creating,
        /// Redis cluster has been created and is fully usable.
        Active,
        /// Redis cluster configuration is being updated.
        Updating,
        /// Redis cluster is being deleted.
        Deleting,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Updating,
                4 => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.redis.cluster.v1.Cluster.State",
            ))
        }
    }

    /// The source to import from.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ImportSources {
        /// Optional. Backups stored in Cloud Storage buckets.
        /// The Cloud Storage buckets need to be the same region as the clusters.
        /// Read permission is required to import from the provided Cloud Storage
        /// objects.
        GcsSource(std::boxed::Box<crate::model::cluster::GcsBackupSource>),
        /// Optional. Backups generated and managed by memorystore service.
        ManagedBackupSource(std::boxed::Box<crate::model::cluster::ManagedBackupSource>),
    }
}

/// The automated backup config for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AutomatedBackupConfig {
    /// Optional. The automated backup mode. If the mode is disabled, the other
    /// fields will be ignored.
    pub automated_backup_mode: crate::model::automated_backup_config::AutomatedBackupMode,

    /// Optional. How long to keep automated backups before the backups are
    /// deleted. The value should be between 1 day and 365 days. If not specified,
    /// the default value is 35 days.
    pub retention: std::option::Option<wkt::Duration>,

    /// The schedule of automated backups.
    pub schedule: std::option::Option<crate::model::automated_backup_config::Schedule>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AutomatedBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automated_backup_mode][crate::model::AutomatedBackupConfig::automated_backup_mode].
    pub fn set_automated_backup_mode<
        T: std::convert::Into<crate::model::automated_backup_config::AutomatedBackupMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_mode = v.into();
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupConfig::retention].
    pub fn set_retention<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [retention][crate::model::AutomatedBackupConfig::retention].
    pub fn set_or_clear_retention<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.retention = v.map(|x| x.into());
        self
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupConfig::schedule].
    ///
    /// Note that all the setters affecting `schedule` are mutually
    /// exclusive.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_config::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// if it holds a `FixedFrequencySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn fixed_frequency_schedule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
    > {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// to hold a `FixedFrequencySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_fixed_frequency_schedule<
        T: std::convert::Into<
                std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.AutomatedBackupConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AutomatedBackupConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __fixed_frequency_schedule,
            __automated_backup_mode,
            __retention,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AutomatedBackupConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fixedFrequencySchedule" => Ok(__FieldTag::__fixed_frequency_schedule),
                            "fixed_frequency_schedule" => {
                                Ok(__FieldTag::__fixed_frequency_schedule)
                            }
                            "automatedBackupMode" => Ok(__FieldTag::__automated_backup_mode),
                            "automated_backup_mode" => Ok(__FieldTag::__automated_backup_mode),
                            "retention" => Ok(__FieldTag::__retention),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AutomatedBackupConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AutomatedBackupConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__fixed_frequency_schedule => {
                            if !fields.insert(__FieldTag::__fixed_frequency_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fixed_frequency_schedule",
                                ));
                            }
                            if result.schedule.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `schedule`, a oneof with full ID .google.cloud.redis.cluster.v1.AutomatedBackupConfig.fixed_frequency_schedule, latest field was fixedFrequencySchedule",
                                ));
                            }
                            result.schedule = std::option::Option::Some(
                                crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__automated_backup_mode => {
                            if !fields.insert(__FieldTag::__automated_backup_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for automated_backup_mode",
                                ));
                            }
                            result.automated_backup_mode = map
                                .next_value::<std::option::Option<
                                    crate::model::automated_backup_config::AutomatedBackupMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__retention => {
                            if !fields.insert(__FieldTag::__retention) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for retention",
                                ));
                            }
                            result.retention =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AutomatedBackupConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.fixed_frequency_schedule() {
            state.serialize_entry("fixedFrequencySchedule", value)?;
        }
        if !wkt::internal::is_default(&self.automated_backup_mode) {
            state.serialize_entry("automatedBackupMode", &self.automated_backup_mode)?;
        }
        if self.retention.is_some() {
            state.serialize_entry("retention", &self.retention)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AutomatedBackupConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AutomatedBackupConfig");
        debug_struct.field("automated_backup_mode", &self.automated_backup_mode);
        debug_struct.field("retention", &self.retention);
        debug_struct.field("schedule", &self.schedule);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AutomatedBackupConfig].
pub mod automated_backup_config {
    #[allow(unused_imports)]
    use super::*;

    /// This schedule allows the backup to be triggered at a fixed frequency
    /// (currently only daily is supported).
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FixedFrequencySchedule {
        /// Required. The start time of every automated backup in UTC. It must be set
        /// to the start of an hour. This field is required.
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FixedFrequencySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::automated_backup_config::FixedFrequencySchedule::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::automated_backup_config::FixedFrequencySchedule::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<gtype::model::TimeOfDay>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for FixedFrequencySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.AutomatedBackupConfig.FixedFrequencySchedule"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FixedFrequencySchedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __start_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FixedFrequencySchedule")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FixedFrequencySchedule;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FixedFrequencySchedule")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time = map
                                    .next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FixedFrequencySchedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for FixedFrequencySchedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("FixedFrequencySchedule");
            debug_struct.field("start_time", &self.start_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The automated backup mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AutomatedBackupMode {
        /// Default value. Automated backup config is not specified.
        Unspecified,
        /// Automated backup config disabled.
        Disabled,
        /// Automated backup config enabled.
        Enabled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AutomatedBackupMode::value] or
        /// [AutomatedBackupMode::name].
        UnknownValue(automated_backup_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod automated_backup_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AutomatedBackupMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Enabled => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("AUTOMATED_BACKUP_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AutomatedBackupMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AutomatedBackupMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AutomatedBackupMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Enabled,
                _ => Self::UnknownValue(automated_backup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AutomatedBackupMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "AUTOMATED_BACKUP_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "ENABLED" => Self::Enabled,
                _ => Self::UnknownValue(automated_backup_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AutomatedBackupMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Enabled => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AutomatedBackupMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AutomatedBackupMode>::new(
                ".google.cloud.redis.cluster.v1.AutomatedBackupConfig.AutomatedBackupMode",
            ))
        }
    }

    /// The schedule of automated backups.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Optional. Trigger automated backups at a fixed frequency.
        FixedFrequencySchedule(
            std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
        ),
    }
}

/// BackupCollection of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupCollection {
    /// Identifier. Full resource path of the backup collection.
    pub name: std::string::String,

    /// Output only. The cluster uid of the backup collection.
    pub cluster_uid: std::string::String,

    /// Output only. The full resource path of the cluster the backup collection
    /// belongs to. Example:
    /// projects/{project}/locations/{location}/clusters/{cluster}
    pub cluster: std::string::String,

    /// Output only. The KMS key used to encrypt the backups under this backup
    /// collection.
    pub kms_key: std::string::String,

    /// Output only. System assigned unique identifier of the backup collection.
    pub uid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupCollection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::BackupCollection::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::BackupCollection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::BackupCollection::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupCollection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for BackupCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupCollection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupCollection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cluster_uid,
            __cluster,
            __kms_key,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupCollection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "clusterUid" => Ok(__FieldTag::__cluster_uid),
                            "cluster_uid" => Ok(__FieldTag::__cluster_uid),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupCollection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupCollection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uid => {
                            if !fields.insert(__FieldTag::__cluster_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uid",
                                ));
                            }
                            result.cluster_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupCollection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.cluster_uid.is_empty() {
            state.serialize_entry("clusterUid", &self.cluster_uid)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupCollection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupCollection");
        debug_struct.field("name", &self.name);
        debug_struct.field("cluster_uid", &self.cluster_uid);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("kms_key", &self.kms_key);
        debug_struct.field("uid", &self.uid);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Backup of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Backup {
    /// Identifier. Full resource path of the backup. the last part of the name is
    /// the backup id with the following format: [YYYYMMDDHHMMSS]_[Shorted Cluster
    /// UID] OR customer specified while backup cluster. Example:
    /// 20240515123000_1234
    pub name: std::string::String,

    /// Output only. The time when the backup was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Cluster resource path of this backup.
    pub cluster: std::string::String,

    /// Output only. Cluster uid of this backup.
    pub cluster_uid: std::string::String,

    /// Output only. Total size of the backup in bytes.
    pub total_size_bytes: i64,

    /// Output only. The time when the backup will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. redis-7.2, valkey-7.5
    pub engine_version: std::string::String,

    /// Output only. List of backup files of the backup.
    pub backup_files: std::vec::Vec<crate::model::BackupFile>,

    /// Output only. Node type of the cluster.
    pub node_type: crate::model::NodeType,

    /// Output only. Number of replicas for the cluster.
    pub replica_count: i32,

    /// Output only. Number of shards for the cluster.
    pub shard_count: i32,

    /// Output only. Type of the backup.
    pub backup_type: crate::model::backup::BackupType,

    /// Output only. State of the backup.
    pub state: crate::model::backup::State,

    /// Output only. Encryption information of the backup.
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Output only. System assigned unique identifier of the backup.
    pub uid: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Backup::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::Backup::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::Backup::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [total_size_bytes][crate::model::Backup::total_size_bytes].
    pub fn set_total_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_size_bytes = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [engine_version][crate::model::Backup::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [backup_files][crate::model::Backup::backup_files].
    pub fn set_backup_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupFile>,
    {
        use std::iter::Iterator;
        self.backup_files = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [node_type][crate::model::Backup::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::NodeType>>(mut self, v: T) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Backup::replica_count].
    pub fn set_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Backup::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_or_clear_encryption_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::EncryptionInfo>,
    {
        self.encryption_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.Backup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Backup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __cluster,
            __cluster_uid,
            __total_size_bytes,
            __expire_time,
            __engine_version,
            __backup_files,
            __node_type,
            __replica_count,
            __shard_count,
            __backup_type,
            __state,
            __encryption_info,
            __uid,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Backup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "clusterUid" => Ok(__FieldTag::__cluster_uid),
                            "cluster_uid" => Ok(__FieldTag::__cluster_uid),
                            "totalSizeBytes" => Ok(__FieldTag::__total_size_bytes),
                            "total_size_bytes" => Ok(__FieldTag::__total_size_bytes),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "engineVersion" => Ok(__FieldTag::__engine_version),
                            "engine_version" => Ok(__FieldTag::__engine_version),
                            "backupFiles" => Ok(__FieldTag::__backup_files),
                            "backup_files" => Ok(__FieldTag::__backup_files),
                            "nodeType" => Ok(__FieldTag::__node_type),
                            "node_type" => Ok(__FieldTag::__node_type),
                            "replicaCount" => Ok(__FieldTag::__replica_count),
                            "replica_count" => Ok(__FieldTag::__replica_count),
                            "shardCount" => Ok(__FieldTag::__shard_count),
                            "shard_count" => Ok(__FieldTag::__shard_count),
                            "backupType" => Ok(__FieldTag::__backup_type),
                            "backup_type" => Ok(__FieldTag::__backup_type),
                            "state" => Ok(__FieldTag::__state),
                            "encryptionInfo" => Ok(__FieldTag::__encryption_info),
                            "encryption_info" => Ok(__FieldTag::__encryption_info),
                            "uid" => Ok(__FieldTag::__uid),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Backup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Backup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_uid => {
                            if !fields.insert(__FieldTag::__cluster_uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_uid",
                                ));
                            }
                            result.cluster_uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__total_size_bytes => {
                            if !fields.insert(__FieldTag::__total_size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_size_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__engine_version => {
                            if !fields.insert(__FieldTag::__engine_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for engine_version",
                                ));
                            }
                            result.engine_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__backup_files => {
                            if !fields.insert(__FieldTag::__backup_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_files",
                                ));
                            }
                            result.backup_files = map.next_value::<std::option::Option<std::vec::Vec<crate::model::BackupFile>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__node_type => {
                            if !fields.insert(__FieldTag::__node_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_type",
                                ));
                            }
                            result.node_type = map
                                .next_value::<std::option::Option<crate::model::NodeType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_count => {
                            if !fields.insert(__FieldTag::__replica_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replica_count =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__shard_count => {
                            if !fields.insert(__FieldTag::__shard_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shard_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.shard_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__backup_type => {
                            if !fields.insert(__FieldTag::__backup_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for backup_type",
                                ));
                            }
                            result.backup_type = map.next_value::<std::option::Option<crate::model::backup::BackupType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::backup::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption_info => {
                            if !fields.insert(__FieldTag::__encryption_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_info",
                                ));
                            }
                            result.encryption_info = map
                                .next_value::<std::option::Option<crate::model::EncryptionInfo>>(
                                )?;
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Backup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.cluster_uid.is_empty() {
            state.serialize_entry("clusterUid", &self.cluster_uid)?;
        }
        if !wkt::internal::is_default(&self.total_size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalSizeBytes", &__With(&self.total_size_bytes))?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self.engine_version.is_empty() {
            state.serialize_entry("engineVersion", &self.engine_version)?;
        }
        if !self.backup_files.is_empty() {
            state.serialize_entry("backupFiles", &self.backup_files)?;
        }
        if !wkt::internal::is_default(&self.node_type) {
            state.serialize_entry("nodeType", &self.node_type)?;
        }
        if !wkt::internal::is_default(&self.replica_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("replicaCount", &__With(&self.replica_count))?;
        }
        if !wkt::internal::is_default(&self.shard_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("shardCount", &__With(&self.shard_count))?;
        }
        if !wkt::internal::is_default(&self.backup_type) {
            state.serialize_entry("backupType", &self.backup_type)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.encryption_info.is_some() {
            state.serialize_entry("encryptionInfo", &self.encryption_info)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Backup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Backup");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("cluster_uid", &self.cluster_uid);
        debug_struct.field("total_size_bytes", &self.total_size_bytes);
        debug_struct.field("expire_time", &self.expire_time);
        debug_struct.field("engine_version", &self.engine_version);
        debug_struct.field("backup_files", &self.backup_files);
        debug_struct.field("node_type", &self.node_type);
        debug_struct.field("replica_count", &self.replica_count);
        debug_struct.field("shard_count", &self.shard_count);
        debug_struct.field("backup_type", &self.backup_type);
        debug_struct.field("state", &self.state);
        debug_struct.field("encryption_info", &self.encryption_info);
        debug_struct.field("uid", &self.uid);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Backup].
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BackupType {
        /// The default value, not set.
        Unspecified,
        /// On-demand backup.
        OnDemand,
        /// Automated backup.
        Automated,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BackupType::value] or
        /// [BackupType::name].
        UnknownValue(backup_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod backup_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BackupType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::OnDemand => std::option::Option::Some(1),
                Self::Automated => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BACKUP_TYPE_UNSPECIFIED"),
                Self::OnDemand => std::option::Option::Some("ON_DEMAND"),
                Self::Automated => std::option::Option::Some("AUTOMATED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BackupType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::OnDemand,
                2 => Self::Automated,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BackupType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BACKUP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "ON_DEMAND" => Self::OnDemand,
                "AUTOMATED" => Self::Automated,
                _ => Self::UnknownValue(backup_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BackupType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::OnDemand => serializer.serialize_i32(1),
                Self::Automated => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BackupType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BackupType>::new(
                ".google.cloud.redis.cluster.v1.Backup.BackupType",
            ))
        }
    }

    /// State of the backup.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The default value, not set.
        Unspecified,
        /// The backup is being created.
        Creating,
        /// The backup is active to be used.
        Active,
        /// The backup is being deleted.
        Deleting,
        /// The backup is currently suspended due to reasons like project deletion,
        /// billing account closure, etc.
        Suspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Suspended => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Active,
                3 => Self::Deleting,
                4 => Self::Suspended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "ACTIVE" => Self::Active,
                "DELETING" => Self::Deleting,
                "SUSPENDED" => Self::Suspended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Suspended => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.redis.cluster.v1.Backup.State",
            ))
        }
    }
}

/// Backup is consisted of multiple backup files.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BackupFile {
    /// Output only. e.g: \<shard-id\>.rdb
    pub file_name: std::string::String,

    /// Output only. Size of the backup file in bytes.
    pub size_bytes: i64,

    /// Output only. The time when the backup file was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BackupFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::BackupFile::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::BackupFile::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupFile::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::BackupFile::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for BackupFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupFile"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BackupFile {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_name,
            __size_bytes,
            __create_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BackupFile")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileName" => Ok(__FieldTag::__file_name),
                            "file_name" => Ok(__FieldTag::__file_name),
                            "sizeBytes" => Ok(__FieldTag::__size_bytes),
                            "size_bytes" => Ok(__FieldTag::__size_bytes),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BackupFile;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BackupFile")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_name => {
                            if !fields.insert(__FieldTag::__file_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_name",
                                ));
                            }
                            result.file_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_bytes => {
                            if !fields.insert(__FieldTag::__size_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BackupFile {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_name.is_empty() {
            state.serialize_entry("fileName", &self.file_name)?;
        }
        if !wkt::internal::is_default(&self.size_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeBytes", &__With(&self.size_bytes))?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BackupFile {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BackupFile");
        debug_struct.field("file_name", &self.file_name);
        debug_struct.field("size_bytes", &self.size_bytes);
        debug_struct.field("create_time", &self.create_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration of a service attachment of the cluster, for creating PSC
/// connections.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PscServiceAttachment {
    /// Output only. Service attachment URI which your self-created PscConnection
    /// should use as target
    pub service_attachment: std::string::String,

    /// Output only. Type of a PSC connection targeting this service attachment.
    pub connection_type: crate::model::ConnectionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscServiceAttachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PscServiceAttachment::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscServiceAttachment::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscServiceAttachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscServiceAttachment"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PscServiceAttachment {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_attachment,
            __connection_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PscServiceAttachment")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAttachment" => Ok(__FieldTag::__service_attachment),
                            "service_attachment" => Ok(__FieldTag::__service_attachment),
                            "connectionType" => Ok(__FieldTag::__connection_type),
                            "connection_type" => Ok(__FieldTag::__connection_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PscServiceAttachment;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PscServiceAttachment")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_attachment => {
                            if !fields.insert(__FieldTag::__service_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_attachment",
                                ));
                            }
                            result.service_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__connection_type => {
                            if !fields.insert(__FieldTag::__connection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_type",
                                ));
                            }
                            result.connection_type = map
                                .next_value::<std::option::Option<crate::model::ConnectionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PscServiceAttachment {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_attachment.is_empty() {
            state.serialize_entry("serviceAttachment", &self.service_attachment)?;
        }
        if !wkt::internal::is_default(&self.connection_type) {
            state.serialize_entry("connectionType", &self.connection_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PscServiceAttachment {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PscServiceAttachment");
        debug_struct.field("service_attachment", &self.service_attachment);
        debug_struct.field("connection_type", &self.connection_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Cross cluster replication config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CrossClusterReplicationConfig {
    /// The role of the cluster in cross cluster replication.
    pub cluster_role: crate::model::cross_cluster_replication_config::ClusterRole,

    /// Details of the primary cluster that is used as the replication source for
    /// this secondary cluster.
    ///
    /// This field is only set for a secondary cluster.
    pub primary_cluster:
        std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,

    /// List of secondary clusters that are replicating from this primary cluster.
    ///
    /// This field is only set for a primary cluster.
    pub secondary_clusters:
        std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>,

    /// Output only. The last time cross cluster replication config was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. An output only view of all the member clusters participating
    /// in the cross cluster replication. This view will be provided by every
    /// member cluster irrespective of its cluster role(primary or secondary).
    ///
    /// A primary cluster can provide information about all the secondary clusters
    /// replicating from it. However, a secondary cluster only knows about the
    /// primary cluster from which it is replicating. However, for scenarios, where
    /// the primary cluster is unavailable(e.g. regional outage), a GetCluster
    /// request can be sent to any other member cluster and this field will list
    /// all the member clusters participating in cross cluster replication.
    pub membership: std::option::Option<crate::model::cross_cluster_replication_config::Membership>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CrossClusterReplicationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_role][crate::model::CrossClusterReplicationConfig::cluster_role].
    pub fn set_cluster_role<
        T: std::convert::Into<crate::model::cross_cluster_replication_config::ClusterRole>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_role = v.into();
        self
    }

    /// Sets the value of [primary_cluster][crate::model::CrossClusterReplicationConfig::primary_cluster].
    pub fn set_primary_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
    {
        self.primary_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [primary_cluster][crate::model::CrossClusterReplicationConfig::primary_cluster].
    pub fn set_or_clear_primary_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
    {
        self.primary_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secondary_clusters][crate::model::CrossClusterReplicationConfig::secondary_clusters].
    pub fn set_secondary_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
    {
        use std::iter::Iterator;
        self.secondary_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::CrossClusterReplicationConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::CrossClusterReplicationConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [membership][crate::model::CrossClusterReplicationConfig::membership].
    pub fn set_membership<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cross_cluster_replication_config::Membership>,
    {
        self.membership = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [membership][crate::model::CrossClusterReplicationConfig::membership].
    pub fn set_or_clear_membership<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cross_cluster_replication_config::Membership>,
    {
        self.membership = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CrossClusterReplicationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CrossClusterReplicationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_role,
            __primary_cluster,
            __secondary_clusters,
            __update_time,
            __membership,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CrossClusterReplicationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterRole" => Ok(__FieldTag::__cluster_role),
                            "cluster_role" => Ok(__FieldTag::__cluster_role),
                            "primaryCluster" => Ok(__FieldTag::__primary_cluster),
                            "primary_cluster" => Ok(__FieldTag::__primary_cluster),
                            "secondaryClusters" => Ok(__FieldTag::__secondary_clusters),
                            "secondary_clusters" => Ok(__FieldTag::__secondary_clusters),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "membership" => Ok(__FieldTag::__membership),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CrossClusterReplicationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CrossClusterReplicationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_role => {
                            if !fields.insert(__FieldTag::__cluster_role) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_role",
                                ));
                            }
                            result.cluster_role = map
                                .next_value::<std::option::Option<
                                    crate::model::cross_cluster_replication_config::ClusterRole,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__primary_cluster => {
                            if !fields.insert(__FieldTag::__primary_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for primary_cluster",
                                ));
                            }
                            result.primary_cluster = map.next_value::<std::option::Option<
                                crate::model::cross_cluster_replication_config::RemoteCluster,
                            >>()?;
                        }
                        __FieldTag::__secondary_clusters => {
                            if !fields.insert(__FieldTag::__secondary_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secondary_clusters",
                                ));
                            }
                            result.secondary_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map.next_value::<std::option::Option<
                                crate::model::cross_cluster_replication_config::Membership,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CrossClusterReplicationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cluster_role) {
            state.serialize_entry("clusterRole", &self.cluster_role)?;
        }
        if self.primary_cluster.is_some() {
            state.serialize_entry("primaryCluster", &self.primary_cluster)?;
        }
        if !self.secondary_clusters.is_empty() {
            state.serialize_entry("secondaryClusters", &self.secondary_clusters)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.membership.is_some() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CrossClusterReplicationConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CrossClusterReplicationConfig");
        debug_struct.field("cluster_role", &self.cluster_role);
        debug_struct.field("primary_cluster", &self.primary_cluster);
        debug_struct.field("secondary_clusters", &self.secondary_clusters);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("membership", &self.membership);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CrossClusterReplicationConfig].
pub mod cross_cluster_replication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the remote cluster associated with this cluster in a cross
    /// cluster replication setup.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RemoteCluster {
        /// The full resource path of the remote cluster in
        /// the format: projects/\<project\>/locations/\<region\>/clusters/\<cluster-id\>
        pub cluster: std::string::String,

        /// Output only. The unique identifier of the remote cluster.
        pub uid: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RemoteCluster {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster][crate::model::cross_cluster_replication_config::RemoteCluster::cluster].
        pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster = v.into();
            self
        }

        /// Sets the value of [uid][crate::model::cross_cluster_replication_config::RemoteCluster::uid].
        pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uid = v.into();
            self
        }
    }

    impl wkt::message::Message for RemoteCluster {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig.RemoteCluster"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RemoteCluster {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __cluster,
                __uid,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RemoteCluster")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "cluster" => Ok(__FieldTag::__cluster),
                                "uid" => Ok(__FieldTag::__uid),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RemoteCluster;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RemoteCluster")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__cluster => {
                                if !fields.insert(__FieldTag::__cluster) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster",
                                    ));
                                }
                                result.cluster = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__uid => {
                                if !fields.insert(__FieldTag::__uid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uid",
                                    ));
                                }
                                result.uid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RemoteCluster {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.cluster.is_empty() {
                state.serialize_entry("cluster", &self.cluster)?;
            }
            if !self.uid.is_empty() {
                state.serialize_entry("uid", &self.uid)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RemoteCluster {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RemoteCluster");
            debug_struct.field("cluster", &self.cluster);
            debug_struct.field("uid", &self.uid);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// An output only view of all the member clusters participating in the cross
    /// cluster replication.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Membership {
        /// Output only. The primary cluster that acts as the source of replication
        /// for the secondary clusters.
        pub primary_cluster:
            std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,

        /// Output only. The list of secondary clusters replicating from the primary
        /// cluster.
        pub secondary_clusters:
            std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Membership {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_cluster][crate::model::cross_cluster_replication_config::Membership::primary_cluster].
        pub fn set_primary_cluster<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
        {
            self.primary_cluster = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [primary_cluster][crate::model::cross_cluster_replication_config::Membership::primary_cluster].
        pub fn set_or_clear_primary_cluster<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
        {
            self.primary_cluster = v.map(|x| x.into());
            self
        }

        /// Sets the value of [secondary_clusters][crate::model::cross_cluster_replication_config::Membership::secondary_clusters].
        pub fn set_secondary_clusters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
        {
            use std::iter::Iterator;
            self.secondary_clusters = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Membership {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig.Membership"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Membership {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __primary_cluster,
                __secondary_clusters,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Membership")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "primaryCluster" => Ok(__FieldTag::__primary_cluster),
                                "primary_cluster" => Ok(__FieldTag::__primary_cluster),
                                "secondaryClusters" => Ok(__FieldTag::__secondary_clusters),
                                "secondary_clusters" => Ok(__FieldTag::__secondary_clusters),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Membership;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Membership")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__primary_cluster => {
                                if !fields.insert(__FieldTag::__primary_cluster) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for primary_cluster",
                                    ));
                                }
                                result.primary_cluster = map.next_value::<std::option::Option<
                                    crate::model::cross_cluster_replication_config::RemoteCluster,
                                >>()?;
                            }
                            __FieldTag::__secondary_clusters => {
                                if !fields.insert(__FieldTag::__secondary_clusters) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secondary_clusters",
                                    ));
                                }
                                result.secondary_clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Membership {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.primary_cluster.is_some() {
                state.serialize_entry("primaryCluster", &self.primary_cluster)?;
            }
            if !self.secondary_clusters.is_empty() {
                state.serialize_entry("secondaryClusters", &self.secondary_clusters)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Membership {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Membership");
            debug_struct.field("primary_cluster", &self.primary_cluster);
            debug_struct.field("secondary_clusters", &self.secondary_clusters);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The role of the cluster in cross cluster replication.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ClusterRole {
        /// Cluster role is not set.
        /// The behavior is equivalent to NONE.
        Unspecified,
        /// This cluster does not participate in cross cluster replication. It is an
        /// independent cluster and does not replicate to or from any other clusters.
        None,
        /// A cluster that allows both reads and writes. Any data written to this
        /// cluster is also replicated to the attached secondary clusters.
        Primary,
        /// A cluster that allows only reads and replicates data from a primary
        /// cluster.
        Secondary,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ClusterRole::value] or
        /// [ClusterRole::name].
        UnknownValue(cluster_role::UnknownValue),
    }

    #[doc(hidden)]
    pub mod cluster_role {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ClusterRole {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Primary => std::option::Option::Some(2),
                Self::Secondary => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CLUSTER_ROLE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Primary => std::option::Option::Some("PRIMARY"),
                Self::Secondary => std::option::Option::Some("SECONDARY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ClusterRole {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ClusterRole {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ClusterRole {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Primary,
                3 => Self::Secondary,
                _ => Self::UnknownValue(cluster_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ClusterRole {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CLUSTER_ROLE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PRIMARY" => Self::Primary,
                "SECONDARY" => Self::Secondary,
                _ => Self::UnknownValue(cluster_role::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ClusterRole {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Primary => serializer.serialize_i32(2),
                Self::Secondary => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ClusterRole {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ClusterRole>::new(
                ".google.cloud.redis.cluster.v1.CrossClusterReplicationConfig.ClusterRole",
            ))
        }
    }
}

/// Maintenance policy per cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterMaintenancePolicy {
    /// Output only. The time when the policy was created i.e. Maintenance Window
    /// or Deny Period was assigned.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the policy was updated i.e. Maintenance Window
    /// or Deny Period was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Maintenance window that is applied to resources covered by this
    /// policy. Minimum 1. For the current version, the maximum number of
    /// weekly_maintenance_window is expected to be one.
    pub weekly_maintenance_window: std::vec::Vec<crate::model::ClusterWeeklyMaintenanceWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterMaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ClusterMaintenancePolicy::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ClusterMaintenancePolicy::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::ClusterMaintenancePolicy::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::ClusterMaintenancePolicy::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [weekly_maintenance_window][crate::model::ClusterMaintenancePolicy::weekly_maintenance_window].
    pub fn set_weekly_maintenance_window<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterWeeklyMaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.weekly_maintenance_window = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterMaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterMaintenancePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterMaintenancePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __weekly_maintenance_window,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterMaintenancePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "weeklyMaintenanceWindow" => {
                                Ok(__FieldTag::__weekly_maintenance_window)
                            }
                            "weekly_maintenance_window" => {
                                Ok(__FieldTag::__weekly_maintenance_window)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterMaintenancePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterMaintenancePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__weekly_maintenance_window => {
                            if !fields.insert(__FieldTag::__weekly_maintenance_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for weekly_maintenance_window",
                                ));
                            }
                            result.weekly_maintenance_window = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ClusterWeeklyMaintenanceWindow>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterMaintenancePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.weekly_maintenance_window.is_empty() {
            state.serialize_entry("weeklyMaintenanceWindow", &self.weekly_maintenance_window)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterMaintenancePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterMaintenancePolicy");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("weekly_maintenance_window", &self.weekly_maintenance_window);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Time window specified for weekly operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterWeeklyMaintenanceWindow {
    /// Allows to define schedule that runs specified day of the week.
    pub day: gtype::model::DayOfWeek,

    /// Start time of the window in UTC.
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterWeeklyMaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::ClusterWeeklyMaintenanceWindow::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ClusterWeeklyMaintenanceWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ClusterWeeklyMaintenanceWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::TimeOfDay>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterWeeklyMaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterWeeklyMaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterWeeklyMaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __day,
            __start_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterWeeklyMaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "day" => Ok(__FieldTag::__day),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterWeeklyMaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterWeeklyMaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__day => {
                            if !fields.insert(__FieldTag::__day) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for day",
                                ));
                            }
                            result.day = map
                                .next_value::<std::option::Option<gtype::model::DayOfWeek>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<gtype::model::TimeOfDay>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterWeeklyMaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.day) {
            state.serialize_entry("day", &self.day)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterWeeklyMaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterWeeklyMaintenanceWindow");
        debug_struct.field("day", &self.day);
        debug_struct.field("start_time", &self.start_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Upcoming maitenance schedule.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterMaintenanceSchedule {
    /// Output only. The start time of any upcoming scheduled maintenance for this
    /// instance.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of any upcoming scheduled maintenance for this
    /// instance.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterMaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ClusterMaintenanceSchedule::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ClusterMaintenanceSchedule::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ClusterMaintenanceSchedule::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ClusterMaintenanceSchedule::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterMaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterMaintenanceSchedule"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterMaintenanceSchedule {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterMaintenanceSchedule")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterMaintenanceSchedule;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterMaintenanceSchedule")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterMaintenanceSchedule {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterMaintenanceSchedule {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterMaintenanceSchedule");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PscConfig {
    /// Required. The network where the IP address of the discovery endpoint will
    /// be reserved, in the form of
    /// projects/{network_project}/global/networks/{network_id}.
    pub network: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::PscConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for PscConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PscConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PscConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PscConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PscConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PscConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PscConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PscConfig");
        debug_struct.field("network", &self.network);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Endpoints on each network, for Redis clients to connect to the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiscoveryEndpoint {
    /// Output only. Address of the exposed Redis endpoint used by clients to
    /// connect to the service. The address could be either IP or hostname.
    pub address: std::string::String,

    /// Output only. The port number of the exposed Redis endpoint.
    pub port: i32,

    /// Output only. Customer configuration for where the endpoint is created and
    /// accessed from.
    pub psc_config: std::option::Option<crate::model::PscConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiscoveryEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::DiscoveryEndpoint::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::DiscoveryEndpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::DiscoveryEndpoint::psc_config].
    pub fn set_psc_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PscConfig>,
    {
        self.psc_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [psc_config][crate::model::DiscoveryEndpoint::psc_config].
    pub fn set_or_clear_psc_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PscConfig>,
    {
        self.psc_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DiscoveryEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DiscoveryEndpoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiscoveryEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __address,
            __port,
            __psc_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiscoveryEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "address" => Ok(__FieldTag::__address),
                            "port" => Ok(__FieldTag::__port),
                            "pscConfig" => Ok(__FieldTag::__psc_config),
                            "psc_config" => Ok(__FieldTag::__psc_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiscoveryEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiscoveryEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__psc_config => {
                            if !fields.insert(__FieldTag::__psc_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_config",
                                ));
                            }
                            result.psc_config =
                                map.next_value::<std::option::Option<crate::model::PscConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiscoveryEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.address.is_empty() {
            state.serialize_entry("address", &self.address)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if self.psc_config.is_some() {
            state.serialize_entry("pscConfig", &self.psc_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiscoveryEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiscoveryEndpoint");
        debug_struct.field("address", &self.address);
        debug_struct.field("port", &self.port);
        debug_struct.field("psc_config", &self.psc_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details of consumer resources in a PSC connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PscConnection {
    /// Required. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    pub psc_connection_id: std::string::String,

    /// Required. The IP allocated on the consumer network for the PSC forwarding
    /// rule.
    pub address: std::string::String,

    /// Required. The URI of the consumer side forwarding rule.
    /// Example:
    /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
    pub forwarding_rule: std::string::String,

    /// Optional. Project ID of the consumer project where the forwarding rule is
    /// created in.
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    pub network: std::string::String,

    /// Required. The service attachment which is the target of the PSC connection,
    /// in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection.
    /// Please note that this value is updated periodically.
    /// To get the latest status of a PSC connection, follow
    /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-services#endpoint-details>.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [address][crate::model::PscConnection::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PscConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __psc_connection_id,
            __address,
            __forwarding_rule,
            __project_id,
            __network,
            __service_attachment,
            __psc_connection_status,
            __connection_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PscConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pscConnectionId" => Ok(__FieldTag::__psc_connection_id),
                            "psc_connection_id" => Ok(__FieldTag::__psc_connection_id),
                            "address" => Ok(__FieldTag::__address),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "network" => Ok(__FieldTag::__network),
                            "serviceAttachment" => Ok(__FieldTag::__service_attachment),
                            "service_attachment" => Ok(__FieldTag::__service_attachment),
                            "pscConnectionStatus" => Ok(__FieldTag::__psc_connection_status),
                            "psc_connection_status" => Ok(__FieldTag::__psc_connection_status),
                            "connectionType" => Ok(__FieldTag::__connection_type),
                            "connection_type" => Ok(__FieldTag::__connection_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PscConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PscConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__psc_connection_id => {
                            if !fields.insert(__FieldTag::__psc_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connection_id",
                                ));
                            }
                            result.psc_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            result.forwarding_rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_attachment => {
                            if !fields.insert(__FieldTag::__service_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_attachment",
                                ));
                            }
                            result.service_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_connection_status => {
                            if !fields.insert(__FieldTag::__psc_connection_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connection_status",
                                ));
                            }
                            result.psc_connection_status = map.next_value::<std::option::Option<crate::model::PscConnectionStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::__connection_type => {
                            if !fields.insert(__FieldTag::__connection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_type",
                                ));
                            }
                            result.connection_type = map
                                .next_value::<std::option::Option<crate::model::ConnectionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PscConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.psc_connection_id.is_empty() {
            state.serialize_entry("pscConnectionId", &self.psc_connection_id)?;
        }
        if !self.address.is_empty() {
            state.serialize_entry("address", &self.address)?;
        }
        if !self.forwarding_rule.is_empty() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.service_attachment.is_empty() {
            state.serialize_entry("serviceAttachment", &self.service_attachment)?;
        }
        if !wkt::internal::is_default(&self.psc_connection_status) {
            state.serialize_entry("pscConnectionStatus", &self.psc_connection_status)?;
        }
        if !wkt::internal::is_default(&self.connection_type) {
            state.serialize_entry("connectionType", &self.connection_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PscConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PscConnection");
        debug_struct.field("psc_connection_id", &self.psc_connection_id);
        debug_struct.field("address", &self.address);
        debug_struct.field("forwarding_rule", &self.forwarding_rule);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("network", &self.network);
        debug_struct.field("service_attachment", &self.service_attachment);
        debug_struct.field("psc_connection_status", &self.psc_connection_status);
        debug_struct.field("connection_type", &self.connection_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ClusterEndpoint consists of PSC connections that are created
/// as a group in each VPC network for accessing the cluster. In each group,
/// there shall be one connection for each service attachment in the cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterEndpoint {
    /// A group of PSC connections. They are created in the same VPC network, one
    /// for each service attachment in the cluster.
    pub connections: std::vec::Vec<crate::model::ConnectionDetail>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ClusterEndpoint::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionDetail>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterEndpoint"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterEndpoint {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __connections,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterEndpoint")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "connections" => Ok(__FieldTag::__connections),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterEndpoint;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterEndpoint")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__connections => {
                            if !fields.insert(__FieldTag::__connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connections",
                                ));
                            }
                            result.connections =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ConnectionDetail>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterEndpoint {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.connections.is_empty() {
            state.serialize_entry("connections", &self.connections)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterEndpoint {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterEndpoint");
        debug_struct.field("connections", &self.connections);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Detailed information of each PSC connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConnectionDetail {
    /// A PSC connection to a cluster could either be created through Service
    /// Connectivity Automation (auto-registered connection) during the cluster
    /// creation, or it could be created by customer themselves (user-registered
    /// connection).
    pub connection: std::option::Option<crate::model::connection_detail::Connection>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConnectionDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::ConnectionDetail::connection].
    ///
    /// Note that all the setters affecting `connection` are mutually
    /// exclusive.
    pub fn set_connection<
        T: std::convert::Into<std::option::Option<crate::model::connection_detail::Connection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// The value of [connection][crate::model::ConnectionDetail::connection]
    /// if it holds a `PscAutoConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn psc_auto_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PscAutoConnection>> {
        #[allow(unreachable_patterns)]
        self.connection.as_ref().and_then(|v| match v {
            crate::model::connection_detail::Connection::PscAutoConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection][crate::model::ConnectionDetail::connection]
    /// to hold a `PscAutoConnection`.
    ///
    /// Note that all the setters affecting `connection` are
    /// mutually exclusive.
    pub fn set_psc_auto_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::PscAutoConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = std::option::Option::Some(
            crate::model::connection_detail::Connection::PscAutoConnection(v.into()),
        );
        self
    }

    /// The value of [connection][crate::model::ConnectionDetail::connection]
    /// if it holds a `PscConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn psc_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PscConnection>> {
        #[allow(unreachable_patterns)]
        self.connection.as_ref().and_then(|v| match v {
            crate::model::connection_detail::Connection::PscConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection][crate::model::ConnectionDetail::connection]
    /// to hold a `PscConnection`.
    ///
    /// Note that all the setters affecting `connection` are
    /// mutually exclusive.
    pub fn set_psc_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::PscConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = std::option::Option::Some(
            crate::model::connection_detail::Connection::PscConnection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ConnectionDetail"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConnectionDetail {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __psc_auto_connection,
            __psc_connection,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConnectionDetail")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pscAutoConnection" => Ok(__FieldTag::__psc_auto_connection),
                            "psc_auto_connection" => Ok(__FieldTag::__psc_auto_connection),
                            "pscConnection" => Ok(__FieldTag::__psc_connection),
                            "psc_connection" => Ok(__FieldTag::__psc_connection),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConnectionDetail;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConnectionDetail")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__psc_auto_connection => {
                            if !fields.insert(__FieldTag::__psc_auto_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_auto_connection",
                                ));
                            }
                            if result.connection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection`, a oneof with full ID .google.cloud.redis.cluster.v1.ConnectionDetail.psc_auto_connection, latest field was pscAutoConnection",
                                ));
                            }
                            result.connection = std::option::Option::Some(
                                crate::model::connection_detail::Connection::PscAutoConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PscAutoConnection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__psc_connection => {
                            if !fields.insert(__FieldTag::__psc_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connection",
                                ));
                            }
                            if result.connection.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `connection`, a oneof with full ID .google.cloud.redis.cluster.v1.ConnectionDetail.psc_connection, latest field was pscConnection",
                                ));
                            }
                            result.connection = std::option::Option::Some(
                                crate::model::connection_detail::Connection::PscConnection(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PscConnection>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConnectionDetail {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.psc_auto_connection() {
            state.serialize_entry("pscAutoConnection", value)?;
        }
        if let Some(value) = self.psc_connection() {
            state.serialize_entry("pscConnection", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConnectionDetail {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConnectionDetail");
        debug_struct.field("connection", &self.connection);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ConnectionDetail].
pub mod connection_detail {
    #[allow(unused_imports)]
    use super::*;

    /// A PSC connection to a cluster could either be created through Service
    /// Connectivity Automation (auto-registered connection) during the cluster
    /// creation, or it could be created by customer themselves (user-registered
    /// connection).
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Connection {
        /// Detailed information of a PSC connection that is created through
        /// service connectivity automation.
        PscAutoConnection(std::boxed::Box<crate::model::PscAutoConnection>),
        /// Detailed information of a PSC connection that is created by the customer
        /// who owns the cluster.
        PscConnection(std::boxed::Box<crate::model::PscConnection>),
    }
}

/// Details of consumer resources in a PSC connection that is created through
/// Service Connectivity Automation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PscAutoConnection {
    /// Output only. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    pub psc_connection_id: std::string::String,

    /// Output only. The IP allocated on the consumer network for the PSC
    /// forwarding rule.
    pub address: std::string::String,

    /// Output only. The URI of the consumer side forwarding rule.
    /// Example:
    /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
    pub forwarding_rule: std::string::String,

    /// Required. The consumer project_id where the forwarding rule is created
    /// from.
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    pub network: std::string::String,

    /// Output only. The service attachment which is the target of the PSC
    /// connection, in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection.
    /// Please note that this value is updated periodically.
    /// Please use Private Service Connect APIs for the latest status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PscAutoConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscAutoConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [address][crate::model::PscAutoConnection::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscAutoConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscAutoConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutoConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscAutoConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscAutoConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscAutoConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscAutoConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscAutoConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PscAutoConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __psc_connection_id,
            __address,
            __forwarding_rule,
            __project_id,
            __network,
            __service_attachment,
            __psc_connection_status,
            __connection_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PscAutoConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "pscConnectionId" => Ok(__FieldTag::__psc_connection_id),
                            "psc_connection_id" => Ok(__FieldTag::__psc_connection_id),
                            "address" => Ok(__FieldTag::__address),
                            "forwardingRule" => Ok(__FieldTag::__forwarding_rule),
                            "forwarding_rule" => Ok(__FieldTag::__forwarding_rule),
                            "projectId" => Ok(__FieldTag::__project_id),
                            "project_id" => Ok(__FieldTag::__project_id),
                            "network" => Ok(__FieldTag::__network),
                            "serviceAttachment" => Ok(__FieldTag::__service_attachment),
                            "service_attachment" => Ok(__FieldTag::__service_attachment),
                            "pscConnectionStatus" => Ok(__FieldTag::__psc_connection_status),
                            "psc_connection_status" => Ok(__FieldTag::__psc_connection_status),
                            "connectionType" => Ok(__FieldTag::__connection_type),
                            "connection_type" => Ok(__FieldTag::__connection_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PscAutoConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PscAutoConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__psc_connection_id => {
                            if !fields.insert(__FieldTag::__psc_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connection_id",
                                ));
                            }
                            result.psc_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__address => {
                            if !fields.insert(__FieldTag::__address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for address",
                                ));
                            }
                            result.address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__forwarding_rule => {
                            if !fields.insert(__FieldTag::__forwarding_rule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for forwarding_rule",
                                ));
                            }
                            result.forwarding_rule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project_id => {
                            if !fields.insert(__FieldTag::__project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project_id",
                                ));
                            }
                            result.project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_attachment => {
                            if !fields.insert(__FieldTag::__service_attachment) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_attachment",
                                ));
                            }
                            result.service_attachment = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__psc_connection_status => {
                            if !fields.insert(__FieldTag::__psc_connection_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for psc_connection_status",
                                ));
                            }
                            result.psc_connection_status = map.next_value::<std::option::Option<crate::model::PscConnectionStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::__connection_type => {
                            if !fields.insert(__FieldTag::__connection_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_type",
                                ));
                            }
                            result.connection_type = map
                                .next_value::<std::option::Option<crate::model::ConnectionType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PscAutoConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.psc_connection_id.is_empty() {
            state.serialize_entry("pscConnectionId", &self.psc_connection_id)?;
        }
        if !self.address.is_empty() {
            state.serialize_entry("address", &self.address)?;
        }
        if !self.forwarding_rule.is_empty() {
            state.serialize_entry("forwardingRule", &self.forwarding_rule)?;
        }
        if !self.project_id.is_empty() {
            state.serialize_entry("projectId", &self.project_id)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.service_attachment.is_empty() {
            state.serialize_entry("serviceAttachment", &self.service_attachment)?;
        }
        if !wkt::internal::is_default(&self.psc_connection_status) {
            state.serialize_entry("pscConnectionStatus", &self.psc_connection_status)?;
        }
        if !wkt::internal::is_default(&self.connection_type) {
            state.serialize_entry("connectionType", &self.connection_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PscAutoConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PscAutoConnection");
        debug_struct.field("psc_connection_id", &self.psc_connection_id);
        debug_struct.field("address", &self.address);
        debug_struct.field("forwarding_rule", &self.forwarding_rule);
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("network", &self.network);
        debug_struct.field("service_attachment", &self.service_attachment);
        debug_struct.field("psc_connection_status", &self.psc_connection_status);
        debug_struct.field("connection_type", &self.connection_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Pre-defined metadata fields.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Redis cluster certificate authority
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CertificateAuthority {
    /// Identifier. Unique name of the resource in this scope including project,
    /// location and cluster using the form:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/certificateAuthority`
    pub name: std::string::String,

    /// server ca information
    pub server_ca: std::option::Option<crate::model::certificate_authority::ServerCa>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CertificateAuthority {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateAuthority::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca].
    ///
    /// Note that all the setters affecting `server_ca` are mutually
    /// exclusive.
    pub fn set_server_ca<
        T: std::convert::Into<std::option::Option<crate::model::certificate_authority::ServerCa>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = v.into();
        self
    }

    /// The value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// if it holds a `ManagedServerCa`, `None` if the field is not set or
    /// holds a different branch.
    pub fn managed_server_ca(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
    > {
        #[allow(unreachable_patterns)]
        self.server_ca.as_ref().and_then(|v| match v {
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// to hold a `ManagedServerCa`.
    ///
    /// Note that all the setters affecting `server_ca` are
    /// mutually exclusive.
    pub fn set_managed_server_ca<
        T: std::convert::Into<
                std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = std::option::Option::Some(
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CertificateAuthority {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CertificateAuthority {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __managed_server_ca,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CertificateAuthority")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "managedServerCa" => Ok(__FieldTag::__managed_server_ca),
                            "managed_server_ca" => Ok(__FieldTag::__managed_server_ca),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CertificateAuthority;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CertificateAuthority")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__managed_server_ca => {
                            if !fields.insert(__FieldTag::__managed_server_ca) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for managed_server_ca",
                                ));
                            }
                            if result.server_ca.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `server_ca`, a oneof with full ID .google.cloud.redis.cluster.v1.CertificateAuthority.managed_server_ca, latest field was managedServerCa",
                                ));
                            }
                            result.server_ca = std::option::Option::Some(
                                crate::model::certificate_authority::ServerCa::ManagedServerCa(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CertificateAuthority {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.managed_server_ca() {
            state.serialize_entry("managedServerCa", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CertificateAuthority {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CertificateAuthority");
        debug_struct.field("name", &self.name);
        debug_struct.field("server_ca", &self.server_ca);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CertificateAuthority].
pub mod certificate_authority {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ManagedCertificateAuthority {
        /// The PEM encoded CA certificate chains for redis managed
        /// server authentication
        pub ca_certs: std::vec::Vec<
            crate::model::certificate_authority::managed_certificate_authority::CertChain,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ManagedCertificateAuthority {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certs][crate::model::certificate_authority::ManagedCertificateAuthority::ca_certs].
        pub fn set_ca_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                    crate::model::certificate_authority::managed_certificate_authority::CertChain,
                >,
        {
            use std::iter::Iterator;
            self.ca_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ManagedCertificateAuthority {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ManagedCertificateAuthority {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ca_certs,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ManagedCertificateAuthority")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "caCerts" => Ok(__FieldTag::__ca_certs),
                                "ca_certs" => Ok(__FieldTag::__ca_certs),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ManagedCertificateAuthority;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ManagedCertificateAuthority")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ca_certs => {
                                if !fields.insert(__FieldTag::__ca_certs) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ca_certs",
                                    ));
                                }
                                result.ca_certs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::certificate_authority::managed_certificate_authority::CertChain>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ManagedCertificateAuthority {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.ca_certs.is_empty() {
                state.serialize_entry("caCerts", &self.ca_certs)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ManagedCertificateAuthority {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ManagedCertificateAuthority");
            debug_struct.field("ca_certs", &self.ca_certs);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ManagedCertificateAuthority].
    pub mod managed_certificate_authority {
        #[allow(unused_imports)]
        use super::*;

        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CertChain {
            /// The certificates that form the CA chain, from leaf to root order.
            pub certificates: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CertChain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [certificates][crate::model::certificate_authority::managed_certificate_authority::CertChain::certificates].
            pub fn set_certificates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.certificates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CertChain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CertChain {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __certificates,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CertChain")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "certificates" => Ok(__FieldTag::__certificates),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CertChain;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CertChain")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__certificates => {
                                    if !fields.insert(__FieldTag::__certificates) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for certificates",
                                            ),
                                        );
                                    }
                                    result.certificates = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CertChain {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.certificates.is_empty() {
                    state.serialize_entry("certificates", &self.certificates)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for CertChain {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("CertChain");
                debug_struct.field("certificates", &self.certificates);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// server ca information
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ServerCa {
        ManagedServerCa(
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        ),
    }
}

/// Configuration of the persistence functionality.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterPersistenceConfig {
    /// Optional. The mode of persistence.
    pub mode: crate::model::cluster_persistence_config::PersistenceMode,

    /// Optional. RDB configuration. This field will be ignored if mode is not RDB.
    pub rdb_config: std::option::Option<crate::model::cluster_persistence_config::RDBConfig>,

    /// Optional. AOF configuration. This field will be ignored if mode is not AOF.
    pub aof_config: std::option::Option<crate::model::cluster_persistence_config::AOFConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterPersistenceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ClusterPersistenceConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::cluster_persistence_config::PersistenceMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [rdb_config][crate::model::ClusterPersistenceConfig::rdb_config].
    pub fn set_rdb_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster_persistence_config::RDBConfig>,
    {
        self.rdb_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [rdb_config][crate::model::ClusterPersistenceConfig::rdb_config].
    pub fn set_or_clear_rdb_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster_persistence_config::RDBConfig>,
    {
        self.rdb_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [aof_config][crate::model::ClusterPersistenceConfig::aof_config].
    pub fn set_aof_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster_persistence_config::AOFConfig>,
    {
        self.aof_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [aof_config][crate::model::ClusterPersistenceConfig::aof_config].
    pub fn set_or_clear_aof_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster_persistence_config::AOFConfig>,
    {
        self.aof_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ClusterPersistenceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterPersistenceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __rdb_config,
            __aof_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterPersistenceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "rdbConfig" => Ok(__FieldTag::__rdb_config),
                            "rdb_config" => Ok(__FieldTag::__rdb_config),
                            "aofConfig" => Ok(__FieldTag::__aof_config),
                            "aof_config" => Ok(__FieldTag::__aof_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterPersistenceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterPersistenceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<
                                    crate::model::cluster_persistence_config::PersistenceMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__rdb_config => {
                            if !fields.insert(__FieldTag::__rdb_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rdb_config",
                                ));
                            }
                            result.rdb_config = map.next_value::<std::option::Option<
                                crate::model::cluster_persistence_config::RDBConfig,
                            >>()?;
                        }
                        __FieldTag::__aof_config => {
                            if !fields.insert(__FieldTag::__aof_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aof_config",
                                ));
                            }
                            result.aof_config = map.next_value::<std::option::Option<
                                crate::model::cluster_persistence_config::AOFConfig,
                            >>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterPersistenceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if self.rdb_config.is_some() {
            state.serialize_entry("rdbConfig", &self.rdb_config)?;
        }
        if self.aof_config.is_some() {
            state.serialize_entry("aofConfig", &self.aof_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterPersistenceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterPersistenceConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("rdb_config", &self.rdb_config);
        debug_struct.field("aof_config", &self.aof_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ClusterPersistenceConfig].
pub mod cluster_persistence_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the RDB based persistence.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RDBConfig {
        /// Optional. Period between RDB snapshots.
        pub rdb_snapshot_period:
            crate::model::cluster_persistence_config::rdb_config::SnapshotPeriod,

        /// Optional. The time that the first snapshot was/will be attempted, and to
        /// which future snapshots will be aligned. If not provided, the current time
        /// will be used.
        pub rdb_snapshot_start_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RDBConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rdb_snapshot_period][crate::model::cluster_persistence_config::RDBConfig::rdb_snapshot_period].
        pub fn set_rdb_snapshot_period<
            T: std::convert::Into<
                    crate::model::cluster_persistence_config::rdb_config::SnapshotPeriod,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_period = v.into();
            self
        }

        /// Sets the value of [rdb_snapshot_start_time][crate::model::cluster_persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_rdb_snapshot_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.rdb_snapshot_start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [rdb_snapshot_start_time][crate::model::cluster_persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_or_clear_rdb_snapshot_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.rdb_snapshot_start_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for RDBConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RDBConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __rdb_snapshot_period,
                __rdb_snapshot_start_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RDBConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "rdbSnapshotPeriod" => Ok(__FieldTag::__rdb_snapshot_period),
                                "rdb_snapshot_period" => Ok(__FieldTag::__rdb_snapshot_period),
                                "rdbSnapshotStartTime" => Ok(__FieldTag::__rdb_snapshot_start_time),
                                "rdb_snapshot_start_time" => {
                                    Ok(__FieldTag::__rdb_snapshot_start_time)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RDBConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RDBConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__rdb_snapshot_period => {
                                if !fields.insert(__FieldTag::__rdb_snapshot_period) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rdb_snapshot_period",
                                    ));
                                }
                                result.rdb_snapshot_period = map.next_value::<std::option::Option<crate::model::cluster_persistence_config::rdb_config::SnapshotPeriod>>()?.unwrap_or_default();
                            }
                            __FieldTag::__rdb_snapshot_start_time => {
                                if !fields.insert(__FieldTag::__rdb_snapshot_start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for rdb_snapshot_start_time",
                                    ));
                                }
                                result.rdb_snapshot_start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RDBConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.rdb_snapshot_period) {
                state.serialize_entry("rdbSnapshotPeriod", &self.rdb_snapshot_period)?;
            }
            if self.rdb_snapshot_start_time.is_some() {
                state.serialize_entry("rdbSnapshotStartTime", &self.rdb_snapshot_start_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RDBConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RDBConfig");
            debug_struct.field("rdb_snapshot_period", &self.rdb_snapshot_period);
            debug_struct.field("rdb_snapshot_start_time", &self.rdb_snapshot_start_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [RDBConfig].
    pub mod rdb_config {
        #[allow(unused_imports)]
        use super::*;

        /// Available snapshot periods.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SnapshotPeriod {
            /// Not set.
            Unspecified,
            /// One hour.
            OneHour,
            /// Six hours.
            SixHours,
            /// Twelve hours.
            TwelveHours,
            /// Twenty four hours.
            TwentyFourHours,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SnapshotPeriod::value] or
            /// [SnapshotPeriod::name].
            UnknownValue(snapshot_period::UnknownValue),
        }

        #[doc(hidden)]
        pub mod snapshot_period {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SnapshotPeriod {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::OneHour => std::option::Option::Some(1),
                    Self::SixHours => std::option::Option::Some(2),
                    Self::TwelveHours => std::option::Option::Some(3),
                    Self::TwentyFourHours => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SNAPSHOT_PERIOD_UNSPECIFIED"),
                    Self::OneHour => std::option::Option::Some("ONE_HOUR"),
                    Self::SixHours => std::option::Option::Some("SIX_HOURS"),
                    Self::TwelveHours => std::option::Option::Some("TWELVE_HOURS"),
                    Self::TwentyFourHours => std::option::Option::Some("TWENTY_FOUR_HOURS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SnapshotPeriod {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SnapshotPeriod {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SnapshotPeriod {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::OneHour,
                    2 => Self::SixHours,
                    3 => Self::TwelveHours,
                    4 => Self::TwentyFourHours,
                    _ => Self::UnknownValue(snapshot_period::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SnapshotPeriod {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SNAPSHOT_PERIOD_UNSPECIFIED" => Self::Unspecified,
                    "ONE_HOUR" => Self::OneHour,
                    "SIX_HOURS" => Self::SixHours,
                    "TWELVE_HOURS" => Self::TwelveHours,
                    "TWENTY_FOUR_HOURS" => Self::TwentyFourHours,
                    _ => Self::UnknownValue(snapshot_period::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SnapshotPeriod {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::OneHour => serializer.serialize_i32(1),
                    Self::SixHours => serializer.serialize_i32(2),
                    Self::TwelveHours => serializer.serialize_i32(3),
                    Self::TwentyFourHours => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SnapshotPeriod {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SnapshotPeriod>::new(
                    ".google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig.SnapshotPeriod"))
            }
        }
    }

    /// Configuration of the AOF based persistence.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AOFConfig {
        /// Optional. fsync configuration.
        pub append_fsync: crate::model::cluster_persistence_config::aof_config::AppendFsync,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AOFConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [append_fsync][crate::model::cluster_persistence_config::AOFConfig::append_fsync].
        pub fn set_append_fsync<
            T: std::convert::Into<crate::model::cluster_persistence_config::aof_config::AppendFsync>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.append_fsync = v.into();
            self
        }
    }

    impl wkt::message::Message for AOFConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AOFConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __append_fsync,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AOFConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "appendFsync" => Ok(__FieldTag::__append_fsync),
                                "append_fsync" => Ok(__FieldTag::__append_fsync),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AOFConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AOFConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__append_fsync => {
                                if !fields.insert(__FieldTag::__append_fsync) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for append_fsync",
                                    ));
                                }
                                result.append_fsync = map.next_value::<std::option::Option<crate::model::cluster_persistence_config::aof_config::AppendFsync>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AOFConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.append_fsync) {
                state.serialize_entry("appendFsync", &self.append_fsync)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AOFConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AOFConfig");
            debug_struct.field("append_fsync", &self.append_fsync);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [AOFConfig].
    pub mod aof_config {
        #[allow(unused_imports)]
        use super::*;

        /// Available fsync modes.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum AppendFsync {
            /// Not set. Default: EVERYSEC
            Unspecified,
            /// Never fsync. Normally Linux will flush data every 30 seconds with this
            /// configuration, but it's up to the kernel's exact tuning.
            No,
            /// fsync every second. Fast enough, and you may lose 1 second of data if
            /// there is a disaster
            Everysec,
            /// fsync every time new write commands are appended to the AOF. It has the
            /// best data loss protection at the cost of performance
            Always,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [AppendFsync::value] or
            /// [AppendFsync::name].
            UnknownValue(append_fsync::UnknownValue),
        }

        #[doc(hidden)]
        pub mod append_fsync {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl AppendFsync {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::No => std::option::Option::Some(1),
                    Self::Everysec => std::option::Option::Some(2),
                    Self::Always => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("APPEND_FSYNC_UNSPECIFIED"),
                    Self::No => std::option::Option::Some("NO"),
                    Self::Everysec => std::option::Option::Some("EVERYSEC"),
                    Self::Always => std::option::Option::Some("ALWAYS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for AppendFsync {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for AppendFsync {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for AppendFsync {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::No,
                    2 => Self::Everysec,
                    3 => Self::Always,
                    _ => Self::UnknownValue(append_fsync::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for AppendFsync {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "APPEND_FSYNC_UNSPECIFIED" => Self::Unspecified,
                    "NO" => Self::No,
                    "EVERYSEC" => Self::Everysec,
                    "ALWAYS" => Self::Always,
                    _ => Self::UnknownValue(append_fsync::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for AppendFsync {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::No => serializer.serialize_i32(1),
                    Self::Everysec => serializer.serialize_i32(2),
                    Self::Always => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for AppendFsync {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<AppendFsync>::new(
                    ".google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig.AppendFsync",
                ))
            }
        }
    }

    /// Available persistence modes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PersistenceMode {
        /// Not set.
        Unspecified,
        /// Persistence is disabled, and any snapshot data is deleted.
        Disabled,
        /// RDB based persistence is enabled.
        Rdb,
        /// AOF based persistence is enabled.
        Aof,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PersistenceMode::value] or
        /// [PersistenceMode::name].
        UnknownValue(persistence_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod persistence_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PersistenceMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disabled => std::option::Option::Some(1),
                Self::Rdb => std::option::Option::Some(2),
                Self::Aof => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("PERSISTENCE_MODE_UNSPECIFIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Rdb => std::option::Option::Some("RDB"),
                Self::Aof => std::option::Option::Some("AOF"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PersistenceMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PersistenceMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PersistenceMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disabled,
                2 => Self::Rdb,
                3 => Self::Aof,
                _ => Self::UnknownValue(persistence_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PersistenceMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PERSISTENCE_MODE_UNSPECIFIED" => Self::Unspecified,
                "DISABLED" => Self::Disabled,
                "RDB" => Self::Rdb,
                "AOF" => Self::Aof,
                _ => Self::UnknownValue(persistence_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PersistenceMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disabled => serializer.serialize_i32(1),
                Self::Rdb => serializer.serialize_i32(2),
                Self::Aof => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PersistenceMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PersistenceMode>::new(
                ".google.cloud.redis.cluster.v1.ClusterPersistenceConfig.PersistenceMode",
            ))
        }
    }
}

/// Zone distribution config for allocation of cluster resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneDistributionConfig {
    /// Optional. The mode of zone distribution. Defaults to MULTI_ZONE, when not
    /// specified.
    pub mode: crate::model::zone_distribution_config::ZoneDistributionMode,

    /// Optional. When SINGLE ZONE distribution is selected, zone field would be
    /// used to allocate all resources in that zone. This is not applicable to
    /// MULTI_ZONE, and would be ignored for MULTI_ZONE clusters.
    pub zone: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZoneDistributionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ZoneDistributionConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::zone_distribution_config::ZoneDistributionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ZoneDistributionConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for ZoneDistributionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ZoneDistributionConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ZoneDistributionConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __mode,
            __zone,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZoneDistributionConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "mode" => Ok(__FieldTag::__mode),
                            "zone" => Ok(__FieldTag::__zone),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ZoneDistributionConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZoneDistributionConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__mode => {
                            if !fields.insert(__FieldTag::__mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for mode",
                                ));
                            }
                            result.mode = map
                                .next_value::<std::option::Option<
                                    crate::model::zone_distribution_config::ZoneDistributionMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ZoneDistributionConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.mode) {
            state.serialize_entry("mode", &self.mode)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ZoneDistributionConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ZoneDistributionConfig");
        debug_struct.field("mode", &self.mode);
        debug_struct.field("zone", &self.zone);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ZoneDistributionConfig].
pub mod zone_distribution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines various modes of zone distribution.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ZoneDistributionMode {
        /// Not Set. Default: MULTI_ZONE
        Unspecified,
        /// Distribute all resources across 3 zones picked at random, within the
        /// region.
        MultiZone,
        /// Distribute all resources in a single zone. The zone field must be
        /// specified, when this mode is selected.
        SingleZone,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ZoneDistributionMode::value] or
        /// [ZoneDistributionMode::name].
        UnknownValue(zone_distribution_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod zone_distribution_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ZoneDistributionMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::MultiZone => std::option::Option::Some(1),
                Self::SingleZone => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("ZONE_DISTRIBUTION_MODE_UNSPECIFIED")
                }
                Self::MultiZone => std::option::Option::Some("MULTI_ZONE"),
                Self::SingleZone => std::option::Option::Some("SINGLE_ZONE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ZoneDistributionMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ZoneDistributionMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ZoneDistributionMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::MultiZone,
                2 => Self::SingleZone,
                _ => Self::UnknownValue(zone_distribution_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ZoneDistributionMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ZONE_DISTRIBUTION_MODE_UNSPECIFIED" => Self::Unspecified,
                "MULTI_ZONE" => Self::MultiZone,
                "SINGLE_ZONE" => Self::SingleZone,
                _ => Self::UnknownValue(zone_distribution_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ZoneDistributionMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::MultiZone => serializer.serialize_i32(1),
                Self::SingleZone => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ZoneDistributionMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ZoneDistributionMode>::new(
                ".google.cloud.redis.cluster.v1.ZoneDistributionConfig.ZoneDistributionMode",
            ))
        }
    }
}

/// Request for rescheduling a cluster maintenance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RescheduleClusterMaintenanceRequest {
    /// Required. Redis Cluster instance resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    pub name: std::string::String,

    /// Required. If reschedule type is SPECIFIC_TIME, must set up schedule_time as
    /// well.
    pub reschedule_type: crate::model::reschedule_cluster_maintenance_request::RescheduleType,

    /// Optional. Timestamp when the maintenance shall be rescheduled to if
    /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for
    /// example `2012-11-15T16:19:00.094Z`.
    pub schedule_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RescheduleClusterMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RescheduleClusterMaintenanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reschedule_type][crate::model::RescheduleClusterMaintenanceRequest::reschedule_type].
    pub fn set_reschedule_type<
        T: std::convert::Into<crate::model::reschedule_cluster_maintenance_request::RescheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reschedule_type = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::RescheduleClusterMaintenanceRequest::schedule_time].
    pub fn set_schedule_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [schedule_time][crate::model::RescheduleClusterMaintenanceRequest::schedule_time].
    pub fn set_or_clear_schedule_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.schedule_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for RescheduleClusterMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.RescheduleClusterMaintenanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RescheduleClusterMaintenanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reschedule_type,
            __schedule_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RescheduleClusterMaintenanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "rescheduleType" => Ok(__FieldTag::__reschedule_type),
                            "reschedule_type" => Ok(__FieldTag::__reschedule_type),
                            "scheduleTime" => Ok(__FieldTag::__schedule_time),
                            "schedule_time" => Ok(__FieldTag::__schedule_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RescheduleClusterMaintenanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RescheduleClusterMaintenanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reschedule_type => {
                            if !fields.insert(__FieldTag::__reschedule_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reschedule_type",
                                ));
                            }
                            result.reschedule_type = map.next_value::<std::option::Option<crate::model::reschedule_cluster_maintenance_request::RescheduleType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__schedule_time => {
                            if !fields.insert(__FieldTag::__schedule_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule_time",
                                ));
                            }
                            result.schedule_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RescheduleClusterMaintenanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.reschedule_type) {
            state.serialize_entry("rescheduleType", &self.reschedule_type)?;
        }
        if self.schedule_time.is_some() {
            state.serialize_entry("scheduleTime", &self.schedule_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RescheduleClusterMaintenanceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RescheduleClusterMaintenanceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("reschedule_type", &self.reschedule_type);
        debug_struct.field("schedule_time", &self.schedule_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [RescheduleClusterMaintenanceRequest].
pub mod reschedule_cluster_maintenance_request {
    #[allow(unused_imports)]
    use super::*;

    /// Reschedule options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RescheduleType {
        /// Not set.
        Unspecified,
        /// If the user wants to schedule the maintenance to happen now.
        Immediate,
        /// If the user wants to reschedule the maintenance to a specific time.
        SpecificTime,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RescheduleType::value] or
        /// [RescheduleType::name].
        UnknownValue(reschedule_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod reschedule_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RescheduleType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediate => std::option::Option::Some(1),
                Self::SpecificTime => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESCHEDULE_TYPE_UNSPECIFIED"),
                Self::Immediate => std::option::Option::Some("IMMEDIATE"),
                Self::SpecificTime => std::option::Option::Some("SPECIFIC_TIME"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RescheduleType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediate,
                3 => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RescheduleType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESCHEDULE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATE" => Self::Immediate,
                "SPECIFIC_TIME" => Self::SpecificTime,
                _ => Self::UnknownValue(reschedule_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RescheduleType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediate => serializer.serialize_i32(1),
                Self::SpecificTime => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RescheduleType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RescheduleType>::new(
                ".google.cloud.redis.cluster.v1.RescheduleClusterMaintenanceRequest.RescheduleType",
            ))
        }
    }
}

/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    pub encryption_type: crate::model::encryption_info::Type,

    /// Output only. KMS key versions that are being used to protect the data
    /// at-rest.
    pub kms_key_versions: std::vec::Vec<std::string::String>,

    /// Output only. The state of the primary version of the KMS key perceived by
    /// the system. This field is not populated in backups.
    pub kms_key_primary_state: crate::model::encryption_info::KmsKeyState,

    /// Output only. The most recent time when the encryption info was updated.
    pub last_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::encryption_info::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [kms_key_versions][crate::model::EncryptionInfo::kms_key_versions].
    pub fn set_kms_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [kms_key_primary_state][crate::model::EncryptionInfo::kms_key_primary_state].
    pub fn set_kms_key_primary_state<
        T: std::convert::Into<crate::model::encryption_info::KmsKeyState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_primary_state = v.into();
        self
    }

    /// Sets the value of [last_update_time][crate::model::EncryptionInfo::last_update_time].
    pub fn set_last_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_update_time][crate::model::EncryptionInfo::last_update_time].
    pub fn set_or_clear_last_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.EncryptionInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for EncryptionInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __encryption_type,
            __kms_key_versions,
            __kms_key_primary_state,
            __last_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for EncryptionInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "encryptionType" => Ok(__FieldTag::__encryption_type),
                            "encryption_type" => Ok(__FieldTag::__encryption_type),
                            "kmsKeyVersions" => Ok(__FieldTag::__kms_key_versions),
                            "kms_key_versions" => Ok(__FieldTag::__kms_key_versions),
                            "kmsKeyPrimaryState" => Ok(__FieldTag::__kms_key_primary_state),
                            "kms_key_primary_state" => Ok(__FieldTag::__kms_key_primary_state),
                            "lastUpdateTime" => Ok(__FieldTag::__last_update_time),
                            "last_update_time" => Ok(__FieldTag::__last_update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = EncryptionInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct EncryptionInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__encryption_type => {
                            if !fields.insert(__FieldTag::__encryption_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_type",
                                ));
                            }
                            result.encryption_type = map.next_value::<std::option::Option<crate::model::encryption_info::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key_versions => {
                            if !fields.insert(__FieldTag::__kms_key_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_versions",
                                ));
                            }
                            result.kms_key_versions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__kms_key_primary_state => {
                            if !fields.insert(__FieldTag::__kms_key_primary_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_primary_state",
                                ));
                            }
                            result.kms_key_primary_state = map.next_value::<std::option::Option<crate::model::encryption_info::KmsKeyState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_update_time => {
                            if !fields.insert(__FieldTag::__last_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_update_time",
                                ));
                            }
                            result.last_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for EncryptionInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.encryption_type) {
            state.serialize_entry("encryptionType", &self.encryption_type)?;
        }
        if !self.kms_key_versions.is_empty() {
            state.serialize_entry("kmsKeyVersions", &self.kms_key_versions)?;
        }
        if !wkt::internal::is_default(&self.kms_key_primary_state) {
            state.serialize_entry("kmsKeyPrimaryState", &self.kms_key_primary_state)?;
        }
        if self.last_update_time.is_some() {
            state.serialize_entry("lastUpdateTime", &self.last_update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for EncryptionInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("EncryptionInfo");
        debug_struct.field("encryption_type", &self.encryption_type);
        debug_struct.field("kms_key_versions", &self.kms_key_versions);
        debug_struct.field("kms_key_primary_state", &self.kms_key_primary_state);
        debug_struct.field("last_update_time", &self.last_update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [EncryptionInfo].
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        Unspecified,
        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        GoogleDefaultEncryption,
        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        CustomerManagedEncryption,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GoogleDefaultEncryption => std::option::Option::Some(1),
                Self::CustomerManagedEncryption => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::GoogleDefaultEncryption => {
                    std::option::Option::Some("GOOGLE_DEFAULT_ENCRYPTION")
                }
                Self::CustomerManagedEncryption => {
                    std::option::Option::Some("CUSTOMER_MANAGED_ENCRYPTION")
                }
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GoogleDefaultEncryption,
                2 => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GOOGLE_DEFAULT_ENCRYPTION" => Self::GoogleDefaultEncryption,
                "CUSTOMER_MANAGED_ENCRYPTION" => Self::CustomerManagedEncryption,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GoogleDefaultEncryption => serializer.serialize_i32(1),
                Self::CustomerManagedEncryption => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.redis.cluster.v1.EncryptionInfo.Type",
            ))
        }
    }

    /// The state of the KMS key perceived by the system. Refer to the public
    /// documentation for the impact of each state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum KmsKeyState {
        /// The default value. This value is unused.
        Unspecified,
        /// The KMS key is enabled and correctly configured.
        Enabled,
        /// Permission denied on the KMS key.
        PermissionDenied,
        /// The KMS key is disabled.
        Disabled,
        /// The KMS key is destroyed.
        Destroyed,
        /// The KMS key is scheduled to be destroyed.
        DestroyScheduled,
        /// The EKM key is unreachable.
        EkmKeyUnreachableDetected,
        /// Billing is disabled for the project.
        BillingDisabled,
        /// All other unknown failures.
        UnknownFailure,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [KmsKeyState::value] or
        /// [KmsKeyState::name].
        UnknownValue(kms_key_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod kms_key_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl KmsKeyState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Enabled => std::option::Option::Some(1),
                Self::PermissionDenied => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::Destroyed => std::option::Option::Some(4),
                Self::DestroyScheduled => std::option::Option::Some(5),
                Self::EkmKeyUnreachableDetected => std::option::Option::Some(6),
                Self::BillingDisabled => std::option::Option::Some(7),
                Self::UnknownFailure => std::option::Option::Some(8),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("KMS_KEY_STATE_UNSPECIFIED"),
                Self::Enabled => std::option::Option::Some("ENABLED"),
                Self::PermissionDenied => std::option::Option::Some("PERMISSION_DENIED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Destroyed => std::option::Option::Some("DESTROYED"),
                Self::DestroyScheduled => std::option::Option::Some("DESTROY_SCHEDULED"),
                Self::EkmKeyUnreachableDetected => {
                    std::option::Option::Some("EKM_KEY_UNREACHABLE_DETECTED")
                }
                Self::BillingDisabled => std::option::Option::Some("BILLING_DISABLED"),
                Self::UnknownFailure => std::option::Option::Some("UNKNOWN_FAILURE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for KmsKeyState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for KmsKeyState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for KmsKeyState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Enabled,
                2 => Self::PermissionDenied,
                3 => Self::Disabled,
                4 => Self::Destroyed,
                5 => Self::DestroyScheduled,
                6 => Self::EkmKeyUnreachableDetected,
                7 => Self::BillingDisabled,
                8 => Self::UnknownFailure,
                _ => Self::UnknownValue(kms_key_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for KmsKeyState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "KMS_KEY_STATE_UNSPECIFIED" => Self::Unspecified,
                "ENABLED" => Self::Enabled,
                "PERMISSION_DENIED" => Self::PermissionDenied,
                "DISABLED" => Self::Disabled,
                "DESTROYED" => Self::Destroyed,
                "DESTROY_SCHEDULED" => Self::DestroyScheduled,
                "EKM_KEY_UNREACHABLE_DETECTED" => Self::EkmKeyUnreachableDetected,
                "BILLING_DISABLED" => Self::BillingDisabled,
                "UNKNOWN_FAILURE" => Self::UnknownFailure,
                _ => Self::UnknownValue(kms_key_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for KmsKeyState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Enabled => serializer.serialize_i32(1),
                Self::PermissionDenied => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::Destroyed => serializer.serialize_i32(4),
                Self::DestroyScheduled => serializer.serialize_i32(5),
                Self::EkmKeyUnreachableDetected => serializer.serialize_i32(6),
                Self::BillingDisabled => serializer.serialize_i32(7),
                Self::UnknownFailure => serializer.serialize_i32(8),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for KmsKeyState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<KmsKeyState>::new(
                ".google.cloud.redis.cluster.v1.EncryptionInfo.KmsKeyState",
            ))
        }
    }
}

/// Status of the PSC connection.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum PscConnectionStatus {
    /// PSC connection status is not specified.
    Unspecified,
    /// The connection is active
    Active,
    /// Connection not found
    NotFound,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [PscConnectionStatus::value] or
    /// [PscConnectionStatus::name].
    UnknownValue(psc_connection_status::UnknownValue),
}

#[doc(hidden)]
pub mod psc_connection_status {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl PscConnectionStatus {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Active => std::option::Option::Some(1),
            Self::NotFound => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("PSC_CONNECTION_STATUS_UNSPECIFIED"),
            Self::Active => std::option::Option::Some("PSC_CONNECTION_STATUS_ACTIVE"),
            Self::NotFound => std::option::Option::Some("PSC_CONNECTION_STATUS_NOT_FOUND"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for PscConnectionStatus {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for PscConnectionStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for PscConnectionStatus {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Active,
            2 => Self::NotFound,
            _ => Self::UnknownValue(psc_connection_status::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for PscConnectionStatus {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "PSC_CONNECTION_STATUS_UNSPECIFIED" => Self::Unspecified,
            "PSC_CONNECTION_STATUS_ACTIVE" => Self::Active,
            "PSC_CONNECTION_STATUS_NOT_FOUND" => Self::NotFound,
            _ => Self::UnknownValue(psc_connection_status::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for PscConnectionStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Active => serializer.serialize_i32(1),
            Self::NotFound => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for PscConnectionStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<PscConnectionStatus>::new(
            ".google.cloud.redis.cluster.v1.PscConnectionStatus",
        ))
    }
}

/// Available authorization mode of a Redis cluster.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum AuthorizationMode {
    /// Not set.
    AuthModeUnspecified,
    /// IAM basic authorization mode
    AuthModeIamAuth,
    /// Authorization disabled mode
    AuthModeDisabled,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [AuthorizationMode::value] or
    /// [AuthorizationMode::name].
    UnknownValue(authorization_mode::UnknownValue),
}

#[doc(hidden)]
pub mod authorization_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl AuthorizationMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::AuthModeUnspecified => std::option::Option::Some(0),
            Self::AuthModeIamAuth => std::option::Option::Some(1),
            Self::AuthModeDisabled => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::AuthModeUnspecified => std::option::Option::Some("AUTH_MODE_UNSPECIFIED"),
            Self::AuthModeIamAuth => std::option::Option::Some("AUTH_MODE_IAM_AUTH"),
            Self::AuthModeDisabled => std::option::Option::Some("AUTH_MODE_DISABLED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for AuthorizationMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for AuthorizationMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for AuthorizationMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::AuthModeUnspecified,
            1 => Self::AuthModeIamAuth,
            2 => Self::AuthModeDisabled,
            _ => Self::UnknownValue(authorization_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for AuthorizationMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "AUTH_MODE_UNSPECIFIED" => Self::AuthModeUnspecified,
            "AUTH_MODE_IAM_AUTH" => Self::AuthModeIamAuth,
            "AUTH_MODE_DISABLED" => Self::AuthModeDisabled,
            _ => Self::UnknownValue(authorization_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for AuthorizationMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::AuthModeUnspecified => serializer.serialize_i32(0),
            Self::AuthModeIamAuth => serializer.serialize_i32(1),
            Self::AuthModeDisabled => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for AuthorizationMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<AuthorizationMode>::new(
            ".google.cloud.redis.cluster.v1.AuthorizationMode",
        ))
    }
}

/// NodeType of a redis cluster node,
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum NodeType {
    /// Node type unspecified
    Unspecified,
    /// Redis shared core nano node_type.
    RedisSharedCoreNano,
    /// Redis highmem medium node_type.
    RedisHighmemMedium,
    /// Redis highmem xlarge node_type.
    RedisHighmemXlarge,
    /// Redis standard small node_type.
    RedisStandardSmall,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [NodeType::value] or
    /// [NodeType::name].
    UnknownValue(node_type::UnknownValue),
}

#[doc(hidden)]
pub mod node_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl NodeType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::RedisSharedCoreNano => std::option::Option::Some(1),
            Self::RedisHighmemMedium => std::option::Option::Some(2),
            Self::RedisHighmemXlarge => std::option::Option::Some(3),
            Self::RedisStandardSmall => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("NODE_TYPE_UNSPECIFIED"),
            Self::RedisSharedCoreNano => std::option::Option::Some("REDIS_SHARED_CORE_NANO"),
            Self::RedisHighmemMedium => std::option::Option::Some("REDIS_HIGHMEM_MEDIUM"),
            Self::RedisHighmemXlarge => std::option::Option::Some("REDIS_HIGHMEM_XLARGE"),
            Self::RedisStandardSmall => std::option::Option::Some("REDIS_STANDARD_SMALL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for NodeType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for NodeType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for NodeType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::RedisSharedCoreNano,
            2 => Self::RedisHighmemMedium,
            3 => Self::RedisHighmemXlarge,
            4 => Self::RedisStandardSmall,
            _ => Self::UnknownValue(node_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for NodeType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "NODE_TYPE_UNSPECIFIED" => Self::Unspecified,
            "REDIS_SHARED_CORE_NANO" => Self::RedisSharedCoreNano,
            "REDIS_HIGHMEM_MEDIUM" => Self::RedisHighmemMedium,
            "REDIS_HIGHMEM_XLARGE" => Self::RedisHighmemXlarge,
            "REDIS_STANDARD_SMALL" => Self::RedisStandardSmall,
            _ => Self::UnknownValue(node_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for NodeType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::RedisSharedCoreNano => serializer.serialize_i32(1),
            Self::RedisHighmemMedium => serializer.serialize_i32(2),
            Self::RedisHighmemXlarge => serializer.serialize_i32(3),
            Self::RedisStandardSmall => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for NodeType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<NodeType>::new(
            ".google.cloud.redis.cluster.v1.NodeType",
        ))
    }
}

/// Available mode of in-transit encryption.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum TransitEncryptionMode {
    /// In-transit encryption not set.
    Unspecified,
    /// In-transit encryption disabled.
    Disabled,
    /// Use server managed encryption for in-transit encryption.
    ServerAuthentication,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [TransitEncryptionMode::value] or
    /// [TransitEncryptionMode::name].
    UnknownValue(transit_encryption_mode::UnknownValue),
}

#[doc(hidden)]
pub mod transit_encryption_mode {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl TransitEncryptionMode {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Disabled => std::option::Option::Some(1),
            Self::ServerAuthentication => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("TRANSIT_ENCRYPTION_MODE_UNSPECIFIED"),
            Self::Disabled => std::option::Option::Some("TRANSIT_ENCRYPTION_MODE_DISABLED"),
            Self::ServerAuthentication => {
                std::option::Option::Some("TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for TransitEncryptionMode {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for TransitEncryptionMode {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for TransitEncryptionMode {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Disabled,
            2 => Self::ServerAuthentication,
            _ => Self::UnknownValue(transit_encryption_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for TransitEncryptionMode {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED" => Self::Unspecified,
            "TRANSIT_ENCRYPTION_MODE_DISABLED" => Self::Disabled,
            "TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION" => Self::ServerAuthentication,
            _ => Self::UnknownValue(transit_encryption_mode::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for TransitEncryptionMode {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Disabled => serializer.serialize_i32(1),
            Self::ServerAuthentication => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for TransitEncryptionMode {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<TransitEncryptionMode>::new(
            ".google.cloud.redis.cluster.v1.TransitEncryptionMode",
        ))
    }
}

/// Type of a PSC connection, for cluster access purpose.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ConnectionType {
    /// Cluster endpoint Type is not set
    Unspecified,
    /// Cluster endpoint that will be used as for cluster topology discovery.
    Discovery,
    /// Cluster endpoint that will be used as primary endpoint to access primary.
    Primary,
    /// Cluster endpoint that will be used as reader endpoint to access replicas.
    Reader,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ConnectionType::value] or
    /// [ConnectionType::name].
    UnknownValue(connection_type::UnknownValue),
}

#[doc(hidden)]
pub mod connection_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ConnectionType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Discovery => std::option::Option::Some(1),
            Self::Primary => std::option::Option::Some(2),
            Self::Reader => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("CONNECTION_TYPE_UNSPECIFIED"),
            Self::Discovery => std::option::Option::Some("CONNECTION_TYPE_DISCOVERY"),
            Self::Primary => std::option::Option::Some("CONNECTION_TYPE_PRIMARY"),
            Self::Reader => std::option::Option::Some("CONNECTION_TYPE_READER"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ConnectionType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ConnectionType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ConnectionType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Discovery,
            2 => Self::Primary,
            3 => Self::Reader,
            _ => Self::UnknownValue(connection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ConnectionType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "CONNECTION_TYPE_UNSPECIFIED" => Self::Unspecified,
            "CONNECTION_TYPE_DISCOVERY" => Self::Discovery,
            "CONNECTION_TYPE_PRIMARY" => Self::Primary,
            "CONNECTION_TYPE_READER" => Self::Reader,
            _ => Self::UnknownValue(connection_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ConnectionType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Discovery => serializer.serialize_i32(1),
            Self::Primary => serializer.serialize_i32(2),
            Self::Reader => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ConnectionType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ConnectionType>::new(
            ".google.cloud.redis.cluster.v1.ConnectionType",
        ))
    }
}
