// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request for [CreateCluster][CloudRedis.CreateCluster].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The resource name of the cluster location using the form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The logical name of the Redis cluster in the customer project
    /// with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, and hyphens.
    /// * Must start with a letter.
    /// * Must be between 1-63 characters.
    /// * Must end with a number or a letter.
    /// * Must be unique within the customer project / location
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The cluster that is to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CreateClusterRequest"
    }
}

/// Request for [ListClusters][CloudRedis.ListClusters].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The resource name of the cluster location using the form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListClustersResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListClustersResponse.next_page_token]: crate::model::ListClustersResponse::next_page_token
    pub page_size: i32,

    /// The `next_page_token` value returned from a previous
    /// [ListClusters][CloudRedis.ListClusters] request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListClustersRequest"
    }
}

/// Response for [ListClusters][CloudRedis.ListClusters].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// A list of Redis clusters in the project in the specified location,
    /// or across all locations.
    ///
    /// If the `location_id` in the parent field of the request is "-", all regions
    /// available to the project are queried, and the results aggregated.
    /// If in such an aggregated query a location is unavailable, a placeholder
    /// Redis entry is included in the response with the `name` field set to a
    /// value of the form
    /// `projects/{project_id}/locations/{location_id}/clusters/`- and the
    /// `status` field set to ERROR and `status_message` field set to "location not
    /// available for ListClusters".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListClustersResponse"
    }
}

impl gax::paginator::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for [UpdateCluster][CloudRedis.UpdateCluster].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in
    /// this field. The elements of the repeated paths field may only include these
    /// fields from [Cluster][google.cloud.redis.cluster.v1.Cluster]:
    ///
    /// * `size_gb`
    /// * `replica_count`
    ///
    /// [google.cloud.redis.cluster.v1.Cluster]: crate::model::Cluster
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Update description.
    /// Only fields specified in update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.UpdateClusterRequest"
    }
}

/// Request for [GetCluster][CloudRedis.GetCluster].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetClusterRequest"
    }
}

/// Request for [DeleteCluster][CloudRedis.DeleteCluster].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DeleteClusterRequest"
    }
}

/// Request for
/// [GetClusterCertificateAuthorityRequest][CloudRedis.GetClusterCertificateAuthorityRequest].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterCertificateAuthorityRequest {
    /// Required. Redis cluster certificate authority resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}/certificateAuthority`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetClusterCertificateAuthorityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterCertificateAuthorityRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterCertificateAuthorityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetClusterCertificateAuthorityRequest"
    }
}

/// Request for [ListBackupCollections]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupCollectionsRequest {
    /// Required. The resource name of the backupCollection location using the
    /// form:
    /// `projects/{project_id}/locations/{location_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListBackupCollectionsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListBackupCollectionsResponse.next_page_token]: crate::model::ListBackupCollectionsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBackupCollectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupCollectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupCollectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupCollectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupCollectionsRequest"
    }
}

/// Response for [ListBackupCollections].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupCollectionsResponse {
    /// A list of backupCollections in the project.
    ///
    /// If the `location_id` in the parent field of the request is "-", all regions
    /// available to the project are queried, and the results aggregated.
    /// If in such an aggregated query a location is unavailable, a placeholder
    /// backupCollection entry is included in the response with the `name` field
    /// set to a value of the form
    /// `projects/{project_id}/locations/{location_id}/backupCollections/`- and the
    /// `status` field set to ERROR and `status_message` field set to "location not
    /// available for ListBackupCollections".
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_collections: std::vec::Vec<crate::model::BackupCollection>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupCollectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupCollectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backup_collections][crate::model::ListBackupCollectionsResponse::backup_collections].
    pub fn set_backup_collections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupCollection>,
    {
        use std::iter::Iterator;
        self.backup_collections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupCollectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupCollectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupCollectionsResponse"
    }
}

impl gax::paginator::PageableResponse for ListBackupCollectionsResponse {
    type PageItem = crate::model::BackupCollection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backup_collections
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for [GetBackupCollection].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupCollectionRequest {
    /// Required. Redis backupCollection resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupCollectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupCollectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupCollectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetBackupCollectionRequest"
    }
}

/// Request for [ListBackups].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsRequest {
    /// Required. The resource name of the backupCollection using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    ///
    /// If not specified, a default value of 1000 will be used by the service.
    /// Regardless of the page_size value, the response may include a partial list
    /// and a caller should only rely on response's
    /// [`next_page_token`][google.cloud.redis.cluster.v1.ListBackupsResponse.next_page_token]
    /// to determine if there are more clusters left to be queried.
    ///
    /// [google.cloud.redis.cluster.v1.ListBackupsResponse.next_page_token]: crate::model::ListBackupsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous
    /// [ListBackupCollections] request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListBackupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBackupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBackupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBackupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListBackupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupsRequest"
    }
}

/// Response for [ListBackups].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBackupsResponse {
    /// A list of backups in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backups: std::vec::Vec<crate::model::Backup>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Backups that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBackupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBackupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backups][crate::model::ListBackupsResponse::backups].
    pub fn set_backups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Backup>,
    {
        use std::iter::Iterator;
        self.backups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBackupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBackupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ListBackupsResponse"
    }
}

impl gax::paginator::PageableResponse for ListBackupsResponse {
    type PageItem = crate::model::Backup;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backups
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for [GetBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.GetBackupRequest"
    }
}

/// Request for [DeleteBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBackupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DeleteBackupRequest"
    }
}

/// Request for [ExportBackup].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportBackupRequest {
    /// Required. Redis backup resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/backupCollections/{backup_collection_id}/backups/{backup_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Specify destination to export a backup.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub destination: std::option::Option<crate::model::export_backup_request::Destination>,
}

impl ExportBackupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportBackupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `destination`.
    pub fn set_destination<
        T: std::convert::Into<std::option::Option<crate::model::export_backup_request::Destination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.destination = v.into();
        self
    }

    /// The value of [destination][crate::model::ExportBackupRequest::destination]
    /// if it holds a `GcsBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_bucket(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.destination.as_ref().and_then(|v| match v {
            crate::model::export_backup_request::Destination::GcsBucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [destination][crate::model::ExportBackupRequest::destination]
    /// to hold a `GcsBucket`.
    ///
    /// Note that all the setters affecting `destination` are
    /// mutually exclusive.
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.destination = std::option::Option::Some(
            crate::model::export_backup_request::Destination::GcsBucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ExportBackupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ExportBackupRequest"
    }
}

/// Defines additional types related to ExportBackupRequest
pub mod export_backup_request {
    #[allow(unused_imports)]
    use super::*;

    /// Required. Specify destination to export a backup.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Destination {
        /// Google Cloud Storage bucket, like "my-bucket".
        GcsBucket(std::string::String),
    }
}

/// Request for [BackupCluster].
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupClusterRequest {
    /// Required. Redis cluster resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. TTL for the backup to expire. Value range is 1 day to 100 years.
    /// If not specified, the default value is 100 years.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub ttl: std::option::Option<wkt::Duration>,

    /// Optional. The id of the backup to be created. If not specified, the
    /// default value ([YYYYMMDDHHMMSS]_[Shortened Cluster UID] is used.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_id: std::option::Option<std::string::String>,
}

impl BackupClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [ttl][crate::model::BackupClusterRequest::ttl].
    pub fn set_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.ttl = v.into();
        self
    }

    /// Sets the value of [backup_id][crate::model::BackupClusterRequest::backup_id].
    pub fn set_backup_id<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_id = v.into();
        self
    }
}

impl wkt::message::Message for BackupClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupClusterRequest"
    }
}

/// A cluster instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Required. Identifier. Unique name of the resource in this scope including
    /// project and location using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp associated with the cluster creation request.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this cluster.
    /// Can be CREATING, READY, UPDATING, DELETING and SUSPENDED
    pub state: crate::model::cluster::State,

    /// Output only. System assigned, unique identifier for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. The number of replica nodes per shard.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub replica_count: std::option::Option<i32>,

    /// Optional. The authorization mode of the Redis cluster.
    /// If not provided, auth feature is disabled for the cluster.
    pub authorization_mode: crate::model::AuthorizationMode,

    /// Optional. The in-transit encryption for the Redis cluster.
    /// If not provided, encryption  is disabled for the cluster.
    pub transit_encryption_mode: crate::model::TransitEncryptionMode,

    /// Output only. Redis memory size in GB for the entire cluster rounded up to
    /// the next integer.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub size_gb: std::option::Option<i32>,

    /// Optional. Number of shards for the Redis cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shard_count: std::option::Option<i32>,

    /// Optional. Each PscConfig configures the consumer network where IPs will
    /// be designated to the cluster for client access through Private Service
    /// Connect Automation. Currently, only one PscConfig is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_configs: std::vec::Vec<crate::model::PscConfig>,

    /// Output only. Endpoints created on each given network, for Redis clients to
    /// connect to the cluster. Currently only one discovery endpoint is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub discovery_endpoints: std::vec::Vec<crate::model::DiscoveryEndpoint>,

    /// Output only. The list of PSC connections that are auto-created through
    /// service connectivity automation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_connections: std::vec::Vec<crate::model::PscConnection>,

    /// Output only. Additional information about the current state of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_info: std::option::Option<crate::model::cluster::StateInfo>,

    /// Optional. The type of a redis node in the cluster. NodeType determines the
    /// underlying machine-type of a redis node.
    pub node_type: crate::model::NodeType,

    /// Optional. Persistence config (RDB, AOF) for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub persistence_config: std::option::Option<crate::model::ClusterPersistenceConfig>,

    /// Optional. Key/Value pairs of customer overrides for mutable Redis Configs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub redis_configs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Precise value of redis memory size in GB for the entire
    /// cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub precise_size_gb: std::option::Option<f64>,

    /// Optional. This config will be used to determine how the customer wants us
    /// to distribute cluster resources within the region.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub zone_distribution_config: std::option::Option<crate::model::ZoneDistributionConfig>,

    /// Optional. Cross cluster replication config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cross_cluster_replication_config:
        std::option::Option<crate::model::CrossClusterReplicationConfig>,

    /// Optional. The delete operation will fail when the value is set to true.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub deletion_protection_enabled: std::option::Option<bool>,

    /// Optional. ClusterMaintenancePolicy determines when to allow or deny
    /// updates.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_policy: std::option::Option<crate::model::ClusterMaintenancePolicy>,

    /// Output only. ClusterMaintenanceSchedule Output only Published maintenance
    /// schedule.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_schedule: std::option::Option<crate::model::ClusterMaintenanceSchedule>,

    /// Output only. Service attachment details to configure Psc connections
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub psc_service_attachments: std::vec::Vec<crate::model::PscServiceAttachment>,

    /// Optional. A list of cluster enpoints.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cluster_endpoints: std::vec::Vec<crate::model::ClusterEndpoint>,

    /// Optional. Output only. The backup collection full resource name. Example:
    /// projects/{project}/locations/{location}/backupCollections/{collection}
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backup_collection: std::option::Option<std::string::String>,

    /// Optional. The KMS key used to encrypt the at-rest data of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub kms_key: std::option::Option<std::string::String>,

    /// Optional. The automated backup config for the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub automated_backup_config: std::option::Option<crate::model::AutomatedBackupConfig>,

    /// Output only. Encryption information of the data at rest of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// The source to import from.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub import_sources: std::option::Option<crate::model::cluster::ImportSources>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Cluster::state].
    pub fn set_state<T: std::convert::Into<crate::model::cluster::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Cluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Cluster::replica_count].
    pub fn set_replica_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [authorization_mode][crate::model::Cluster::authorization_mode].
    pub fn set_authorization_mode<T: std::convert::Into<crate::model::AuthorizationMode>>(
        mut self,
        v: T,
    ) -> Self {
        self.authorization_mode = v.into();
        self
    }

    /// Sets the value of [transit_encryption_mode][crate::model::Cluster::transit_encryption_mode].
    pub fn set_transit_encryption_mode<
        T: std::convert::Into<crate::model::TransitEncryptionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.transit_encryption_mode = v.into();
        self
    }

    /// Sets the value of [size_gb][crate::model::Cluster::size_gb].
    pub fn set_size_gb<T: std::convert::Into<std::option::Option<i32>>>(mut self, v: T) -> Self {
        self.size_gb = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Cluster::shard_count].
    pub fn set_shard_count<T: std::convert::Into<std::option::Option<i32>>>(
        mut self,
        v: T,
    ) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [state_info][crate::model::Cluster::state_info].
    pub fn set_state_info<
        T: std::convert::Into<std::option::Option<crate::model::cluster::StateInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.state_info = v.into();
        self
    }

    /// Sets the value of [node_type][crate::model::Cluster::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::NodeType>>(mut self, v: T) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [persistence_config][crate::model::Cluster::persistence_config].
    pub fn set_persistence_config<
        T: std::convert::Into<std::option::Option<crate::model::ClusterPersistenceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.persistence_config = v.into();
        self
    }

    /// Sets the value of [precise_size_gb][crate::model::Cluster::precise_size_gb].
    pub fn set_precise_size_gb<T: std::convert::Into<std::option::Option<f64>>>(
        mut self,
        v: T,
    ) -> Self {
        self.precise_size_gb = v.into();
        self
    }

    /// Sets the value of [zone_distribution_config][crate::model::Cluster::zone_distribution_config].
    pub fn set_zone_distribution_config<
        T: std::convert::Into<std::option::Option<crate::model::ZoneDistributionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.zone_distribution_config = v.into();
        self
    }

    /// Sets the value of [cross_cluster_replication_config][crate::model::Cluster::cross_cluster_replication_config].
    pub fn set_cross_cluster_replication_config<
        T: std::convert::Into<std::option::Option<crate::model::CrossClusterReplicationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cross_cluster_replication_config = v.into();
        self
    }

    /// Sets the value of [deletion_protection_enabled][crate::model::Cluster::deletion_protection_enabled].
    pub fn set_deletion_protection_enabled<T: std::convert::Into<std::option::Option<bool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.deletion_protection_enabled = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<
        T: std::convert::Into<std::option::Option<crate::model::ClusterMaintenancePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_policy = v.into();
        self
    }

    /// Sets the value of [maintenance_schedule][crate::model::Cluster::maintenance_schedule].
    pub fn set_maintenance_schedule<
        T: std::convert::Into<std::option::Option<crate::model::ClusterMaintenanceSchedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_schedule = v.into();
        self
    }

    /// Sets the value of [backup_collection][crate::model::Cluster::backup_collection].
    pub fn set_backup_collection<
        T: std::convert::Into<std::option::Option<std::string::String>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backup_collection = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Cluster::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::option::Option<std::string::String>>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [automated_backup_config][crate::model::Cluster::automated_backup_config].
    pub fn set_automated_backup_config<
        T: std::convert::Into<std::option::Option<crate::model::AutomatedBackupConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_config = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Cluster::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [psc_configs][crate::model::Cluster::psc_configs].
    pub fn set_psc_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscConfig>,
    {
        use std::iter::Iterator;
        self.psc_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [discovery_endpoints][crate::model::Cluster::discovery_endpoints].
    pub fn set_discovery_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiscoveryEndpoint>,
    {
        use std::iter::Iterator;
        self.discovery_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_connections][crate::model::Cluster::psc_connections].
    pub fn set_psc_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscConnection>,
    {
        use std::iter::Iterator;
        self.psc_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [psc_service_attachments][crate::model::Cluster::psc_service_attachments].
    pub fn set_psc_service_attachments<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PscServiceAttachment>,
    {
        use std::iter::Iterator;
        self.psc_service_attachments = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cluster_endpoints][crate::model::Cluster::cluster_endpoints].
    pub fn set_cluster_endpoints<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterEndpoint>,
    {
        use std::iter::Iterator;
        self.cluster_endpoints = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [redis_configs][crate::model::Cluster::redis_configs].
    pub fn set_redis_configs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.redis_configs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `import_sources`.
    pub fn set_import_sources<
        T: std::convert::Into<std::option::Option<crate::model::cluster::ImportSources>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = v.into();
        self
    }

    /// The value of [import_sources][crate::model::Cluster::import_sources]
    /// if it holds a `GcsSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcs_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::GcsBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::cluster::ImportSources::GcsSource(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [import_sources][crate::model::Cluster::import_sources]
    /// if it holds a `ManagedBackupSource`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_managed_backup_source(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::ManagedBackupSource>> {
        #[allow(unreachable_patterns)]
        self.import_sources.as_ref().and_then(|v| match v {
            crate::model::cluster::ImportSources::ManagedBackupSource(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [import_sources][crate::model::Cluster::import_sources]
    /// to hold a `GcsSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_gcs_source<
        T: std::convert::Into<std::boxed::Box<crate::model::cluster::GcsBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources =
            std::option::Option::Some(crate::model::cluster::ImportSources::GcsSource(v.into()));
        self
    }

    /// Sets the value of [import_sources][crate::model::Cluster::import_sources]
    /// to hold a `ManagedBackupSource`.
    ///
    /// Note that all the setters affecting `import_sources` are
    /// mutually exclusive.
    pub fn set_managed_backup_source<
        T: std::convert::Into<std::boxed::Box<crate::model::cluster::ManagedBackupSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.import_sources = std::option::Option::Some(
            crate::model::cluster::ImportSources::ManagedBackupSource(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster"
    }
}

/// Defines additional types related to Cluster
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Represents additional information about the state of the cluster.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct StateInfo {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub info: std::option::Option<crate::model::cluster::state_info::Info>,
    }

    impl StateInfo {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `info`.
        pub fn set_info<
            T: std::convert::Into<std::option::Option<crate::model::cluster::state_info::Info>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = v.into();
            self
        }

        /// The value of [info][crate::model::cluster::StateInfo::info]
        /// if it holds a `UpdateInfo`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_update_info(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>>
        {
            #[allow(unreachable_patterns)]
            self.info.as_ref().and_then(|v| match v {
                crate::model::cluster::state_info::Info::UpdateInfo(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [info][crate::model::cluster::StateInfo::info]
        /// to hold a `UpdateInfo`.
        ///
        /// Note that all the setters affecting `info` are
        /// mutually exclusive.
        pub fn set_update_info<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.info = std::option::Option::Some(
                crate::model::cluster::state_info::Info::UpdateInfo(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for StateInfo {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.StateInfo"
        }
    }

    /// Defines additional types related to StateInfo
    pub mod state_info {
        #[allow(unused_imports)]
        use super::*;

        /// Represents information about an updating cluster.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct UpdateInfo {
            /// Target number of shards for redis cluster
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_shard_count: std::option::Option<i32>,

            /// Target number of replica nodes per shard.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub target_replica_count: std::option::Option<i32>,
        }

        impl UpdateInfo {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target_shard_count][crate::model::cluster::state_info::UpdateInfo::target_shard_count].
            pub fn set_target_shard_count<T: std::convert::Into<std::option::Option<i32>>>(
                mut self,
                v: T,
            ) -> Self {
                self.target_shard_count = v.into();
                self
            }

            /// Sets the value of [target_replica_count][crate::model::cluster::state_info::UpdateInfo::target_replica_count].
            pub fn set_target_replica_count<T: std::convert::Into<std::option::Option<i32>>>(
                mut self,
                v: T,
            ) -> Self {
                self.target_replica_count = v.into();
                self
            }
        }

        impl wkt::message::Message for UpdateInfo {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.StateInfo.UpdateInfo"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Info {
            /// Describes ongoing update on the cluster when cluster state is UPDATING.
            UpdateInfo(std::boxed::Box<crate::model::cluster::state_info::UpdateInfo>),
        }
    }

    /// Backups stored in Cloud Storage buckets.
    /// The Cloud Storage buckets need to be the same region as the clusters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcsBackupSource {
        /// Optional. URIs of the GCS objects to import.
        /// Example: gs://bucket1/object1, gs://bucket2/folder2/object2
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub uris: std::vec::Vec<std::string::String>,
    }

    impl GcsBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uris][crate::model::cluster::GcsBackupSource::uris].
        pub fn set_uris<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.uris = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcsBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.GcsBackupSource"
        }
    }

    /// Backups that generated and managed by memorystore.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedBackupSource {
        /// Optional. Example:
        /// //redis.googleapis.com/projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup}
        /// A shorter version (without the prefix) of the backup name is also
        /// supported, like
        /// projects/{project}/locations/{location}/backupCollections/{collection}/backups/{backup_id}
        /// In this case, it assumes the backup is under redis.googleapis.com.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub backup: std::string::String,
    }

    impl ManagedBackupSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [backup][crate::model::cluster::ManagedBackupSource::backup].
        pub fn set_backup<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.backup = v.into();
            self
        }
    }

    impl wkt::message::Message for ManagedBackupSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.Cluster.ManagedBackupSource"
        }
    }

    /// Represents the different states of a Redis cluster.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Redis cluster is being created.
        pub const CREATING: State = State::new(1);

        /// Redis cluster has been created and is fully usable.
        pub const ACTIVE: State = State::new(2);

        /// Redis cluster configuration is being updated.
        pub const UPDATING: State = State::new(3);

        /// Redis cluster is being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The source to import from.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ImportSources {
        /// Optional. Backups stored in Cloud Storage buckets.
        /// The Cloud Storage buckets need to be the same region as the clusters.
        /// Read permission is required to import from the provided Cloud Storage
        /// objects.
        GcsSource(std::boxed::Box<crate::model::cluster::GcsBackupSource>),
        /// Optional. Backups generated and managed by memorystore service.
        ManagedBackupSource(std::boxed::Box<crate::model::cluster::ManagedBackupSource>),
    }
}

/// The automated backup config for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AutomatedBackupConfig {
    /// Optional. The automated backup mode. If the mode is disabled, the other
    /// fields will be ignored.
    pub automated_backup_mode: crate::model::automated_backup_config::AutomatedBackupMode,

    /// Optional. How long to keep automated backups before the backups are
    /// deleted. The value should be between 1 day and 365 days. If not specified,
    /// the default value is 35 days.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub retention: std::option::Option<wkt::Duration>,

    /// The schedule of automated backups.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub schedule: std::option::Option<crate::model::automated_backup_config::Schedule>,
}

impl AutomatedBackupConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [automated_backup_mode][crate::model::AutomatedBackupConfig::automated_backup_mode].
    pub fn set_automated_backup_mode<
        T: std::convert::Into<crate::model::automated_backup_config::AutomatedBackupMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.automated_backup_mode = v.into();
        self
    }

    /// Sets the value of [retention][crate::model::AutomatedBackupConfig::retention].
    pub fn set_retention<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.retention = v.into();
        self
    }

    /// Sets the value of `schedule`.
    pub fn set_schedule<
        T: std::convert::Into<std::option::Option<crate::model::automated_backup_config::Schedule>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// The value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// if it holds a `FixedFrequencySchedule`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_fixed_frequency_schedule(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
    > {
        #[allow(unreachable_patterns)]
        self.schedule.as_ref().and_then(|v| match v {
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [schedule][crate::model::AutomatedBackupConfig::schedule]
    /// to hold a `FixedFrequencySchedule`.
    ///
    /// Note that all the setters affecting `schedule` are
    /// mutually exclusive.
    pub fn set_fixed_frequency_schedule<
        T: std::convert::Into<
            std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = std::option::Option::Some(
            crate::model::automated_backup_config::Schedule::FixedFrequencySchedule(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AutomatedBackupConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.AutomatedBackupConfig"
    }
}

/// Defines additional types related to AutomatedBackupConfig
pub mod automated_backup_config {
    #[allow(unused_imports)]
    use super::*;

    /// This schedule allows the backup to be triggered at a fixed frequency
    /// (currently only daily is supported).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct FixedFrequencySchedule {
        /// Required. The start time of every automated backup in UTC. It must be set
        /// to the start of an hour. This field is required.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<gtype::model::TimeOfDay>,
    }

    impl FixedFrequencySchedule {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [start_time][crate::model::automated_backup_config::FixedFrequencySchedule::start_time].
        pub fn set_start_time<
            T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for FixedFrequencySchedule {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.AutomatedBackupConfig.FixedFrequencySchedule"
        }
    }

    /// The automated backup mode.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct AutomatedBackupMode(i32);

    impl AutomatedBackupMode {
        /// Default value. Automated backup config is not specified.
        pub const AUTOMATED_BACKUP_MODE_UNSPECIFIED: AutomatedBackupMode =
            AutomatedBackupMode::new(0);

        /// Automated backup config disabled.
        pub const DISABLED: AutomatedBackupMode = AutomatedBackupMode::new(1);

        /// Automated backup config enabled.
        pub const ENABLED: AutomatedBackupMode = AutomatedBackupMode::new(2);

        /// Creates a new AutomatedBackupMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("AUTOMATED_BACKUP_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("ENABLED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "AUTOMATED_BACKUP_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::AUTOMATED_BACKUP_MODE_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for AutomatedBackupMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for AutomatedBackupMode {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The schedule of automated backups.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Schedule {
        /// Optional. Trigger automated backups at a fixed frequency.
        FixedFrequencySchedule(
            std::boxed::Box<crate::model::automated_backup_config::FixedFrequencySchedule>,
        ),
    }
}

/// BackupCollection of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupCollection {
    /// Identifier. Full resource path of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The cluster uid of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uid: std::string::String,

    /// Output only. The full resource path of the cluster the backup collection
    /// belongs to. Example:
    /// projects/{project}/locations/{location}/clusters/{cluster}
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Output only. The KMS key used to encrypt the backups under this backup
    /// collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,

    /// Output only. System assigned unique identifier of the backup collection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,
}

impl BackupCollection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BackupCollection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::BackupCollection::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::BackupCollection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::BackupCollection::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::BackupCollection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }
}

impl wkt::message::Message for BackupCollection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupCollection"
    }
}

/// Backup of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Backup {
    /// Identifier. Full resource path of the backup. the last part of the name is
    /// the backup id with the following format: [YYYYMMDDHHMMSS]_[Shorted Cluster
    /// UID] OR customer specified while backup cluster. Example:
    /// 20240515123000_1234
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the backup was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Cluster resource path of this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// Output only. Cluster uid of this backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_uid: std::string::String,

    /// Output only. Total size of the backup in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub total_size_bytes: i64,

    /// Output only. The time when the backup will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,

    /// Output only. redis-7.2, valkey-7.5
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Output only. List of backup files of the backup.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backup_files: std::vec::Vec<crate::model::BackupFile>,

    /// Output only. Node type of the cluster.
    pub node_type: crate::model::NodeType,

    /// Output only. Number of replicas for the cluster.
    pub replica_count: i32,

    /// Output only. Number of shards for the cluster.
    pub shard_count: i32,

    /// Output only. Type of the backup.
    pub backup_type: crate::model::backup::BackupType,

    /// Output only. State of the backup.
    pub state: crate::model::backup::State,

    /// Output only. Encryption information of the backup.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_info: std::option::Option<crate::model::EncryptionInfo>,

    /// Output only. System assigned unique identifier of the backup.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,
}

impl Backup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Backup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Backup::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::Backup::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [cluster_uid][crate::model::Backup::cluster_uid].
    pub fn set_cluster_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_uid = v.into();
        self
    }

    /// Sets the value of [total_size_bytes][crate::model::Backup::total_size_bytes].
    pub fn set_total_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_size_bytes = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::Backup::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }

    /// Sets the value of [engine_version][crate::model::Backup::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [node_type][crate::model::Backup::node_type].
    pub fn set_node_type<T: std::convert::Into<crate::model::NodeType>>(mut self, v: T) -> Self {
        self.node_type = v.into();
        self
    }

    /// Sets the value of [replica_count][crate::model::Backup::replica_count].
    pub fn set_replica_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.replica_count = v.into();
        self
    }

    /// Sets the value of [shard_count][crate::model::Backup::shard_count].
    pub fn set_shard_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.shard_count = v.into();
        self
    }

    /// Sets the value of [backup_type][crate::model::Backup::backup_type].
    pub fn set_backup_type<T: std::convert::Into<crate::model::backup::BackupType>>(
        mut self,
        v: T,
    ) -> Self {
        self.backup_type = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Backup::state].
    pub fn set_state<T: std::convert::Into<crate::model::backup::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [encryption_info][crate::model::Backup::encryption_info].
    pub fn set_encryption_info<
        T: std::convert::Into<std::option::Option<crate::model::EncryptionInfo>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_info = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Backup::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [backup_files][crate::model::Backup::backup_files].
    pub fn set_backup_files<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BackupFile>,
    {
        use std::iter::Iterator;
        self.backup_files = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Backup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.Backup"
    }
}

/// Defines additional types related to Backup
pub mod backup {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the backup.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct BackupType(i32);

    impl BackupType {
        /// The default value, not set.
        pub const BACKUP_TYPE_UNSPECIFIED: BackupType = BackupType::new(0);

        /// On-demand backup.
        pub const ON_DEMAND: BackupType = BackupType::new(1);

        /// Automated backup.
        pub const AUTOMATED: BackupType = BackupType::new(2);

        /// Creates a new BackupType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("BACKUP_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ON_DEMAND"),
                2 => std::borrow::Cow::Borrowed("AUTOMATED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "BACKUP_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::BACKUP_TYPE_UNSPECIFIED)
                }
                "ON_DEMAND" => std::option::Option::Some(Self::ON_DEMAND),
                "AUTOMATED" => std::option::Option::Some(Self::AUTOMATED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for BackupType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for BackupType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// State of the backup.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// The default value, not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The backup is being created.
        pub const CREATING: State = State::new(1);

        /// The backup is active to be used.
        pub const ACTIVE: State = State::new(2);

        /// The backup is being deleted.
        pub const DELETING: State = State::new(3);

        /// The backup is currently suspended due to reasons like project deletion,
        /// billing account closure, etc.
        pub const SUSPENDED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                4 => std::borrow::Cow::Borrowed("SUSPENDED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "SUSPENDED" => std::option::Option::Some(Self::SUSPENDED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Backup is consisted of multiple backup files.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BackupFile {
    /// Output only. e.g: \<shard-id\>.rdb
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub file_name: std::string::String,

    /// Output only. Size of the backup file in bytes.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub size_bytes: i64,

    /// Output only. The time when the backup file was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,
}

impl BackupFile {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_name][crate::model::BackupFile::file_name].
    pub fn set_file_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_name = v.into();
        self
    }

    /// Sets the value of [size_bytes][crate::model::BackupFile::size_bytes].
    pub fn set_size_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_bytes = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BackupFile::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }
}

impl wkt::message::Message for BackupFile {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.BackupFile"
    }
}

/// Configuration of a service attachment of the cluster, for creating PSC
/// connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscServiceAttachment {
    /// Output only. Service attachment URI which your self-created PscConnection
    /// should use as target
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. Type of a PSC connection targeting this service attachment.
    pub connection_type: crate::model::ConnectionType,
}

impl PscServiceAttachment {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_attachment][crate::model::PscServiceAttachment::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscServiceAttachment::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscServiceAttachment {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscServiceAttachment"
    }
}

/// Cross cluster replication config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CrossClusterReplicationConfig {
    /// The role of the cluster in cross cluster replication.
    pub cluster_role: crate::model::cross_cluster_replication_config::ClusterRole,

    /// Details of the primary cluster that is used as the replication source for
    /// this secondary cluster.
    ///
    /// This field is only set for a secondary cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub primary_cluster:
        std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,

    /// List of secondary clusters that are replicating from this primary cluster.
    ///
    /// This field is only set for a primary cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub secondary_clusters:
        std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>,

    /// Output only. The last time cross cluster replication config was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. An output only view of all the member clusters participating
    /// in the cross cluster replication. This view will be provided by every
    /// member cluster irrespective of its cluster role(primary or secondary).
    ///
    /// A primary cluster can provide information about all the secondary clusters
    /// replicating from it. However, a secondary cluster only knows about the
    /// primary cluster from which it is replicating. However, for scenarios, where
    /// the primary cluster is unavailable(e.g. regional outage), a GetCluster
    /// request can be sent to any other member cluster and this field will list
    /// all the member clusters participating in cross cluster replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub membership: std::option::Option<crate::model::cross_cluster_replication_config::Membership>,
}

impl CrossClusterReplicationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_role][crate::model::CrossClusterReplicationConfig::cluster_role].
    pub fn set_cluster_role<
        T: std::convert::Into<crate::model::cross_cluster_replication_config::ClusterRole>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_role = v.into();
        self
    }

    /// Sets the value of [primary_cluster][crate::model::CrossClusterReplicationConfig::primary_cluster].
    pub fn set_primary_cluster<
        T: std::convert::Into<
            std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.primary_cluster = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::CrossClusterReplicationConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::CrossClusterReplicationConfig::membership].
    pub fn set_membership<
        T: std::convert::Into<
            std::option::Option<crate::model::cross_cluster_replication_config::Membership>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.membership = v.into();
        self
    }

    /// Sets the value of [secondary_clusters][crate::model::CrossClusterReplicationConfig::secondary_clusters].
    pub fn set_secondary_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
    {
        use std::iter::Iterator;
        self.secondary_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CrossClusterReplicationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig"
    }
}

/// Defines additional types related to CrossClusterReplicationConfig
pub mod cross_cluster_replication_config {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the remote cluster associated with this cluster in a cross
    /// cluster replication setup.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RemoteCluster {
        /// The full resource path of the remote cluster in
        /// the format: projects/\<project\>/locations/\<region\>/clusters/\<cluster-id\>
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster: std::string::String,

        /// Output only. The unique identifier of the remote cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uid: std::string::String,
    }

    impl RemoteCluster {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [cluster][crate::model::cross_cluster_replication_config::RemoteCluster::cluster].
        pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.cluster = v.into();
            self
        }

        /// Sets the value of [uid][crate::model::cross_cluster_replication_config::RemoteCluster::uid].
        pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uid = v.into();
            self
        }
    }

    impl wkt::message::Message for RemoteCluster {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig.RemoteCluster"
        }
    }

    /// An output only view of all the member clusters participating in the cross
    /// cluster replication.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Membership {
        /// Output only. The primary cluster that acts as the source of replication
        /// for the secondary clusters.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub primary_cluster:
            std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,

        /// Output only. The list of secondary clusters replicating from the primary
        /// cluster.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub secondary_clusters:
            std::vec::Vec<crate::model::cross_cluster_replication_config::RemoteCluster>,
    }

    impl Membership {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_cluster][crate::model::cross_cluster_replication_config::Membership::primary_cluster].
        pub fn set_primary_cluster<
            T: std::convert::Into<
                std::option::Option<crate::model::cross_cluster_replication_config::RemoteCluster>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.primary_cluster = v.into();
            self
        }

        /// Sets the value of [secondary_clusters][crate::model::cross_cluster_replication_config::Membership::secondary_clusters].
        pub fn set_secondary_clusters<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::cross_cluster_replication_config::RemoteCluster>,
        {
            use std::iter::Iterator;
            self.secondary_clusters = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Membership {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CrossClusterReplicationConfig.Membership"
        }
    }

    /// The role of the cluster in cross cluster replication.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ClusterRole(i32);

    impl ClusterRole {
        /// Cluster role is not set.
        /// The behavior is equivalent to NONE.
        pub const CLUSTER_ROLE_UNSPECIFIED: ClusterRole = ClusterRole::new(0);

        /// This cluster does not participate in cross cluster replication. It is an
        /// independent cluster and does not replicate to or from any other clusters.
        pub const NONE: ClusterRole = ClusterRole::new(1);

        /// A cluster that allows both reads and writes. Any data written to this
        /// cluster is also replicated to the attached secondary clusters.
        pub const PRIMARY: ClusterRole = ClusterRole::new(2);

        /// A cluster that allows only reads and replicates data from a primary
        /// cluster.
        pub const SECONDARY: ClusterRole = ClusterRole::new(3);

        /// Creates a new ClusterRole instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("CLUSTER_ROLE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("NONE"),
                2 => std::borrow::Cow::Borrowed("PRIMARY"),
                3 => std::borrow::Cow::Borrowed("SECONDARY"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "CLUSTER_ROLE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::CLUSTER_ROLE_UNSPECIFIED)
                }
                "NONE" => std::option::Option::Some(Self::NONE),
                "PRIMARY" => std::option::Option::Some(Self::PRIMARY),
                "SECONDARY" => std::option::Option::Some(Self::SECONDARY),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ClusterRole {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ClusterRole {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Maintenance policy per cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterMaintenancePolicy {
    /// Output only. The time when the policy was created i.e. Maintenance Window
    /// or Deny Period was assigned.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the policy was updated i.e. Maintenance Window
    /// or Deny Period was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Maintenance window that is applied to resources covered by this
    /// policy. Minimum 1. For the current version, the maximum number of
    /// weekly_maintenance_window is expected to be one.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub weekly_maintenance_window: std::vec::Vec<crate::model::ClusterWeeklyMaintenanceWindow>,
}

impl ClusterMaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::ClusterMaintenancePolicy::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::ClusterMaintenancePolicy::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [weekly_maintenance_window][crate::model::ClusterMaintenancePolicy::weekly_maintenance_window].
    pub fn set_weekly_maintenance_window<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ClusterWeeklyMaintenanceWindow>,
    {
        use std::iter::Iterator;
        self.weekly_maintenance_window = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterMaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterMaintenancePolicy"
    }
}

/// Time window specified for weekly operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterWeeklyMaintenanceWindow {
    /// Allows to define schedule that runs specified day of the week.
    pub day: gtype::model::DayOfWeek,

    /// Start time of the window in UTC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<gtype::model::TimeOfDay>,
}

impl ClusterWeeklyMaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [day][crate::model::ClusterWeeklyMaintenanceWindow::day].
    pub fn set_day<T: std::convert::Into<gtype::model::DayOfWeek>>(mut self, v: T) -> Self {
        self.day = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ClusterWeeklyMaintenanceWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<gtype::model::TimeOfDay>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }
}

impl wkt::message::Message for ClusterWeeklyMaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterWeeklyMaintenanceWindow"
    }
}

/// Upcoming maitenance schedule.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterMaintenanceSchedule {
    /// Output only. The start time of any upcoming scheduled maintenance for this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The end time of any upcoming scheduled maintenance for this
    /// instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl ClusterMaintenanceSchedule {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ClusterMaintenanceSchedule::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::ClusterMaintenanceSchedule::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for ClusterMaintenanceSchedule {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterMaintenanceSchedule"
    }
}

#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConfig {
    /// Required. The network where the IP address of the discovery endpoint will
    /// be reserved, in the form of
    /// projects/{network_project}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,
}

impl PscConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::PscConfig::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }
}

impl wkt::message::Message for PscConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscConfig"
    }
}

/// Endpoints on each network, for Redis clients to connect to the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiscoveryEndpoint {
    /// Output only. Address of the exposed Redis endpoint used by clients to
    /// connect to the service. The address could be either IP or hostname.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Output only. The port number of the exposed Redis endpoint.
    pub port: i32,

    /// Output only. Customer configuration for where the endpoint is created and
    /// accessed from.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub psc_config: std::option::Option<crate::model::PscConfig>,
}

impl DiscoveryEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [address][crate::model::DiscoveryEndpoint::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [port][crate::model::DiscoveryEndpoint::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [psc_config][crate::model::DiscoveryEndpoint::psc_config].
    pub fn set_psc_config<T: std::convert::Into<std::option::Option<crate::model::PscConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_config = v.into();
        self
    }
}

impl wkt::message::Message for DiscoveryEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.DiscoveryEndpoint"
    }
}

/// Details of consumer resources in a PSC connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscConnection {
    /// Required. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Required. The IP allocated on the consumer network for the PSC forwarding
    /// rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Required. The URI of the consumer side forwarding rule.
    /// Example:
    /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Optional. Project ID of the consumer project where the forwarding rule is
    /// created in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Required. The service attachment which is the target of the PSC connection,
    /// in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection.
    /// Please note that this value is updated periodically.
    /// To get the latest status of a PSC connection, follow
    /// <https://cloud.google.com/vpc/docs/configure-private-service-connect-services#endpoint-details>.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,
}

impl PscConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [address][crate::model::PscConnection::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscConnection"
    }
}

/// ClusterEndpoint consists of PSC connections that are created
/// as a group in each VPC network for accessing the cluster. In each group,
/// there shall be one connection for each service attachment in the cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterEndpoint {
    /// A group of PSC connections. They are created in the same VPC network, one
    /// for each service attachment in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::ConnectionDetail>,
}

impl ClusterEndpoint {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ClusterEndpoint::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ConnectionDetail>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterEndpoint {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterEndpoint"
    }
}

/// Detailed information of each PSC connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConnectionDetail {
    /// A PSC connection to a cluster could either be created through Service
    /// Connectivity Automation (auto-registered connection) during the cluster
    /// creation, or it could be created by customer themselves (user-registered
    /// connection).
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::connection_detail::Connection>,
}

impl ConnectionDetail {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `connection`.
    pub fn set_connection<
        T: std::convert::Into<std::option::Option<crate::model::connection_detail::Connection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = v.into();
        self
    }

    /// The value of [connection][crate::model::ConnectionDetail::connection]
    /// if it holds a `PscAutoConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_psc_auto_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PscAutoConnection>> {
        #[allow(unreachable_patterns)]
        self.connection.as_ref().and_then(|v| match v {
            crate::model::connection_detail::Connection::PscAutoConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [connection][crate::model::ConnectionDetail::connection]
    /// if it holds a `PscConnection`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_psc_connection(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PscConnection>> {
        #[allow(unreachable_patterns)]
        self.connection.as_ref().and_then(|v| match v {
            crate::model::connection_detail::Connection::PscConnection(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection][crate::model::ConnectionDetail::connection]
    /// to hold a `PscAutoConnection`.
    ///
    /// Note that all the setters affecting `connection` are
    /// mutually exclusive.
    pub fn set_psc_auto_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::PscAutoConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = std::option::Option::Some(
            crate::model::connection_detail::Connection::PscAutoConnection(v.into()),
        );
        self
    }

    /// Sets the value of [connection][crate::model::ConnectionDetail::connection]
    /// to hold a `PscConnection`.
    ///
    /// Note that all the setters affecting `connection` are
    /// mutually exclusive.
    pub fn set_psc_connection<
        T: std::convert::Into<std::boxed::Box<crate::model::PscConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection = std::option::Option::Some(
            crate::model::connection_detail::Connection::PscConnection(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ConnectionDetail {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ConnectionDetail"
    }
}

/// Defines additional types related to ConnectionDetail
pub mod connection_detail {
    #[allow(unused_imports)]
    use super::*;

    /// A PSC connection to a cluster could either be created through Service
    /// Connectivity Automation (auto-registered connection) during the cluster
    /// creation, or it could be created by customer themselves (user-registered
    /// connection).
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Connection {
        /// Detailed information of a PSC connection that is created through
        /// service connectivity automation.
        PscAutoConnection(std::boxed::Box<crate::model::PscAutoConnection>),
        /// Detailed information of a PSC connection that is created by the customer
        /// who owns the cluster.
        PscConnection(std::boxed::Box<crate::model::PscConnection>),
    }
}

/// Details of consumer resources in a PSC connection that is created through
/// Service Connectivity Automation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PscAutoConnection {
    /// Output only. The PSC connection id of the forwarding rule connected to the
    /// service attachment.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub psc_connection_id: std::string::String,

    /// Output only. The IP allocated on the consumer network for the PSC
    /// forwarding rule.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub address: std::string::String,

    /// Output only. The URI of the consumer side forwarding rule.
    /// Example:
    /// projects/{projectNumOrId}/regions/us-east1/forwardingRules/{resourceId}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub forwarding_rule: std::string::String,

    /// Required. The consumer project_id where the forwarding rule is created
    /// from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project_id: std::string::String,

    /// Required. The consumer network where the IP address resides, in the form of
    /// projects/{project_id}/global/networks/{network_id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Output only. The service attachment which is the target of the PSC
    /// connection, in the form of
    /// projects/{project-id}/regions/{region}/serviceAttachments/{service-attachment-id}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_attachment: std::string::String,

    /// Output only. The status of the PSC connection.
    /// Please note that this value is updated periodically.
    /// Please use Private Service Connect APIs for the latest status.
    pub psc_connection_status: crate::model::PscConnectionStatus,

    /// Output only. Type of the PSC connection.
    pub connection_type: crate::model::ConnectionType,
}

impl PscAutoConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [psc_connection_id][crate::model::PscAutoConnection::psc_connection_id].
    pub fn set_psc_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_id = v.into();
        self
    }

    /// Sets the value of [address][crate::model::PscAutoConnection::address].
    pub fn set_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.address = v.into();
        self
    }

    /// Sets the value of [forwarding_rule][crate::model::PscAutoConnection::forwarding_rule].
    pub fn set_forwarding_rule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.forwarding_rule = v.into();
        self
    }

    /// Sets the value of [project_id][crate::model::PscAutoConnection::project_id].
    pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project_id = v.into();
        self
    }

    /// Sets the value of [network][crate::model::PscAutoConnection::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [service_attachment][crate::model::PscAutoConnection::service_attachment].
    pub fn set_service_attachment<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.service_attachment = v.into();
        self
    }

    /// Sets the value of [psc_connection_status][crate::model::PscAutoConnection::psc_connection_status].
    pub fn set_psc_connection_status<T: std::convert::Into<crate::model::PscConnectionStatus>>(
        mut self,
        v: T,
    ) -> Self {
        self.psc_connection_status = v.into();
        self
    }

    /// Sets the value of [connection_type][crate::model::PscAutoConnection::connection_type].
    pub fn set_connection_type<T: std::convert::Into<crate::model::ConnectionType>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_type = v.into();
        self
    }
}

impl wkt::message::Message for PscAutoConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.PscAutoConnection"
    }
}

/// Pre-defined metadata fields.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.OperationMetadata"
    }
}

/// Redis cluster certificate authority
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CertificateAuthority {
    /// Identifier. Unique name of the resource in this scope including project,
    /// location and cluster using the form:
    /// `projects/{project}/locations/{location}/clusters/{cluster}/certificateAuthority`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// server ca information
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub server_ca: std::option::Option<crate::model::certificate_authority::ServerCa>,
}

impl CertificateAuthority {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CertificateAuthority::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of `server_ca`.
    pub fn set_server_ca<
        T: std::convert::Into<std::option::Option<crate::model::certificate_authority::ServerCa>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = v.into();
        self
    }

    /// The value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// if it holds a `ManagedServerCa`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_managed_server_ca(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
    > {
        #[allow(unreachable_patterns)]
        self.server_ca.as_ref().and_then(|v| match v {
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [server_ca][crate::model::CertificateAuthority::server_ca]
    /// to hold a `ManagedServerCa`.
    ///
    /// Note that all the setters affecting `server_ca` are
    /// mutually exclusive.
    pub fn set_managed_server_ca<
        T: std::convert::Into<
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.server_ca = std::option::Option::Some(
            crate::model::certificate_authority::ServerCa::ManagedServerCa(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CertificateAuthority {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority"
    }
}

/// Defines additional types related to CertificateAuthority
pub mod certificate_authority {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ManagedCertificateAuthority {
        /// The PEM encoded CA certificate chains for redis managed
        /// server authentication
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub ca_certs: std::vec::Vec<
            crate::model::certificate_authority::managed_certificate_authority::CertChain,
        >,
    }

    impl ManagedCertificateAuthority {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ca_certs][crate::model::certificate_authority::ManagedCertificateAuthority::ca_certs].
        pub fn set_ca_certs<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<
                crate::model::certificate_authority::managed_certificate_authority::CertChain,
            >,
        {
            use std::iter::Iterator;
            self.ca_certs = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ManagedCertificateAuthority {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority"
        }
    }

    /// Defines additional types related to ManagedCertificateAuthority
    pub mod managed_certificate_authority {
        #[allow(unused_imports)]
        use super::*;

        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CertChain {
            /// The certificates that form the CA chain, from leaf to root order.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub certificates: std::vec::Vec<std::string::String>,
        }

        impl CertChain {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [certificates][crate::model::certificate_authority::managed_certificate_authority::CertChain::certificates].
            pub fn set_certificates<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.certificates = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for CertChain {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.redis.cluster.v1.CertificateAuthority.ManagedCertificateAuthority.CertChain"
            }
        }
    }

    /// server ca information
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ServerCa {
        ManagedServerCa(
            std::boxed::Box<crate::model::certificate_authority::ManagedCertificateAuthority>,
        ),
    }
}

/// Configuration of the persistence functionality.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterPersistenceConfig {
    /// Optional. The mode of persistence.
    pub mode: crate::model::cluster_persistence_config::PersistenceMode,

    /// Optional. RDB configuration. This field will be ignored if mode is not RDB.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub rdb_config: std::option::Option<crate::model::cluster_persistence_config::RDBConfig>,

    /// Optional. AOF configuration. This field will be ignored if mode is not AOF.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub aof_config: std::option::Option<crate::model::cluster_persistence_config::AOFConfig>,
}

impl ClusterPersistenceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ClusterPersistenceConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::cluster_persistence_config::PersistenceMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [rdb_config][crate::model::ClusterPersistenceConfig::rdb_config].
    pub fn set_rdb_config<
        T: std::convert::Into<
            std::option::Option<crate::model::cluster_persistence_config::RDBConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.rdb_config = v.into();
        self
    }

    /// Sets the value of [aof_config][crate::model::ClusterPersistenceConfig::aof_config].
    pub fn set_aof_config<
        T: std::convert::Into<
            std::option::Option<crate::model::cluster_persistence_config::AOFConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.aof_config = v.into();
        self
    }
}

impl wkt::message::Message for ClusterPersistenceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig"
    }
}

/// Defines additional types related to ClusterPersistenceConfig
pub mod cluster_persistence_config {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the RDB based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RDBConfig {
        /// Optional. Period between RDB snapshots.
        pub rdb_snapshot_period:
            crate::model::cluster_persistence_config::rdb_config::SnapshotPeriod,

        /// Optional. The time that the first snapshot was/will be attempted, and to
        /// which future snapshots will be aligned. If not provided, the current time
        /// will be used.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub rdb_snapshot_start_time: std::option::Option<wkt::Timestamp>,
    }

    impl RDBConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [rdb_snapshot_period][crate::model::cluster_persistence_config::RDBConfig::rdb_snapshot_period].
        pub fn set_rdb_snapshot_period<
            T: std::convert::Into<
                crate::model::cluster_persistence_config::rdb_config::SnapshotPeriod,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_period = v.into();
            self
        }

        /// Sets the value of [rdb_snapshot_start_time][crate::model::cluster_persistence_config::RDBConfig::rdb_snapshot_start_time].
        pub fn set_rdb_snapshot_start_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.rdb_snapshot_start_time = v.into();
            self
        }
    }

    impl wkt::message::Message for RDBConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig.RDBConfig"
        }
    }

    /// Defines additional types related to RDBConfig
    pub mod rdb_config {
        #[allow(unused_imports)]
        use super::*;

        /// Available snapshot periods.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct SnapshotPeriod(i32);

        impl SnapshotPeriod {
            /// Not set.
            pub const SNAPSHOT_PERIOD_UNSPECIFIED: SnapshotPeriod = SnapshotPeriod::new(0);

            /// One hour.
            pub const ONE_HOUR: SnapshotPeriod = SnapshotPeriod::new(1);

            /// Six hours.
            pub const SIX_HOURS: SnapshotPeriod = SnapshotPeriod::new(2);

            /// Twelve hours.
            pub const TWELVE_HOURS: SnapshotPeriod = SnapshotPeriod::new(3);

            /// Twenty four hours.
            pub const TWENTY_FOUR_HOURS: SnapshotPeriod = SnapshotPeriod::new(4);

            /// Creates a new SnapshotPeriod instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("SNAPSHOT_PERIOD_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("ONE_HOUR"),
                    2 => std::borrow::Cow::Borrowed("SIX_HOURS"),
                    3 => std::borrow::Cow::Borrowed("TWELVE_HOURS"),
                    4 => std::borrow::Cow::Borrowed("TWENTY_FOUR_HOURS"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "SNAPSHOT_PERIOD_UNSPECIFIED" => {
                        std::option::Option::Some(Self::SNAPSHOT_PERIOD_UNSPECIFIED)
                    }
                    "ONE_HOUR" => std::option::Option::Some(Self::ONE_HOUR),
                    "SIX_HOURS" => std::option::Option::Some(Self::SIX_HOURS),
                    "TWELVE_HOURS" => std::option::Option::Some(Self::TWELVE_HOURS),
                    "TWENTY_FOUR_HOURS" => std::option::Option::Some(Self::TWENTY_FOUR_HOURS),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for SnapshotPeriod {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for SnapshotPeriod {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Configuration of the AOF based persistence.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AOFConfig {
        /// Optional. fsync configuration.
        pub append_fsync: crate::model::cluster_persistence_config::aof_config::AppendFsync,
    }

    impl AOFConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [append_fsync][crate::model::cluster_persistence_config::AOFConfig::append_fsync].
        pub fn set_append_fsync<
            T: std::convert::Into<crate::model::cluster_persistence_config::aof_config::AppendFsync>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.append_fsync = v.into();
            self
        }
    }

    impl wkt::message::Message for AOFConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.redis.cluster.v1.ClusterPersistenceConfig.AOFConfig"
        }
    }

    /// Defines additional types related to AOFConfig
    pub mod aof_config {
        #[allow(unused_imports)]
        use super::*;

        /// Available fsync modes.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        pub struct AppendFsync(i32);

        impl AppendFsync {
            /// Not set. Default: EVERYSEC
            pub const APPEND_FSYNC_UNSPECIFIED: AppendFsync = AppendFsync::new(0);

            /// Never fsync. Normally Linux will flush data every 30 seconds with this
            /// configuration, but it's up to the kernel's exact tuning.
            pub const NO: AppendFsync = AppendFsync::new(1);

            /// fsync every second. Fast enough, and you may lose 1 second of data if
            /// there is a disaster
            pub const EVERYSEC: AppendFsync = AppendFsync::new(2);

            /// fsync every time new write commands are appended to the AOF. It has the
            /// best data loss protection at the cost of performance
            pub const ALWAYS: AppendFsync = AppendFsync::new(3);

            /// Creates a new AppendFsync instance.
            pub(crate) const fn new(value: i32) -> Self {
                Self(value)
            }

            /// Gets the enum value.
            pub fn value(&self) -> i32 {
                self.0
            }

            /// Gets the enum value as a string.
            pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                match self.0 {
                    0 => std::borrow::Cow::Borrowed("APPEND_FSYNC_UNSPECIFIED"),
                    1 => std::borrow::Cow::Borrowed("NO"),
                    2 => std::borrow::Cow::Borrowed("EVERYSEC"),
                    3 => std::borrow::Cow::Borrowed("ALWAYS"),
                    _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                }
            }

            /// Creates an enum value from the value name.
            pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                match name {
                    "APPEND_FSYNC_UNSPECIFIED" => {
                        std::option::Option::Some(Self::APPEND_FSYNC_UNSPECIFIED)
                    }
                    "NO" => std::option::Option::Some(Self::NO),
                    "EVERYSEC" => std::option::Option::Some(Self::EVERYSEC),
                    "ALWAYS" => std::option::Option::Some(Self::ALWAYS),
                    _ => std::option::Option::None,
                }
            }
        }

        impl std::convert::From<i32> for AppendFsync {
            fn from(value: i32) -> Self {
                Self::new(value)
            }
        }

        impl std::default::Default for AppendFsync {
            fn default() -> Self {
                Self::new(0)
            }
        }
    }

    /// Available persistence modes.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct PersistenceMode(i32);

    impl PersistenceMode {
        /// Not set.
        pub const PERSISTENCE_MODE_UNSPECIFIED: PersistenceMode = PersistenceMode::new(0);

        /// Persistence is disabled, and any snapshot data is deleted.
        pub const DISABLED: PersistenceMode = PersistenceMode::new(1);

        /// RDB based persistence is enabled.
        pub const RDB: PersistenceMode = PersistenceMode::new(2);

        /// AOF based persistence is enabled.
        pub const AOF: PersistenceMode = PersistenceMode::new(3);

        /// Creates a new PersistenceMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("PERSISTENCE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("DISABLED"),
                2 => std::borrow::Cow::Borrowed("RDB"),
                3 => std::borrow::Cow::Borrowed("AOF"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "PERSISTENCE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::PERSISTENCE_MODE_UNSPECIFIED)
                }
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "RDB" => std::option::Option::Some(Self::RDB),
                "AOF" => std::option::Option::Some(Self::AOF),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for PersistenceMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for PersistenceMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Zone distribution config for allocation of cluster resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZoneDistributionConfig {
    /// Optional. The mode of zone distribution. Defaults to MULTI_ZONE, when not
    /// specified.
    pub mode: crate::model::zone_distribution_config::ZoneDistributionMode,

    /// Optional. When SINGLE ZONE distribution is selected, zone field would be
    /// used to allocate all resources in that zone. This is not applicable to
    /// MULTI_ZONE, and would be ignored for MULTI_ZONE clusters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,
}

impl ZoneDistributionConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [mode][crate::model::ZoneDistributionConfig::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::zone_distribution_config::ZoneDistributionMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ZoneDistributionConfig::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }
}

impl wkt::message::Message for ZoneDistributionConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.ZoneDistributionConfig"
    }
}

/// Defines additional types related to ZoneDistributionConfig
pub mod zone_distribution_config {
    #[allow(unused_imports)]
    use super::*;

    /// Defines various modes of zone distribution.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct ZoneDistributionMode(i32);

    impl ZoneDistributionMode {
        /// Not Set. Default: MULTI_ZONE
        pub const ZONE_DISTRIBUTION_MODE_UNSPECIFIED: ZoneDistributionMode =
            ZoneDistributionMode::new(0);

        /// Distribute all resources across 3 zones picked at random, within the
        /// region.
        pub const MULTI_ZONE: ZoneDistributionMode = ZoneDistributionMode::new(1);

        /// Distribute all resources in a single zone. The zone field must be
        /// specified, when this mode is selected.
        pub const SINGLE_ZONE: ZoneDistributionMode = ZoneDistributionMode::new(2);

        /// Creates a new ZoneDistributionMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("ZONE_DISTRIBUTION_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("MULTI_ZONE"),
                2 => std::borrow::Cow::Borrowed("SINGLE_ZONE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "ZONE_DISTRIBUTION_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::ZONE_DISTRIBUTION_MODE_UNSPECIFIED)
                }
                "MULTI_ZONE" => std::option::Option::Some(Self::MULTI_ZONE),
                "SINGLE_ZONE" => std::option::Option::Some(Self::SINGLE_ZONE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for ZoneDistributionMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for ZoneDistributionMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for rescheduling a cluster maintenance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RescheduleClusterMaintenanceRequest {
    /// Required. Redis Cluster instance resource name using the form:
    /// `projects/{project_id}/locations/{location_id}/clusters/{cluster_id}`
    /// where `location_id` refers to a GCP region.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. If reschedule type is SPECIFIC_TIME, must set up schedule_time as
    /// well.
    pub reschedule_type: crate::model::reschedule_cluster_maintenance_request::RescheduleType,

    /// Optional. Timestamp when the maintenance shall be rescheduled to if
    /// reschedule_type=SPECIFIC_TIME, in RFC 3339 format, for
    /// example `2012-11-15T16:19:00.094Z`.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub schedule_time: std::option::Option<wkt::Timestamp>,
}

impl RescheduleClusterMaintenanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RescheduleClusterMaintenanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reschedule_type][crate::model::RescheduleClusterMaintenanceRequest::reschedule_type].
    pub fn set_reschedule_type<
        T: std::convert::Into<crate::model::reschedule_cluster_maintenance_request::RescheduleType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.reschedule_type = v.into();
        self
    }

    /// Sets the value of [schedule_time][crate::model::RescheduleClusterMaintenanceRequest::schedule_time].
    pub fn set_schedule_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule_time = v.into();
        self
    }
}

impl wkt::message::Message for RescheduleClusterMaintenanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.RescheduleClusterMaintenanceRequest"
    }
}

/// Defines additional types related to RescheduleClusterMaintenanceRequest
pub mod reschedule_cluster_maintenance_request {
    #[allow(unused_imports)]
    use super::*;

    /// Reschedule options.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct RescheduleType(i32);

    impl RescheduleType {
        /// Not set.
        pub const RESCHEDULE_TYPE_UNSPECIFIED: RescheduleType = RescheduleType::new(0);

        /// If the user wants to schedule the maintenance to happen now.
        pub const IMMEDIATE: RescheduleType = RescheduleType::new(1);

        /// If the user wants to reschedule the maintenance to a specific time.
        pub const SPECIFIC_TIME: RescheduleType = RescheduleType::new(3);

        /// Creates a new RescheduleType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("RESCHEDULE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("IMMEDIATE"),
                3 => std::borrow::Cow::Borrowed("SPECIFIC_TIME"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "RESCHEDULE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::RESCHEDULE_TYPE_UNSPECIFIED)
                }
                "IMMEDIATE" => std::option::Option::Some(Self::IMMEDIATE),
                "SPECIFIC_TIME" => std::option::Option::Some(Self::SPECIFIC_TIME),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for RescheduleType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for RescheduleType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// EncryptionInfo describes the encryption information of a cluster or a backup.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EncryptionInfo {
    /// Output only. Type of encryption.
    pub encryption_type: crate::model::encryption_info::Type,

    /// Output only. KMS key versions that are being used to protect the data
    /// at-rest.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub kms_key_versions: std::vec::Vec<std::string::String>,

    /// Output only. The state of the primary version of the KMS key perceived by
    /// the system. This field is not populated in backups.
    pub kms_key_primary_state: crate::model::encryption_info::KmsKeyState,

    /// Output only. The most recent time when the encryption info was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_update_time: std::option::Option<wkt::Timestamp>,
}

impl EncryptionInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [encryption_type][crate::model::EncryptionInfo::encryption_type].
    pub fn set_encryption_type<T: std::convert::Into<crate::model::encryption_info::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_type = v.into();
        self
    }

    /// Sets the value of [kms_key_primary_state][crate::model::EncryptionInfo::kms_key_primary_state].
    pub fn set_kms_key_primary_state<
        T: std::convert::Into<crate::model::encryption_info::KmsKeyState>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_primary_state = v.into();
        self
    }

    /// Sets the value of [last_update_time][crate::model::EncryptionInfo::last_update_time].
    pub fn set_last_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_update_time = v.into();
        self
    }

    /// Sets the value of [kms_key_versions][crate::model::EncryptionInfo::kms_key_versions].
    pub fn set_kms_key_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.kms_key_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for EncryptionInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.redis.cluster.v1.EncryptionInfo"
    }
}

/// Defines additional types related to EncryptionInfo
pub mod encryption_info {
    #[allow(unused_imports)]
    use super::*;

    /// Possible encryption types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct Type(i32);

    impl Type {
        /// Encryption type not specified. Defaults to GOOGLE_DEFAULT_ENCRYPTION.
        pub const TYPE_UNSPECIFIED: Type = Type::new(0);

        /// The data is encrypted at rest with a key that is fully managed by Google.
        /// No key version will be populated. This is the default state.
        pub const GOOGLE_DEFAULT_ENCRYPTION: Type = Type::new(1);

        /// The data is encrypted at rest with a key that is managed by the customer.
        /// KMS key versions will be populated.
        pub const CUSTOMER_MANAGED_ENCRYPTION: Type = Type::new(2);

        /// Creates a new Type instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("GOOGLE_DEFAULT_ENCRYPTION"),
                2 => std::borrow::Cow::Borrowed("CUSTOMER_MANAGED_ENCRYPTION"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TYPE_UNSPECIFIED),
                "GOOGLE_DEFAULT_ENCRYPTION" => {
                    std::option::Option::Some(Self::GOOGLE_DEFAULT_ENCRYPTION)
                }
                "CUSTOMER_MANAGED_ENCRYPTION" => {
                    std::option::Option::Some(Self::CUSTOMER_MANAGED_ENCRYPTION)
                }
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The state of the KMS key perceived by the system. Refer to the public
    /// documentation for the impact of each state.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct KmsKeyState(i32);

    impl KmsKeyState {
        /// The default value. This value is unused.
        pub const KMS_KEY_STATE_UNSPECIFIED: KmsKeyState = KmsKeyState::new(0);

        /// The KMS key is enabled and correctly configured.
        pub const ENABLED: KmsKeyState = KmsKeyState::new(1);

        /// Permission denied on the KMS key.
        pub const PERMISSION_DENIED: KmsKeyState = KmsKeyState::new(2);

        /// The KMS key is disabled.
        pub const DISABLED: KmsKeyState = KmsKeyState::new(3);

        /// The KMS key is destroyed.
        pub const DESTROYED: KmsKeyState = KmsKeyState::new(4);

        /// The KMS key is scheduled to be destroyed.
        pub const DESTROY_SCHEDULED: KmsKeyState = KmsKeyState::new(5);

        /// The EKM key is unreachable.
        pub const EKM_KEY_UNREACHABLE_DETECTED: KmsKeyState = KmsKeyState::new(6);

        /// Billing is disabled for the project.
        pub const BILLING_DISABLED: KmsKeyState = KmsKeyState::new(7);

        /// All other unknown failures.
        pub const UNKNOWN_FAILURE: KmsKeyState = KmsKeyState::new(8);

        /// Creates a new KmsKeyState instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("KMS_KEY_STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ENABLED"),
                2 => std::borrow::Cow::Borrowed("PERMISSION_DENIED"),
                3 => std::borrow::Cow::Borrowed("DISABLED"),
                4 => std::borrow::Cow::Borrowed("DESTROYED"),
                5 => std::borrow::Cow::Borrowed("DESTROY_SCHEDULED"),
                6 => std::borrow::Cow::Borrowed("EKM_KEY_UNREACHABLE_DETECTED"),
                7 => std::borrow::Cow::Borrowed("BILLING_DISABLED"),
                8 => std::borrow::Cow::Borrowed("UNKNOWN_FAILURE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "KMS_KEY_STATE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::KMS_KEY_STATE_UNSPECIFIED)
                }
                "ENABLED" => std::option::Option::Some(Self::ENABLED),
                "PERMISSION_DENIED" => std::option::Option::Some(Self::PERMISSION_DENIED),
                "DISABLED" => std::option::Option::Some(Self::DISABLED),
                "DESTROYED" => std::option::Option::Some(Self::DESTROYED),
                "DESTROY_SCHEDULED" => std::option::Option::Some(Self::DESTROY_SCHEDULED),
                "EKM_KEY_UNREACHABLE_DETECTED" => {
                    std::option::Option::Some(Self::EKM_KEY_UNREACHABLE_DETECTED)
                }
                "BILLING_DISABLED" => std::option::Option::Some(Self::BILLING_DISABLED),
                "UNKNOWN_FAILURE" => std::option::Option::Some(Self::UNKNOWN_FAILURE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for KmsKeyState {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for KmsKeyState {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Status of the PSC connection.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct PscConnectionStatus(i32);

impl PscConnectionStatus {
    /// PSC connection status is not specified.
    pub const PSC_CONNECTION_STATUS_UNSPECIFIED: PscConnectionStatus = PscConnectionStatus::new(0);

    /// The connection is active
    pub const PSC_CONNECTION_STATUS_ACTIVE: PscConnectionStatus = PscConnectionStatus::new(1);

    /// Connection not found
    pub const PSC_CONNECTION_STATUS_NOT_FOUND: PscConnectionStatus = PscConnectionStatus::new(2);

    /// Creates a new PscConnectionStatus instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("PSC_CONNECTION_STATUS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("PSC_CONNECTION_STATUS_ACTIVE"),
            2 => std::borrow::Cow::Borrowed("PSC_CONNECTION_STATUS_NOT_FOUND"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "PSC_CONNECTION_STATUS_UNSPECIFIED" => {
                std::option::Option::Some(Self::PSC_CONNECTION_STATUS_UNSPECIFIED)
            }
            "PSC_CONNECTION_STATUS_ACTIVE" => {
                std::option::Option::Some(Self::PSC_CONNECTION_STATUS_ACTIVE)
            }
            "PSC_CONNECTION_STATUS_NOT_FOUND" => {
                std::option::Option::Some(Self::PSC_CONNECTION_STATUS_NOT_FOUND)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for PscConnectionStatus {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for PscConnectionStatus {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Available authorization mode of a Redis cluster.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct AuthorizationMode(i32);

impl AuthorizationMode {
    /// Not set.
    pub const AUTH_MODE_UNSPECIFIED: AuthorizationMode = AuthorizationMode::new(0);

    /// IAM basic authorization mode
    pub const AUTH_MODE_IAM_AUTH: AuthorizationMode = AuthorizationMode::new(1);

    /// Authorization disabled mode
    pub const AUTH_MODE_DISABLED: AuthorizationMode = AuthorizationMode::new(2);

    /// Creates a new AuthorizationMode instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("AUTH_MODE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("AUTH_MODE_IAM_AUTH"),
            2 => std::borrow::Cow::Borrowed("AUTH_MODE_DISABLED"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "AUTH_MODE_UNSPECIFIED" => std::option::Option::Some(Self::AUTH_MODE_UNSPECIFIED),
            "AUTH_MODE_IAM_AUTH" => std::option::Option::Some(Self::AUTH_MODE_IAM_AUTH),
            "AUTH_MODE_DISABLED" => std::option::Option::Some(Self::AUTH_MODE_DISABLED),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for AuthorizationMode {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for AuthorizationMode {
    fn default() -> Self {
        Self::new(0)
    }
}

/// NodeType of a redis cluster node,
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct NodeType(i32);

impl NodeType {
    /// Node type unspecified
    pub const NODE_TYPE_UNSPECIFIED: NodeType = NodeType::new(0);

    /// Redis shared core nano node_type.
    pub const REDIS_SHARED_CORE_NANO: NodeType = NodeType::new(1);

    /// Redis highmem medium node_type.
    pub const REDIS_HIGHMEM_MEDIUM: NodeType = NodeType::new(2);

    /// Redis highmem xlarge node_type.
    pub const REDIS_HIGHMEM_XLARGE: NodeType = NodeType::new(3);

    /// Redis standard small node_type.
    pub const REDIS_STANDARD_SMALL: NodeType = NodeType::new(4);

    /// Creates a new NodeType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("NODE_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("REDIS_SHARED_CORE_NANO"),
            2 => std::borrow::Cow::Borrowed("REDIS_HIGHMEM_MEDIUM"),
            3 => std::borrow::Cow::Borrowed("REDIS_HIGHMEM_XLARGE"),
            4 => std::borrow::Cow::Borrowed("REDIS_STANDARD_SMALL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "NODE_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::NODE_TYPE_UNSPECIFIED),
            "REDIS_SHARED_CORE_NANO" => std::option::Option::Some(Self::REDIS_SHARED_CORE_NANO),
            "REDIS_HIGHMEM_MEDIUM" => std::option::Option::Some(Self::REDIS_HIGHMEM_MEDIUM),
            "REDIS_HIGHMEM_XLARGE" => std::option::Option::Some(Self::REDIS_HIGHMEM_XLARGE),
            "REDIS_STANDARD_SMALL" => std::option::Option::Some(Self::REDIS_STANDARD_SMALL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for NodeType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for NodeType {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Available mode of in-transit encryption.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct TransitEncryptionMode(i32);

impl TransitEncryptionMode {
    /// In-transit encryption not set.
    pub const TRANSIT_ENCRYPTION_MODE_UNSPECIFIED: TransitEncryptionMode =
        TransitEncryptionMode::new(0);

    /// In-transit encryption disabled.
    pub const TRANSIT_ENCRYPTION_MODE_DISABLED: TransitEncryptionMode =
        TransitEncryptionMode::new(1);

    /// Use server managed encryption for in-transit encryption.
    pub const TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION: TransitEncryptionMode =
        TransitEncryptionMode::new(2);

    /// Creates a new TransitEncryptionMode instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("TRANSIT_ENCRYPTION_MODE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("TRANSIT_ENCRYPTION_MODE_DISABLED"),
            2 => std::borrow::Cow::Borrowed("TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "TRANSIT_ENCRYPTION_MODE_UNSPECIFIED" => {
                std::option::Option::Some(Self::TRANSIT_ENCRYPTION_MODE_UNSPECIFIED)
            }
            "TRANSIT_ENCRYPTION_MODE_DISABLED" => {
                std::option::Option::Some(Self::TRANSIT_ENCRYPTION_MODE_DISABLED)
            }
            "TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION" => {
                std::option::Option::Some(Self::TRANSIT_ENCRYPTION_MODE_SERVER_AUTHENTICATION)
            }
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for TransitEncryptionMode {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for TransitEncryptionMode {
    fn default() -> Self {
        Self::new(0)
    }
}

/// Type of a PSC connection, for cluster access purpose.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct ConnectionType(i32);

impl ConnectionType {
    /// Cluster endpoint Type is not set
    pub const CONNECTION_TYPE_UNSPECIFIED: ConnectionType = ConnectionType::new(0);

    /// Cluster endpoint that will be used as for cluster topology discovery.
    pub const CONNECTION_TYPE_DISCOVERY: ConnectionType = ConnectionType::new(1);

    /// Cluster endpoint that will be used as primary endpoint to access primary.
    pub const CONNECTION_TYPE_PRIMARY: ConnectionType = ConnectionType::new(2);

    /// Cluster endpoint that will be used as reader endpoint to access replicas.
    pub const CONNECTION_TYPE_READER: ConnectionType = ConnectionType::new(3);

    /// Creates a new ConnectionType instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_DISCOVERY"),
            2 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_PRIMARY"),
            3 => std::borrow::Cow::Borrowed("CONNECTION_TYPE_READER"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "CONNECTION_TYPE_UNSPECIFIED" => {
                std::option::Option::Some(Self::CONNECTION_TYPE_UNSPECIFIED)
            }
            "CONNECTION_TYPE_DISCOVERY" => {
                std::option::Option::Some(Self::CONNECTION_TYPE_DISCOVERY)
            }
            "CONNECTION_TYPE_PRIMARY" => std::option::Option::Some(Self::CONNECTION_TYPE_PRIMARY),
            "CONNECTION_TYPE_READER" => std::option::Option::Some(Self::CONNECTION_TYPE_READER),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for ConnectionType {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for ConnectionType {
    fn default() -> Self {
        Self::new(0)
    }
}
