// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Google Distributed Cloud Edge Kubernetes cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Output only. The time when the cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the cluster was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fleet configuration.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Required. Cluster-wide networking configuration.
    pub networking: std::option::Option<crate::model::ClusterNetworking>,

    /// Required. Immutable. RBAC policy that will be applied and managed by GEC.
    pub authorization: std::option::Option<crate::model::Authorization>,

    /// Optional. The default maximum number of pods per node used if a maximum
    /// value is not specified explicitly for a node pool in this cluster. If
    /// unspecified, the Kubernetes default value will be used.
    pub default_max_pods_per_node: i32,

    /// Output only. The IP address of the Kubernetes API server.
    pub endpoint: std::string::String,

    /// Output only. The port number of the Kubernetes API server.
    pub port: i32,

    /// Output only. The PEM-encoded public certificate of the cluster's CA.
    pub cluster_ca_certificate: std::string::String,

    /// Optional. Cluster-wide maintenance policy configuration.
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Output only. The control plane release version
    pub control_plane_version: std::string::String,

    /// Output only. The lowest release version among all worker nodes. This field
    /// can be empty if the cluster does not have any worker nodes.
    pub node_version: std::string::String,

    /// Optional. The configuration of the cluster control plane.
    pub control_plane: std::option::Option<crate::model::cluster::ControlPlane>,

    /// Optional. The configuration of the system add-ons.
    pub system_addons_config: std::option::Option<crate::model::cluster::SystemAddonsConfig>,

    /// Optional. IPv4 address pools for cluster data plane external load
    /// balancing.
    pub external_load_balancer_ipv4_address_pools: std::vec::Vec<std::string::String>,

    /// Optional. Remote control plane disk encryption options. This field is only
    /// used when enabling CMEK support.
    pub control_plane_encryption:
        std::option::Option<crate::model::cluster::ControlPlaneEncryption>,

    /// Output only. The current status of the cluster.
    pub status: crate::model::cluster::Status,

    /// Output only. All the maintenance events scheduled for the cluster,
    /// including the ones ongoing, planned for the future and done in the past (up
    /// to 90 days).
    pub maintenance_events: std::vec::Vec<crate::model::cluster::MaintenanceEvent>,

    /// Optional. The target cluster version. For example: "1.5.0".
    pub target_version: std::string::String,

    /// Optional. The release channel a cluster is subscribed to.
    pub release_channel: crate::model::cluster::ReleaseChannel,

    /// Optional. Configuration of the cluster survivability, e.g., for the case
    /// when network connectivity is lost. Note: This only applies to local control
    /// plane clusters.
    pub survivability_config: std::option::Option<crate::model::cluster::SurvivabilityConfig>,

    /// Optional. IPv6 address pools for cluster data plane external load
    /// balancing.
    pub external_load_balancer_ipv6_address_pools: std::vec::Vec<std::string::String>,

    /// Output only. The current connection state of the cluster.
    pub connection_state: std::option::Option<crate::model::cluster::ConnectionState>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Fleet>,
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [networking][crate::model::Cluster::networking].
    pub fn set_networking<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterNetworking>,
    {
        self.networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [networking][crate::model::Cluster::networking].
    pub fn set_or_clear_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterNetworking>,
    {
        self.networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization][crate::model::Cluster::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Authorization>,
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::Cluster::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Authorization>,
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_max_pods_per_node][crate::model::Cluster::default_max_pods_per_node].
    pub fn set_default_max_pods_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.default_max_pods_per_node = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Cluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Cluster::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::Cluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenancePolicy>,
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_plane_version][crate::model::Cluster::control_plane_version].
    pub fn set_control_plane_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_version = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::Cluster::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::Cluster::control_plane].
    pub fn set_control_plane<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ControlPlane>,
    {
        self.control_plane = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane][crate::model::Cluster::control_plane].
    pub fn set_or_clear_control_plane<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ControlPlane>,
    {
        self.control_plane = v.map(|x| x.into());
        self
    }

    /// Sets the value of [system_addons_config][crate::model::Cluster::system_addons_config].
    pub fn set_system_addons_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SystemAddonsConfig>,
    {
        self.system_addons_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [system_addons_config][crate::model::Cluster::system_addons_config].
    pub fn set_or_clear_system_addons_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SystemAddonsConfig>,
    {
        self.system_addons_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_load_balancer_ipv4_address_pools][crate::model::Cluster::external_load_balancer_ipv4_address_pools].
    pub fn set_external_load_balancer_ipv4_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv4_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [control_plane_encryption][crate::model::Cluster::control_plane_encryption].
    pub fn set_control_plane_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ControlPlaneEncryption>,
    {
        self.control_plane_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane_encryption][crate::model::Cluster::control_plane_encryption].
    pub fn set_or_clear_control_plane_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ControlPlaneEncryption>,
    {
        self.control_plane_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<crate::model::cluster::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [maintenance_events][crate::model::Cluster::maintenance_events].
    pub fn set_maintenance_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cluster::MaintenanceEvent>,
    {
        use std::iter::Iterator;
        self.maintenance_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_version][crate::model::Cluster::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_release_channel<T: std::convert::Into<crate::model::cluster::ReleaseChannel>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_channel = v.into();
        self
    }

    /// Sets the value of [survivability_config][crate::model::Cluster::survivability_config].
    pub fn set_survivability_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SurvivabilityConfig>,
    {
        self.survivability_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [survivability_config][crate::model::Cluster::survivability_config].
    pub fn set_or_clear_survivability_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::SurvivabilityConfig>,
    {
        self.survivability_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_load_balancer_ipv6_address_pools][crate::model::Cluster::external_load_balancer_ipv6_address_pools].
    pub fn set_external_load_balancer_ipv6_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv6_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_state][crate::model::Cluster::connection_state].
    pub fn set_connection_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ConnectionState>,
    {
        self.connection_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_state][crate::model::Cluster::connection_state].
    pub fn set_or_clear_connection_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::cluster::ConnectionState>,
    {
        self.connection_state = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Cluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __fleet,
            __networking,
            __authorization,
            __default_max_pods_per_node,
            __endpoint,
            __port,
            __cluster_ca_certificate,
            __maintenance_policy,
            __control_plane_version,
            __node_version,
            __control_plane,
            __system_addons_config,
            __external_load_balancer_ipv4_address_pools,
            __control_plane_encryption,
            __status,
            __maintenance_events,
            __target_version,
            __release_channel,
            __survivability_config,
            __external_load_balancer_ipv6_address_pools,
            __connection_state,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Cluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "fleet" => Ok(__FieldTag::__fleet),
                            "networking" => Ok(__FieldTag::__networking),
                            "authorization" => Ok(__FieldTag::__authorization),
                            "defaultMaxPodsPerNode" => Ok(__FieldTag::__default_max_pods_per_node),
                            "default_max_pods_per_node" => {
                                Ok(__FieldTag::__default_max_pods_per_node)
                            }
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            "port" => Ok(__FieldTag::__port),
                            "clusterCaCertificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "cluster_ca_certificate" => Ok(__FieldTag::__cluster_ca_certificate),
                            "maintenancePolicy" => Ok(__FieldTag::__maintenance_policy),
                            "maintenance_policy" => Ok(__FieldTag::__maintenance_policy),
                            "controlPlaneVersion" => Ok(__FieldTag::__control_plane_version),
                            "control_plane_version" => Ok(__FieldTag::__control_plane_version),
                            "nodeVersion" => Ok(__FieldTag::__node_version),
                            "node_version" => Ok(__FieldTag::__node_version),
                            "controlPlane" => Ok(__FieldTag::__control_plane),
                            "control_plane" => Ok(__FieldTag::__control_plane),
                            "systemAddonsConfig" => Ok(__FieldTag::__system_addons_config),
                            "system_addons_config" => Ok(__FieldTag::__system_addons_config),
                            "externalLoadBalancerIpv4AddressPools" => {
                                Ok(__FieldTag::__external_load_balancer_ipv4_address_pools)
                            }
                            "external_load_balancer_ipv4_address_pools" => {
                                Ok(__FieldTag::__external_load_balancer_ipv4_address_pools)
                            }
                            "controlPlaneEncryption" => Ok(__FieldTag::__control_plane_encryption),
                            "control_plane_encryption" => {
                                Ok(__FieldTag::__control_plane_encryption)
                            }
                            "status" => Ok(__FieldTag::__status),
                            "maintenanceEvents" => Ok(__FieldTag::__maintenance_events),
                            "maintenance_events" => Ok(__FieldTag::__maintenance_events),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "releaseChannel" => Ok(__FieldTag::__release_channel),
                            "release_channel" => Ok(__FieldTag::__release_channel),
                            "survivabilityConfig" => Ok(__FieldTag::__survivability_config),
                            "survivability_config" => Ok(__FieldTag::__survivability_config),
                            "externalLoadBalancerIpv6AddressPools" => {
                                Ok(__FieldTag::__external_load_balancer_ipv6_address_pools)
                            }
                            "external_load_balancer_ipv6_address_pools" => {
                                Ok(__FieldTag::__external_load_balancer_ipv6_address_pools)
                            }
                            "connectionState" => Ok(__FieldTag::__connection_state),
                            "connection_state" => Ok(__FieldTag::__connection_state),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Cluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Cluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fleet => {
                            if !fields.insert(__FieldTag::__fleet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fleet",
                                ));
                            }
                            result.fleet =
                                map.next_value::<std::option::Option<crate::model::Fleet>>()?;
                        }
                        __FieldTag::__networking => {
                            if !fields.insert(__FieldTag::__networking) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for networking",
                                ));
                            }
                            result.networking = map
                                .next_value::<std::option::Option<crate::model::ClusterNetworking>>(
                                )?;
                        }
                        __FieldTag::__authorization => {
                            if !fields.insert(__FieldTag::__authorization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorization",
                                ));
                            }
                            result.authorization = map
                                .next_value::<std::option::Option<crate::model::Authorization>>()?;
                        }
                        __FieldTag::__default_max_pods_per_node => {
                            if !fields.insert(__FieldTag::__default_max_pods_per_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_max_pods_per_node",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.default_max_pods_per_node =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__port => {
                            if !fields.insert(__FieldTag::__port) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for port",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cluster_ca_certificate => {
                            if !fields.insert(__FieldTag::__cluster_ca_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ca_certificate",
                                ));
                            }
                            result.cluster_ca_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_policy => {
                            if !fields.insert(__FieldTag::__maintenance_policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_policy",
                                ));
                            }
                            result.maintenance_policy = map
                                .next_value::<std::option::Option<crate::model::MaintenancePolicy>>(
                                )?;
                        }
                        __FieldTag::__control_plane_version => {
                            if !fields.insert(__FieldTag::__control_plane_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_version",
                                ));
                            }
                            result.control_plane_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_version => {
                            if !fields.insert(__FieldTag::__node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_version",
                                ));
                            }
                            result.node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane => {
                            if !fields.insert(__FieldTag::__control_plane) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane",
                                ));
                            }
                            result.control_plane = map.next_value::<std::option::Option<crate::model::cluster::ControlPlane>>()?
                                ;
                        }
                        __FieldTag::__system_addons_config => {
                            if !fields.insert(__FieldTag::__system_addons_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for system_addons_config",
                                ));
                            }
                            result.system_addons_config = map.next_value::<std::option::Option<crate::model::cluster::SystemAddonsConfig>>()?
                                ;
                        }
                        __FieldTag::__external_load_balancer_ipv4_address_pools => {
                            if !fields
                                .insert(__FieldTag::__external_load_balancer_ipv4_address_pools)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_load_balancer_ipv4_address_pools",
                                ));
                            }
                            result.external_load_balancer_ipv4_address_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__control_plane_encryption => {
                            if !fields.insert(__FieldTag::__control_plane_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_encryption",
                                ));
                            }
                            result.control_plane_encryption = map
                                .next_value::<std::option::Option<
                                    crate::model::cluster::ControlPlaneEncryption,
                                >>()?;
                        }
                        __FieldTag::__status => {
                            if !fields.insert(__FieldTag::__status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status",
                                ));
                            }
                            result.status = map
                                .next_value::<std::option::Option<crate::model::cluster::Status>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__maintenance_events => {
                            if !fields.insert(__FieldTag::__maintenance_events) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_events",
                                ));
                            }
                            result.maintenance_events = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::cluster::MaintenanceEvent>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_channel => {
                            if !fields.insert(__FieldTag::__release_channel) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_channel",
                                ));
                            }
                            result.release_channel = map.next_value::<std::option::Option<crate::model::cluster::ReleaseChannel>>()?.unwrap_or_default();
                        }
                        __FieldTag::__survivability_config => {
                            if !fields.insert(__FieldTag::__survivability_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for survivability_config",
                                ));
                            }
                            result.survivability_config = map.next_value::<std::option::Option<crate::model::cluster::SurvivabilityConfig>>()?
                                ;
                        }
                        __FieldTag::__external_load_balancer_ipv6_address_pools => {
                            if !fields
                                .insert(__FieldTag::__external_load_balancer_ipv6_address_pools)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_load_balancer_ipv6_address_pools",
                                ));
                            }
                            result.external_load_balancer_ipv6_address_pools = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__connection_state => {
                            if !fields.insert(__FieldTag::__connection_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for connection_state",
                                ));
                            }
                            result.connection_state = map.next_value::<std::option::Option<crate::model::cluster::ConnectionState>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Cluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.fleet.is_some() {
            state.serialize_entry("fleet", &self.fleet)?;
        }
        if self.networking.is_some() {
            state.serialize_entry("networking", &self.networking)?;
        }
        if self.authorization.is_some() {
            state.serialize_entry("authorization", &self.authorization)?;
        }
        if !wkt::internal::is_default(&self.default_max_pods_per_node) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "defaultMaxPodsPerNode",
                &__With(&self.default_max_pods_per_node),
            )?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !wkt::internal::is_default(&self.port) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("port", &__With(&self.port))?;
        }
        if !self.cluster_ca_certificate.is_empty() {
            state.serialize_entry("clusterCaCertificate", &self.cluster_ca_certificate)?;
        }
        if self.maintenance_policy.is_some() {
            state.serialize_entry("maintenancePolicy", &self.maintenance_policy)?;
        }
        if !self.control_plane_version.is_empty() {
            state.serialize_entry("controlPlaneVersion", &self.control_plane_version)?;
        }
        if !self.node_version.is_empty() {
            state.serialize_entry("nodeVersion", &self.node_version)?;
        }
        if self.control_plane.is_some() {
            state.serialize_entry("controlPlane", &self.control_plane)?;
        }
        if self.system_addons_config.is_some() {
            state.serialize_entry("systemAddonsConfig", &self.system_addons_config)?;
        }
        if !self.external_load_balancer_ipv4_address_pools.is_empty() {
            state.serialize_entry(
                "externalLoadBalancerIpv4AddressPools",
                &self.external_load_balancer_ipv4_address_pools,
            )?;
        }
        if self.control_plane_encryption.is_some() {
            state.serialize_entry("controlPlaneEncryption", &self.control_plane_encryption)?;
        }
        if !wkt::internal::is_default(&self.status) {
            state.serialize_entry("status", &self.status)?;
        }
        if !self.maintenance_events.is_empty() {
            state.serialize_entry("maintenanceEvents", &self.maintenance_events)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !wkt::internal::is_default(&self.release_channel) {
            state.serialize_entry("releaseChannel", &self.release_channel)?;
        }
        if self.survivability_config.is_some() {
            state.serialize_entry("survivabilityConfig", &self.survivability_config)?;
        }
        if !self.external_load_balancer_ipv6_address_pools.is_empty() {
            state.serialize_entry(
                "externalLoadBalancerIpv6AddressPools",
                &self.external_load_balancer_ipv6_address_pools,
            )?;
        }
        if self.connection_state.is_some() {
            state.serialize_entry("connectionState", &self.connection_state)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Cluster {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Cluster");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("fleet", &self.fleet);
        debug_struct.field("networking", &self.networking);
        debug_struct.field("authorization", &self.authorization);
        debug_struct.field("default_max_pods_per_node", &self.default_max_pods_per_node);
        debug_struct.field("endpoint", &self.endpoint);
        debug_struct.field("port", &self.port);
        debug_struct.field("cluster_ca_certificate", &self.cluster_ca_certificate);
        debug_struct.field("maintenance_policy", &self.maintenance_policy);
        debug_struct.field("control_plane_version", &self.control_plane_version);
        debug_struct.field("node_version", &self.node_version);
        debug_struct.field("control_plane", &self.control_plane);
        debug_struct.field("system_addons_config", &self.system_addons_config);
        debug_struct.field(
            "external_load_balancer_ipv4_address_pools",
            &self.external_load_balancer_ipv4_address_pools,
        );
        debug_struct.field("control_plane_encryption", &self.control_plane_encryption);
        debug_struct.field("status", &self.status);
        debug_struct.field("maintenance_events", &self.maintenance_events);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("release_channel", &self.release_channel);
        debug_struct.field("survivability_config", &self.survivability_config);
        debug_struct.field(
            "external_load_balancer_ipv6_address_pools",
            &self.external_load_balancer_ipv6_address_pools,
        );
        debug_struct.field("connection_state", &self.connection_state);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the cluster control plane.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ControlPlane {
        pub config: std::option::Option<crate::model::cluster::control_plane::Config>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ControlPlane {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config].
        ///
        /// Note that all the setters affecting `config` are mutually
        /// exclusive.
        pub fn set_config<
            T: std::convert::Into<std::option::Option<crate::model::cluster::control_plane::Config>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = v.into();
            self
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Remote`, `None` if the field is not set or
        /// holds a different branch.
        pub fn remote(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Remote>>
        {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Remote(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Remote`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_remote<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Remote>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Remote(v.into()),
            );
            self
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Local`, `None` if the field is not set or
        /// holds a different branch.
        pub fn local(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Local>>
        {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Local(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Local`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_local<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Local>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Local(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ControlPlane {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ControlPlane {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __remote,
                __local,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ControlPlane")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "remote" => Ok(__FieldTag::__remote),
                                "local" => Ok(__FieldTag::__local),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ControlPlane;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ControlPlane")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__remote => {
                                if !fields.insert(__FieldTag::__remote) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for remote",
                                    ));
                                }
                                if result.config.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `config`, a oneof with full ID .google.cloud.edgecontainer.v1.Cluster.ControlPlane.remote, latest field was remote",
                                    ));
                                }
                                result.config = std::option::Option::Some(
                                    crate::model::cluster::control_plane::Config::Remote(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::cluster::control_plane::Remote,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::__local => {
                                if !fields.insert(__FieldTag::__local) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for local",
                                    ));
                                }
                                if result.config.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `config`, a oneof with full ID .google.cloud.edgecontainer.v1.Cluster.ControlPlane.local, latest field was local",
                                    ));
                                }
                                result.config = std::option::Option::Some(
                                    crate::model::cluster::control_plane::Config::Local(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::cluster::control_plane::Local,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ControlPlane {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.remote() {
                state.serialize_entry("remote", value)?;
            }
            if let Some(value) = self.local() {
                state.serialize_entry("local", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ControlPlane {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ControlPlane");
            debug_struct.field("config", &self.config);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ControlPlane].
    pub mod control_plane {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration specific to clusters with a control plane hosted remotely.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Remote {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Remote {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Remote {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Remote"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Remote {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Remote")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Remote;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Remote")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Remote {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Remote {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Remote");

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Configuration specific to clusters with a control plane hosted locally.
        ///
        /// Warning: Local control plane clusters must be created in their own
        /// project. Local control plane clusters cannot coexist in the same
        /// project with any other type of clusters, including non-GDCE clusters.
        /// Mixing local control plane GDCE clusters with any other type of
        /// clusters in the same project can result in data loss.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Local {
            /// Name of the Google Distributed Cloud Edge zones where this node pool
            /// will be created. For example: `us-central1-edge-customer-a`.
            pub node_location: std::string::String,

            /// The number of nodes to serve as replicas of the Control Plane.
            pub node_count: i32,

            /// Only machines matching this filter will be allowed to host control
            /// plane nodes. The filtering language accepts strings like "name=\<name\>",
            /// and is documented here: [AIP-160](https://google.aip.dev/160).
            pub machine_filter: std::string::String,

            /// Policy configuration about how user applications are deployed.
            pub shared_deployment_policy:
                crate::model::cluster::control_plane::SharedDeploymentPolicy,

            /// Optional. Name for the storage schema of control plane nodes.
            ///
            /// Warning: Configurable node local storage schema feature is an
            /// experimental feature, and is not recommended for general use
            /// in production clusters/nodepools.
            pub control_plane_node_storage_schema: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Local {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [node_location][crate::model::cluster::control_plane::Local::node_location].
            pub fn set_node_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.node_location = v.into();
                self
            }

            /// Sets the value of [node_count][crate::model::cluster::control_plane::Local::node_count].
            pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.node_count = v.into();
                self
            }

            /// Sets the value of [machine_filter][crate::model::cluster::control_plane::Local::machine_filter].
            pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.machine_filter = v.into();
                self
            }

            /// Sets the value of [shared_deployment_policy][crate::model::cluster::control_plane::Local::shared_deployment_policy].
            pub fn set_shared_deployment_policy<
                T: std::convert::Into<crate::model::cluster::control_plane::SharedDeploymentPolicy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.shared_deployment_policy = v.into();
                self
            }

            /// Sets the value of [control_plane_node_storage_schema][crate::model::cluster::control_plane::Local::control_plane_node_storage_schema].
            pub fn set_control_plane_node_storage_schema<
                T: std::convert::Into<std::string::String>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.control_plane_node_storage_schema = v.into();
                self
            }
        }

        impl wkt::message::Message for Local {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Local"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Local {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __node_location,
                    __node_count,
                    __machine_filter,
                    __shared_deployment_policy,
                    __control_plane_node_storage_schema,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Local")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "nodeLocation" => Ok(__FieldTag::__node_location),
                                    "node_location" => Ok(__FieldTag::__node_location),
                                    "nodeCount" => Ok(__FieldTag::__node_count),
                                    "node_count" => Ok(__FieldTag::__node_count),
                                    "machineFilter" => Ok(__FieldTag::__machine_filter),
                                    "machine_filter" => Ok(__FieldTag::__machine_filter),
                                    "sharedDeploymentPolicy" => {
                                        Ok(__FieldTag::__shared_deployment_policy)
                                    }
                                    "shared_deployment_policy" => {
                                        Ok(__FieldTag::__shared_deployment_policy)
                                    }
                                    "controlPlaneNodeStorageSchema" => {
                                        Ok(__FieldTag::__control_plane_node_storage_schema)
                                    }
                                    "control_plane_node_storage_schema" => {
                                        Ok(__FieldTag::__control_plane_node_storage_schema)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Local;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Local")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__node_location => {
                                    if !fields.insert(__FieldTag::__node_location) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for node_location",
                                            ),
                                        );
                                    }
                                    result.node_location = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__node_count => {
                                    if !fields.insert(__FieldTag::__node_count) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for node_count",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.node_count =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__machine_filter => {
                                    if !fields.insert(__FieldTag::__machine_filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for machine_filter",
                                            ),
                                        );
                                    }
                                    result.machine_filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__shared_deployment_policy => {
                                    if !fields.insert(__FieldTag::__shared_deployment_policy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for shared_deployment_policy",
                                            ),
                                        );
                                    }
                                    result.shared_deployment_policy = map.next_value::<std::option::Option<crate::model::cluster::control_plane::SharedDeploymentPolicy>>()?.unwrap_or_default();
                                }
                                __FieldTag::__control_plane_node_storage_schema => {
                                    if !fields
                                        .insert(__FieldTag::__control_plane_node_storage_schema)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for control_plane_node_storage_schema",
                                            ),
                                        );
                                    }
                                    result.control_plane_node_storage_schema = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Local {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.node_location.is_empty() {
                    state.serialize_entry("nodeLocation", &self.node_location)?;
                }
                if !wkt::internal::is_default(&self.node_count) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("nodeCount", &__With(&self.node_count))?;
                }
                if !self.machine_filter.is_empty() {
                    state.serialize_entry("machineFilter", &self.machine_filter)?;
                }
                if !wkt::internal::is_default(&self.shared_deployment_policy) {
                    state.serialize_entry(
                        "sharedDeploymentPolicy",
                        &self.shared_deployment_policy,
                    )?;
                }
                if !self.control_plane_node_storage_schema.is_empty() {
                    state.serialize_entry(
                        "controlPlaneNodeStorageSchema",
                        &self.control_plane_node_storage_schema,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Local {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Local");
                debug_struct.field("node_location", &self.node_location);
                debug_struct.field("node_count", &self.node_count);
                debug_struct.field("machine_filter", &self.machine_filter);
                debug_struct.field("shared_deployment_policy", &self.shared_deployment_policy);
                debug_struct.field(
                    "control_plane_node_storage_schema",
                    &self.control_plane_node_storage_schema,
                );

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Represents the policy configuration about how user applications are
        /// deployed.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SharedDeploymentPolicy {
            /// Unspecified.
            Unspecified,
            /// User applications can be deployed both on control plane and worker
            /// nodes.
            Allowed,
            /// User applications can not be deployed on control plane nodes and can
            /// only be deployed on worker nodes.
            Disallowed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SharedDeploymentPolicy::value] or
            /// [SharedDeploymentPolicy::name].
            UnknownValue(shared_deployment_policy::UnknownValue),
        }

        #[doc(hidden)]
        pub mod shared_deployment_policy {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SharedDeploymentPolicy {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allowed => std::option::Option::Some(1),
                    Self::Disallowed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => {
                        std::option::Option::Some("SHARED_DEPLOYMENT_POLICY_UNSPECIFIED")
                    }
                    Self::Allowed => std::option::Option::Some("ALLOWED"),
                    Self::Disallowed => std::option::Option::Some("DISALLOWED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SharedDeploymentPolicy {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SharedDeploymentPolicy {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SharedDeploymentPolicy {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allowed,
                    2 => Self::Disallowed,
                    _ => Self::UnknownValue(shared_deployment_policy::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for SharedDeploymentPolicy {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED" => Self::Unspecified,
                    "ALLOWED" => Self::Allowed,
                    "DISALLOWED" => Self::Disallowed,
                    _ => Self::UnknownValue(shared_deployment_policy::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for SharedDeploymentPolicy {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allowed => serializer.serialize_i32(1),
                    Self::Disallowed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SharedDeploymentPolicy {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SharedDeploymentPolicy>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.ControlPlane.SharedDeploymentPolicy"))
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Config {
            /// Remote control plane configuration.
            Remote(std::boxed::Box<crate::model::cluster::control_plane::Remote>),
            /// Local control plane configuration.
            ///
            /// Warning: Local control plane clusters must be created in their own
            /// project. Local control plane clusters cannot coexist in the same
            /// project with any other type of clusters, including non-GDCE clusters.
            /// Mixing local control plane GDCE clusters with any other type of
            /// clusters in the same project can result in data loss.
            Local(std::boxed::Box<crate::model::cluster::control_plane::Local>),
        }
    }

    /// Config that customers are allowed to define for GDCE system add-ons.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SystemAddonsConfig {
        /// Optional. Config for Ingress.
        pub ingress: std::option::Option<crate::model::cluster::system_addons_config::Ingress>,

        /// Optional. Config for VM Service.
        pub vm_service_config:
            std::option::Option<crate::model::cluster::system_addons_config::VMServiceConfig>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SystemAddonsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ingress][crate::model::cluster::SystemAddonsConfig::ingress].
        pub fn set_ingress<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::cluster::system_addons_config::Ingress>,
        {
            self.ingress = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ingress][crate::model::cluster::SystemAddonsConfig::ingress].
        pub fn set_or_clear_ingress<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::cluster::system_addons_config::Ingress>,
        {
            self.ingress = v.map(|x| x.into());
            self
        }

        /// Sets the value of [vm_service_config][crate::model::cluster::SystemAddonsConfig::vm_service_config].
        pub fn set_vm_service_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::cluster::system_addons_config::VMServiceConfig>,
        {
            self.vm_service_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [vm_service_config][crate::model::cluster::SystemAddonsConfig::vm_service_config].
        pub fn set_or_clear_vm_service_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::cluster::system_addons_config::VMServiceConfig>,
        {
            self.vm_service_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SystemAddonsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SystemAddonsConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __ingress,
                __vm_service_config,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SystemAddonsConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "ingress" => Ok(__FieldTag::__ingress),
                                "vmServiceConfig" => Ok(__FieldTag::__vm_service_config),
                                "vm_service_config" => Ok(__FieldTag::__vm_service_config),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SystemAddonsConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SystemAddonsConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__ingress => {
                                if !fields.insert(__FieldTag::__ingress) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ingress",
                                    ));
                                }
                                result.ingress = map.next_value::<std::option::Option<
                                    crate::model::cluster::system_addons_config::Ingress,
                                >>()?;
                            }
                            __FieldTag::__vm_service_config => {
                                if !fields.insert(__FieldTag::__vm_service_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for vm_service_config",
                                    ));
                                }
                                result.vm_service_config = map.next_value::<std::option::Option<
                                    crate::model::cluster::system_addons_config::VMServiceConfig,
                                >>(
                                )?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SystemAddonsConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.ingress.is_some() {
                state.serialize_entry("ingress", &self.ingress)?;
            }
            if self.vm_service_config.is_some() {
                state.serialize_entry("vmServiceConfig", &self.vm_service_config)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SystemAddonsConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SystemAddonsConfig");
            debug_struct.field("ingress", &self.ingress);
            debug_struct.field("vm_service_config", &self.vm_service_config);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [SystemAddonsConfig].
    pub mod system_addons_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for the Ingress add-on which allows customers to create an Ingress
        /// object to manage external access to the servers in a cluster. The add-on
        /// consists of istiod and istio-ingress.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Ingress {
            /// Optional. Whether Ingress is disabled.
            pub disabled: bool,

            /// Optional. Ingress VIP.
            pub ipv4_vip: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Ingress {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disabled][crate::model::cluster::system_addons_config::Ingress::disabled].
            pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disabled = v.into();
                self
            }

            /// Sets the value of [ipv4_vip][crate::model::cluster::system_addons_config::Ingress::ipv4_vip].
            pub fn set_ipv4_vip<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.ipv4_vip = v.into();
                self
            }
        }

        impl wkt::message::Message for Ingress {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.Ingress"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Ingress {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __disabled,
                    __ipv4_vip,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Ingress")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "disabled" => Ok(__FieldTag::__disabled),
                                    "ipv4Vip" => Ok(__FieldTag::__ipv4_vip),
                                    "ipv4_vip" => Ok(__FieldTag::__ipv4_vip),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Ingress;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Ingress")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__disabled => {
                                    if !fields.insert(__FieldTag::__disabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disabled",
                                            ),
                                        );
                                    }
                                    result.disabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__ipv4_vip => {
                                    if !fields.insert(__FieldTag::__ipv4_vip) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for ipv4_vip",
                                            ),
                                        );
                                    }
                                    result.ipv4_vip = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Ingress {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.disabled) {
                    state.serialize_entry("disabled", &self.disabled)?;
                }
                if !self.ipv4_vip.is_empty() {
                    state.serialize_entry("ipv4Vip", &self.ipv4_vip)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Ingress {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Ingress");
                debug_struct.field("disabled", &self.disabled);
                debug_struct.field("ipv4_vip", &self.ipv4_vip);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// VMServiceConfig defines the configuration for GDCE VM Service.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VMServiceConfig {
            /// Optional. Whether VMM is enabled.
            pub vmm_enabled: bool,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VMServiceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [vmm_enabled][crate::model::cluster::system_addons_config::VMServiceConfig::vmm_enabled].
            pub fn set_vmm_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.vmm_enabled = v.into();
                self
            }
        }

        impl wkt::message::Message for VMServiceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.VMServiceConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for VMServiceConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __vmm_enabled,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for VMServiceConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "vmmEnabled" => Ok(__FieldTag::__vmm_enabled),
                                    "vmm_enabled" => Ok(__FieldTag::__vmm_enabled),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = VMServiceConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct VMServiceConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__vmm_enabled => {
                                    if !fields.insert(__FieldTag::__vmm_enabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for vmm_enabled",
                                            ),
                                        );
                                    }
                                    result.vmm_enabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for VMServiceConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.vmm_enabled) {
                    state.serialize_entry("vmmEnabled", &self.vmm_enabled)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for VMServiceConfig {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("VMServiceConfig");
                debug_struct.field("vmm_enabled", &self.vmm_enabled);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    /// Configuration for Customer-managed KMS key support for control plane nodes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ControlPlaneEncryption {
        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting control plane disks. If not specified, a
        /// Google-managed key will be used instead.
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting control plane disks. Only applicable if kms_key is set.
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ControlPlaneEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::cluster::ControlPlaneEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::cluster::ControlPlaneEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::cluster::ControlPlaneEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::cluster::ControlPlaneEncryption::kms_status].
        pub fn set_kms_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.kms_status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [kms_status][crate::model::cluster::ControlPlaneEncryption::kms_status].
        pub fn set_or_clear_kms_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.kms_status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource_state][crate::model::cluster::ControlPlaneEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for ControlPlaneEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlaneEncryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ControlPlaneEncryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key,
                __kms_key_active_version,
                __kms_key_state,
                __kms_status,
                __resource_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ControlPlaneEncryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKey" => Ok(__FieldTag::__kms_key),
                                "kms_key" => Ok(__FieldTag::__kms_key),
                                "kmsKeyActiveVersion" => Ok(__FieldTag::__kms_key_active_version),
                                "kms_key_active_version" => {
                                    Ok(__FieldTag::__kms_key_active_version)
                                }
                                "kmsKeyState" => Ok(__FieldTag::__kms_key_state),
                                "kms_key_state" => Ok(__FieldTag::__kms_key_state),
                                "kmsStatus" => Ok(__FieldTag::__kms_status),
                                "kms_status" => Ok(__FieldTag::__kms_status),
                                "resourceState" => Ok(__FieldTag::__resource_state),
                                "resource_state" => Ok(__FieldTag::__resource_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ControlPlaneEncryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ControlPlaneEncryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key => {
                                if !fields.insert(__FieldTag::__kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key",
                                    ));
                                }
                                result.kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_key_active_version => {
                                if !fields.insert(__FieldTag::__kms_key_active_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_active_version",
                                    ));
                                }
                                result.kms_key_active_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_key_state => {
                                if !fields.insert(__FieldTag::__kms_key_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_state",
                                    ));
                                }
                                result.kms_key_state = map
                                    .next_value::<std::option::Option<crate::model::KmsKeyState>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_status => {
                                if !fields.insert(__FieldTag::__kms_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_status",
                                    ));
                                }
                                result.kms_status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__resource_state => {
                                if !fields.insert(__FieldTag::__resource_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_state",
                                    ));
                                }
                                result.resource_state = map
                                    .next_value::<std::option::Option<crate::model::ResourceState>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ControlPlaneEncryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key.is_empty() {
                state.serialize_entry("kmsKey", &self.kms_key)?;
            }
            if !self.kms_key_active_version.is_empty() {
                state.serialize_entry("kmsKeyActiveVersion", &self.kms_key_active_version)?;
            }
            if !wkt::internal::is_default(&self.kms_key_state) {
                state.serialize_entry("kmsKeyState", &self.kms_key_state)?;
            }
            if self.kms_status.is_some() {
                state.serialize_entry("kmsStatus", &self.kms_status)?;
            }
            if !wkt::internal::is_default(&self.resource_state) {
                state.serialize_entry("resourceState", &self.resource_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ControlPlaneEncryption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ControlPlaneEncryption");
            debug_struct.field("kms_key", &self.kms_key);
            debug_struct.field("kms_key_active_version", &self.kms_key_active_version);
            debug_struct.field("kms_key_state", &self.kms_key_state);
            debug_struct.field("kms_status", &self.kms_status);
            debug_struct.field("resource_state", &self.resource_state);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A Maintenance Event is an operation that could cause temporary disruptions
    /// to the cluster workloads, including Google-driven or user-initiated cluster
    /// upgrades, user-initiated cluster configuration changes that require
    /// restarting nodes, etc.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MaintenanceEvent {
        /// Output only. UUID of the maintenance event.
        pub uuid: std::string::String,

        /// Output only. The target version of the cluster.
        pub target_version: std::string::String,

        /// Output only. The operation for running the maintenance event. Specified
        /// in the format projects/*/locations/*/operations/*. If the maintenance
        /// event is split into multiple operations (e.g. due to maintenance
        /// windows), the latest one is recorded.
        pub operation: std::string::String,

        /// Output only. The type of the maintenance event.
        pub r#type: crate::model::cluster::maintenance_event::Type,

        /// Output only. The schedule of the maintenance event.
        pub schedule: crate::model::cluster::maintenance_event::Schedule,

        /// Output only. The state of the maintenance event.
        pub state: crate::model::cluster::maintenance_event::State,

        /// Output only. The time when the maintenance event request was created.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event started.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event ended, either
        /// successfully or not. If the maintenance event is split into multiple
        /// maintenance windows, end_time is only updated when the whole flow ends.
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event message was updated.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaintenanceEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uuid][crate::model::cluster::MaintenanceEvent::uuid].
        pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uuid = v.into();
            self
        }

        /// Sets the value of [target_version][crate::model::cluster::MaintenanceEvent::target_version].
        pub fn set_target_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_version = v.into();
            self
        }

        /// Sets the value of [operation][crate::model::cluster::MaintenanceEvent::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cluster::MaintenanceEvent::type].
        pub fn set_type<T: std::convert::Into<crate::model::cluster::maintenance_event::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [schedule][crate::model::cluster::MaintenanceEvent::schedule].
        pub fn set_schedule<
            T: std::convert::Into<crate::model::cluster::maintenance_event::Schedule>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.schedule = v.into();
            self
        }

        /// Sets the value of [state][crate::model::cluster::MaintenanceEvent::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::maintenance_event::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::cluster::MaintenanceEvent::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::cluster::MaintenanceEvent::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [start_time][crate::model::cluster::MaintenanceEvent::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::cluster::MaintenanceEvent::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::MaintenanceEvent::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::cluster::MaintenanceEvent::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::MaintenanceEvent::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::cluster::MaintenanceEvent::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MaintenanceEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for MaintenanceEvent {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __uuid,
                __target_version,
                __operation,
                __type,
                __schedule,
                __state,
                __create_time,
                __start_time,
                __end_time,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for MaintenanceEvent")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "uuid" => Ok(__FieldTag::__uuid),
                                "targetVersion" => Ok(__FieldTag::__target_version),
                                "target_version" => Ok(__FieldTag::__target_version),
                                "operation" => Ok(__FieldTag::__operation),
                                "type" => Ok(__FieldTag::__type),
                                "schedule" => Ok(__FieldTag::__schedule),
                                "state" => Ok(__FieldTag::__state),
                                "createTime" => Ok(__FieldTag::__create_time),
                                "create_time" => Ok(__FieldTag::__create_time),
                                "startTime" => Ok(__FieldTag::__start_time),
                                "start_time" => Ok(__FieldTag::__start_time),
                                "endTime" => Ok(__FieldTag::__end_time),
                                "end_time" => Ok(__FieldTag::__end_time),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = MaintenanceEvent;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct MaintenanceEvent")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__uuid => {
                                if !fields.insert(__FieldTag::__uuid) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for uuid",
                                    ));
                                }
                                result.uuid = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__target_version => {
                                if !fields.insert(__FieldTag::__target_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for target_version",
                                    ));
                                }
                                result.target_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__operation => {
                                if !fields.insert(__FieldTag::__operation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for operation",
                                    ));
                                }
                                result.operation = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<
                                        crate::model::cluster::maintenance_event::Type,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__schedule => {
                                if !fields.insert(__FieldTag::__schedule) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schedule",
                                    ));
                                }
                                result.schedule = map
                                    .next_value::<std::option::Option<
                                        crate::model::cluster::maintenance_event::Schedule,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::cluster::maintenance_event::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__create_time => {
                                if !fields.insert(__FieldTag::__create_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for create_time",
                                    ));
                                }
                                result.create_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__start_time => {
                                if !fields.insert(__FieldTag::__start_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for start_time",
                                    ));
                                }
                                result.start_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__end_time => {
                                if !fields.insert(__FieldTag::__end_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for end_time",
                                    ));
                                }
                                result.end_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for MaintenanceEvent {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.uuid.is_empty() {
                state.serialize_entry("uuid", &self.uuid)?;
            }
            if !self.target_version.is_empty() {
                state.serialize_entry("targetVersion", &self.target_version)?;
            }
            if !self.operation.is_empty() {
                state.serialize_entry("operation", &self.operation)?;
            }
            if !wkt::internal::is_default(&self.r#type) {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !wkt::internal::is_default(&self.schedule) {
                state.serialize_entry("schedule", &self.schedule)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if self.create_time.is_some() {
                state.serialize_entry("createTime", &self.create_time)?;
            }
            if self.start_time.is_some() {
                state.serialize_entry("startTime", &self.start_time)?;
            }
            if self.end_time.is_some() {
                state.serialize_entry("endTime", &self.end_time)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for MaintenanceEvent {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("MaintenanceEvent");
            debug_struct.field("uuid", &self.uuid);
            debug_struct.field("target_version", &self.target_version);
            debug_struct.field("operation", &self.operation);
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("schedule", &self.schedule);
            debug_struct.field("state", &self.state);
            debug_struct.field("create_time", &self.create_time);
            debug_struct.field("start_time", &self.start_time);
            debug_struct.field("end_time", &self.end_time);
            debug_struct.field("update_time", &self.update_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [MaintenanceEvent].
    pub mod maintenance_event {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the maintenance event type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unspecified.
            Unspecified,
            /// Upgrade initiated by users.
            UserInitiatedUpgrade,
            /// Upgrade driven by Google.
            GoogleDrivenUpgrade,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::UserInitiatedUpgrade => std::option::Option::Some(1),
                    Self::GoogleDrivenUpgrade => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::UserInitiatedUpgrade => {
                        std::option::Option::Some("USER_INITIATED_UPGRADE")
                    }
                    Self::GoogleDrivenUpgrade => std::option::Option::Some("GOOGLE_DRIVEN_UPGRADE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::UserInitiatedUpgrade,
                    2 => Self::GoogleDrivenUpgrade,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "USER_INITIATED_UPGRADE" => Self::UserInitiatedUpgrade,
                    "GOOGLE_DRIVEN_UPGRADE" => Self::GoogleDrivenUpgrade,
                    _ => Self::UnknownValue(r#type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::UserInitiatedUpgrade => serializer.serialize_i32(1),
                    Self::GoogleDrivenUpgrade => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.Type",
                ))
            }
        }

        /// Indicates when the maintenance event should be performed.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Schedule {
            /// Unspecified.
            Unspecified,
            /// Immediately after receiving the request.
            Immediately,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Schedule::value] or
            /// [Schedule::name].
            UnknownValue(schedule::UnknownValue),
        }

        #[doc(hidden)]
        pub mod schedule {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Schedule {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Immediately => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCHEDULE_UNSPECIFIED"),
                    Self::Immediately => std::option::Option::Some("IMMEDIATELY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Schedule {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Schedule {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Schedule {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Immediately,
                    _ => Self::UnknownValue(schedule::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for Schedule {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                    "IMMEDIATELY" => Self::Immediately,
                    _ => Self::UnknownValue(schedule::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for Schedule {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Immediately => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Schedule {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Schedule>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.Schedule",
                ))
            }
        }

        /// Indicates the maintenance event state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unspecified.
            Unspecified,
            /// The maintenance event is ongoing. The cluster might be unusable.
            Reconciling,
            /// The maintenance event succeeded.
            Succeeded,
            /// The maintenance event failed.
            Failed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Reconciling => std::option::Option::Some(1),
                    Self::Succeeded => std::option::Option::Some(2),
                    Self::Failed => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Reconciling => std::option::Option::Some("RECONCILING"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Reconciling,
                    2 => Self::Succeeded,
                    3 => Self::Failed,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "RECONCILING" => Self::Reconciling,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Reconciling => serializer.serialize_i32(1),
                    Self::Succeeded => serializer.serialize_i32(2),
                    Self::Failed => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.State",
                ))
            }
        }
    }

    /// Configuration of the cluster survivability, e.g., for the case when network
    /// connectivity is lost.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SurvivabilityConfig {
        /// Optional. Time period that allows the cluster nodes to be rebooted and
        /// become functional without network connectivity to Google. The default 0
        /// means not allowed. The maximum is 7 days.
        pub offline_reboot_ttl: std::option::Option<wkt::Duration>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SurvivabilityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offline_reboot_ttl][crate::model::cluster::SurvivabilityConfig::offline_reboot_ttl].
        pub fn set_offline_reboot_ttl<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.offline_reboot_ttl = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [offline_reboot_ttl][crate::model::cluster::SurvivabilityConfig::offline_reboot_ttl].
        pub fn set_or_clear_offline_reboot_ttl<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Duration>,
        {
            self.offline_reboot_ttl = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SurvivabilityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SurvivabilityConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SurvivabilityConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __offline_reboot_ttl,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SurvivabilityConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "offlineRebootTtl" => Ok(__FieldTag::__offline_reboot_ttl),
                                "offline_reboot_ttl" => Ok(__FieldTag::__offline_reboot_ttl),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SurvivabilityConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SurvivabilityConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__offline_reboot_ttl => {
                                if !fields.insert(__FieldTag::__offline_reboot_ttl) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for offline_reboot_ttl",
                                    ));
                                }
                                result.offline_reboot_ttl =
                                    map.next_value::<std::option::Option<wkt::Duration>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SurvivabilityConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.offline_reboot_ttl.is_some() {
                state.serialize_entry("offlineRebootTtl", &self.offline_reboot_ttl)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for SurvivabilityConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("SurvivabilityConfig");
            debug_struct.field("offline_reboot_ttl", &self.offline_reboot_ttl);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// ConnectionState holds the current connection state from the cluster to
    /// Google.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConnectionState {
        /// Output only. The current connection state.
        pub state: crate::model::cluster::connection_state::State,

        /// Output only. The time when the connection state was last changed.
        pub update_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::cluster::ConnectionState::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::connection_state::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::ConnectionState::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::cluster::ConnectionState::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ConnectionState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ConnectionState"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ConnectionState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __update_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ConnectionState")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "updateTime" => Ok(__FieldTag::__update_time),
                                "update_time" => Ok(__FieldTag::__update_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ConnectionState;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ConnectionState")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::cluster::connection_state::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__update_time => {
                                if !fields.insert(__FieldTag::__update_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for update_time",
                                    ));
                                }
                                result.update_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ConnectionState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if self.update_time.is_some() {
                state.serialize_entry("updateTime", &self.update_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ConnectionState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ConnectionState");
            debug_struct.field("state", &self.state);
            debug_struct.field("update_time", &self.update_time);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [ConnectionState].
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;

        /// The connection state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unknown connection state.
            Unspecified,
            /// This cluster is currently disconnected from Google.
            Disconnected,
            /// This cluster is currently connected to Google.
            Connected,
            /// This cluster is currently connected to Google, but may have recently
            /// reconnected after a disconnection. It is still syncing back.
            ConnectedAndSyncing,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disconnected => std::option::Option::Some(1),
                    Self::Connected => std::option::Option::Some(2),
                    Self::ConnectedAndSyncing => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Disconnected => std::option::Option::Some("DISCONNECTED"),
                    Self::Connected => std::option::Option::Some("CONNECTED"),
                    Self::ConnectedAndSyncing => std::option::Option::Some("CONNECTED_AND_SYNCING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disconnected,
                    2 => Self::Connected,
                    3 => Self::ConnectedAndSyncing,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "DISCONNECTED" => Self::Disconnected,
                    "CONNECTED" => Self::Connected,
                    "CONNECTED_AND_SYNCING" => Self::ConnectedAndSyncing,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disconnected => serializer.serialize_i32(1),
                    Self::Connected => serializer.serialize_i32(2),
                    Self::ConnectedAndSyncing => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.ConnectionState.State",
                ))
            }
        }
    }

    /// Indicates the status of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Status unknown.
        Unspecified,
        /// The cluster is being created.
        Provisioning,
        /// The cluster is created and fully usable.
        Running,
        /// The cluster is being deleted.
        Deleting,
        /// The status indicates that some errors occurred while reconciling/deleting
        /// the cluster.
        Error,
        /// The cluster is undergoing some work such as version upgrades, etc.
        Reconciling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Reconciling => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Reconciling,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "RECONCILING" => Self::Reconciling,
                _ => Self::UnknownValue(status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Reconciling => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.edgecontainer.v1.Cluster.Status",
            ))
        }
    }

    /// The release channel a cluster is subscribed to.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReleaseChannel {
        /// Unspecified release channel. This will default to the REGULAR channel.
        Unspecified,
        /// No release channel.
        None,
        /// Regular release channel.
        Regular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReleaseChannel::value] or
        /// [ReleaseChannel::name].
        UnknownValue(release_channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod release_channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReleaseChannel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELEASE_CHANNEL_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReleaseChannel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReleaseChannel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReleaseChannel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Regular,
                _ => Self::UnknownValue(release_channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ReleaseChannel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELEASE_CHANNEL_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "REGULAR" => Self::Regular,
                _ => Self::UnknownValue(release_channel::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ReleaseChannel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReleaseChannel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReleaseChannel>::new(
                ".google.cloud.edgecontainer.v1.Cluster.ReleaseChannel",
            ))
        }
    }
}

/// Cluster-wide networking configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterNetworking {
    /// Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
    /// these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    pub cluster_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. All services in the cluster are assigned an RFC1918 IPv4 address
    /// from these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    pub services_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_ipv4_cidr_blocks][crate::model::ClusterNetworking::cluster_ipv4_cidr_blocks].
    pub fn set_cluster_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services_ipv4_cidr_blocks][crate::model::ClusterNetworking::services_ipv4_cidr_blocks].
    pub fn set_services_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.services_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterNetworking"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterNetworking {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster_ipv4_cidr_blocks,
            __services_ipv4_cidr_blocks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterNetworking")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusterIpv4CidrBlocks" => Ok(__FieldTag::__cluster_ipv4_cidr_blocks),
                            "cluster_ipv4_cidr_blocks" => {
                                Ok(__FieldTag::__cluster_ipv4_cidr_blocks)
                            }
                            "servicesIpv4CidrBlocks" => Ok(__FieldTag::__services_ipv4_cidr_blocks),
                            "services_ipv4_cidr_blocks" => {
                                Ok(__FieldTag::__services_ipv4_cidr_blocks)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterNetworking;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterNetworking")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster_ipv4_cidr_blocks => {
                            if !fields.insert(__FieldTag::__cluster_ipv4_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_ipv4_cidr_blocks",
                                ));
                            }
                            result.cluster_ipv4_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__services_ipv4_cidr_blocks => {
                            if !fields.insert(__FieldTag::__services_ipv4_cidr_blocks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for services_ipv4_cidr_blocks",
                                ));
                            }
                            result.services_ipv4_cidr_blocks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterNetworking {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster_ipv4_cidr_blocks.is_empty() {
            state.serialize_entry("clusterIpv4CidrBlocks", &self.cluster_ipv4_cidr_blocks)?;
        }
        if !self.services_ipv4_cidr_blocks.is_empty() {
            state.serialize_entry("servicesIpv4CidrBlocks", &self.services_ipv4_cidr_blocks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterNetworking {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterNetworking");
        debug_struct.field("cluster_ipv4_cidr_blocks", &self.cluster_ipv4_cidr_blocks);
        debug_struct.field("services_ipv4_cidr_blocks", &self.services_ipv4_cidr_blocks);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Fleet related configuration.
///
/// Fleets are a Google Cloud concept for logically organizing clusters,
/// letting you use and manage multi-cluster capabilities and apply
/// consistent policies across your systems.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Fleet {
    /// Required. The name of the Fleet host project where this cluster will be
    /// registered.
    ///
    /// Project names are formatted as
    /// `projects/<project-number>`.
    pub project: std::string::String,

    /// Output only. The name of the managed Hub Membership resource associated to
    /// this cluster.
    ///
    /// Membership names are formatted as
    /// `projects/<project-number>/locations/global/membership/<cluster-id>`.
    pub membership: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Fleet"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Fleet {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __membership,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Fleet")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "membership" => Ok(__FieldTag::__membership),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Fleet;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Fleet")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__membership => {
                            if !fields.insert(__FieldTag::__membership) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for membership",
                                ));
                            }
                            result.membership = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Fleet {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.membership.is_empty() {
            state.serialize_entry("membership", &self.membership)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Fleet {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Fleet");
        debug_struct.field("project", &self.project);
        debug_struct.field("membership", &self.membership);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A user principal for an RBAC policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterUser {
    /// Required. An active Google username.
    pub username: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::ClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for ClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterUser"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ClusterUser {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ClusterUser")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ClusterUser;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ClusterUser")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ClusterUser {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ClusterUser {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ClusterUser");
        debug_struct.field("username", &self.username);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// RBAC policy that will be applied and managed by GEC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Authorization {
    /// Required. User that will be granted the cluster-admin role on the cluster,
    /// providing full access to the cluster. Currently, this is a singular field,
    /// but will be expanded to allow multiple admins in the future.
    pub admin_users: std::option::Option<crate::model::ClusterUser>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Authorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::Authorization::admin_users].
    pub fn set_admin_users<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ClusterUser>,
    {
        self.admin_users = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [admin_users][crate::model::Authorization::admin_users].
    pub fn set_or_clear_admin_users<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ClusterUser>,
    {
        self.admin_users = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Authorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Authorization"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Authorization {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __admin_users,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Authorization")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adminUsers" => Ok(__FieldTag::__admin_users),
                            "admin_users" => Ok(__FieldTag::__admin_users),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Authorization;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Authorization")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__admin_users => {
                            if !fields.insert(__FieldTag::__admin_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin_users",
                                ));
                            }
                            result.admin_users =
                                map.next_value::<std::option::Option<crate::model::ClusterUser>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Authorization {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.admin_users.is_some() {
            state.serialize_entry("adminUsers", &self.admin_users)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Authorization {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Authorization");
        debug_struct.field("admin_users", &self.admin_users);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A set of Kubernetes nodes in a cluster with common configuration and
/// specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePool {
    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Name of the Google Distributed Cloud Edge zone where this node pool will be
    /// created. For example: `us-central1-edge-customer-a`.
    pub node_location: std::string::String,

    /// Required. The number of nodes in the pool.
    pub node_count: i32,

    /// Only machines matching this filter will be allowed to join the node pool.
    /// The filtering language accepts strings like "name=\<name\>", and is
    /// documented in more detail in [AIP-160](https://google.aip.dev/160).
    pub machine_filter: std::string::String,

    /// Optional. Local disk encryption options. This field is only used when
    /// enabling CMEK support.
    pub local_disk_encryption: std::option::Option<crate::model::node_pool::LocalDiskEncryption>,

    /// Output only. The lowest release version among all worker nodes.
    pub node_version: std::string::String,

    /// Optional. Configuration for each node in the NodePool
    pub node_config: std::option::Option<crate::model::node_pool::NodeConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NodePool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::NodePool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::NodePool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NodePool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::NodePool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [node_location][crate::model::NodePool::node_location].
    pub fn set_node_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_location = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::NodePool::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [machine_filter][crate::model::NodePool::machine_filter].
    pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_filter = v.into();
        self
    }

    /// Sets the value of [local_disk_encryption][crate::model::NodePool::local_disk_encryption].
    pub fn set_local_disk_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::LocalDiskEncryption>,
    {
        self.local_disk_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_disk_encryption][crate::model::NodePool::local_disk_encryption].
    pub fn set_or_clear_local_disk_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::LocalDiskEncryption>,
    {
        self.local_disk_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_version][crate::model::NodePool::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::NodePool::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::NodeConfig>,
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::NodePool::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::node_pool::NodeConfig>,
    {
        self.node_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NodePool {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __node_location,
            __node_count,
            __machine_filter,
            __local_disk_encryption,
            __node_version,
            __node_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NodePool")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "nodeLocation" => Ok(__FieldTag::__node_location),
                            "node_location" => Ok(__FieldTag::__node_location),
                            "nodeCount" => Ok(__FieldTag::__node_count),
                            "node_count" => Ok(__FieldTag::__node_count),
                            "machineFilter" => Ok(__FieldTag::__machine_filter),
                            "machine_filter" => Ok(__FieldTag::__machine_filter),
                            "localDiskEncryption" => Ok(__FieldTag::__local_disk_encryption),
                            "local_disk_encryption" => Ok(__FieldTag::__local_disk_encryption),
                            "nodeVersion" => Ok(__FieldTag::__node_version),
                            "node_version" => Ok(__FieldTag::__node_version),
                            "nodeConfig" => Ok(__FieldTag::__node_config),
                            "node_config" => Ok(__FieldTag::__node_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NodePool;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NodePool")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_location => {
                            if !fields.insert(__FieldTag::__node_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_location",
                                ));
                            }
                            result.node_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_count => {
                            if !fields.insert(__FieldTag::__node_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.node_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__machine_filter => {
                            if !fields.insert(__FieldTag::__machine_filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_filter",
                                ));
                            }
                            result.machine_filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__local_disk_encryption => {
                            if !fields.insert(__FieldTag::__local_disk_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for local_disk_encryption",
                                ));
                            }
                            result.local_disk_encryption =
                                map.next_value::<std::option::Option<
                                    crate::model::node_pool::LocalDiskEncryption,
                                >>()?;
                        }
                        __FieldTag::__node_version => {
                            if !fields.insert(__FieldTag::__node_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_version",
                                ));
                            }
                            result.node_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_config => {
                            if !fields.insert(__FieldTag::__node_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_config",
                                ));
                            }
                            result.node_config = map.next_value::<std::option::Option<crate::model::node_pool::NodeConfig>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NodePool {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.node_location.is_empty() {
            state.serialize_entry("nodeLocation", &self.node_location)?;
        }
        if !wkt::internal::is_default(&self.node_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("nodeCount", &__With(&self.node_count))?;
        }
        if !self.machine_filter.is_empty() {
            state.serialize_entry("machineFilter", &self.machine_filter)?;
        }
        if self.local_disk_encryption.is_some() {
            state.serialize_entry("localDiskEncryption", &self.local_disk_encryption)?;
        }
        if !self.node_version.is_empty() {
            state.serialize_entry("nodeVersion", &self.node_version)?;
        }
        if self.node_config.is_some() {
            state.serialize_entry("nodeConfig", &self.node_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NodePool {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NodePool");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("node_location", &self.node_location);
        debug_struct.field("node_count", &self.node_count);
        debug_struct.field("machine_filter", &self.machine_filter);
        debug_struct.field("local_disk_encryption", &self.local_disk_encryption);
        debug_struct.field("node_version", &self.node_version);
        debug_struct.field("node_config", &self.node_config);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [NodePool].
pub mod node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for CMEK support for edge machine local disk encryption.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LocalDiskEncryption {
        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting node local disks. If not specified, a
        /// Google-managed key will be used instead.
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting node local disks. Only applicable if kms_key is set.
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LocalDiskEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::node_pool::LocalDiskEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::node_pool::LocalDiskEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::node_pool::LocalDiskEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::node_pool::LocalDiskEncryption::kms_status].
        pub fn set_kms_status<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.kms_status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [kms_status][crate::model::node_pool::LocalDiskEncryption::kms_status].
        pub fn set_or_clear_kms_status<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<rpc::model::Status>,
        {
            self.kms_status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource_state][crate::model::node_pool::LocalDiskEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for LocalDiskEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.LocalDiskEncryption"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LocalDiskEncryption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key,
                __kms_key_active_version,
                __kms_key_state,
                __kms_status,
                __resource_state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LocalDiskEncryption")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKey" => Ok(__FieldTag::__kms_key),
                                "kms_key" => Ok(__FieldTag::__kms_key),
                                "kmsKeyActiveVersion" => Ok(__FieldTag::__kms_key_active_version),
                                "kms_key_active_version" => {
                                    Ok(__FieldTag::__kms_key_active_version)
                                }
                                "kmsKeyState" => Ok(__FieldTag::__kms_key_state),
                                "kms_key_state" => Ok(__FieldTag::__kms_key_state),
                                "kmsStatus" => Ok(__FieldTag::__kms_status),
                                "kms_status" => Ok(__FieldTag::__kms_status),
                                "resourceState" => Ok(__FieldTag::__resource_state),
                                "resource_state" => Ok(__FieldTag::__resource_state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LocalDiskEncryption;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LocalDiskEncryption")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key => {
                                if !fields.insert(__FieldTag::__kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key",
                                    ));
                                }
                                result.kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_key_active_version => {
                                if !fields.insert(__FieldTag::__kms_key_active_version) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_active_version",
                                    ));
                                }
                                result.kms_key_active_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_key_state => {
                                if !fields.insert(__FieldTag::__kms_key_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_state",
                                    ));
                                }
                                result.kms_key_state = map
                                    .next_value::<std::option::Option<crate::model::KmsKeyState>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_status => {
                                if !fields.insert(__FieldTag::__kms_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_status",
                                    ));
                                }
                                result.kms_status =
                                    map.next_value::<std::option::Option<rpc::model::Status>>()?;
                            }
                            __FieldTag::__resource_state => {
                                if !fields.insert(__FieldTag::__resource_state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_state",
                                    ));
                                }
                                result.resource_state = map
                                    .next_value::<std::option::Option<crate::model::ResourceState>>(
                                    )?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LocalDiskEncryption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key.is_empty() {
                state.serialize_entry("kmsKey", &self.kms_key)?;
            }
            if !self.kms_key_active_version.is_empty() {
                state.serialize_entry("kmsKeyActiveVersion", &self.kms_key_active_version)?;
            }
            if !wkt::internal::is_default(&self.kms_key_state) {
                state.serialize_entry("kmsKeyState", &self.kms_key_state)?;
            }
            if self.kms_status.is_some() {
                state.serialize_entry("kmsStatus", &self.kms_status)?;
            }
            if !wkt::internal::is_default(&self.resource_state) {
                state.serialize_entry("resourceState", &self.resource_state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for LocalDiskEncryption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("LocalDiskEncryption");
            debug_struct.field("kms_key", &self.kms_key);
            debug_struct.field("kms_key_active_version", &self.kms_key_active_version);
            debug_struct.field("kms_key_state", &self.kms_key_state);
            debug_struct.field("kms_status", &self.kms_status);
            debug_struct.field("resource_state", &self.resource_state);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Configuration for each node in the NodePool
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NodeConfig {
        /// Optional. The Kubernetes node labels
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Name for the storage schema of worker nodes.
        ///
        /// Warning: Configurable node local storage schema feature is an
        /// experimental feature, and is not recommended for general use
        /// in production clusters/nodepools.
        pub node_storage_schema: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::node_pool::NodeConfig::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [node_storage_schema][crate::model::node_pool::NodeConfig::node_storage_schema].
        pub fn set_node_storage_schema<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.node_storage_schema = v.into();
            self
        }
    }

    impl wkt::message::Message for NodeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.NodeConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NodeConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __labels,
                __node_storage_schema,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NodeConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "labels" => Ok(__FieldTag::__labels),
                                "nodeStorageSchema" => Ok(__FieldTag::__node_storage_schema),
                                "node_storage_schema" => Ok(__FieldTag::__node_storage_schema),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NodeConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NodeConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__labels => {
                                if !fields.insert(__FieldTag::__labels) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for labels",
                                    ));
                                }
                                result.labels = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__node_storage_schema => {
                                if !fields.insert(__FieldTag::__node_storage_schema) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for node_storage_schema",
                                    ));
                                }
                                result.node_storage_schema = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NodeConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.labels.is_empty() {
                state.serialize_entry("labels", &self.labels)?;
            }
            if !self.node_storage_schema.is_empty() {
                state.serialize_entry("nodeStorageSchema", &self.node_storage_schema)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for NodeConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("NodeConfig");
            debug_struct.field("labels", &self.labels);
            debug_struct.field("node_storage_schema", &self.node_storage_schema);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// A Google Distributed Cloud Edge machine capable of acting as a Kubernetes
/// node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Machine {
    /// Required. The resource name of the machine.
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Canonical resource name of the node that this machine is responsible for
    /// hosting e.g.
    /// projects/{project}/locations/{location}/clusters/{cluster_id}/nodePools/{pool_id}/{node},
    /// Or empty if the machine is not assigned to assume the role of a node.
    ///
    /// For control plane nodes hosted on edge machines, this will return
    /// the following format:
    /// "projects/{project}/locations/{location}/clusters/{cluster_id}/controlPlaneNodes/{node}".
    pub hosted_node: std::string::String,

    /// The Google Distributed Cloud Edge zone of this machine.
    pub zone: std::string::String,

    /// Output only. The software version of the machine.
    pub version: std::string::String,

    /// Output only. Whether the machine is disabled. If disabled, the machine is
    /// unable to enter service.
    pub disabled: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Machine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Machine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Machine::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Machine::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Machine::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Machine::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Machine::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [hosted_node][crate::model::Machine::hosted_node].
    pub fn set_hosted_node<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hosted_node = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Machine::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Machine::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::Machine::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for Machine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Machine"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Machine {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __hosted_node,
            __zone,
            __version,
            __disabled,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Machine")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "hostedNode" => Ok(__FieldTag::__hosted_node),
                            "hosted_node" => Ok(__FieldTag::__hosted_node),
                            "zone" => Ok(__FieldTag::__zone),
                            "version" => Ok(__FieldTag::__version),
                            "disabled" => Ok(__FieldTag::__disabled),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Machine;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Machine")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__hosted_node => {
                            if !fields.insert(__FieldTag::__hosted_node) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hosted_node",
                                ));
                            }
                            result.hosted_node = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Machine {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.hosted_node.is_empty() {
            state.serialize_entry("hostedNode", &self.hosted_node)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Machine {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Machine");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("hosted_node", &self.hosted_node);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("version", &self.version);
        debug_struct.field("disabled", &self.disabled);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A VPN connection .
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpnConnection {
    /// Required. The resource name of VPN connection
    pub name: std::string::String,

    /// Output only. The time when the VPN connection was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the VPN connection was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// NAT gateway IP, or WAN IP address. If a customer has multiple NAT IPs, the
    /// customer needs to configure NAT such that only one external IP maps to the
    /// GMEC Anthos cluster. This is empty if NAT is not used.
    pub nat_gateway_ip: std::string::String,

    /// Dynamic routing mode of the VPC network, `regional` or `global`.
    #[deprecated]
    pub bgp_routing_mode: crate::model::vpn_connection::BgpRoutingMode,

    /// The canonical Cluster name to connect to. It is in the form of
    /// projects/{project}/locations/{location}/clusters/{cluster}.
    pub cluster: std::string::String,

    /// The network ID of VPC to connect to.
    pub vpc: std::string::String,

    /// Optional. Project detail of the VPC network. Required if VPC is in a
    /// different project than the cluster project.
    pub vpc_project: std::option::Option<crate::model::vpn_connection::VpcProject>,

    /// Whether this VPN connection has HA enabled on cluster side. If enabled,
    /// when creating VPN connection we will attempt to use 2 ANG floating IPs.
    pub enable_high_availability: bool,

    /// Optional. The VPN connection Cloud Router name.
    pub router: std::string::String,

    /// Output only. The created connection details.
    pub details: std::option::Option<crate::model::vpn_connection::Details>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpnConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpnConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VpnConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VpnConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VpnConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VpnConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::VpnConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [nat_gateway_ip][crate::model::VpnConnection::nat_gateway_ip].
    pub fn set_nat_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nat_gateway_ip = v.into();
        self
    }

    /// Sets the value of [bgp_routing_mode][crate::model::VpnConnection::bgp_routing_mode].
    #[deprecated]
    pub fn set_bgp_routing_mode<
        T: std::convert::Into<crate::model::vpn_connection::BgpRoutingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bgp_routing_mode = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::VpnConnection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::VpnConnection::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }

    /// Sets the value of [vpc_project][crate::model::VpnConnection::vpc_project].
    pub fn set_vpc_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpn_connection::VpcProject>,
    {
        self.vpc_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_project][crate::model::VpnConnection::vpc_project].
    pub fn set_or_clear_vpc_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpn_connection::VpcProject>,
    {
        self.vpc_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_high_availability][crate::model::VpnConnection::enable_high_availability].
    pub fn set_enable_high_availability<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_high_availability = v.into();
        self
    }

    /// Sets the value of [router][crate::model::VpnConnection::router].
    pub fn set_router<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.router = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VpnConnection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::vpn_connection::Details>,
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::VpnConnection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::vpn_connection::Details>,
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VpnConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VpnConnection {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __labels,
            __nat_gateway_ip,
            __bgp_routing_mode,
            __cluster,
            __vpc,
            __vpc_project,
            __enable_high_availability,
            __router,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VpnConnection")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "natGatewayIp" => Ok(__FieldTag::__nat_gateway_ip),
                            "nat_gateway_ip" => Ok(__FieldTag::__nat_gateway_ip),
                            "bgpRoutingMode" => Ok(__FieldTag::__bgp_routing_mode),
                            "bgp_routing_mode" => Ok(__FieldTag::__bgp_routing_mode),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "vpc" => Ok(__FieldTag::__vpc),
                            "vpcProject" => Ok(__FieldTag::__vpc_project),
                            "vpc_project" => Ok(__FieldTag::__vpc_project),
                            "enableHighAvailability" => Ok(__FieldTag::__enable_high_availability),
                            "enable_high_availability" => {
                                Ok(__FieldTag::__enable_high_availability)
                            }
                            "router" => Ok(__FieldTag::__router),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VpnConnection;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VpnConnection")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nat_gateway_ip => {
                            if !fields.insert(__FieldTag::__nat_gateway_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nat_gateway_ip",
                                ));
                            }
                            result.nat_gateway_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bgp_routing_mode => {
                            if !fields.insert(__FieldTag::__bgp_routing_mode) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bgp_routing_mode",
                                ));
                            }
                            result.bgp_routing_mode =
                                map.next_value::<std::option::Option<
                                    crate::model::vpn_connection::BgpRoutingMode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc => {
                            if !fields.insert(__FieldTag::__vpc) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc",
                                ));
                            }
                            result.vpc = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_project => {
                            if !fields.insert(__FieldTag::__vpc_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_project",
                                ));
                            }
                            result.vpc_project = map.next_value::<std::option::Option<crate::model::vpn_connection::VpcProject>>()?
                                ;
                        }
                        __FieldTag::__enable_high_availability => {
                            if !fields.insert(__FieldTag::__enable_high_availability) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_high_availability",
                                ));
                            }
                            result.enable_high_availability = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__router => {
                            if !fields.insert(__FieldTag::__router) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for router",
                                ));
                            }
                            result.router = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map.next_value::<std::option::Option<crate::model::vpn_connection::Details>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VpnConnection {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.nat_gateway_ip.is_empty() {
            state.serialize_entry("natGatewayIp", &self.nat_gateway_ip)?;
        }
        if !wkt::internal::is_default(&self.bgp_routing_mode) {
            state.serialize_entry("bgpRoutingMode", &self.bgp_routing_mode)?;
        }
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.vpc.is_empty() {
            state.serialize_entry("vpc", &self.vpc)?;
        }
        if self.vpc_project.is_some() {
            state.serialize_entry("vpcProject", &self.vpc_project)?;
        }
        if !wkt::internal::is_default(&self.enable_high_availability) {
            state.serialize_entry("enableHighAvailability", &self.enable_high_availability)?;
        }
        if !self.router.is_empty() {
            state.serialize_entry("router", &self.router)?;
        }
        if self.details.is_some() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VpnConnection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VpnConnection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("nat_gateway_ip", &self.nat_gateway_ip);
        debug_struct.field("bgp_routing_mode", &self.bgp_routing_mode);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("vpc", &self.vpc);
        debug_struct.field("vpc_project", &self.vpc_project);
        debug_struct.field("enable_high_availability", &self.enable_high_availability);
        debug_struct.field("router", &self.router);
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VpnConnection].
pub mod vpn_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Project detail of the VPC network.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VpcProject {
        /// The project of the VPC to connect to. If not specified, it is the same as
        /// the cluster project.
        pub project_id: std::string::String,

        /// Optional. Deprecated: do not use.
        #[deprecated]
        pub service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VpcProject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::vpn_connection::VpcProject::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [service_account][crate::model::vpn_connection::VpcProject::service_account].
        #[deprecated]
        pub fn set_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for VpcProject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.VpcProject"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VpcProject {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __project_id,
                __service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VpcProject")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "projectId" => Ok(__FieldTag::__project_id),
                                "project_id" => Ok(__FieldTag::__project_id),
                                "serviceAccount" => Ok(__FieldTag::__service_account),
                                "service_account" => Ok(__FieldTag::__service_account),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VpcProject;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VpcProject")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__project_id => {
                                if !fields.insert(__FieldTag::__project_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for project_id",
                                    ));
                                }
                                result.project_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_account => {
                                if !fields.insert(__FieldTag::__service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_account",
                                    ));
                                }
                                result.service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VpcProject {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.project_id.is_empty() {
                state.serialize_entry("projectId", &self.project_id)?;
            }
            if !self.service_account.is_empty() {
                state.serialize_entry("serviceAccount", &self.service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VpcProject {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VpcProject");
            debug_struct.field("project_id", &self.project_id);
            debug_struct.field("service_account", &self.service_account);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The created connection details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Details {
        /// The state of this connection.
        pub state: crate::model::vpn_connection::details::State,

        /// The error message. This is only populated when state=ERROR.
        pub error: std::string::String,

        /// The Cloud Router info.
        pub cloud_router: std::option::Option<crate::model::vpn_connection::details::CloudRouter>,

        /// Each connection has multiple Cloud VPN gateways.
        pub cloud_vpns: std::vec::Vec<crate::model::vpn_connection::details::CloudVpn>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Details {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::vpn_connection::Details::state].
        pub fn set_state<T: std::convert::Into<crate::model::vpn_connection::details::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::vpn_connection::Details::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }

        /// Sets the value of [cloud_router][crate::model::vpn_connection::Details::cloud_router].
        pub fn set_cloud_router<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::vpn_connection::details::CloudRouter>,
        {
            self.cloud_router = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cloud_router][crate::model::vpn_connection::Details::cloud_router].
        pub fn set_or_clear_cloud_router<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::vpn_connection::details::CloudRouter>,
        {
            self.cloud_router = v.map(|x| x.into());
            self
        }

        /// Sets the value of [cloud_vpns][crate::model::vpn_connection::Details::cloud_vpns].
        pub fn set_cloud_vpns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vpn_connection::details::CloudVpn>,
        {
            use std::iter::Iterator;
            self.cloud_vpns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Details {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Details {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __state,
                __error,
                __cloud_router,
                __cloud_vpns,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Details")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "state" => Ok(__FieldTag::__state),
                                "error" => Ok(__FieldTag::__error),
                                "cloudRouter" => Ok(__FieldTag::__cloud_router),
                                "cloud_router" => Ok(__FieldTag::__cloud_router),
                                "cloudVpns" => Ok(__FieldTag::__cloud_vpns),
                                "cloud_vpns" => Ok(__FieldTag::__cloud_vpns),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Details;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Details")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map
                                    .next_value::<std::option::Option<
                                        crate::model::vpn_connection::details::State,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__error => {
                                if !fields.insert(__FieldTag::__error) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error",
                                    ));
                                }
                                result.error = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cloud_router => {
                                if !fields.insert(__FieldTag::__cloud_router) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_router",
                                    ));
                                }
                                result.cloud_router = map.next_value::<std::option::Option<
                                    crate::model::vpn_connection::details::CloudRouter,
                                >>()?;
                            }
                            __FieldTag::__cloud_vpns => {
                                if !fields.insert(__FieldTag::__cloud_vpns) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cloud_vpns",
                                    ));
                                }
                                result.cloud_vpns = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<
                                            crate::model::vpn_connection::details::CloudVpn,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Details {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self.error.is_empty() {
                state.serialize_entry("error", &self.error)?;
            }
            if self.cloud_router.is_some() {
                state.serialize_entry("cloudRouter", &self.cloud_router)?;
            }
            if !self.cloud_vpns.is_empty() {
                state.serialize_entry("cloudVpns", &self.cloud_vpns)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Details {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Details");
            debug_struct.field("state", &self.state);
            debug_struct.field("error", &self.error);
            debug_struct.field("cloud_router", &self.cloud_router);
            debug_struct.field("cloud_vpns", &self.cloud_vpns);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Details].
    pub mod details {
        #[allow(unused_imports)]
        use super::*;

        /// The Cloud Router info.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CloudRouter {
            /// The associated Cloud Router name.
            pub name: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CloudRouter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vpn_connection::details::CloudRouter::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudRouter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudRouter"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CloudRouter {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __name,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CloudRouter")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "name" => Ok(__FieldTag::__name),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CloudRouter;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CloudRouter")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__name => {
                                    if !fields.insert(__FieldTag::__name) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for name"),
                                        );
                                    }
                                    result.name = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CloudRouter {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.name.is_empty() {
                    state.serialize_entry("name", &self.name)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for CloudRouter {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("CloudRouter");
                debug_struct.field("name", &self.name);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The Cloud VPN info.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CloudVpn {
            /// The created Cloud VPN gateway name.
            pub gateway: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CloudVpn {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gateway][crate::model::vpn_connection::details::CloudVpn::gateway].
            pub fn set_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.gateway = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudVpn {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudVpn"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for CloudVpn {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __gateway,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for CloudVpn")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "gateway" => Ok(__FieldTag::__gateway),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = CloudVpn;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct CloudVpn")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__gateway => {
                                    if !fields.insert(__FieldTag::__gateway) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for gateway",
                                            ),
                                        );
                                    }
                                    result.gateway = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for CloudVpn {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.gateway.is_empty() {
                    state.serialize_entry("gateway", &self.gateway)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for CloudVpn {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("CloudVpn");
                debug_struct.field("gateway", &self.gateway);

                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The current connection state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unknown.
            Unspecified,
            /// Connected.
            Connected,
            /// Still connecting.
            Connecting,
            /// Error occurred.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Connected => std::option::Option::Some(1),
                    Self::Connecting => std::option::Option::Some(2),
                    Self::Error => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Connected => std::option::Option::Some("STATE_CONNECTED"),
                    Self::Connecting => std::option::Option::Some("STATE_CONNECTING"),
                    Self::Error => std::option::Option::Some("STATE_ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Connected,
                    2 => Self::Connecting,
                    3 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "STATE_CONNECTED" => Self::Connected,
                    "STATE_CONNECTING" => Self::Connecting,
                    "STATE_ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Connected => serializer.serialize_i32(1),
                    Self::Connecting => serializer.serialize_i32(2),
                    Self::Error => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.VpnConnection.Details.State",
                ))
            }
        }
    }

    /// Routing mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BgpRoutingMode {
        /// Unknown.
        Unspecified,
        /// Regional mode.
        Regional,
        /// Global mode.
        Global,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BgpRoutingMode::value] or
        /// [BgpRoutingMode::name].
        UnknownValue(bgp_routing_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bgp_routing_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BgpRoutingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Regional => std::option::Option::Some(1),
                Self::Global => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BGP_ROUTING_MODE_UNSPECIFIED"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BgpRoutingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BgpRoutingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BgpRoutingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Regional,
                2 => Self::Global,
                _ => Self::UnknownValue(bgp_routing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BgpRoutingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BGP_ROUTING_MODE_UNSPECIFIED" => Self::Unspecified,
                "REGIONAL" => Self::Regional,
                "GLOBAL" => Self::Global,
                _ => Self::UnknownValue(bgp_routing_mode::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BgpRoutingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Regional => serializer.serialize_i32(1),
                Self::Global => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BgpRoutingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BgpRoutingMode>::new(
                ".google.cloud.edgecontainer.v1.VpnConnection.BgpRoutingMode",
            ))
        }
    }
}

/// Metadata for a given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {
    /// The set of available Google Distributed Cloud Edge zones in the location.
    /// The map is keyed by the lowercase ID of each zone.
    pub available_zones: std::collections::HashMap<std::string::String, crate::model::ZoneMetadata>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_zones][crate::model::LocationMetadata::available_zones].
    pub fn set_available_zones<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ZoneMetadata>,
    {
        use std::iter::Iterator;
        self.available_zones = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.LocationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LocationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __available_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LocationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "availableZones" => Ok(__FieldTag::__available_zones),
                            "available_zones" => Ok(__FieldTag::__available_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LocationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LocationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__available_zones => {
                            if !fields.insert(__FieldTag::__available_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_zones",
                                ));
                            }
                            result.available_zones = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ZoneMetadata,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LocationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.available_zones.is_empty() {
            state.serialize_entry("availableZones", &self.available_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LocationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LocationMetadata");
        debug_struct.field("available_zones", &self.available_zones);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A Google Distributed Cloud Edge zone where edge machines are located.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneMetadata {
    /// Quota for resources in this zone.
    pub quota: std::vec::Vec<crate::model::Quota>,

    /// The map keyed by rack name and has value of RackType.
    pub rack_types:
        std::collections::HashMap<std::string::String, crate::model::zone_metadata::RackType>,

    /// Config data for the zone.
    pub config_data: std::option::Option<crate::model::ConfigData>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZoneMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota][crate::model::ZoneMetadata::quota].
    pub fn set_quota<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Quota>,
    {
        use std::iter::Iterator;
        self.quota = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rack_types][crate::model::ZoneMetadata::rack_types].
    pub fn set_rack_types<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::zone_metadata::RackType>,
    {
        use std::iter::Iterator;
        self.rack_types = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [config_data][crate::model::ZoneMetadata::config_data].
    pub fn set_config_data<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ConfigData>,
    {
        self.config_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_data][crate::model::ZoneMetadata::config_data].
    pub fn set_or_clear_config_data<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ConfigData>,
    {
        self.config_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ZoneMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ZoneMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ZoneMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __quota,
            __rack_types,
            __config_data,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ZoneMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "quota" => Ok(__FieldTag::__quota),
                            "rackTypes" => Ok(__FieldTag::__rack_types),
                            "rack_types" => Ok(__FieldTag::__rack_types),
                            "configData" => Ok(__FieldTag::__config_data),
                            "config_data" => Ok(__FieldTag::__config_data),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ZoneMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ZoneMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__quota => {
                            if !fields.insert(__FieldTag::__quota) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for quota",
                                ));
                            }
                            result.quota = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Quota>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__rack_types => {
                            if !fields.insert(__FieldTag::__rack_types) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for rack_types",
                                ));
                            }
                            result.rack_types = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::zone_metadata::RackType,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__config_data => {
                            if !fields.insert(__FieldTag::__config_data) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config_data",
                                ));
                            }
                            result.config_data =
                                map.next_value::<std::option::Option<crate::model::ConfigData>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ZoneMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.quota.is_empty() {
            state.serialize_entry("quota", &self.quota)?;
        }
        if !self.rack_types.is_empty() {
            state.serialize_entry("rackTypes", &self.rack_types)?;
        }
        if self.config_data.is_some() {
            state.serialize_entry("configData", &self.config_data)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ZoneMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ZoneMetadata");
        debug_struct.field("quota", &self.quota);
        debug_struct.field("rack_types", &self.rack_types);
        debug_struct.field("config_data", &self.config_data);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ZoneMetadata].
pub mod zone_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the rack.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RackType {
        /// Unspecified rack type, single rack also belongs to this type.
        Unspecified,
        /// Base rack type, a pair of two modified Config-1 racks containing
        /// Aggregation switches.
        Base,
        /// Expansion rack type, also known as standalone racks,
        /// added by customers on demand.
        Expansion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RackType::value] or
        /// [RackType::name].
        UnknownValue(rack_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Base => std::option::Option::Some(1),
                Self::Expansion => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RACK_TYPE_UNSPECIFIED"),
                Self::Base => std::option::Option::Some("BASE"),
                Self::Expansion => std::option::Option::Some("EXPANSION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Base,
                2 => Self::Expansion,
                _ => Self::UnknownValue(rack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RACK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BASE" => Self::Base,
                "EXPANSION" => Self::Expansion,
                _ => Self::UnknownValue(rack_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Base => serializer.serialize_i32(1),
                Self::Expansion => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RackType>::new(
                ".google.cloud.edgecontainer.v1.ZoneMetadata.RackType",
            ))
        }
    }
}

/// Config data holds all the config related data for the zone.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigData {
    /// list of available v4 ip pools for external loadbalancer
    pub available_external_lb_pools_ipv4: std::vec::Vec<std::string::String>,

    /// list of available v6 ip pools for external loadbalancer
    pub available_external_lb_pools_ipv6: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_external_lb_pools_ipv4][crate::model::ConfigData::available_external_lb_pools_ipv4].
    pub fn set_available_external_lb_pools_ipv4<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv4 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_external_lb_pools_ipv6][crate::model::ConfigData::available_external_lb_pools_ipv6].
    pub fn set_available_external_lb_pools_ipv6<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv6 = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ConfigData"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ConfigData {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __available_external_lb_pools_ipv4,
            __available_external_lb_pools_ipv6,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ConfigData")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "availableExternalLbPoolsIpv4" => {
                                Ok(__FieldTag::__available_external_lb_pools_ipv4)
                            }
                            "available_external_lb_pools_ipv4" => {
                                Ok(__FieldTag::__available_external_lb_pools_ipv4)
                            }
                            "availableExternalLbPoolsIpv6" => {
                                Ok(__FieldTag::__available_external_lb_pools_ipv6)
                            }
                            "available_external_lb_pools_ipv6" => {
                                Ok(__FieldTag::__available_external_lb_pools_ipv6)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ConfigData;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ConfigData")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__available_external_lb_pools_ipv4 => {
                            if !fields.insert(__FieldTag::__available_external_lb_pools_ipv4) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_external_lb_pools_ipv4",
                                ));
                            }
                            result.available_external_lb_pools_ipv4 = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__available_external_lb_pools_ipv6 => {
                            if !fields.insert(__FieldTag::__available_external_lb_pools_ipv6) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_external_lb_pools_ipv6",
                                ));
                            }
                            result.available_external_lb_pools_ipv6 = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ConfigData {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.available_external_lb_pools_ipv4.is_empty() {
            state.serialize_entry(
                "availableExternalLbPoolsIpv4",
                &self.available_external_lb_pools_ipv4,
            )?;
        }
        if !self.available_external_lb_pools_ipv6.is_empty() {
            state.serialize_entry(
                "availableExternalLbPoolsIpv6",
                &self.available_external_lb_pools_ipv6,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ConfigData {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ConfigData");
        debug_struct.field(
            "available_external_lb_pools_ipv4",
            &self.available_external_lb_pools_ipv4,
        );
        debug_struct.field(
            "available_external_lb_pools_ipv6",
            &self.available_external_lb_pools_ipv6,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents quota for Edge Container resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Quota {
    /// Name of the quota metric.
    pub metric: std::string::String,

    /// Quota limit for this metric.
    pub limit: f64,

    /// Current usage of this metric.
    pub usage: f64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Quota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::Quota::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [limit][crate::model::Quota::limit].
    pub fn set_limit<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.limit = v.into();
        self
    }

    /// Sets the value of [usage][crate::model::Quota::usage].
    pub fn set_usage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.usage = v.into();
        self
    }
}

impl wkt::message::Message for Quota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Quota"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Quota {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __metric,
            __limit,
            __usage,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Quota")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "metric" => Ok(__FieldTag::__metric),
                            "limit" => Ok(__FieldTag::__limit),
                            "usage" => Ok(__FieldTag::__usage),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Quota;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Quota")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__metric => {
                            if !fields.insert(__FieldTag::__metric) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metric",
                                ));
                            }
                            result.metric = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__limit => {
                            if !fields.insert(__FieldTag::__limit) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for limit",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.limit = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__usage => {
                            if !fields.insert(__FieldTag::__usage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for usage",
                                ));
                            }
                            struct __With(std::option::Option<f64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::F64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.usage = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Quota {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.metric.is_empty() {
            state.serialize_entry("metric", &self.metric)?;
        }
        if !wkt::internal::is_default(&self.limit) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("limit", &__With(&self.limit))?;
        }
        if !wkt::internal::is_default(&self.usage) {
            struct __With<'a>(&'a f64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::F64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("usage", &__With(&self.usage))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Quota {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Quota");
        debug_struct.field("metric", &self.metric);
        debug_struct.field("limit", &self.limit);
        debug_struct.field("usage", &self.usage);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Maintenance policy configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenancePolicy {
    /// Specifies the maintenance window in which maintenance may be performed.
    pub window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Optional. Exclusions to automatic maintenance. Non-emergency maintenance
    /// should not occur in these windows. Each exclusion has a unique name and may
    /// be active or expired. The max number of maintenance exclusions allowed at a
    /// given time is 3.
    pub maintenance_exclusions: std::vec::Vec<crate::model::MaintenanceExclusionWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MaintenanceWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_exclusions][crate::model::MaintenancePolicy::maintenance_exclusions].
    pub fn set_maintenance_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MaintenanceExclusionWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenancePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenancePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __maintenance_exclusions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenancePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "maintenanceExclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            "maintenance_exclusions" => Ok(__FieldTag::__maintenance_exclusions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenancePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenancePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window = map
                                .next_value::<std::option::Option<crate::model::MaintenanceWindow>>(
                                )?;
                        }
                        __FieldTag::__maintenance_exclusions => {
                            if !fields.insert(__FieldTag::__maintenance_exclusions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for maintenance_exclusions",
                                ));
                            }
                            result.maintenance_exclusions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MaintenanceExclusionWindow>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenancePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.maintenance_exclusions.is_empty() {
            state.serialize_entry("maintenanceExclusions", &self.maintenance_exclusions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenancePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenancePolicy");
        debug_struct.field("window", &self.window);
        debug_struct.field("maintenance_exclusions", &self.maintenance_exclusions);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Maintenance window configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Configuration of a recurring maintenance window.
    pub recurring_window: std::option::Option<crate::model::RecurringTimeWindow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recurring_window][crate::model::MaintenanceWindow::recurring_window].
    pub fn set_recurring_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::RecurringTimeWindow>,
    {
        self.recurring_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recurring_window][crate::model::MaintenanceWindow::recurring_window].
    pub fn set_or_clear_recurring_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::RecurringTimeWindow>,
    {
        self.recurring_window = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __recurring_window,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "recurringWindow" => Ok(__FieldTag::__recurring_window),
                            "recurring_window" => Ok(__FieldTag::__recurring_window),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__recurring_window => {
                            if !fields.insert(__FieldTag::__recurring_window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurring_window",
                                ));
                            }
                            result.recurring_window = map.next_value::<std::option::Option<crate::model::RecurringTimeWindow>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.recurring_window.is_some() {
            state.serialize_entry("recurringWindow", &self.recurring_window)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceWindow");
        debug_struct.field("recurring_window", &self.recurring_window);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an arbitrary window of time that recurs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecurringTimeWindow {
    /// The window of the first recurrence.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window recurs. They go on for the span of time between the start and
    /// end time.
    pub recurrence: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::RecurringTimeWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for RecurringTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.RecurringTimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RecurringTimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __recurrence,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RecurringTimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "recurrence" => Ok(__FieldTag::__recurrence),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RecurringTimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RecurringTimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__recurrence => {
                            if !fields.insert(__FieldTag::__recurrence) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recurrence",
                                ));
                            }
                            result.recurrence = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RecurringTimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.recurrence.is_empty() {
            state.serialize_entry("recurrence", &self.recurrence)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RecurringTimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RecurringTimeWindow");
        debug_struct.field("window", &self.window);
        debug_struct.field("recurrence", &self.recurrence);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents a maintenance exclusion window.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceExclusionWindow {
    /// Optional. The time window.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// Optional. A unique (per cluster) id for the window.
    pub id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceExclusionWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenanceExclusionWindow::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::MaintenanceExclusionWindow::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TimeWindow>,
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::MaintenanceExclusionWindow::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceExclusionWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceExclusionWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MaintenanceExclusionWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __window,
            __id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MaintenanceExclusionWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "window" => Ok(__FieldTag::__window),
                            "id" => Ok(__FieldTag::__id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MaintenanceExclusionWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MaintenanceExclusionWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__window => {
                            if !fields.insert(__FieldTag::__window) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for window",
                                ));
                            }
                            result.window =
                                map.next_value::<std::option::Option<crate::model::TimeWindow>>()?;
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MaintenanceExclusionWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.window.is_some() {
            state.serialize_entry("window", &self.window)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MaintenanceExclusionWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MaintenanceExclusionWindow");
        debug_struct.field("window", &self.window);
        debug_struct.field("id", &self.id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents an arbitrary window of time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeWindow {
    /// The time that the window first starts.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time that the window ends. The end time must take place after the
    /// start time.
    pub end_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.TimeWindow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TimeWindow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TimeWindow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TimeWindow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TimeWindow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TimeWindow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TimeWindow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TimeWindow");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Server configuration for supported versions and release channels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerConfig {
    /// Output only. Mapping from release channel to channel config.
    pub channels: std::collections::HashMap<std::string::String, crate::model::ChannelConfig>,

    /// Output only. Supported versions, e.g.: ["1.4.0", "1.5.0"].
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Output only. Default version, e.g.: "1.4.0".
    pub default_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::ServerConfig::channels].
    pub fn set_channels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ChannelConfig>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [versions][crate::model::ServerConfig::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_version][crate::model::ServerConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }
}

impl wkt::message::Message for ServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ServerConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServerConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __channels,
            __versions,
            __default_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServerConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "channels" => Ok(__FieldTag::__channels),
                            "versions" => Ok(__FieldTag::__versions),
                            "defaultVersion" => Ok(__FieldTag::__default_version),
                            "default_version" => Ok(__FieldTag::__default_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServerConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServerConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__channels => {
                            if !fields.insert(__FieldTag::__channels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for channels",
                                ));
                            }
                            result.channels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        crate::model::ChannelConfig,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__versions => {
                            if !fields.insert(__FieldTag::__versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for versions",
                                ));
                            }
                            result.versions = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Version>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__default_version => {
                            if !fields.insert(__FieldTag::__default_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_version",
                                ));
                            }
                            result.default_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServerConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.channels.is_empty() {
            state.serialize_entry("channels", &self.channels)?;
        }
        if !self.versions.is_empty() {
            state.serialize_entry("versions", &self.versions)?;
        }
        if !self.default_version.is_empty() {
            state.serialize_entry("defaultVersion", &self.default_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServerConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServerConfig");
        debug_struct.field("channels", &self.channels);
        debug_struct.field("versions", &self.versions);
        debug_struct.field("default_version", &self.default_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Configuration for a release channel.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChannelConfig {
    /// Output only. Default version for this release channel, e.g.: "1.4.0".
    pub default_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChannelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_version][crate::model::ChannelConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }
}

impl wkt::message::Message for ChannelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ChannelConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ChannelConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ChannelConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultVersion" => Ok(__FieldTag::__default_version),
                            "default_version" => Ok(__FieldTag::__default_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ChannelConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ChannelConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_version => {
                            if !fields.insert(__FieldTag::__default_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_version",
                                ));
                            }
                            result.default_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ChannelConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_version.is_empty() {
            state.serialize_entry("defaultVersion", &self.default_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ChannelConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ChannelConfig");
        debug_struct.field("default_version", &self.default_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Version of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {
    /// Output only. Name of the version, e.g.: "1.4.0".
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Version"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Version {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Version")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Version;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Version")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Version {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Version {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Version");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Long-running operation metadata for Edge Container API methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// The verb executed by the operation.
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation of the operation.
    /// Operations that have successfully been cancelled have [Operation.error][]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    pub api_version: std::string::String,

    /// Warnings that do not block the operation, but still hold relevant
    /// information for the end user to receive.
    pub warnings: std::vec::Vec<std::string::String>,

    /// Machine-readable status of the operation, if any.
    pub status_reason: crate::model::operation_metadata::StatusReason,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::OperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_reason][crate::model::OperationMetadata::status_reason].
    pub fn set_status_reason<
        T: std::convert::Into<crate::model::operation_metadata::StatusReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status_reason = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __warnings,
            __status_reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "statusReason" => Ok(__FieldTag::__status_reason),
                            "status_reason" => Ok(__FieldTag::__status_reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__status_reason => {
                            if !fields.insert(__FieldTag::__status_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_reason",
                                ));
                            }
                            result.status_reason =
                                map.next_value::<std::option::Option<
                                    crate::model::operation_metadata::StatusReason,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !wkt::internal::is_default(&self.status_reason) {
            state.serialize_entry("statusReason", &self.status_reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("status_reason", &self.status_reason);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the reason for the status of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StatusReason {
        /// Reason unknown.
        Unspecified,
        /// The cluster upgrade is currently paused.
        UpgradePaused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StatusReason::value] or
        /// [StatusReason::name].
        UnknownValue(status_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StatusReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UpgradePaused => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_REASON_UNSPECIFIED"),
                Self::UpgradePaused => std::option::Option::Some("UPGRADE_PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StatusReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StatusReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StatusReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UpgradePaused,
                _ => Self::UnknownValue(status_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StatusReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_REASON_UNSPECIFIED" => Self::Unspecified,
                "UPGRADE_PAUSED" => Self::UpgradePaused,
                _ => Self::UnknownValue(status_reason::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StatusReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UpgradePaused => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StatusReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StatusReason>::new(
                ".google.cloud.edgecontainer.v1.OperationMetadata.StatusReason",
            ))
        }
    }
}

/// Lists clusters in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The parent location, which owns this collection of clusters.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of clusters in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// Clusters in the location.
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clusters,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clusters" => Ok(__FieldTag::__clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clusters => {
                            if !fields.insert(__FieldTag::__clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clusters",
                                ));
                            }
                            result.clusters = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Cluster>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clusters.is_empty() {
            state.serialize_entry("clusters", &self.clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListClustersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListClustersResponse");
        debug_struct.field("clusters", &self.clusters);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetClusterRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Creates a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The parent location where this cluster will be created.
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the cluster.
    pub cluster_id: std::string::String,

    /// Required. The cluster to create.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cluster_id,
            __cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "clusterId" => Ok(__FieldTag::__cluster_id),
                            "cluster_id" => Ok(__FieldTag::__cluster_id),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster_id => {
                            if !fields.insert(__FieldTag::__cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster_id",
                                ));
                            }
                            result.cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cluster_id.is_empty() {
            state.serialize_entry("clusterId", &self.cluster_id)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateClusterRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cluster_id", &self.cluster_id);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Updates a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated cluster.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended.
    /// This request is only idempotent if `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Cluster>,
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __cluster,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "cluster" => Ok(__FieldTag::__cluster),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster =
                                map.next_value::<std::option::Option<crate::model::Cluster>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.cluster.is_some() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateClusterRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Upgrades a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The version the cluster is going to be upgraded to.
    pub target_version: std::string::String,

    /// The schedule for the upgrade.
    pub schedule: crate::model::upgrade_cluster_request::Schedule,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeClusterRequest::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::UpgradeClusterRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<crate::model::upgrade_cluster_request::Schedule>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpgradeClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_version,
            __schedule,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            "schedule" => Ok(__FieldTag::__schedule),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schedule => {
                            if !fields.insert(__FieldTag::__schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schedule",
                                ));
                            }
                            result.schedule = map
                                .next_value::<std::option::Option<
                                    crate::model::upgrade_cluster_request::Schedule,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !wkt::internal::is_default(&self.schedule) {
            state.serialize_entry("schedule", &self.schedule)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeClusterRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_version", &self.target_version);
        debug_struct.field("schedule", &self.schedule);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UpgradeClusterRequest].
pub mod upgrade_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the schedule about when the cluster is going to be upgraded.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Unspecified. The default is to upgrade the cluster immediately which is
        /// the only option today.
        Unspecified,
        /// The cluster is going to be upgraded immediately after receiving the
        /// request.
        Immediately,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Schedule::value] or
        /// [Schedule::name].
        UnknownValue(schedule::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Schedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediately => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEDULE_UNSPECIFIED"),
                Self::Immediately => std::option::Option::Some("IMMEDIATELY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Schedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Schedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Schedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediately,
                _ => Self::UnknownValue(schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Schedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATELY" => Self::Immediately,
                _ => Self::UnknownValue(schedule::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediately => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Schedule>::new(
                ".google.cloud.edgecontainer.v1.UpgradeClusterRequest.Schedule",
            ))
        }
    }
}

/// Deletes a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteClusterRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteClusterRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Generates an access token for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenRequest {
    /// Required. The resource name of the cluster.
    pub cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateAccessTokenRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAccessTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAccessTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAccessTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAccessTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAccessTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateAccessTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateAccessTokenRequest");
        debug_struct.field("cluster", &self.cluster);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An access token for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAccessTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAccessTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAccessTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAccessTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAccessTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateAccessTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateAccessTokenResponse");
        debug_struct.field("access_token", &self.access_token);
        debug_struct.field("expire_time", &self.expire_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Generates an offline credential(offline) for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOfflineCredentialRequest {
    /// Required. The resource name of the cluster.
    pub cluster: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOfflineCredentialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateOfflineCredentialRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateOfflineCredentialRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cluster,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateOfflineCredentialRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cluster" => Ok(__FieldTag::__cluster),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateOfflineCredentialRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateOfflineCredentialRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cluster => {
                            if !fields.insert(__FieldTag::__cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cluster",
                                ));
                            }
                            result.cluster = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateOfflineCredentialRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cluster.is_empty() {
            state.serialize_entry("cluster", &self.cluster)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateOfflineCredentialRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateOfflineCredentialRequest");
        debug_struct.field("cluster", &self.cluster);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// An offline credential for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOfflineCredentialResponse {
    /// Output only. Client certificate to authenticate to k8s api-server.
    pub client_certificate: std::string::String,

    /// Output only. Client private key to authenticate to k8s api-server.
    pub client_key: std::string::String,

    /// Output only. Client's identity.
    pub user_id: std::string::String,

    /// Output only. Timestamp at which this credential will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOfflineCredentialResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_certificate][crate::model::GenerateOfflineCredentialResponse::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::GenerateOfflineCredentialResponse::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::GenerateOfflineCredentialResponse::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateOfflineCredentialResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GenerateOfflineCredentialResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateOfflineCredentialResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client_certificate,
            __client_key,
            __user_id,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateOfflineCredentialResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clientCertificate" => Ok(__FieldTag::__client_certificate),
                            "client_certificate" => Ok(__FieldTag::__client_certificate),
                            "clientKey" => Ok(__FieldTag::__client_key),
                            "client_key" => Ok(__FieldTag::__client_key),
                            "userId" => Ok(__FieldTag::__user_id),
                            "user_id" => Ok(__FieldTag::__user_id),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateOfflineCredentialResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateOfflineCredentialResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client_certificate => {
                            if !fields.insert(__FieldTag::__client_certificate) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_certificate",
                                ));
                            }
                            result.client_certificate = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__client_key => {
                            if !fields.insert(__FieldTag::__client_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_key",
                                ));
                            }
                            result.client_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__user_id => {
                            if !fields.insert(__FieldTag::__user_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for user_id",
                                ));
                            }
                            result.user_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateOfflineCredentialResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.client_certificate.is_empty() {
            state.serialize_entry("clientCertificate", &self.client_certificate)?;
        }
        if !self.client_key.is_empty() {
            state.serialize_entry("clientKey", &self.client_key)?;
        }
        if !self.user_id.is_empty() {
            state.serialize_entry("userId", &self.user_id)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GenerateOfflineCredentialResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GenerateOfflineCredentialResponse");
        debug_struct.field("client_certificate", &self.client_certificate);
        debug_struct.field("client_key", &self.client_key);
        debug_struct.field("user_id", &self.user_id);
        debug_struct.field("expire_time", &self.expire_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Lists node pools in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsRequest {
    /// Required. The parent cluster, which owns this collection of node pools.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNodePoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNodePoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNodePoolsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNodePoolsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNodePoolsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNodePoolsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of node pools in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsResponse {
    /// Node pools in the cluster.
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pools][crate::model::ListNodePoolsResponse::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNodePoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNodePoolsResponse {
    type PageItem = crate::model::NodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListNodePoolsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __node_pools,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListNodePoolsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "nodePools" => Ok(__FieldTag::__node_pools),
                            "node_pools" => Ok(__FieldTag::__node_pools),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListNodePoolsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListNodePoolsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__node_pools => {
                            if !fields.insert(__FieldTag::__node_pools) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pools",
                                ));
                            }
                            result.node_pools = map.next_value::<std::option::Option<std::vec::Vec<crate::model::NodePool>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListNodePoolsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.node_pools.is_empty() {
            state.serialize_entry("nodePools", &self.node_pools)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListNodePoolsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListNodePoolsResponse");
        debug_struct.field("node_pools", &self.node_pools);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNodePoolRequest {
    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetNodePoolRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Creates a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNodePoolRequest {
    /// Required. The parent cluster where this node pool will be created.
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the node pool.
    pub node_pool_id: std::string::String,

    /// Required. The node pool to create.
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::CreateNodePoolRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_or_clear_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __node_pool_id,
            __node_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "nodePoolId" => Ok(__FieldTag::__node_pool_id),
                            "node_pool_id" => Ok(__FieldTag::__node_pool_id),
                            "nodePool" => Ok(__FieldTag::__node_pool),
                            "node_pool" => Ok(__FieldTag::__node_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool_id => {
                            if !fields.insert(__FieldTag::__node_pool_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool_id",
                                ));
                            }
                            result.node_pool_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_pool => {
                            if !fields.insert(__FieldTag::__node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool",
                                ));
                            }
                            result.node_pool =
                                map.next_value::<std::option::Option<crate::model::NodePool>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.node_pool_id.is_empty() {
            state.serialize_entry("nodePoolId", &self.node_pool_id)?;
        }
        if self.node_pool.is_some() {
            state.serialize_entry("nodePool", &self.node_pool)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateNodePoolRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("node_pool_id", &self.node_pool_id);
        debug_struct.field("node_pool", &self.node_pool);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Updates a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNodePoolRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// NodePool resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated node pool.
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateNodePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNodePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_pool][crate::model::UpdateNodePoolRequest::node_pool].
    pub fn set_node_pool<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool][crate::model::UpdateNodePoolRequest::node_pool].
    pub fn set_or_clear_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::NodePool>,
    {
        self.node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __node_pool,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "nodePool" => Ok(__FieldTag::__node_pool),
                            "node_pool" => Ok(__FieldTag::__node_pool),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__node_pool => {
                            if !fields.insert(__FieldTag::__node_pool) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_pool",
                                ));
                            }
                            result.node_pool =
                                map.next_value::<std::option::Option<crate::model::NodePool>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.node_pool.is_some() {
            state.serialize_entry("nodePool", &self.node_pool)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateNodePoolRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("node_pool", &self.node_pool);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Deletes a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNodePoolRequest {
    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteNodePoolRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteNodePoolRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteNodePoolRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteNodePoolRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteNodePoolRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteNodePoolRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteNodePoolRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteNodePoolRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Lists machines in a site.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMachinesRequest {
    /// Required. The parent site, which owns this collection of machines.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMachinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMachinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMachinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMachinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMachinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMachinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMachinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMachinesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMachinesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMachinesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMachinesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMachinesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMachinesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMachinesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of machines in a site.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMachinesResponse {
    /// Machines in the site.
    pub machines: std::vec::Vec<crate::model::Machine>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMachinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machines][crate::model::ListMachinesResponse::machines].
    pub fn set_machines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Machine>,
    {
        use std::iter::Iterator;
        self.machines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMachinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMachinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMachinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMachinesResponse {
    type PageItem = crate::model::Machine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.machines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMachinesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machines,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMachinesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machines" => Ok(__FieldTag::__machines),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMachinesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMachinesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machines => {
                            if !fields.insert(__FieldTag::__machines) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machines",
                                ));
                            }
                            result.machines = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Machine>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMachinesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machines.is_empty() {
            state.serialize_entry("machines", &self.machines)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMachinesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMachinesResponse");
        debug_struct.field("machines", &self.machines);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets a machine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMachineRequest {
    /// Required. The resource name of the machine.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMachineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMachineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMachineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetMachineRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMachineRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMachineRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMachineRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMachineRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMachineRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMachineRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMachineRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Lists VPN connections.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpnConnectionsRequest {
    /// Required. The parent location, which owns this collection of VPN
    /// connections.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpnConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVpnConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVpnConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVpnConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVpnConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVpnConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVpnConnectionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpnConnectionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVpnConnectionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpnConnectionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVpnConnectionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVpnConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVpnConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// List of VPN connections in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpnConnectionsResponse {
    /// VpnConnections in the location.
    pub vpn_connections: std::vec::Vec<crate::model::VpnConnection>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpnConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpn_connections][crate::model::ListVpnConnectionsResponse::vpn_connections].
    pub fn set_vpn_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VpnConnection>,
    {
        use std::iter::Iterator;
        self.vpn_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVpnConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVpnConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVpnConnectionsResponse {
    type PageItem = crate::model::VpnConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vpn_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListVpnConnectionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vpn_connections,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListVpnConnectionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vpnConnections" => Ok(__FieldTag::__vpn_connections),
                            "vpn_connections" => Ok(__FieldTag::__vpn_connections),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListVpnConnectionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListVpnConnectionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vpn_connections => {
                            if !fields.insert(__FieldTag::__vpn_connections) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_connections",
                                ));
                            }
                            result.vpn_connections = map.next_value::<std::option::Option<std::vec::Vec<crate::model::VpnConnection>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListVpnConnectionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vpn_connections.is_empty() {
            state.serialize_entry("vpnConnections", &self.vpn_connections)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListVpnConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListVpnConnectionsResponse");
        debug_struct.field("vpn_connections", &self.vpn_connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets a VPN connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVpnConnectionRequest {
    /// Required. The resource name of the vpn connection.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetVpnConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetVpnConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetVpnConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetVpnConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetVpnConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetVpnConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetVpnConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetVpnConnectionRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Creates a VPN connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVpnConnectionRequest {
    /// Required. The parent location where this vpn connection will be created.
    pub parent: std::string::String,

    /// Required. The VPN connection identifier.
    pub vpn_connection_id: std::string::String,

    /// Required. The VPN connection to create.
    pub vpn_connection: std::option::Option<crate::model::VpnConnection>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVpnConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vpn_connection_id][crate::model::CreateVpnConnectionRequest::vpn_connection_id].
    pub fn set_vpn_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpn_connection_id = v.into();
        self
    }

    /// Sets the value of [vpn_connection][crate::model::CreateVpnConnectionRequest::vpn_connection].
    pub fn set_vpn_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VpnConnection>,
    {
        self.vpn_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpn_connection][crate::model::CreateVpnConnectionRequest::vpn_connection].
    pub fn set_or_clear_vpn_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VpnConnection>,
    {
        self.vpn_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateVpnConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateVpnConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __vpn_connection_id,
            __vpn_connection,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateVpnConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "vpnConnectionId" => Ok(__FieldTag::__vpn_connection_id),
                            "vpn_connection_id" => Ok(__FieldTag::__vpn_connection_id),
                            "vpnConnection" => Ok(__FieldTag::__vpn_connection),
                            "vpn_connection" => Ok(__FieldTag::__vpn_connection),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateVpnConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateVpnConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpn_connection_id => {
                            if !fields.insert(__FieldTag::__vpn_connection_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_connection_id",
                                ));
                            }
                            result.vpn_connection_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpn_connection => {
                            if !fields.insert(__FieldTag::__vpn_connection) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpn_connection",
                                ));
                            }
                            result.vpn_connection = map
                                .next_value::<std::option::Option<crate::model::VpnConnection>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateVpnConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.vpn_connection_id.is_empty() {
            state.serialize_entry("vpnConnectionId", &self.vpn_connection_id)?;
        }
        if self.vpn_connection.is_some() {
            state.serialize_entry("vpnConnection", &self.vpn_connection)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateVpnConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateVpnConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("vpn_connection_id", &self.vpn_connection_id);
        debug_struct.field("vpn_connection", &self.vpn_connection);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Deletes a vpn connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVpnConnectionRequest {
    /// Required. The resource name of the vpn connection.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteVpnConnectionRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteVpnConnectionRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteVpnConnectionRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteVpnConnectionRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteVpnConnectionRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteVpnConnectionRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteVpnConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteVpnConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Gets the server config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServerConfigRequest {
    /// Required. The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetServerConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetServerConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetServerConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetServerConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetServerConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetServerConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetServerConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetServerConfigRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the accessibility state of a customer-managed KMS key used for
/// CMEK integration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KmsKeyState {
    /// Unspecified.
    Unspecified,
    /// The key is available for use, and dependent resources should be accessible.
    KeyAvailable,
    /// The key is unavailable for an unspecified reason. Dependent resources may
    /// be inaccessible.
    KeyUnavailable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [KmsKeyState::value] or
    /// [KmsKeyState::name].
    UnknownValue(kms_key_state::UnknownValue),
}

#[doc(hidden)]
pub mod kms_key_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl KmsKeyState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::KeyAvailable => std::option::Option::Some(1),
            Self::KeyUnavailable => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("KMS_KEY_STATE_UNSPECIFIED"),
            Self::KeyAvailable => std::option::Option::Some("KMS_KEY_STATE_KEY_AVAILABLE"),
            Self::KeyUnavailable => std::option::Option::Some("KMS_KEY_STATE_KEY_UNAVAILABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for KmsKeyState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for KmsKeyState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for KmsKeyState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::KeyAvailable,
            2 => Self::KeyUnavailable,
            _ => Self::UnknownValue(kms_key_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for KmsKeyState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "KMS_KEY_STATE_UNSPECIFIED" => Self::Unspecified,
            "KMS_KEY_STATE_KEY_AVAILABLE" => Self::KeyAvailable,
            "KMS_KEY_STATE_KEY_UNAVAILABLE" => Self::KeyUnavailable,
            _ => Self::UnknownValue(kms_key_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for KmsKeyState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::KeyAvailable => serializer.serialize_i32(1),
            Self::KeyUnavailable => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for KmsKeyState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<KmsKeyState>::new(
            ".google.cloud.edgecontainer.v1.KmsKeyState",
        ))
    }
}

/// Represents if the resource is in lock down state or pending.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceState {
    /// Default value.
    Unspecified,
    /// The resource is in LOCK DOWN state.
    LockDown,
    /// The resource is pending lock down.
    LockDownPending,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceState::value] or
    /// [ResourceState::name].
    UnknownValue(resource_state::UnknownValue),
}

#[doc(hidden)]
pub mod resource_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LockDown => std::option::Option::Some(1),
            Self::LockDownPending => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_STATE_UNSPECIFIED"),
            Self::LockDown => std::option::Option::Some("RESOURCE_STATE_LOCK_DOWN"),
            Self::LockDownPending => std::option::Option::Some("RESOURCE_STATE_LOCK_DOWN_PENDING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LockDown,
            2 => Self::LockDownPending,
            _ => Self::UnknownValue(resource_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ResourceState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_STATE_UNSPECIFIED" => Self::Unspecified,
            "RESOURCE_STATE_LOCK_DOWN" => Self::LockDown,
            "RESOURCE_STATE_LOCK_DOWN_PENDING" => Self::LockDownPending,
            _ => Self::UnknownValue(resource_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ResourceState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LockDown => serializer.serialize_i32(1),
            Self::LockDownPending => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceState>::new(
            ".google.cloud.edgecontainer.v1.ResourceState",
        ))
    }
}
