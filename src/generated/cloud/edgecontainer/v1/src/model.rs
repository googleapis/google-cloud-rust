// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A Google Distributed Cloud Edge Kubernetes cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Cluster {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the cluster was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. Fleet configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Required. Cluster-wide networking configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub networking: std::option::Option<crate::model::ClusterNetworking>,

    /// Required. Immutable. RBAC policy that will be applied and managed by GEC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorization: std::option::Option<crate::model::Authorization>,

    /// Optional. The default maximum number of pods per node used if a maximum
    /// value is not specified explicitly for a node pool in this cluster. If
    /// unspecified, the Kubernetes default value will be used.
    pub default_max_pods_per_node: i32,

    /// Output only. The IP address of the Kubernetes API server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,

    /// Output only. The port number of the Kubernetes API server.
    pub port: i32,

    /// Output only. The PEM-encoded public certificate of the cluster's CA.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_ca_certificate: std::string::String,

    /// Optional. Cluster-wide maintenance policy configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Output only. The control plane release version
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub control_plane_version: std::string::String,

    /// Output only. The lowest release version among all worker nodes. This field
    /// can be empty if the cluster does not have any worker nodes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_version: std::string::String,

    /// Optional. The configuration of the cluster control plane.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control_plane: std::option::Option<crate::model::cluster::ControlPlane>,

    /// Optional. The configuration of the system add-ons.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub system_addons_config: std::option::Option<crate::model::cluster::SystemAddonsConfig>,

    /// Optional. IPv4 address pools for cluster data plane external load
    /// balancing.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_load_balancer_ipv4_address_pools: std::vec::Vec<std::string::String>,

    /// Optional. Remote control plane disk encryption options. This field is only
    /// used when enabling CMEK support.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub control_plane_encryption:
        std::option::Option<crate::model::cluster::ControlPlaneEncryption>,

    /// Output only. The current status of the cluster.
    pub status: crate::model::cluster::Status,

    /// Output only. All the maintenance events scheduled for the cluster,
    /// including the ones ongoing, planned for the future and done in the past (up
    /// to 90 days).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maintenance_events: std::vec::Vec<crate::model::cluster::MaintenanceEvent>,

    /// Optional. The target cluster version. For example: "1.5.0".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_version: std::string::String,

    /// Optional. The release channel a cluster is subscribed to.
    pub release_channel: crate::model::cluster::ReleaseChannel,

    /// Optional. Configuration of the cluster survivability, e.g., for the case
    /// when network connectivity is lost. Note: This only applies to local control
    /// plane clusters.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub survivability_config: std::option::Option<crate::model::cluster::SurvivabilityConfig>,

    /// Optional. IPv6 address pools for cluster data plane external load
    /// balancing.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub external_load_balancer_ipv6_address_pools: std::vec::Vec<std::string::String>,

    /// Output only. The current connection state of the cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection_state: std::option::Option<crate::model::cluster::ConnectionState>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_fleet<T: std::convert::Into<std::option::Option<crate::model::Fleet>>>(
        mut self,
        v: T,
    ) -> Self {
        self.fleet = v.into();
        self
    }

    /// Sets the value of [networking][crate::model::Cluster::networking].
    pub fn set_networking<
        T: std::convert::Into<std::option::Option<crate::model::ClusterNetworking>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.networking = v.into();
        self
    }

    /// Sets the value of [authorization][crate::model::Cluster::authorization].
    pub fn set_authorization<
        T: std::convert::Into<std::option::Option<crate::model::Authorization>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.authorization = v.into();
        self
    }

    /// Sets the value of [default_max_pods_per_node][crate::model::Cluster::default_max_pods_per_node].
    pub fn set_default_max_pods_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.default_max_pods_per_node = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Cluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Cluster::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::Cluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<
        T: std::convert::Into<std::option::Option<crate::model::MaintenancePolicy>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.maintenance_policy = v.into();
        self
    }

    /// Sets the value of [control_plane_version][crate::model::Cluster::control_plane_version].
    pub fn set_control_plane_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_version = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::Cluster::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::Cluster::control_plane].
    pub fn set_control_plane<
        T: std::convert::Into<std::option::Option<crate::model::cluster::ControlPlane>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane = v.into();
        self
    }

    /// Sets the value of [system_addons_config][crate::model::Cluster::system_addons_config].
    pub fn set_system_addons_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::SystemAddonsConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.system_addons_config = v.into();
        self
    }

    /// Sets the value of [control_plane_encryption][crate::model::Cluster::control_plane_encryption].
    pub fn set_control_plane_encryption<
        T: std::convert::Into<std::option::Option<crate::model::cluster::ControlPlaneEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_encryption = v.into();
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<crate::model::cluster::Status>>(
        mut self,
        v: T,
    ) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::Cluster::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_release_channel<T: std::convert::Into<crate::model::cluster::ReleaseChannel>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_channel = v.into();
        self
    }

    /// Sets the value of [survivability_config][crate::model::Cluster::survivability_config].
    pub fn set_survivability_config<
        T: std::convert::Into<std::option::Option<crate::model::cluster::SurvivabilityConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.survivability_config = v.into();
        self
    }

    /// Sets the value of [connection_state][crate::model::Cluster::connection_state].
    pub fn set_connection_state<
        T: std::convert::Into<std::option::Option<crate::model::cluster::ConnectionState>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_state = v.into();
        self
    }

    /// Sets the value of [external_load_balancer_ipv4_address_pools][crate::model::Cluster::external_load_balancer_ipv4_address_pools].
    pub fn set_external_load_balancer_ipv4_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv4_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [maintenance_events][crate::model::Cluster::maintenance_events].
    pub fn set_maintenance_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cluster::MaintenanceEvent>,
    {
        use std::iter::Iterator;
        self.maintenance_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [external_load_balancer_ipv6_address_pools][crate::model::Cluster::external_load_balancer_ipv6_address_pools].
    pub fn set_external_load_balancer_ipv6_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv6_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster"
    }
}

/// Defines additional types related to Cluster
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration of the cluster control plane.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ControlPlane {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub config: std::option::Option<crate::model::cluster::control_plane::Config>,
    }

    impl ControlPlane {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `config`.
        pub fn set_config<
            T: std::convert::Into<std::option::Option<crate::model::cluster::control_plane::Config>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = v.into();
            self
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Remote`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_remote(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Remote>>
        {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Remote(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Local`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_local(
            &self,
        ) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Local>>
        {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Local(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Remote`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_remote<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Remote>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Remote(v.into()),
            );
            self
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Local`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_local<
            T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Local>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Local(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for ControlPlane {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane"
        }
    }

    /// Defines additional types related to ControlPlane
    pub mod control_plane {
        #[allow(unused_imports)]
        use super::*;

        /// Configuration specific to clusters with a control plane hosted remotely.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Remote {}

        impl Remote {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Remote {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Remote"
            }
        }

        /// Configuration specific to clusters with a control plane hosted locally.
        ///
        /// Warning: Local control plane clusters must be created in their own
        /// project. Local control plane clusters cannot coexist in the same
        /// project with any other type of clusters, including non-GDCE clusters.
        /// Mixing local control plane GDCE clusters with any other type of
        /// clusters in the same project can result in data loss.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Local {
            /// Name of the Google Distributed Cloud Edge zones where this node pool
            /// will be created. For example: `us-central1-edge-customer-a`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub node_location: std::string::String,

            /// The number of nodes to serve as replicas of the Control Plane.
            pub node_count: i32,

            /// Only machines matching this filter will be allowed to host control
            /// plane nodes. The filtering language accepts strings like "name=\<name\>",
            /// and is documented here: [AIP-160](https://google.aip.dev/160).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub machine_filter: std::string::String,

            /// Policy configuration about how user applications are deployed.
            pub shared_deployment_policy:
                crate::model::cluster::control_plane::SharedDeploymentPolicy,

            /// Optional. Name for the storage schema of control plane nodes.
            ///
            /// Warning: Configurable node local storage schema feature is an
            /// experimental feature, and is not recommended for general use
            /// in production clusters/nodepools.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub control_plane_node_storage_schema: std::string::String,
        }

        impl Local {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [node_location][crate::model::cluster::control_plane::Local::node_location].
            pub fn set_node_location<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.node_location = v.into();
                self
            }

            /// Sets the value of [node_count][crate::model::cluster::control_plane::Local::node_count].
            pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.node_count = v.into();
                self
            }

            /// Sets the value of [machine_filter][crate::model::cluster::control_plane::Local::machine_filter].
            pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.machine_filter = v.into();
                self
            }

            /// Sets the value of [shared_deployment_policy][crate::model::cluster::control_plane::Local::shared_deployment_policy].
            pub fn set_shared_deployment_policy<
                T: std::convert::Into<crate::model::cluster::control_plane::SharedDeploymentPolicy>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.shared_deployment_policy = v.into();
                self
            }

            /// Sets the value of [control_plane_node_storage_schema][crate::model::cluster::control_plane::Local::control_plane_node_storage_schema].
            pub fn set_control_plane_node_storage_schema<
                T: std::convert::Into<std::string::String>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.control_plane_node_storage_schema = v.into();
                self
            }
        }

        impl wkt::message::Message for Local {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Local"
            }
        }

        /// Represents the policy configuration about how user applications are
        /// deployed.
        #[derive(Clone, Debug, PartialEq)]
        pub struct SharedDeploymentPolicy(wkt::enumerations::Enumeration);

        /// Useful constants to work with [SharedDeploymentPolicy](SharedDeploymentPolicy)
        pub mod shared_deployment_policy {
            use super::SharedDeploymentPolicy;

            /// Unspecified.
            pub const SHARED_DEPLOYMENT_POLICY_UNSPECIFIED: SharedDeploymentPolicy =
                SharedDeploymentPolicy::known("SHARED_DEPLOYMENT_POLICY_UNSPECIFIED", 0);

            /// User applications can be deployed both on control plane and worker
            /// nodes.
            pub const ALLOWED: SharedDeploymentPolicy = SharedDeploymentPolicy::known("ALLOWED", 1);

            /// User applications can not be deployed on control plane nodes and can
            /// only be deployed on worker nodes.
            pub const DISALLOWED: SharedDeploymentPolicy =
                SharedDeploymentPolicy::known("DISALLOWED", 2);
        }

        impl SharedDeploymentPolicy {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for SharedDeploymentPolicy {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SharedDeploymentPolicy {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(SharedDeploymentPolicy::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => {
                        Ok(SharedDeploymentPolicy::from(val))
                    }
                    Enumeration::UnknownNum { str } => Ok(SharedDeploymentPolicy::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for SharedDeploymentPolicy {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED" => {
                        shared_deployment_policy::SHARED_DEPLOYMENT_POLICY_UNSPECIFIED
                    }
                    "ALLOWED" => shared_deployment_policy::ALLOWED,
                    "DISALLOWED" => shared_deployment_policy::DISALLOWED,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for SharedDeploymentPolicy {
            fn from(value: i32) -> Self {
                match value {
                    0 => shared_deployment_policy::SHARED_DEPLOYMENT_POLICY_UNSPECIFIED,
                    1 => shared_deployment_policy::ALLOWED,
                    2 => shared_deployment_policy::DISALLOWED,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for SharedDeploymentPolicy {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Config {
            /// Remote control plane configuration.
            Remote(std::boxed::Box<crate::model::cluster::control_plane::Remote>),
            /// Local control plane configuration.
            ///
            /// Warning: Local control plane clusters must be created in their own
            /// project. Local control plane clusters cannot coexist in the same
            /// project with any other type of clusters, including non-GDCE clusters.
            /// Mixing local control plane GDCE clusters with any other type of
            /// clusters in the same project can result in data loss.
            Local(std::boxed::Box<crate::model::cluster::control_plane::Local>),
        }
    }

    /// Config that customers are allowed to define for GDCE system add-ons.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SystemAddonsConfig {
        /// Optional. Config for Ingress.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub ingress: std::option::Option<crate::model::cluster::system_addons_config::Ingress>,

        /// Optional. Config for VM Service.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub vm_service_config:
            std::option::Option<crate::model::cluster::system_addons_config::VMServiceConfig>,
    }

    impl SystemAddonsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ingress][crate::model::cluster::SystemAddonsConfig::ingress].
        pub fn set_ingress<
            T: std::convert::Into<
                std::option::Option<crate::model::cluster::system_addons_config::Ingress>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.ingress = v.into();
            self
        }

        /// Sets the value of [vm_service_config][crate::model::cluster::SystemAddonsConfig::vm_service_config].
        pub fn set_vm_service_config<
            T: std::convert::Into<
                std::option::Option<crate::model::cluster::system_addons_config::VMServiceConfig>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.vm_service_config = v.into();
            self
        }
    }

    impl wkt::message::Message for SystemAddonsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig"
        }
    }

    /// Defines additional types related to SystemAddonsConfig
    pub mod system_addons_config {
        #[allow(unused_imports)]
        use super::*;

        /// Config for the Ingress add-on which allows customers to create an Ingress
        /// object to manage external access to the servers in a cluster. The add-on
        /// consists of istiod and istio-ingress.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Ingress {
            /// Optional. Whether Ingress is disabled.
            pub disabled: bool,

            /// Optional. Ingress VIP.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub ipv4_vip: std::string::String,
        }

        impl Ingress {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disabled][crate::model::cluster::system_addons_config::Ingress::disabled].
            pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disabled = v.into();
                self
            }

            /// Sets the value of [ipv4_vip][crate::model::cluster::system_addons_config::Ingress::ipv4_vip].
            pub fn set_ipv4_vip<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.ipv4_vip = v.into();
                self
            }
        }

        impl wkt::message::Message for Ingress {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.Ingress"
            }
        }

        /// VMServiceConfig defines the configuration for GDCE VM Service.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct VMServiceConfig {
            /// Optional. Whether VMM is enabled.
            pub vmm_enabled: bool,
        }

        impl VMServiceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [vmm_enabled][crate::model::cluster::system_addons_config::VMServiceConfig::vmm_enabled].
            pub fn set_vmm_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.vmm_enabled = v.into();
                self
            }
        }

        impl wkt::message::Message for VMServiceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.VMServiceConfig"
            }
        }
    }

    /// Configuration for Customer-managed KMS key support for control plane nodes.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ControlPlaneEncryption {
        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting control plane disks. If not specified, a
        /// Google-managed key will be used instead.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting control plane disks. Only applicable if kms_key is set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,
    }

    impl ControlPlaneEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::cluster::ControlPlaneEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::cluster::ControlPlaneEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::cluster::ControlPlaneEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::cluster::ControlPlaneEncryption::kms_status].
        pub fn set_kms_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_status = v.into();
            self
        }

        /// Sets the value of [resource_state][crate::model::cluster::ControlPlaneEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for ControlPlaneEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlaneEncryption"
        }
    }

    /// A Maintenance Event is an operation that could cause temporary disruptions
    /// to the cluster workloads, including Google-driven or user-initiated cluster
    /// upgrades, user-initiated cluster configuration changes that require
    /// restarting nodes, etc.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct MaintenanceEvent {
        /// Output only. UUID of the maintenance event.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub uuid: std::string::String,

        /// Output only. The target version of the cluster.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub target_version: std::string::String,

        /// Output only. The operation for running the maintenance event. Specified
        /// in the format projects/*/locations/*/operations/*. If the maintenance
        /// event is split into multiple operations (e.g. due to maintenance
        /// windows), the latest one is recorded.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub operation: std::string::String,

        /// Output only. The type of the maintenance event.
        #[serde(rename = "type")]
        pub r#type: crate::model::cluster::maintenance_event::Type,

        /// Output only. The schedule of the maintenance event.
        pub schedule: crate::model::cluster::maintenance_event::Schedule,

        /// Output only. The state of the maintenance event.
        pub state: crate::model::cluster::maintenance_event::State,

        /// Output only. The time when the maintenance event request was created.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event started.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event ended, either
        /// successfully or not. If the maintenance event is split into multiple
        /// maintenance windows, end_time is only updated when the whole flow ends.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event message was updated.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,
    }

    impl MaintenanceEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uuid][crate::model::cluster::MaintenanceEvent::uuid].
        pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uuid = v.into();
            self
        }

        /// Sets the value of [target_version][crate::model::cluster::MaintenanceEvent::target_version].
        pub fn set_target_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.target_version = v.into();
            self
        }

        /// Sets the value of [operation][crate::model::cluster::MaintenanceEvent::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cluster::MaintenanceEvent::type].
        pub fn set_type<T: std::convert::Into<crate::model::cluster::maintenance_event::Type>>(
            mut self,
            v: T,
        ) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [schedule][crate::model::cluster::MaintenanceEvent::schedule].
        pub fn set_schedule<
            T: std::convert::Into<crate::model::cluster::maintenance_event::Schedule>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.schedule = v.into();
            self
        }

        /// Sets the value of [state][crate::model::cluster::MaintenanceEvent::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::maintenance_event::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::cluster::MaintenanceEvent::create_time].
        pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.create_time = v.into();
            self
        }

        /// Sets the value of [start_time][crate::model::cluster::MaintenanceEvent::start_time].
        pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.start_time = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::MaintenanceEvent::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::MaintenanceEvent::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for MaintenanceEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent"
        }
    }

    /// Defines additional types related to MaintenanceEvent
    pub mod maintenance_event {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the maintenance event type.
        #[derive(Clone, Debug, PartialEq)]
        pub struct Type(wkt::enumerations::Enumeration);

        /// Useful constants to work with [Type](Type)
        pub mod r#type {
            use super::Type;

            /// Unspecified.
            pub const TYPE_UNSPECIFIED: Type = Type::known("TYPE_UNSPECIFIED", 0);

            /// Upgrade initiated by users.
            pub const USER_INITIATED_UPGRADE: Type = Type::known("USER_INITIATED_UPGRADE", 1);

            /// Upgrade driven by Google.
            pub const GOOGLE_DRIVEN_UPGRADE: Type = Type::known("GOOGLE_DRIVEN_UPGRADE", 2);
        }

        impl Type {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(Type::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(Type::from(val)),
                    Enumeration::UnknownNum { str } => Ok(Type::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for Type {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "TYPE_UNSPECIFIED" => r#type::TYPE_UNSPECIFIED,
                    "USER_INITIATED_UPGRADE" => r#type::USER_INITIATED_UPGRADE,
                    "GOOGLE_DRIVEN_UPGRADE" => r#type::GOOGLE_DRIVEN_UPGRADE,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => r#type::TYPE_UNSPECIFIED,
                    1 => r#type::USER_INITIATED_UPGRADE,
                    2 => r#type::GOOGLE_DRIVEN_UPGRADE,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }

        /// Indicates when the maintenance event should be performed.
        #[derive(Clone, Debug, PartialEq)]
        pub struct Schedule(wkt::enumerations::Enumeration);

        /// Useful constants to work with [Schedule](Schedule)
        pub mod schedule {
            use super::Schedule;

            /// Unspecified.
            pub const SCHEDULE_UNSPECIFIED: Schedule = Schedule::known("SCHEDULE_UNSPECIFIED", 0);

            /// Immediately after receiving the request.
            pub const IMMEDIATELY: Schedule = Schedule::known("IMMEDIATELY", 1);
        }

        impl Schedule {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for Schedule {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Schedule {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(Schedule::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(Schedule::from(val)),
                    Enumeration::UnknownNum { str } => Ok(Schedule::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for Schedule {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "SCHEDULE_UNSPECIFIED" => schedule::SCHEDULE_UNSPECIFIED,
                    "IMMEDIATELY" => schedule::IMMEDIATELY,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for Schedule {
            fn from(value: i32) -> Self {
                match value {
                    0 => schedule::SCHEDULE_UNSPECIFIED,
                    1 => schedule::IMMEDIATELY,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for Schedule {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }

        /// Indicates the maintenance event state.
        #[derive(Clone, Debug, PartialEq)]
        pub struct State(wkt::enumerations::Enumeration);

        /// Useful constants to work with [State](State)
        pub mod state {
            use super::State;

            /// Unspecified.
            pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

            /// The maintenance event is ongoing. The cluster might be unusable.
            pub const RECONCILING: State = State::known("RECONCILING", 1);

            /// The maintenance event succeeded.
            pub const SUCCEEDED: State = State::known("SUCCEEDED", 2);

            /// The maintenance event failed.
            pub const FAILED: State = State::known("FAILED", 3);
        }

        impl State {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(State::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                    Enumeration::UnknownNum { str } => Ok(State::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for State {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                    "RECONCILING" => state::RECONCILING,
                    "SUCCEEDED" => state::SUCCEEDED,
                    "FAILED" => state::FAILED,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => state::STATE_UNSPECIFIED,
                    1 => state::RECONCILING,
                    2 => state::SUCCEEDED,
                    3 => state::FAILED,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }
    }

    /// Configuration of the cluster survivability, e.g., for the case when network
    /// connectivity is lost.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct SurvivabilityConfig {
        /// Optional. Time period that allows the cluster nodes to be rebooted and
        /// become functional without network connectivity to Google. The default 0
        /// means not allowed. The maximum is 7 days.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub offline_reboot_ttl: std::option::Option<wkt::Duration>,
    }

    impl SurvivabilityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offline_reboot_ttl][crate::model::cluster::SurvivabilityConfig::offline_reboot_ttl].
        pub fn set_offline_reboot_ttl<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
            mut self,
            v: T,
        ) -> Self {
            self.offline_reboot_ttl = v.into();
            self
        }
    }

    impl wkt::message::Message for SurvivabilityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SurvivabilityConfig"
        }
    }

    /// ConnectionState holds the current connection state from the cluster to
    /// Google.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ConnectionState {
        /// Output only. The current connection state.
        pub state: crate::model::cluster::connection_state::State,

        /// Output only. The time when the connection state was last changed.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub update_time: std::option::Option<wkt::Timestamp>,
    }

    impl ConnectionState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::cluster::ConnectionState::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::connection_state::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::ConnectionState::update_time].
        pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.update_time = v.into();
            self
        }
    }

    impl wkt::message::Message for ConnectionState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ConnectionState"
        }
    }

    /// Defines additional types related to ConnectionState
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;

        /// The connection state.
        #[derive(Clone, Debug, PartialEq)]
        pub struct State(wkt::enumerations::Enumeration);

        /// Useful constants to work with [State](State)
        pub mod state {
            use super::State;

            /// Unknown connection state.
            pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

            /// This cluster is currently disconnected from Google.
            pub const DISCONNECTED: State = State::known("DISCONNECTED", 1);

            /// This cluster is currently connected to Google.
            pub const CONNECTED: State = State::known("CONNECTED", 2);

            /// This cluster is currently connected to Google, but may have recently
            /// reconnected after a disconnection. It is still syncing back.
            pub const CONNECTED_AND_SYNCING: State = State::known("CONNECTED_AND_SYNCING", 3);
        }

        impl State {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(State::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                    Enumeration::UnknownNum { str } => Ok(State::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for State {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                    "DISCONNECTED" => state::DISCONNECTED,
                    "CONNECTED" => state::CONNECTED,
                    "CONNECTED_AND_SYNCING" => state::CONNECTED_AND_SYNCING,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => state::STATE_UNSPECIFIED,
                    1 => state::DISCONNECTED,
                    2 => state::CONNECTED,
                    3 => state::CONNECTED_AND_SYNCING,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }
    }

    /// Indicates the status of the cluster.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Status(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Status](Status)
    pub mod status {
        use super::Status;

        /// Status unknown.
        pub const STATUS_UNSPECIFIED: Status = Status::known("STATUS_UNSPECIFIED", 0);

        /// The cluster is being created.
        pub const PROVISIONING: Status = Status::known("PROVISIONING", 1);

        /// The cluster is created and fully usable.
        pub const RUNNING: Status = Status::known("RUNNING", 2);

        /// The cluster is being deleted.
        pub const DELETING: Status = Status::known("DELETING", 3);

        /// The status indicates that some errors occurred while reconciling/deleting
        /// the cluster.
        pub const ERROR: Status = Status::known("ERROR", 4);

        /// The cluster is undergoing some work such as version upgrades, etc.
        pub const RECONCILING: Status = Status::known("RECONCILING", 5);
    }

    impl Status {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Status::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Status::from(val)),
                Enumeration::UnknownNum { str } => Ok(Status::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Status {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATUS_UNSPECIFIED" => status::STATUS_UNSPECIFIED,
                "PROVISIONING" => status::PROVISIONING,
                "RUNNING" => status::RUNNING,
                "DELETING" => status::DELETING,
                "ERROR" => status::ERROR,
                "RECONCILING" => status::RECONCILING,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => status::STATUS_UNSPECIFIED,
                1 => status::PROVISIONING,
                2 => status::RUNNING,
                3 => status::DELETING,
                4 => status::ERROR,
                5 => status::RECONCILING,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The release channel a cluster is subscribed to.
    #[derive(Clone, Debug, PartialEq)]
    pub struct ReleaseChannel(wkt::enumerations::Enumeration);

    /// Useful constants to work with [ReleaseChannel](ReleaseChannel)
    pub mod release_channel {
        use super::ReleaseChannel;

        /// Unspecified release channel. This will default to the REGULAR channel.
        pub const RELEASE_CHANNEL_UNSPECIFIED: ReleaseChannel =
            ReleaseChannel::known("RELEASE_CHANNEL_UNSPECIFIED", 0);

        /// No release channel.
        pub const NONE: ReleaseChannel = ReleaseChannel::known("NONE", 1);

        /// Regular release channel.
        pub const REGULAR: ReleaseChannel = ReleaseChannel::known("REGULAR", 2);
    }

    impl ReleaseChannel {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for ReleaseChannel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReleaseChannel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(ReleaseChannel::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(ReleaseChannel::from(val)),
                Enumeration::UnknownNum { str } => Ok(ReleaseChannel::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for ReleaseChannel {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "RELEASE_CHANNEL_UNSPECIFIED" => release_channel::RELEASE_CHANNEL_UNSPECIFIED,
                "NONE" => release_channel::NONE,
                "REGULAR" => release_channel::REGULAR,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for ReleaseChannel {
        fn from(value: i32) -> Self {
            match value {
                0 => release_channel::RELEASE_CHANNEL_UNSPECIFIED,
                1 => release_channel::NONE,
                2 => release_channel::REGULAR,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for ReleaseChannel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Cluster-wide networking configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterNetworking {
    /// Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
    /// these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cluster_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. All services in the cluster are assigned an RFC1918 IPv4 address
    /// from these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub services_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,
}

impl ClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_ipv4_cidr_blocks][crate::model::ClusterNetworking::cluster_ipv4_cidr_blocks].
    pub fn set_cluster_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.cluster_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services_ipv4_cidr_blocks][crate::model::ClusterNetworking::services_ipv4_cidr_blocks].
    pub fn set_services_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.services_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterNetworking"
    }
}

/// Fleet related configuration.
///
/// Fleets are a Google Cloud concept for logically organizing clusters,
/// letting you use and manage multi-cluster capabilities and apply
/// consistent policies across your systems.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Fleet {
    /// Required. The name of the Fleet host project where this cluster will be
    /// registered.
    ///
    /// Project names are formatted as
    /// `projects/<project-number>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// Output only. The name of the managed Hub Membership resource associated to
    /// this cluster.
    ///
    /// Membership names are formatted as
    /// `projects/<project-number>/locations/global/membership/<cluster-id>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub membership: std::string::String,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Fleet"
    }
}

/// A user principal for an RBAC policy.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ClusterUser {
    /// Required. An active Google username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,
}

impl ClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::ClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for ClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterUser"
    }
}

/// RBAC policy that will be applied and managed by GEC.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Authorization {
    /// Required. User that will be granted the cluster-admin role on the cluster,
    /// providing full access to the cluster. Currently, this is a singular field,
    /// but will be expanded to allow multiple admins in the future.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub admin_users: std::option::Option<crate::model::ClusterUser>,
}

impl Authorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::Authorization::admin_users].
    pub fn set_admin_users<
        T: std::convert::Into<std::option::Option<crate::model::ClusterUser>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.admin_users = v.into();
        self
    }
}

impl wkt::message::Message for Authorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Authorization"
    }
}

/// A set of Kubernetes nodes in a cluster with common configuration and
/// specification.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NodePool {
    /// Required. The resource name of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Name of the Google Distributed Cloud Edge zone where this node pool will be
    /// created. For example: `us-central1-edge-customer-a`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_location: std::string::String,

    /// Required. The number of nodes in the pool.
    pub node_count: i32,

    /// Only machines matching this filter will be allowed to join the node pool.
    /// The filtering language accepts strings like "name=\<name\>", and is
    /// documented in more detail in [AIP-160](https://google.aip.dev/160).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_filter: std::string::String,

    /// Optional. Local disk encryption options. This field is only used when
    /// enabling CMEK support.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub local_disk_encryption: std::option::Option<crate::model::node_pool::LocalDiskEncryption>,

    /// Output only. The lowest release version among all worker nodes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_version: std::string::String,

    /// Optional. Configuration for each node in the NodePool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_config: std::option::Option<crate::model::node_pool::NodeConfig>,
}

impl NodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NodePool::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::NodePool::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [node_location][crate::model::NodePool::node_location].
    pub fn set_node_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_location = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::NodePool::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [machine_filter][crate::model::NodePool::machine_filter].
    pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_filter = v.into();
        self
    }

    /// Sets the value of [local_disk_encryption][crate::model::NodePool::local_disk_encryption].
    pub fn set_local_disk_encryption<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::LocalDiskEncryption>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.local_disk_encryption = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::NodePool::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::NodePool::node_config].
    pub fn set_node_config<
        T: std::convert::Into<std::option::Option<crate::model::node_pool::NodeConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.node_config = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::NodePool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for NodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool"
    }
}

/// Defines additional types related to NodePool
pub mod node_pool {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for CMEK support for edge machine local disk encryption.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct LocalDiskEncryption {
        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting node local disks. If not specified, a
        /// Google-managed key will be used instead.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting node local disks. Only applicable if kms_key is set.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,
    }

    impl LocalDiskEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::node_pool::LocalDiskEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::node_pool::LocalDiskEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::node_pool::LocalDiskEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::node_pool::LocalDiskEncryption::kms_status].
        pub fn set_kms_status<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_status = v.into();
            self
        }

        /// Sets the value of [resource_state][crate::model::node_pool::LocalDiskEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for LocalDiskEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.LocalDiskEncryption"
        }
    }

    /// Configuration for each node in the NodePool
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct NodeConfig {
        /// Optional. The Kubernetes node labels
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub labels: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. Name for the storage schema of worker nodes.
        ///
        /// Warning: Configurable node local storage schema feature is an
        /// experimental feature, and is not recommended for general use
        /// in production clusters/nodepools.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub node_storage_schema: std::string::String,
    }

    impl NodeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [node_storage_schema][crate::model::node_pool::NodeConfig::node_storage_schema].
        pub fn set_node_storage_schema<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.node_storage_schema = v.into();
            self
        }

        /// Sets the value of [labels][crate::model::node_pool::NodeConfig::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for NodeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.NodeConfig"
        }
    }
}

/// A Google Distributed Cloud Edge machine capable of acting as a Kubernetes
/// node.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Machine {
    /// Required. The resource name of the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Canonical resource name of the node that this machine is responsible for
    /// hosting e.g.
    /// projects/{project}/locations/{location}/clusters/{cluster_id}/nodePools/{pool_id}/{node},
    /// Or empty if the machine is not assigned to assume the role of a node.
    ///
    /// For control plane nodes hosted on edge machines, this will return
    /// the following format:
    /// "projects/{project}/locations/{location}/clusters/{cluster_id}/controlPlaneNodes/{node}".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hosted_node: std::string::String,

    /// The Google Distributed Cloud Edge zone of this machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// Output only. The software version of the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. Whether the machine is disabled. If disabled, the machine is
    /// unable to enter service.
    pub disabled: bool,
}

impl Machine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Machine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Machine::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Machine::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [hosted_node][crate::model::Machine::hosted_node].
    pub fn set_hosted_node<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hosted_node = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Machine::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Machine::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::Machine::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Machine::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Machine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Machine"
    }
}

/// A VPN connection .
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VpnConnection {
    /// Required. The resource name of VPN connection
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The time when the VPN connection was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the VPN connection was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// NAT gateway IP, or WAN IP address. If a customer has multiple NAT IPs, the
    /// customer needs to configure NAT such that only one external IP maps to the
    /// GMEC Anthos cluster. This is empty if NAT is not used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub nat_gateway_ip: std::string::String,

    /// Dynamic routing mode of the VPC network, `regional` or `global`.
    pub bgp_routing_mode: crate::model::vpn_connection::BgpRoutingMode,

    /// The canonical Cluster name to connect to. It is in the form of
    /// projects/{project}/locations/{location}/clusters/{cluster}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,

    /// The network ID of VPC to connect to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc: std::string::String,

    /// Optional. Project detail of the VPC network. Required if VPC is in a
    /// different project than the cluster project.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpc_project: std::option::Option<crate::model::vpn_connection::VpcProject>,

    /// Whether this VPN connection has HA enabled on cluster side. If enabled,
    /// when creating VPN connection we will attempt to use 2 ANG floating IPs.
    pub enable_high_availability: bool,

    /// Optional. The VPN connection Cloud Router name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub router: std::string::String,

    /// Output only. The created connection details.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub details: std::option::Option<crate::model::vpn_connection::Details>,
}

impl VpnConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpnConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VpnConnection::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::VpnConnection::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [nat_gateway_ip][crate::model::VpnConnection::nat_gateway_ip].
    pub fn set_nat_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nat_gateway_ip = v.into();
        self
    }

    /// Sets the value of [bgp_routing_mode][crate::model::VpnConnection::bgp_routing_mode].
    pub fn set_bgp_routing_mode<
        T: std::convert::Into<crate::model::vpn_connection::BgpRoutingMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.bgp_routing_mode = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::VpnConnection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::VpnConnection::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }

    /// Sets the value of [vpc_project][crate::model::VpnConnection::vpc_project].
    pub fn set_vpc_project<
        T: std::convert::Into<std::option::Option<crate::model::vpn_connection::VpcProject>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpc_project = v.into();
        self
    }

    /// Sets the value of [enable_high_availability][crate::model::VpnConnection::enable_high_availability].
    pub fn set_enable_high_availability<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_high_availability = v.into();
        self
    }

    /// Sets the value of [router][crate::model::VpnConnection::router].
    pub fn set_router<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.router = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VpnConnection::details].
    pub fn set_details<
        T: std::convert::Into<std::option::Option<crate::model::vpn_connection::Details>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.details = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::VpnConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for VpnConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection"
    }
}

/// Defines additional types related to VpnConnection
pub mod vpn_connection {
    #[allow(unused_imports)]
    use super::*;

    /// Project detail of the VPC network.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct VpcProject {
        /// The project of the VPC to connect to. If not specified, it is the same as
        /// the cluster project.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub project_id: std::string::String,

        /// Optional. Deprecated: do not use.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_account: std::string::String,
    }

    impl VpcProject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::vpn_connection::VpcProject::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [service_account][crate::model::vpn_connection::VpcProject::service_account].
        pub fn set_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for VpcProject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.VpcProject"
        }
    }

    /// The created connection details.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Details {
        /// The state of this connection.
        pub state: crate::model::vpn_connection::details::State,

        /// The error message. This is only populated when state=ERROR.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub error: std::string::String,

        /// The Cloud Router info.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub cloud_router: std::option::Option<crate::model::vpn_connection::details::CloudRouter>,

        /// Each connection has multiple Cloud VPN gateways.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub cloud_vpns: std::vec::Vec<crate::model::vpn_connection::details::CloudVpn>,
    }

    impl Details {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::vpn_connection::Details::state].
        pub fn set_state<T: std::convert::Into<crate::model::vpn_connection::details::State>>(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::vpn_connection::Details::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }

        /// Sets the value of [cloud_router][crate::model::vpn_connection::Details::cloud_router].
        pub fn set_cloud_router<
            T: std::convert::Into<
                std::option::Option<crate::model::vpn_connection::details::CloudRouter>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.cloud_router = v.into();
            self
        }

        /// Sets the value of [cloud_vpns][crate::model::vpn_connection::Details::cloud_vpns].
        pub fn set_cloud_vpns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vpn_connection::details::CloudVpn>,
        {
            use std::iter::Iterator;
            self.cloud_vpns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Details {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details"
        }
    }

    /// Defines additional types related to Details
    pub mod details {
        #[allow(unused_imports)]
        use super::*;

        /// The Cloud Router info.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CloudRouter {
            /// The associated Cloud Router name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub name: std::string::String,
        }

        impl CloudRouter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vpn_connection::details::CloudRouter::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudRouter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudRouter"
            }
        }

        /// The Cloud VPN info.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct CloudVpn {
            /// The created Cloud VPN gateway name.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub gateway: std::string::String,
        }

        impl CloudVpn {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gateway][crate::model::vpn_connection::details::CloudVpn::gateway].
            pub fn set_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.gateway = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudVpn {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudVpn"
            }
        }

        /// The current connection state.
        #[derive(Clone, Debug, PartialEq)]
        pub struct State(wkt::enumerations::Enumeration);

        /// Useful constants to work with [State](State)
        pub mod state {
            use super::State;

            /// Unknown.
            pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

            /// Connected.
            pub const STATE_CONNECTED: State = State::known("STATE_CONNECTED", 1);

            /// Still connecting.
            pub const STATE_CONNECTING: State = State::known("STATE_CONNECTING", 2);

            /// Error occurred.
            pub const STATE_ERROR: State = State::known("STATE_ERROR", 3);
        }

        impl State {
            pub(crate) const fn known(str: &'static str, val: i32) -> Self {
                Self(wkt::enumerations::Enumeration::known(str, val))
            }

            /// Gets the enum value.
            pub fn value(&self) -> &str {
                self.0.value()
            }

            /// Gets the numeric value of the enum (if available).
            pub fn numeric_value(&self) -> std::option::Option<i32> {
                self.0.numeric_value()
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                self.0.serialize(serializer)
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                use std::convert::From;
                use std::result::Result::Ok;
                use wkt::enumerations::Enumeration;
                match Enumeration::deserialize(deserializer)? {
                    Enumeration::Known { str: _, val } => Ok(State::from(val)),
                    Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                    Enumeration::UnknownNum { str } => Ok(State::from(str)),
                }
            }
        }

        impl std::convert::From<std::string::String> for State {
            fn from(value: std::string::String) -> Self {
                match value.as_str() {
                    "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                    "STATE_CONNECTED" => state::STATE_CONNECTED,
                    "STATE_CONNECTING" => state::STATE_CONNECTING,
                    "STATE_ERROR" => state::STATE_ERROR,
                    _ => Self(wkt::enumerations::Enumeration::known_str(value)),
                }
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => state::STATE_UNSPECIFIED,
                    1 => state::STATE_CONNECTED,
                    2 => state::STATE_CONNECTING,
                    3 => state::STATE_ERROR,
                    _ => Self(wkt::enumerations::Enumeration::known_num(value)),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0_i32)
            }
        }
    }

    /// Routing mode.
    #[derive(Clone, Debug, PartialEq)]
    pub struct BgpRoutingMode(wkt::enumerations::Enumeration);

    /// Useful constants to work with [BgpRoutingMode](BgpRoutingMode)
    pub mod bgp_routing_mode {
        use super::BgpRoutingMode;

        /// Unknown.
        pub const BGP_ROUTING_MODE_UNSPECIFIED: BgpRoutingMode =
            BgpRoutingMode::known("BGP_ROUTING_MODE_UNSPECIFIED", 0);

        /// Regional mode.
        pub const REGIONAL: BgpRoutingMode = BgpRoutingMode::known("REGIONAL", 1);

        /// Global mode.
        pub const GLOBAL: BgpRoutingMode = BgpRoutingMode::known("GLOBAL", 2);
    }

    impl BgpRoutingMode {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for BgpRoutingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BgpRoutingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(BgpRoutingMode::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(BgpRoutingMode::from(val)),
                Enumeration::UnknownNum { str } => Ok(BgpRoutingMode::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for BgpRoutingMode {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "BGP_ROUTING_MODE_UNSPECIFIED" => bgp_routing_mode::BGP_ROUTING_MODE_UNSPECIFIED,
                "REGIONAL" => bgp_routing_mode::REGIONAL,
                "GLOBAL" => bgp_routing_mode::GLOBAL,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for BgpRoutingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => bgp_routing_mode::BGP_ROUTING_MODE_UNSPECIFIED,
                1 => bgp_routing_mode::REGIONAL,
                2 => bgp_routing_mode::GLOBAL,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for BgpRoutingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Metadata for a given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LocationMetadata {
    /// The set of available Google Distributed Cloud Edge zones in the location.
    /// The map is keyed by the lowercase ID of each zone.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub available_zones: std::collections::HashMap<std::string::String, crate::model::ZoneMetadata>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_zones][crate::model::LocationMetadata::available_zones].
    pub fn set_available_zones<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ZoneMetadata>,
    {
        use std::iter::Iterator;
        self.available_zones = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.LocationMetadata"
    }
}

/// A Google Distributed Cloud Edge zone where edge machines are located.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ZoneMetadata {
    /// Quota for resources in this zone.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub quota: std::vec::Vec<crate::model::Quota>,

    /// The map keyed by rack name and has value of RackType.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub rack_types:
        std::collections::HashMap<std::string::String, crate::model::zone_metadata::RackType>,

    /// Config data for the zone.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub config_data: std::option::Option<crate::model::ConfigData>,
}

impl ZoneMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config_data][crate::model::ZoneMetadata::config_data].
    pub fn set_config_data<T: std::convert::Into<std::option::Option<crate::model::ConfigData>>>(
        mut self,
        v: T,
    ) -> Self {
        self.config_data = v.into();
        self
    }

    /// Sets the value of [quota][crate::model::ZoneMetadata::quota].
    pub fn set_quota<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Quota>,
    {
        use std::iter::Iterator;
        self.quota = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rack_types][crate::model::ZoneMetadata::rack_types].
    pub fn set_rack_types<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::zone_metadata::RackType>,
    {
        use std::iter::Iterator;
        self.rack_types = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ZoneMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ZoneMetadata"
    }
}

/// Defines additional types related to ZoneMetadata
pub mod zone_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the rack.
    #[derive(Clone, Debug, PartialEq)]
    pub struct RackType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [RackType](RackType)
    pub mod rack_type {
        use super::RackType;

        /// Unspecified rack type, single rack also belongs to this type.
        pub const RACK_TYPE_UNSPECIFIED: RackType = RackType::known("RACK_TYPE_UNSPECIFIED", 0);

        /// Base rack type, a pair of two modified Config-1 racks containing
        /// Aggregation switches.
        pub const BASE: RackType = RackType::known("BASE", 1);

        /// Expansion rack type, also known as standalone racks,
        /// added by customers on demand.
        pub const EXPANSION: RackType = RackType::known("EXPANSION", 2);
    }

    impl RackType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for RackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(RackType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(RackType::from(val)),
                Enumeration::UnknownNum { str } => Ok(RackType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for RackType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "RACK_TYPE_UNSPECIFIED" => rack_type::RACK_TYPE_UNSPECIFIED,
                "BASE" => rack_type::BASE,
                "EXPANSION" => rack_type::EXPANSION,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for RackType {
        fn from(value: i32) -> Self {
            match value {
                0 => rack_type::RACK_TYPE_UNSPECIFIED,
                1 => rack_type::BASE,
                2 => rack_type::EXPANSION,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for RackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Config data holds all the config related data for the zone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ConfigData {
    /// list of available v4 ip pools for external loadbalancer
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub available_external_lb_pools_ipv4: std::vec::Vec<std::string::String>,

    /// list of available v6 ip pools for external loadbalancer
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub available_external_lb_pools_ipv6: std::vec::Vec<std::string::String>,
}

impl ConfigData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_external_lb_pools_ipv4][crate::model::ConfigData::available_external_lb_pools_ipv4].
    pub fn set_available_external_lb_pools_ipv4<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv4 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_external_lb_pools_ipv6][crate::model::ConfigData::available_external_lb_pools_ipv6].
    pub fn set_available_external_lb_pools_ipv6<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv6 = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ConfigData"
    }
}

/// Represents quota for Edge Container resources.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Quota {
    /// Name of the quota metric.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub metric: std::string::String,

    /// Quota limit for this metric.
    pub limit: f64,

    /// Current usage of this metric.
    pub usage: f64,
}

impl Quota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::Quota::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [limit][crate::model::Quota::limit].
    pub fn set_limit<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.limit = v.into();
        self
    }

    /// Sets the value of [usage][crate::model::Quota::usage].
    pub fn set_usage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.usage = v.into();
        self
    }
}

impl wkt::message::Message for Quota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Quota"
    }
}

/// Maintenance policy configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenancePolicy {
    /// Specifies the maintenance window in which maintenance may be performed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Optional. Exclusions to automatic maintenance. Non-emergency maintenance
    /// should not occur in these windows. Each exclusion has a unique name and may
    /// be active or expired. The max number of maintenance exclusions allowed at a
    /// given time is 3.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub maintenance_exclusions: std::vec::Vec<crate::model::MaintenanceExclusionWindow>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_window<
        T: std::convert::Into<std::option::Option<crate::model::MaintenanceWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.window = v.into();
        self
    }

    /// Sets the value of [maintenance_exclusions][crate::model::MaintenancePolicy::maintenance_exclusions].
    pub fn set_maintenance_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MaintenanceExclusionWindow>,
    {
        use std::iter::Iterator;
        self.maintenance_exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenancePolicy"
    }
}

/// Maintenance window configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceWindow {
    /// Configuration of a recurring maintenance window.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub recurring_window: std::option::Option<crate::model::RecurringTimeWindow>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recurring_window][crate::model::MaintenanceWindow::recurring_window].
    pub fn set_recurring_window<
        T: std::convert::Into<std::option::Option<crate::model::RecurringTimeWindow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.recurring_window = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceWindow"
    }
}

/// Represents an arbitrary window of time that recurs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RecurringTimeWindow {
    /// The window of the first recurrence.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window recurs. They go on for the span of time between the start and
    /// end time.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub recurrence: std::string::String,
}

impl RecurringTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_window<T: std::convert::Into<std::option::Option<crate::model::TimeWindow>>>(
        mut self,
        v: T,
    ) -> Self {
        self.window = v.into();
        self
    }

    /// Sets the value of [recurrence][crate::model::RecurringTimeWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for RecurringTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.RecurringTimeWindow"
    }
}

/// Represents a maintenance exclusion window.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MaintenanceExclusionWindow {
    /// Optional. The time window.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// Optional. A unique (per cluster) id for the window.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,
}

impl MaintenanceExclusionWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenanceExclusionWindow::window].
    pub fn set_window<T: std::convert::Into<std::option::Option<crate::model::TimeWindow>>>(
        mut self,
        v: T,
    ) -> Self {
        self.window = v.into();
        self
    }

    /// Sets the value of [id][crate::model::MaintenanceExclusionWindow::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceExclusionWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceExclusionWindow"
    }
}

/// Represents an arbitrary window of time.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TimeWindow {
    /// The time that the window first starts.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time that the window ends. The end time must take place after the
    /// start time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.TimeWindow"
    }
}

/// Server configuration for supported versions and release channels.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServerConfig {
    /// Output only. Mapping from release channel to channel config.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub channels: std::collections::HashMap<std::string::String, crate::model::ChannelConfig>,

    /// Output only. Supported versions, e.g.: ["1.4.0", "1.5.0"].
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Output only. Default version, e.g.: "1.4.0".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_version: std::string::String,
}

impl ServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_version][crate::model::ServerConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }

    /// Sets the value of [versions][crate::model::ServerConfig::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>,
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [channels][crate::model::ServerConfig::channels].
    pub fn set_channels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ChannelConfig>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for ServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ServerConfig"
    }
}

/// Configuration for a release channel.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ChannelConfig {
    /// Output only. Default version for this release channel, e.g.: "1.4.0".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub default_version: std::string::String,
}

impl ChannelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_version][crate::model::ChannelConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }
}

impl wkt::message::Message for ChannelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ChannelConfig"
    }
}

/// Version of a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Version {
    /// Output only. Name of the version, e.g.: "1.4.0".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Version"
    }
}

/// Long-running operation metadata for Edge Container API methods.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// The verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation of the operation.
    /// Operations that have successfully been cancelled have [Operation.error][]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// Warnings that do not block the operation, but still hold relevant
    /// information for the end user to receive.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub warnings: std::vec::Vec<std::string::String>,

    /// Machine-readable status of the operation, if any.
    pub status_reason: crate::model::operation_metadata::StatusReason,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [status_reason][crate::model::OperationMetadata::status_reason].
    pub fn set_status_reason<
        T: std::convert::Into<crate::model::operation_metadata::StatusReason>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.status_reason = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::OperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.OperationMetadata"
    }
}

/// Defines additional types related to OperationMetadata
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the reason for the status of the operation.
    #[derive(Clone, Debug, PartialEq)]
    pub struct StatusReason(wkt::enumerations::Enumeration);

    /// Useful constants to work with [StatusReason](StatusReason)
    pub mod status_reason {
        use super::StatusReason;

        /// Reason unknown.
        pub const STATUS_REASON_UNSPECIFIED: StatusReason =
            StatusReason::known("STATUS_REASON_UNSPECIFIED", 0);

        /// The cluster upgrade is currently paused.
        pub const UPGRADE_PAUSED: StatusReason = StatusReason::known("UPGRADE_PAUSED", 1);
    }

    impl StatusReason {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for StatusReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StatusReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(StatusReason::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(StatusReason::from(val)),
                Enumeration::UnknownNum { str } => Ok(StatusReason::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for StatusReason {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATUS_REASON_UNSPECIFIED" => status_reason::STATUS_REASON_UNSPECIFIED,
                "UPGRADE_PAUSED" => status_reason::UPGRADE_PAUSED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for StatusReason {
        fn from(value: i32) -> Self {
            match value {
                0 => status_reason::STATUS_REASON_UNSPECIFIED,
                1 => status_reason::UPGRADE_PAUSED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for StatusReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Lists clusters in a location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersRequest {
    /// Required. The parent location, which owns this collection of clusters.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    /// A page token received from previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersRequest"
    }
}

/// List of clusters in a location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListClustersResponse {
    /// Clusters in the location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token to retrieve next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>,
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Gets a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetClusterRequest {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetClusterRequest"
    }
}

/// Creates a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateClusterRequest {
    /// Required. The parent location where this cluster will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster_id: std::string::String,

    /// Required. The cluster to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateClusterRequest"
    }
}

/// Updates a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateClusterRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended.
    /// This request is only idempotent if `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::option::Option<crate::model::Cluster>>>(
        mut self,
        v: T,
    ) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateClusterRequest"
    }
}

/// Upgrades a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeClusterRequest {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The version the cluster is going to be upgraded to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_version: std::string::String,

    /// The schedule for the upgrade.
    pub schedule: crate::model::upgrade_cluster_request::Schedule,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpgradeClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeClusterRequest::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::UpgradeClusterRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<crate::model::upgrade_cluster_request::Schedule>>(
        mut self,
        v: T,
    ) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpgradeClusterRequest"
    }
}

/// Defines additional types related to UpgradeClusterRequest
pub mod upgrade_cluster_request {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the schedule about when the cluster is going to be upgraded.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Schedule(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Schedule](Schedule)
    pub mod schedule {
        use super::Schedule;

        /// Unspecified. The default is to upgrade the cluster immediately which is
        /// the only option today.
        pub const SCHEDULE_UNSPECIFIED: Schedule = Schedule::known("SCHEDULE_UNSPECIFIED", 0);

        /// The cluster is going to be upgraded immediately after receiving the
        /// request.
        pub const IMMEDIATELY: Schedule = Schedule::known("IMMEDIATELY", 1);
    }

    impl Schedule {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Schedule::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Schedule::from(val)),
                Enumeration::UnknownNum { str } => Ok(Schedule::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Schedule {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "SCHEDULE_UNSPECIFIED" => schedule::SCHEDULE_UNSPECIFIED,
                "IMMEDIATELY" => schedule::IMMEDIATELY,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Schedule {
        fn from(value: i32) -> Self {
            match value {
                0 => schedule::SCHEDULE_UNSPECIFIED,
                1 => schedule::IMMEDIATELY,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Schedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Deletes a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteClusterRequest {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteClusterRequest"
    }
}

/// Generates an access token for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAccessTokenRequest {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,
}

impl GenerateAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateAccessTokenRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenRequest"
    }
}

/// An access token for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAccessTokenResponse {
    /// Output only. Access token to authenticate to k8s api-server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl GenerateAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenResponse"
    }
}

/// Generates an offline credential(offline) for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateOfflineCredentialRequest {
    /// Required. The resource name of the cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cluster: std::string::String,
}

impl GenerateOfflineCredentialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateOfflineCredentialRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialRequest"
    }
}

/// An offline credential for a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateOfflineCredentialResponse {
    /// Output only. Client certificate to authenticate to k8s api-server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_certificate: std::string::String,

    /// Output only. Client private key to authenticate to k8s api-server.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub client_key: std::string::String,

    /// Output only. Client's identity.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_id: std::string::String,

    /// Output only. Timestamp at which this credential will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl GenerateOfflineCredentialResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_certificate][crate::model::GenerateOfflineCredentialResponse::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::GenerateOfflineCredentialResponse::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::GenerateOfflineCredentialResponse::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateOfflineCredentialResponse::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialResponse"
    }
}

/// Lists node pools in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodePoolsRequest {
    /// Required. The parent cluster, which owns this collection of node pools.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNodePoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNodePoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsRequest"
    }
}

/// List of node pools in a cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListNodePoolsResponse {
    /// Node pools in the cluster.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    /// A token to retrieve next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [node_pools][crate::model::ListNodePoolsResponse::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>,
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNodePoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListNodePoolsResponse {
    type PageItem = crate::model::NodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Gets a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetNodePoolRequest {
    /// Required. The resource name of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetNodePoolRequest"
    }
}

/// Creates a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateNodePoolRequest {
    /// Required. The parent cluster where this node pool will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub node_pool_id: std::string::String,

    /// Required. The node pool to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::CreateNodePoolRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_node_pool<T: std::convert::Into<std::option::Option<crate::model::NodePool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateNodePoolRequest"
    }
}

/// Updates a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateNodePoolRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// NodePool resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated node pool.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateNodePoolRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::UpdateNodePoolRequest::node_pool].
    pub fn set_node_pool<T: std::convert::Into<std::option::Option<crate::model::NodePool>>>(
        mut self,
        v: T,
    ) -> Self {
        self.node_pool = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateNodePoolRequest"
    }
}

/// Deletes a node pool.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteNodePoolRequest {
    /// Required. The resource name of the node pool.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteNodePoolRequest"
    }
}

/// Lists machines in a site.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMachinesRequest {
    /// Required. The parent site, which owns this collection of machines.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListMachinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMachinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMachinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMachinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMachinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMachinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMachinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesRequest"
    }
}

/// List of machines in a site.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMachinesResponse {
    /// Machines in the site.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub machines: std::vec::Vec<crate::model::Machine>,

    /// A token to retrieve next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListMachinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListMachinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [machines][crate::model::ListMachinesResponse::machines].
    pub fn set_machines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Machine>,
    {
        use std::iter::Iterator;
        self.machines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMachinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMachinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListMachinesResponse {
    type PageItem = crate::model::Machine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.machines
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Gets a machine.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMachineRequest {
    /// Required. The resource name of the machine.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetMachineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMachineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMachineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetMachineRequest"
    }
}

/// Lists VPN connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVpnConnectionsRequest {
    /// Required. The parent location, which owns this collection of VPN
    /// connections.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListVpnConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVpnConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVpnConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVpnConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVpnConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVpnConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsRequest"
    }
}

/// List of VPN connections in a location.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListVpnConnectionsResponse {
    /// VpnConnections in the location.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vpn_connections: std::vec::Vec<crate::model::VpnConnection>,

    /// A token to retrieve next page of results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListVpnConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListVpnConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [vpn_connections][crate::model::ListVpnConnectionsResponse::vpn_connections].
    pub fn set_vpn_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VpnConnection>,
    {
        use std::iter::Iterator;
        self.vpn_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVpnConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListVpnConnectionsResponse {
    type PageItem = crate::model::VpnConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vpn_connections
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Gets a VPN connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetVpnConnectionRequest {
    /// Required. The resource name of the vpn connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetVpnConnectionRequest"
    }
}

/// Creates a VPN connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateVpnConnectionRequest {
    /// Required. The parent location where this vpn connection will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The VPN connection identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpn_connection_id: std::string::String,

    /// Required. The VPN connection to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub vpn_connection: std::option::Option<crate::model::VpnConnection>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVpnConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vpn_connection_id][crate::model::CreateVpnConnectionRequest::vpn_connection_id].
    pub fn set_vpn_connection_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.vpn_connection_id = v.into();
        self
    }

    /// Sets the value of [vpn_connection][crate::model::CreateVpnConnectionRequest::vpn_connection].
    pub fn set_vpn_connection<
        T: std::convert::Into<std::option::Option<crate::model::VpnConnection>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vpn_connection = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateVpnConnectionRequest"
    }
}

/// Deletes a vpn connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteVpnConnectionRequest {
    /// Required. The resource name of the vpn connection.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteVpnConnectionRequest"
    }
}

/// Gets the server config.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetServerConfigRequest {
    /// Required. The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetServerConfigRequest"
    }
}

/// Represents the accessibility state of a customer-managed KMS key used for
/// CMEK integration.
#[derive(Clone, Debug, PartialEq)]
pub struct KmsKeyState(wkt::enumerations::Enumeration);

/// Useful constants to work with [KmsKeyState](KmsKeyState)
pub mod kms_key_state {
    use super::KmsKeyState;

    /// Unspecified.
    pub const KMS_KEY_STATE_UNSPECIFIED: KmsKeyState =
        KmsKeyState::known("KMS_KEY_STATE_UNSPECIFIED", 0);

    /// The key is available for use, and dependent resources should be accessible.
    pub const KMS_KEY_STATE_KEY_AVAILABLE: KmsKeyState =
        KmsKeyState::known("KMS_KEY_STATE_KEY_AVAILABLE", 1);

    /// The key is unavailable for an unspecified reason. Dependent resources may
    /// be inaccessible.
    pub const KMS_KEY_STATE_KEY_UNAVAILABLE: KmsKeyState =
        KmsKeyState::known("KMS_KEY_STATE_KEY_UNAVAILABLE", 2);
}

impl KmsKeyState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for KmsKeyState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for KmsKeyState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(KmsKeyState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(KmsKeyState::from(val)),
            Enumeration::UnknownNum { str } => Ok(KmsKeyState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for KmsKeyState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "KMS_KEY_STATE_UNSPECIFIED" => kms_key_state::KMS_KEY_STATE_UNSPECIFIED,
            "KMS_KEY_STATE_KEY_AVAILABLE" => kms_key_state::KMS_KEY_STATE_KEY_AVAILABLE,
            "KMS_KEY_STATE_KEY_UNAVAILABLE" => kms_key_state::KMS_KEY_STATE_KEY_UNAVAILABLE,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for KmsKeyState {
    fn from(value: i32) -> Self {
        match value {
            0 => kms_key_state::KMS_KEY_STATE_UNSPECIFIED,
            1 => kms_key_state::KMS_KEY_STATE_KEY_AVAILABLE,
            2 => kms_key_state::KMS_KEY_STATE_KEY_UNAVAILABLE,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for KmsKeyState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Represents if the resource is in lock down state or pending.
#[derive(Clone, Debug, PartialEq)]
pub struct ResourceState(wkt::enumerations::Enumeration);

/// Useful constants to work with [ResourceState](ResourceState)
pub mod resource_state {
    use super::ResourceState;

    /// Default value.
    pub const RESOURCE_STATE_UNSPECIFIED: ResourceState =
        ResourceState::known("RESOURCE_STATE_UNSPECIFIED", 0);

    /// The resource is in LOCK DOWN state.
    pub const RESOURCE_STATE_LOCK_DOWN: ResourceState =
        ResourceState::known("RESOURCE_STATE_LOCK_DOWN", 1);

    /// The resource is pending lock down.
    pub const RESOURCE_STATE_LOCK_DOWN_PENDING: ResourceState =
        ResourceState::known("RESOURCE_STATE_LOCK_DOWN_PENDING", 2);
}

impl ResourceState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for ResourceState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(ResourceState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(ResourceState::from(val)),
            Enumeration::UnknownNum { str } => Ok(ResourceState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for ResourceState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "RESOURCE_STATE_UNSPECIFIED" => resource_state::RESOURCE_STATE_UNSPECIFIED,
            "RESOURCE_STATE_LOCK_DOWN" => resource_state::RESOURCE_STATE_LOCK_DOWN,
            "RESOURCE_STATE_LOCK_DOWN_PENDING" => resource_state::RESOURCE_STATE_LOCK_DOWN_PENDING,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for ResourceState {
    fn from(value: i32) -> Self {
        match value {
            0 => resource_state::RESOURCE_STATE_UNSPECIFIED,
            1 => resource_state::RESOURCE_STATE_LOCK_DOWN,
            2 => resource_state::RESOURCE_STATE_LOCK_DOWN_PENDING,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for ResourceState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
