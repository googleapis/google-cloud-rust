// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate std;
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate tracing;
extern crate wkt;

mod debug;
mod deserialize;
mod serialize;

/// A Google Distributed Cloud Edge Kubernetes cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Cluster {

    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Output only. The time when the cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the cluster was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Required. Fleet configuration.
    pub fleet: std::option::Option<crate::model::Fleet>,

    /// Required. Cluster-wide networking configuration.
    pub networking: std::option::Option<crate::model::ClusterNetworking>,

    /// Required. Immutable. RBAC policy that will be applied and managed by GEC.
    pub authorization: std::option::Option<crate::model::Authorization>,

    /// Optional. The default maximum number of pods per node used if a maximum
    /// value is not specified explicitly for a node pool in this cluster. If
    /// unspecified, the Kubernetes default value will be used.
    pub default_max_pods_per_node: i32,

    /// Output only. The IP address of the Kubernetes API server.
    pub endpoint: std::string::String,

    /// Output only. The port number of the Kubernetes API server.
    pub port: i32,

    /// Output only. The PEM-encoded public certificate of the cluster's CA.
    pub cluster_ca_certificate: std::string::String,

    /// Optional. Cluster-wide maintenance policy configuration.
    pub maintenance_policy: std::option::Option<crate::model::MaintenancePolicy>,

    /// Output only. The control plane release version
    pub control_plane_version: std::string::String,

    /// Output only. The lowest release version among all worker nodes. This field
    /// can be empty if the cluster does not have any worker nodes.
    pub node_version: std::string::String,

    /// Optional. The configuration of the cluster control plane.
    pub control_plane: std::option::Option<crate::model::cluster::ControlPlane>,

    /// Optional. The configuration of the system add-ons.
    pub system_addons_config: std::option::Option<crate::model::cluster::SystemAddonsConfig>,

    /// Optional. IPv4 address pools for cluster data plane external load
    /// balancing.
    pub external_load_balancer_ipv4_address_pools: std::vec::Vec<std::string::String>,

    /// Optional. Remote control plane disk encryption options. This field is only
    /// used when enabling CMEK support.
    pub control_plane_encryption: std::option::Option<crate::model::cluster::ControlPlaneEncryption>,

    /// Output only. The current status of the cluster.
    pub status: crate::model::cluster::Status,

    /// Output only. All the maintenance events scheduled for the cluster,
    /// including the ones ongoing, planned for the future and done in the past (up
    /// to 90 days).
    pub maintenance_events: std::vec::Vec<crate::model::cluster::MaintenanceEvent>,

    /// Optional. The target cluster version. For example: "1.5.0".
    pub target_version: std::string::String,

    /// Optional. The release channel a cluster is subscribed to.
    pub release_channel: crate::model::cluster::ReleaseChannel,

    /// Optional. Configuration of the cluster survivability, e.g., for the case
    /// when network connectivity is lost. Note: This only applies to local control
    /// plane clusters.
    pub survivability_config: std::option::Option<crate::model::cluster::SurvivabilityConfig>,

    /// Optional. IPv6 address pools for cluster data plane external load
    /// balancing.
    pub external_load_balancer_ipv6_address_pools: std::vec::Vec<std::string::String>,

    /// Output only. The current connection state of the cluster.
    pub connection_state: std::option::Option<crate::model::cluster::ConnectionState>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Cluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Cluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Cluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Cluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Cluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_fleet<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Fleet>
    {
        self.fleet = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [fleet][crate::model::Cluster::fleet].
    pub fn set_or_clear_fleet<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Fleet>
    {
        self.fleet = v.map(|x| x.into());
        self
    }

    /// Sets the value of [networking][crate::model::Cluster::networking].
    pub fn set_networking<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ClusterNetworking>
    {
        self.networking = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [networking][crate::model::Cluster::networking].
    pub fn set_or_clear_networking<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ClusterNetworking>
    {
        self.networking = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorization][crate::model::Cluster::authorization].
    pub fn set_authorization<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Authorization>
    {
        self.authorization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorization][crate::model::Cluster::authorization].
    pub fn set_or_clear_authorization<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Authorization>
    {
        self.authorization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [default_max_pods_per_node][crate::model::Cluster::default_max_pods_per_node].
    pub fn set_default_max_pods_per_node<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.default_max_pods_per_node = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::Cluster::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }

    /// Sets the value of [port][crate::model::Cluster::port].
    pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.port = v.into();
        self
    }

    /// Sets the value of [cluster_ca_certificate][crate::model::Cluster::cluster_ca_certificate].
    pub fn set_cluster_ca_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_ca_certificate = v.into();
        self
    }

    /// Sets the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_maintenance_policy<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::MaintenancePolicy>
    {
        self.maintenance_policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [maintenance_policy][crate::model::Cluster::maintenance_policy].
    pub fn set_or_clear_maintenance_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::MaintenancePolicy>
    {
        self.maintenance_policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [control_plane_version][crate::model::Cluster::control_plane_version].
    pub fn set_control_plane_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.control_plane_version = v.into();
        self
    }

    /// Sets the value of [node_version][crate::model::Cluster::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [control_plane][crate::model::Cluster::control_plane].
    pub fn set_control_plane<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::cluster::ControlPlane>
    {
        self.control_plane = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane][crate::model::Cluster::control_plane].
    pub fn set_or_clear_control_plane<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::cluster::ControlPlane>
    {
        self.control_plane = v.map(|x| x.into());
        self
    }

    /// Sets the value of [system_addons_config][crate::model::Cluster::system_addons_config].
    pub fn set_system_addons_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::cluster::SystemAddonsConfig>
    {
        self.system_addons_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [system_addons_config][crate::model::Cluster::system_addons_config].
    pub fn set_or_clear_system_addons_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::cluster::SystemAddonsConfig>
    {
        self.system_addons_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_load_balancer_ipv4_address_pools][crate::model::Cluster::external_load_balancer_ipv4_address_pools].
    pub fn set_external_load_balancer_ipv4_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv4_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [control_plane_encryption][crate::model::Cluster::control_plane_encryption].
    pub fn set_control_plane_encryption<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::cluster::ControlPlaneEncryption>
    {
        self.control_plane_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [control_plane_encryption][crate::model::Cluster::control_plane_encryption].
    pub fn set_or_clear_control_plane_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::cluster::ControlPlaneEncryption>
    {
        self.control_plane_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [status][crate::model::Cluster::status].
    pub fn set_status<T: std::convert::Into<crate::model::cluster::Status>>(mut self, v: T) -> Self {
        self.status = v.into();
        self
    }

    /// Sets the value of [maintenance_events][crate::model::Cluster::maintenance_events].
    pub fn set_maintenance_events<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::cluster::MaintenanceEvent>
    {
        use std::iter::Iterator;
        self.maintenance_events = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_version][crate::model::Cluster::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [release_channel][crate::model::Cluster::release_channel].
    pub fn set_release_channel<T: std::convert::Into<crate::model::cluster::ReleaseChannel>>(mut self, v: T) -> Self {
        self.release_channel = v.into();
        self
    }

    /// Sets the value of [survivability_config][crate::model::Cluster::survivability_config].
    pub fn set_survivability_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::cluster::SurvivabilityConfig>
    {
        self.survivability_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [survivability_config][crate::model::Cluster::survivability_config].
    pub fn set_or_clear_survivability_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::cluster::SurvivabilityConfig>
    {
        self.survivability_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [external_load_balancer_ipv6_address_pools][crate::model::Cluster::external_load_balancer_ipv6_address_pools].
    pub fn set_external_load_balancer_ipv6_address_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.external_load_balancer_ipv6_address_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [connection_state][crate::model::Cluster::connection_state].
    pub fn set_connection_state<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::cluster::ConnectionState>
    {
        self.connection_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection_state][crate::model::Cluster::connection_state].
    pub fn set_or_clear_connection_state<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::cluster::ConnectionState>
    {
        self.connection_state = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Cluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster"
    }
}

/// Defines additional types related to [Cluster].
pub mod cluster {
    #[allow(unused_imports)]
    use super::*;


    /// Configuration of the cluster control plane.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ControlPlane {

        pub config: std::option::Option<crate::model::cluster::control_plane::Config>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ControlPlane {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config].
        ///
        /// Note that all the setters affecting `config` are mutually
        /// exclusive.
        pub fn set_config<T: std::convert::Into<std::option::Option<crate::model::cluster::control_plane::Config>>>(mut self, v: T) -> Self
        {
            self.config = v.into();
            self
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Remote`, `None` if the field is not set or
        /// holds a different branch.
        pub fn remote(&self) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Remote>> {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Remote(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Remote`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_remote<T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Remote>>>(mut self, v: T) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Remote(
                    v.into()
                )
            );
            self
        }

        /// The value of [config][crate::model::cluster::ControlPlane::config]
        /// if it holds a `Local`, `None` if the field is not set or
        /// holds a different branch.
        pub fn local(&self) -> std::option::Option<&std::boxed::Box<crate::model::cluster::control_plane::Local>> {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::cluster::control_plane::Config::Local(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::cluster::ControlPlane::config]
        /// to hold a `Local`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_local<T: std::convert::Into<std::boxed::Box<crate::model::cluster::control_plane::Local>>>(mut self, v: T) -> Self {
            self.config = std::option::Option::Some(
                crate::model::cluster::control_plane::Config::Local(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for ControlPlane {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane"
        }
    }

    /// Defines additional types related to [ControlPlane].
    pub mod control_plane {
        #[allow(unused_imports)]
        use super::*;


        /// Configuration specific to clusters with a control plane hosted remotely.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Remote {

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Remote {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Remote {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Remote"
            }
        }

        /// Configuration specific to clusters with a control plane hosted locally.
        ///
        /// Warning: Local control plane clusters must be created in their own
        /// project. Local control plane clusters cannot coexist in the same
        /// project with any other type of clusters, including non-GDCE clusters.
        /// Mixing local control plane GDCE clusters with any other type of
        /// clusters in the same project can result in data loss.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Local {

            /// Name of the Google Distributed Cloud Edge zones where this node pool
            /// will be created. For example: `us-central1-edge-customer-a`.
            pub node_location: std::string::String,

            /// The number of nodes to serve as replicas of the Control Plane.
            pub node_count: i32,

            /// Only machines matching this filter will be allowed to host control
            /// plane nodes. The filtering language accepts strings like "name=\<name\>",
            /// and is documented here: [AIP-160](https://google.aip.dev/160).
            pub machine_filter: std::string::String,

            /// Policy configuration about how user applications are deployed.
            pub shared_deployment_policy: crate::model::cluster::control_plane::SharedDeploymentPolicy,

            /// Optional. Name for the storage schema of control plane nodes.
            ///
            /// Warning: Configurable node local storage schema feature is an
            /// experimental feature, and is not recommended for general use
            /// in production clusters/nodepools.
            pub control_plane_node_storage_schema: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Local {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [node_location][crate::model::cluster::control_plane::Local::node_location].
            pub fn set_node_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.node_location = v.into();
                self
            }

            /// Sets the value of [node_count][crate::model::cluster::control_plane::Local::node_count].
            pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.node_count = v.into();
                self
            }

            /// Sets the value of [machine_filter][crate::model::cluster::control_plane::Local::machine_filter].
            pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.machine_filter = v.into();
                self
            }

            /// Sets the value of [shared_deployment_policy][crate::model::cluster::control_plane::Local::shared_deployment_policy].
            pub fn set_shared_deployment_policy<T: std::convert::Into<crate::model::cluster::control_plane::SharedDeploymentPolicy>>(mut self, v: T) -> Self {
                self.shared_deployment_policy = v.into();
                self
            }

            /// Sets the value of [control_plane_node_storage_schema][crate::model::cluster::control_plane::Local::control_plane_node_storage_schema].
            pub fn set_control_plane_node_storage_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.control_plane_node_storage_schema = v.into();
                self
            }
        }

        impl wkt::message::Message for Local {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlane.Local"
            }
        }

        /// Represents the policy configuration about how user applications are
        /// deployed.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum SharedDeploymentPolicy {
            /// Unspecified.
            Unspecified,
            /// User applications can be deployed both on control plane and worker
            /// nodes.
            Allowed,
            /// User applications can not be deployed on control plane nodes and can
            /// only be deployed on worker nodes.
            Disallowed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [SharedDeploymentPolicy::value] or
            /// [SharedDeploymentPolicy::name].
            UnknownValue(shared_deployment_policy::UnknownValue),
        }

        #[doc(hidden)]
        pub mod shared_deployment_policy {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl SharedDeploymentPolicy {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Allowed => std::option::Option::Some(1),
                    Self::Disallowed => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SHARED_DEPLOYMENT_POLICY_UNSPECIFIED"),
                    Self::Allowed => std::option::Option::Some("ALLOWED"),
                    Self::Disallowed => std::option::Option::Some("DISALLOWED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for SharedDeploymentPolicy {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for SharedDeploymentPolicy {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for SharedDeploymentPolicy {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Allowed,
                    2 => Self::Disallowed,
                    _ => Self::UnknownValue(shared_deployment_policy::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for SharedDeploymentPolicy {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SHARED_DEPLOYMENT_POLICY_UNSPECIFIED" => Self::Unspecified,
                    "ALLOWED" => Self::Allowed,
                    "DISALLOWED" => Self::Disallowed,
                    _ => Self::UnknownValue(shared_deployment_policy::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for SharedDeploymentPolicy {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Allowed => serializer.serialize_i32(1),
                    Self::Disallowed => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for SharedDeploymentPolicy {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<SharedDeploymentPolicy>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.ControlPlane.SharedDeploymentPolicy"))
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Config {
            /// Remote control plane configuration.
            Remote(std::boxed::Box<crate::model::cluster::control_plane::Remote>),
            /// Local control plane configuration.
            ///
            /// Warning: Local control plane clusters must be created in their own
            /// project. Local control plane clusters cannot coexist in the same
            /// project with any other type of clusters, including non-GDCE clusters.
            /// Mixing local control plane GDCE clusters with any other type of
            /// clusters in the same project can result in data loss.
            Local(std::boxed::Box<crate::model::cluster::control_plane::Local>),
        }
    }

    /// Config that customers are allowed to define for GDCE system add-ons.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SystemAddonsConfig {

        /// Optional. Config for Ingress.
        pub ingress: std::option::Option<crate::model::cluster::system_addons_config::Ingress>,

        /// Optional. Config for VM Service.
        pub vm_service_config: std::option::Option<crate::model::cluster::system_addons_config::VMServiceConfig>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SystemAddonsConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [ingress][crate::model::cluster::SystemAddonsConfig::ingress].
        pub fn set_ingress<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::cluster::system_addons_config::Ingress>
        {
            self.ingress = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ingress][crate::model::cluster::SystemAddonsConfig::ingress].
        pub fn set_or_clear_ingress<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::cluster::system_addons_config::Ingress>
        {
            self.ingress = v.map(|x| x.into());
            self
        }

        /// Sets the value of [vm_service_config][crate::model::cluster::SystemAddonsConfig::vm_service_config].
        pub fn set_vm_service_config<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::cluster::system_addons_config::VMServiceConfig>
        {
            self.vm_service_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [vm_service_config][crate::model::cluster::SystemAddonsConfig::vm_service_config].
        pub fn set_or_clear_vm_service_config<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::cluster::system_addons_config::VMServiceConfig>
        {
            self.vm_service_config = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SystemAddonsConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig"
        }
    }

    /// Defines additional types related to [SystemAddonsConfig].
    pub mod system_addons_config {
        #[allow(unused_imports)]
        use super::*;


        /// Config for the Ingress add-on which allows customers to create an Ingress
        /// object to manage external access to the servers in a cluster. The add-on
        /// consists of istiod and istio-ingress.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Ingress {

            /// Optional. Whether Ingress is disabled.
            pub disabled: bool,

            /// Optional. Ingress VIP.
            pub ipv4_vip: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Ingress {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [disabled][crate::model::cluster::system_addons_config::Ingress::disabled].
            pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.disabled = v.into();
                self
            }

            /// Sets the value of [ipv4_vip][crate::model::cluster::system_addons_config::Ingress::ipv4_vip].
            pub fn set_ipv4_vip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.ipv4_vip = v.into();
                self
            }
        }

        impl wkt::message::Message for Ingress {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.Ingress"
            }
        }

        /// VMServiceConfig defines the configuration for GDCE VM Service.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct VMServiceConfig {

            /// Optional. Whether VMM is enabled.
            pub vmm_enabled: bool,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl VMServiceConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [vmm_enabled][crate::model::cluster::system_addons_config::VMServiceConfig::vmm_enabled].
            pub fn set_vmm_enabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.vmm_enabled = v.into();
                self
            }
        }

        impl wkt::message::Message for VMServiceConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SystemAddonsConfig.VMServiceConfig"
            }
        }
    }

    /// Configuration for Customer-managed KMS key support for control plane nodes.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ControlPlaneEncryption {

        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting control plane disks. If not specified, a
        /// Google-managed key will be used instead.
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting control plane disks. Only applicable if kms_key is set.
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ControlPlaneEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::cluster::ControlPlaneEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::cluster::ControlPlaneEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::cluster::ControlPlaneEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(mut self, v: T) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::cluster::ControlPlaneEncryption::kms_status].
        pub fn set_kms_status<T>(mut self, v: T) -> Self
        where T: std::convert::Into<rpc::model::Status>
        {
            self.kms_status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [kms_status][crate::model::cluster::ControlPlaneEncryption::kms_status].
        pub fn set_or_clear_kms_status<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<rpc::model::Status>
        {
            self.kms_status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource_state][crate::model::cluster::ControlPlaneEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(mut self, v: T) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for ControlPlaneEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ControlPlaneEncryption"
        }
    }

    /// A Maintenance Event is an operation that could cause temporary disruptions
    /// to the cluster workloads, including Google-driven or user-initiated cluster
    /// upgrades, user-initiated cluster configuration changes that require
    /// restarting nodes, etc.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct MaintenanceEvent {

        /// Output only. UUID of the maintenance event.
        pub uuid: std::string::String,

        /// Output only. The target version of the cluster.
        pub target_version: std::string::String,

        /// Output only. The operation for running the maintenance event. Specified
        /// in the format projects/*/locations/*/operations/*. If the maintenance
        /// event is split into multiple operations (e.g. due to maintenance
        /// windows), the latest one is recorded.
        pub operation: std::string::String,

        /// Output only. The type of the maintenance event.
        pub r#type: crate::model::cluster::maintenance_event::Type,

        /// Output only. The schedule of the maintenance event.
        pub schedule: crate::model::cluster::maintenance_event::Schedule,

        /// Output only. The state of the maintenance event.
        pub state: crate::model::cluster::maintenance_event::State,

        /// Output only. The time when the maintenance event request was created.
        pub create_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event started.
        pub start_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event ended, either
        /// successfully or not. If the maintenance event is split into multiple
        /// maintenance windows, end_time is only updated when the whole flow ends.
        pub end_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time when the maintenance event message was updated.
        pub update_time: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl MaintenanceEvent {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [uuid][crate::model::cluster::MaintenanceEvent::uuid].
        pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.uuid = v.into();
            self
        }

        /// Sets the value of [target_version][crate::model::cluster::MaintenanceEvent::target_version].
        pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.target_version = v.into();
            self
        }

        /// Sets the value of [operation][crate::model::cluster::MaintenanceEvent::operation].
        pub fn set_operation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.operation = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::cluster::MaintenanceEvent::type].
        pub fn set_type<T: std::convert::Into<crate::model::cluster::maintenance_event::Type>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [schedule][crate::model::cluster::MaintenanceEvent::schedule].
        pub fn set_schedule<T: std::convert::Into<crate::model::cluster::maintenance_event::Schedule>>(mut self, v: T) -> Self {
            self.schedule = v.into();
            self
        }

        /// Sets the value of [state][crate::model::cluster::MaintenanceEvent::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::maintenance_event::State>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [create_time][crate::model::cluster::MaintenanceEvent::create_time].
        pub fn set_create_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.create_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [create_time][crate::model::cluster::MaintenanceEvent::create_time].
        pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.create_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [start_time][crate::model::cluster::MaintenanceEvent::start_time].
        pub fn set_start_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.start_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [start_time][crate::model::cluster::MaintenanceEvent::start_time].
        pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.start_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [end_time][crate::model::cluster::MaintenanceEvent::end_time].
        pub fn set_end_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.end_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [end_time][crate::model::cluster::MaintenanceEvent::end_time].
        pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.end_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::MaintenanceEvent::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::cluster::MaintenanceEvent::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for MaintenanceEvent {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent"
        }
    }

    /// Defines additional types related to [MaintenanceEvent].
    pub mod maintenance_event {
        #[allow(unused_imports)]
        use super::*;


        /// Indicates the maintenance event type.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Type {
            /// Unspecified.
            Unspecified,
            /// Upgrade initiated by users.
            UserInitiatedUpgrade,
            /// Upgrade driven by Google.
            GoogleDrivenUpgrade,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Type::value] or
            /// [Type::name].
            UnknownValue(r#type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod r#type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Type {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::UserInitiatedUpgrade => std::option::Option::Some(1),
                    Self::GoogleDrivenUpgrade => std::option::Option::Some(2),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                    Self::UserInitiatedUpgrade => std::option::Option::Some("USER_INITIATED_UPGRADE"),
                    Self::GoogleDrivenUpgrade => std::option::Option::Some("GOOGLE_DRIVEN_UPGRADE"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Type {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Type {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Type {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::UserInitiatedUpgrade,
                    2 => Self::GoogleDrivenUpgrade,
                    _ => Self::UnknownValue(r#type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for Type {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TYPE_UNSPECIFIED" => Self::Unspecified,
                    "USER_INITIATED_UPGRADE" => Self::UserInitiatedUpgrade,
                    "GOOGLE_DRIVEN_UPGRADE" => Self::GoogleDrivenUpgrade,
                    _ => Self::UnknownValue(r#type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for Type {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::UserInitiatedUpgrade => serializer.serialize_i32(1),
                    Self::GoogleDrivenUpgrade => serializer.serialize_i32(2),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Type {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.Type"))
            }
        }

        /// Indicates when the maintenance event should be performed.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Schedule {
            /// Unspecified.
            Unspecified,
            /// Immediately after receiving the request.
            Immediately,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [Schedule::value] or
            /// [Schedule::name].
            UnknownValue(schedule::UnknownValue),
        }

        #[doc(hidden)]
        pub mod schedule {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl Schedule {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Immediately => std::option::Option::Some(1),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("SCHEDULE_UNSPECIFIED"),
                    Self::Immediately => std::option::Option::Some("IMMEDIATELY"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for Schedule {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for Schedule {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for Schedule {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Immediately,
                    _ => Self::UnknownValue(schedule::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for Schedule {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                    "IMMEDIATELY" => Self::Immediately,
                    _ => Self::UnknownValue(schedule::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for Schedule {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Immediately => serializer.serialize_i32(1),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for Schedule {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<Schedule>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.Schedule"))
            }
        }

        /// Indicates the maintenance event state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unspecified.
            Unspecified,
            /// The maintenance event is ongoing. The cluster might be unusable.
            Reconciling,
            /// The maintenance event succeeded.
            Succeeded,
            /// The maintenance event failed.
            Failed,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Reconciling => std::option::Option::Some(1),
                    Self::Succeeded => std::option::Option::Some(2),
                    Self::Failed => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Reconciling => std::option::Option::Some("RECONCILING"),
                    Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                    Self::Failed => std::option::Option::Some("FAILED"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Reconciling,
                    2 => Self::Succeeded,
                    3 => Self::Failed,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "RECONCILING" => Self::Reconciling,
                    "SUCCEEDED" => Self::Succeeded,
                    "FAILED" => Self::Failed,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Reconciling => serializer.serialize_i32(1),
                    Self::Succeeded => serializer.serialize_i32(2),
                    Self::Failed => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.MaintenanceEvent.State"))
            }
        }
    }

    /// Configuration of the cluster survivability, e.g., for the case when network
    /// connectivity is lost.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SurvivabilityConfig {

        /// Optional. Time period that allows the cluster nodes to be rebooted and
        /// become functional without network connectivity to Google. The default 0
        /// means not allowed. The maximum is 7 days.
        pub offline_reboot_ttl: std::option::Option<wkt::Duration>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SurvivabilityConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [offline_reboot_ttl][crate::model::cluster::SurvivabilityConfig::offline_reboot_ttl].
        pub fn set_offline_reboot_ttl<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Duration>
        {
            self.offline_reboot_ttl = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [offline_reboot_ttl][crate::model::cluster::SurvivabilityConfig::offline_reboot_ttl].
        pub fn set_or_clear_offline_reboot_ttl<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Duration>
        {
            self.offline_reboot_ttl = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for SurvivabilityConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.SurvivabilityConfig"
        }
    }

    /// ConnectionState holds the current connection state from the cluster to
    /// Google.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ConnectionState {

        /// Output only. The current connection state.
        pub state: crate::model::cluster::connection_state::State,

        /// Output only. The time when the connection state was last changed.
        pub update_time: std::option::Option<wkt::Timestamp>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ConnectionState {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::cluster::ConnectionState::state].
        pub fn set_state<T: std::convert::Into<crate::model::cluster::connection_state::State>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [update_time][crate::model::cluster::ConnectionState::update_time].
        pub fn set_update_time<T>(mut self, v: T) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.update_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [update_time][crate::model::cluster::ConnectionState::update_time].
        pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<wkt::Timestamp>
        {
            self.update_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for ConnectionState {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.Cluster.ConnectionState"
        }
    }

    /// Defines additional types related to [ConnectionState].
    pub mod connection_state {
        #[allow(unused_imports)]
        use super::*;


        /// The connection state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unknown connection state.
            Unspecified,
            /// This cluster is currently disconnected from Google.
            Disconnected,
            /// This cluster is currently connected to Google.
            Connected,
            /// This cluster is currently connected to Google, but may have recently
            /// reconnected after a disconnection. It is still syncing back.
            ConnectedAndSyncing,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Disconnected => std::option::Option::Some(1),
                    Self::Connected => std::option::Option::Some(2),
                    Self::ConnectedAndSyncing => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Disconnected => std::option::Option::Some("DISCONNECTED"),
                    Self::Connected => std::option::Option::Some("CONNECTED"),
                    Self::ConnectedAndSyncing => std::option::Option::Some("CONNECTED_AND_SYNCING"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Disconnected,
                    2 => Self::Connected,
                    3 => Self::ConnectedAndSyncing,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "DISCONNECTED" => Self::Disconnected,
                    "CONNECTED" => Self::Connected,
                    "CONNECTED_AND_SYNCING" => Self::ConnectedAndSyncing,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Disconnected => serializer.serialize_i32(1),
                    Self::Connected => serializer.serialize_i32(2),
                    Self::ConnectedAndSyncing => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.Cluster.ConnectionState.State"))
            }
        }
    }

    /// Indicates the status of the cluster.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Status {
        /// Status unknown.
        Unspecified,
        /// The cluster is being created.
        Provisioning,
        /// The cluster is created and fully usable.
        Running,
        /// The cluster is being deleted.
        Deleting,
        /// The status indicates that some errors occurred while reconciling/deleting
        /// the cluster.
        Error,
        /// The cluster is undergoing some work such as version upgrades, etc.
        Reconciling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Status::value] or
        /// [Status::name].
        UnknownValue(status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Status {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Provisioning => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Error => std::option::Option::Some(4),
                Self::Reconciling => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_UNSPECIFIED"),
                Self::Provisioning => std::option::Option::Some("PROVISIONING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Reconciling => std::option::Option::Some("RECONCILING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Status {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Status {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Status {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Provisioning,
                2 => Self::Running,
                3 => Self::Deleting,
                4 => Self::Error,
                5 => Self::Reconciling,
                _ => Self::UnknownValue(status::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Status {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_UNSPECIFIED" => Self::Unspecified,
                "PROVISIONING" => Self::Provisioning,
                "RUNNING" => Self::Running,
                "DELETING" => Self::Deleting,
                "ERROR" => Self::Error,
                "RECONCILING" => Self::Reconciling,
                _ => Self::UnknownValue(status::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Status {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Provisioning => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Error => serializer.serialize_i32(4),
                Self::Reconciling => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Status {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Status>::new(
                ".google.cloud.edgecontainer.v1.Cluster.Status"))
        }
    }

    /// The release channel a cluster is subscribed to.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ReleaseChannel {
        /// Unspecified release channel. This will default to the REGULAR channel.
        Unspecified,
        /// No release channel.
        None,
        /// Regular release channel.
        Regular,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ReleaseChannel::value] or
        /// [ReleaseChannel::name].
        UnknownValue(release_channel::UnknownValue),
    }

    #[doc(hidden)]
    pub mod release_channel {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ReleaseChannel {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Regular => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RELEASE_CHANNEL_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Regular => std::option::Option::Some("REGULAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ReleaseChannel {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ReleaseChannel {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ReleaseChannel {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Regular,
                _ => Self::UnknownValue(release_channel::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for ReleaseChannel {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RELEASE_CHANNEL_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "REGULAR" => Self::Regular,
                _ => Self::UnknownValue(release_channel::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for ReleaseChannel {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Regular => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ReleaseChannel {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReleaseChannel>::new(
                ".google.cloud.edgecontainer.v1.Cluster.ReleaseChannel"))
        }
    }
}

/// Cluster-wide networking configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterNetworking {

    /// Required. All pods in the cluster are assigned an RFC1918 IPv4 address from
    /// these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    pub cluster_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,

    /// Required. All services in the cluster are assigned an RFC1918 IPv4 address
    /// from these blocks. Only a single block is supported. This field cannot be
    /// changed after creation.
    pub services_ipv4_cidr_blocks: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterNetworking {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster_ipv4_cidr_blocks][crate::model::ClusterNetworking::cluster_ipv4_cidr_blocks].
    pub fn set_cluster_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.cluster_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [services_ipv4_cidr_blocks][crate::model::ClusterNetworking::services_ipv4_cidr_blocks].
    pub fn set_services_ipv4_cidr_blocks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.services_ipv4_cidr_blocks = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ClusterNetworking {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterNetworking"
    }
}

/// Fleet related configuration.
///
/// Fleets are a Google Cloud concept for logically organizing clusters,
/// letting you use and manage multi-cluster capabilities and apply
/// consistent policies across your systems.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Fleet {

    /// Required. The name of the Fleet host project where this cluster will be
    /// registered.
    ///
    /// Project names are formatted as
    /// `projects/<project-number>`.
    pub project: std::string::String,

    /// Output only. The name of the managed Hub Membership resource associated to
    /// this cluster.
    ///
    /// Membership names are formatted as
    /// `projects/<project-number>/locations/global/membership/<cluster-id>`.
    pub membership: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Fleet {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::Fleet::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [membership][crate::model::Fleet::membership].
    pub fn set_membership<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.membership = v.into();
        self
    }
}

impl wkt::message::Message for Fleet {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Fleet"
    }
}

/// A user principal for an RBAC policy.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ClusterUser {

    /// Required. An active Google username.
    pub username: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ClusterUser {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::ClusterUser::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for ClusterUser {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ClusterUser"
    }
}

/// RBAC policy that will be applied and managed by GEC.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Authorization {

    /// Required. User that will be granted the cluster-admin role on the cluster,
    /// providing full access to the cluster. Currently, this is a singular field,
    /// but will be expanded to allow multiple admins in the future.
    pub admin_users: std::option::Option<crate::model::ClusterUser>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Authorization {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [admin_users][crate::model::Authorization::admin_users].
    pub fn set_admin_users<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ClusterUser>
    {
        self.admin_users = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [admin_users][crate::model::Authorization::admin_users].
    pub fn set_or_clear_admin_users<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ClusterUser>
    {
        self.admin_users = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Authorization {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Authorization"
    }
}

/// A set of Kubernetes nodes in a cluster with common configuration and
/// specification.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NodePool {

    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Name of the Google Distributed Cloud Edge zone where this node pool will be
    /// created. For example: `us-central1-edge-customer-a`.
    pub node_location: std::string::String,

    /// Required. The number of nodes in the pool.
    pub node_count: i32,

    /// Only machines matching this filter will be allowed to join the node pool.
    /// The filtering language accepts strings like "name=\<name\>", and is
    /// documented in more detail in [AIP-160](https://google.aip.dev/160).
    pub machine_filter: std::string::String,

    /// Optional. Local disk encryption options. This field is only used when
    /// enabling CMEK support.
    pub local_disk_encryption: std::option::Option<crate::model::node_pool::LocalDiskEncryption>,

    /// Output only. The lowest release version among all worker nodes.
    pub node_version: std::string::String,

    /// Optional. Configuration for each node in the NodePool
    pub node_config: std::option::Option<crate::model::node_pool::NodeConfig>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NodePool {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::NodePool::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::NodePool::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::NodePool::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::NodePool::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::NodePool::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::NodePool::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [node_location][crate::model::NodePool::node_location].
    pub fn set_node_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_location = v.into();
        self
    }

    /// Sets the value of [node_count][crate::model::NodePool::node_count].
    pub fn set_node_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.node_count = v.into();
        self
    }

    /// Sets the value of [machine_filter][crate::model::NodePool::machine_filter].
    pub fn set_machine_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_filter = v.into();
        self
    }

    /// Sets the value of [local_disk_encryption][crate::model::NodePool::local_disk_encryption].
    pub fn set_local_disk_encryption<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::node_pool::LocalDiskEncryption>
    {
        self.local_disk_encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [local_disk_encryption][crate::model::NodePool::local_disk_encryption].
    pub fn set_or_clear_local_disk_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::node_pool::LocalDiskEncryption>
    {
        self.local_disk_encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_version][crate::model::NodePool::node_version].
    pub fn set_node_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_version = v.into();
        self
    }

    /// Sets the value of [node_config][crate::model::NodePool::node_config].
    pub fn set_node_config<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::node_pool::NodeConfig>
    {
        self.node_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_config][crate::model::NodePool::node_config].
    pub fn set_or_clear_node_config<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::node_pool::NodeConfig>
    {
        self.node_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for NodePool {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool"
    }
}

/// Defines additional types related to [NodePool].
pub mod node_pool {
    #[allow(unused_imports)]
    use super::*;


    /// Configuration for CMEK support for edge machine local disk encryption.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LocalDiskEncryption {

        /// Optional. The Cloud KMS CryptoKey e.g.
        /// projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}
        /// to use for protecting node local disks. If not specified, a
        /// Google-managed key will be used instead.
        pub kms_key: std::string::String,

        /// Output only. The Cloud KMS CryptoKeyVersion currently in use for
        /// protecting node local disks. Only applicable if kms_key is set.
        pub kms_key_active_version: std::string::String,

        /// Output only. Availability of the Cloud KMS CryptoKey. If not
        /// `KEY_AVAILABLE`, then nodes may go offline as they cannot access their
        /// local data. This can be caused by a lack of permissions to use the key,
        /// or if the key is disabled or deleted.
        pub kms_key_state: crate::model::KmsKeyState,

        /// Output only. Error status returned by Cloud KMS when using this key. This
        /// field may be populated only if `kms_key_state` is not
        /// `KMS_KEY_STATE_KEY_AVAILABLE`. If populated, this field contains the
        /// error status reported by Cloud KMS.
        pub kms_status: std::option::Option<rpc::model::Status>,

        /// Output only. The current resource state associated with the cmek.
        pub resource_state: crate::model::ResourceState,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LocalDiskEncryption {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::node_pool::LocalDiskEncryption::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_active_version][crate::model::node_pool::LocalDiskEncryption::kms_key_active_version].
        pub fn set_kms_key_active_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key_active_version = v.into();
            self
        }

        /// Sets the value of [kms_key_state][crate::model::node_pool::LocalDiskEncryption::kms_key_state].
        pub fn set_kms_key_state<T: std::convert::Into<crate::model::KmsKeyState>>(mut self, v: T) -> Self {
            self.kms_key_state = v.into();
            self
        }

        /// Sets the value of [kms_status][crate::model::node_pool::LocalDiskEncryption::kms_status].
        pub fn set_kms_status<T>(mut self, v: T) -> Self
        where T: std::convert::Into<rpc::model::Status>
        {
            self.kms_status = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [kms_status][crate::model::node_pool::LocalDiskEncryption::kms_status].
        pub fn set_or_clear_kms_status<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<rpc::model::Status>
        {
            self.kms_status = v.map(|x| x.into());
            self
        }

        /// Sets the value of [resource_state][crate::model::node_pool::LocalDiskEncryption::resource_state].
        pub fn set_resource_state<T: std::convert::Into<crate::model::ResourceState>>(mut self, v: T) -> Self {
            self.resource_state = v.into();
            self
        }
    }

    impl wkt::message::Message for LocalDiskEncryption {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.LocalDiskEncryption"
        }
    }

    /// Configuration for each node in the NodePool
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NodeConfig {

        /// Optional. The Kubernetes node labels
        pub labels: std::collections::HashMap<std::string::String,std::string::String>,

        /// Optional. Name for the storage schema of worker nodes.
        ///
        /// Warning: Configurable node local storage schema feature is an
        /// experimental feature, and is not recommended for general use
        /// in production clusters/nodepools.
        pub node_storage_schema: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NodeConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [labels][crate::model::node_pool::NodeConfig::labels].
        pub fn set_labels<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [node_storage_schema][crate::model::node_pool::NodeConfig::node_storage_schema].
        pub fn set_node_storage_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.node_storage_schema = v.into();
            self
        }
    }

    impl wkt::message::Message for NodeConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.NodePool.NodeConfig"
        }
    }
}

/// A Google Distributed Cloud Edge machine capable of acting as a Kubernetes
/// node.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Machine {

    /// Required. The resource name of the machine.
    pub name: std::string::String,

    /// Output only. The time when the node pool was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the node pool was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// Canonical resource name of the node that this machine is responsible for
    /// hosting e.g.
    /// projects/{project}/locations/{location}/clusters/{cluster_id}/nodePools/{pool_id}/{node},
    /// Or empty if the machine is not assigned to assume the role of a node.
    ///
    /// For control plane nodes hosted on edge machines, this will return
    /// the following format:
    /// "projects/{project}/locations/{location}/clusters/{cluster_id}/controlPlaneNodes/{node}".
    pub hosted_node: std::string::String,

    /// The Google Distributed Cloud Edge zone of this machine.
    pub zone: std::string::String,

    /// Output only. The software version of the machine.
    pub version: std::string::String,

    /// Output only. Whether the machine is disabled. If disabled, the machine is
    /// unable to enter service.
    pub disabled: bool,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Machine {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Machine::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Machine::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Machine::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Machine::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Machine::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Machine::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [hosted_node][crate::model::Machine::hosted_node].
    pub fn set_hosted_node<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hosted_node = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::Machine::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [version][crate::model::Machine::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::Machine::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }
}

impl wkt::message::Message for Machine {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Machine"
    }
}

/// A VPN connection .
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VpnConnection {

    /// Required. The resource name of VPN connection
    pub name: std::string::String,

    /// Output only. The time when the VPN connection was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time when the VPN connection was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels associated with this resource.
    pub labels: std::collections::HashMap<std::string::String,std::string::String>,

    /// NAT gateway IP, or WAN IP address. If a customer has multiple NAT IPs, the
    /// customer needs to configure NAT such that only one external IP maps to the
    /// GMEC Anthos cluster. This is empty if NAT is not used.
    pub nat_gateway_ip: std::string::String,

    /// Dynamic routing mode of the VPC network, `regional` or `global`.
    #[deprecated]
    pub bgp_routing_mode: crate::model::vpn_connection::BgpRoutingMode,

    /// The canonical Cluster name to connect to. It is in the form of
    /// projects/{project}/locations/{location}/clusters/{cluster}.
    pub cluster: std::string::String,

    /// The network ID of VPC to connect to.
    pub vpc: std::string::String,

    /// Optional. Project detail of the VPC network. Required if VPC is in a
    /// different project than the cluster project.
    pub vpc_project: std::option::Option<crate::model::vpn_connection::VpcProject>,

    /// Whether this VPN connection has HA enabled on cluster side. If enabled,
    /// when creating VPN connection we will attempt to use 2 ANG floating IPs.
    pub enable_high_availability: bool,

    /// Optional. The VPN connection Cloud Router name.
    pub router: std::string::String,

    /// Output only. The created connection details.
    pub details: std::option::Option<crate::model::vpn_connection::Details>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VpnConnection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::VpnConnection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::VpnConnection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::VpnConnection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::VpnConnection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::VpnConnection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::VpnConnection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [nat_gateway_ip][crate::model::VpnConnection::nat_gateway_ip].
    pub fn set_nat_gateway_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.nat_gateway_ip = v.into();
        self
    }

    /// Sets the value of [bgp_routing_mode][crate::model::VpnConnection::bgp_routing_mode].
    #[deprecated]
    pub fn set_bgp_routing_mode<T: std::convert::Into<crate::model::vpn_connection::BgpRoutingMode>>(mut self, v: T) -> Self {
        self.bgp_routing_mode = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::VpnConnection::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }

    /// Sets the value of [vpc][crate::model::VpnConnection::vpc].
    pub fn set_vpc<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc = v.into();
        self
    }

    /// Sets the value of [vpc_project][crate::model::VpnConnection::vpc_project].
    pub fn set_vpc_project<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vpn_connection::VpcProject>
    {
        self.vpc_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpc_project][crate::model::VpnConnection::vpc_project].
    pub fn set_or_clear_vpc_project<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vpn_connection::VpcProject>
    {
        self.vpc_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [enable_high_availability][crate::model::VpnConnection::enable_high_availability].
    pub fn set_enable_high_availability<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_high_availability = v.into();
        self
    }

    /// Sets the value of [router][crate::model::VpnConnection::router].
    pub fn set_router<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.router = v.into();
        self
    }

    /// Sets the value of [details][crate::model::VpnConnection::details].
    pub fn set_details<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::vpn_connection::Details>
    {
        self.details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [details][crate::model::VpnConnection::details].
    pub fn set_or_clear_details<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::vpn_connection::Details>
    {
        self.details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VpnConnection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection"
    }
}

/// Defines additional types related to [VpnConnection].
pub mod vpn_connection {
    #[allow(unused_imports)]
    use super::*;


    /// Project detail of the VPC network.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VpcProject {

        /// The project of the VPC to connect to. If not specified, it is the same as
        /// the cluster project.
        pub project_id: std::string::String,

        /// Optional. Deprecated: do not use.
        #[deprecated]
        pub service_account: std::string::String,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VpcProject {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [project_id][crate::model::vpn_connection::VpcProject::project_id].
        pub fn set_project_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.project_id = v.into();
            self
        }

        /// Sets the value of [service_account][crate::model::vpn_connection::VpcProject::service_account].
        #[deprecated]
        pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for VpcProject {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.VpcProject"
        }
    }

    /// The created connection details.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Details {

        /// The state of this connection.
        pub state: crate::model::vpn_connection::details::State,

        /// The error message. This is only populated when state=ERROR.
        pub error: std::string::String,

        /// The Cloud Router info.
        pub cloud_router: std::option::Option<crate::model::vpn_connection::details::CloudRouter>,

        /// Each connection has multiple Cloud VPN gateways.
        pub cloud_vpns: std::vec::Vec<crate::model::vpn_connection::details::CloudVpn>,

        pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Details {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [state][crate::model::vpn_connection::Details::state].
        pub fn set_state<T: std::convert::Into<crate::model::vpn_connection::details::State>>(mut self, v: T) -> Self {
            self.state = v.into();
            self
        }

        /// Sets the value of [error][crate::model::vpn_connection::Details::error].
        pub fn set_error<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.error = v.into();
            self
        }

        /// Sets the value of [cloud_router][crate::model::vpn_connection::Details::cloud_router].
        pub fn set_cloud_router<T>(mut self, v: T) -> Self
        where T: std::convert::Into<crate::model::vpn_connection::details::CloudRouter>
        {
            self.cloud_router = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [cloud_router][crate::model::vpn_connection::Details::cloud_router].
        pub fn set_or_clear_cloud_router<T>(mut self, v: std::option::Option<T>) -> Self
        where T: std::convert::Into<crate::model::vpn_connection::details::CloudRouter>
        {
            self.cloud_router = v.map(|x| x.into());
            self
        }

        /// Sets the value of [cloud_vpns][crate::model::vpn_connection::Details::cloud_vpns].
        pub fn set_cloud_vpns<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::vpn_connection::details::CloudVpn>
        {
            use std::iter::Iterator;
            self.cloud_vpns = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Details {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details"
        }
    }

    /// Defines additional types related to [Details].
    pub mod details {
        #[allow(unused_imports)]
        use super::*;


        /// The Cloud Router info.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CloudRouter {

            /// The associated Cloud Router name.
            pub name: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CloudRouter {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [name][crate::model::vpn_connection::details::CloudRouter::name].
            pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.name = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudRouter {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudRouter"
            }
        }

        /// The Cloud VPN info.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct CloudVpn {

            /// The created Cloud VPN gateway name.
            pub gateway: std::string::String,

            pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl CloudVpn {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [gateway][crate::model::vpn_connection::details::CloudVpn::gateway].
            pub fn set_gateway<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.gateway = v.into();
                self
            }
        }

        impl wkt::message::Message for CloudVpn {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.edgecontainer.v1.VpnConnection.Details.CloudVpn"
            }
        }

        /// The current connection state.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Unknown.
            Unspecified,
            /// Connected.
            Connected,
            /// Still connecting.
            Connecting,
            /// Error occurred.
            Error,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Connected => std::option::Option::Some(1),
                    Self::Connecting => std::option::Option::Some(2),
                    Self::Error => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Connected => std::option::Option::Some("STATE_CONNECTED"),
                    Self::Connecting => std::option::Option::Some("STATE_CONNECTING"),
                    Self::Error => std::option::Option::Some("STATE_ERROR"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Connected,
                    2 => Self::Connecting,
                    3 => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "STATE_CONNECTED" => Self::Connected,
                    "STATE_CONNECTING" => Self::Connecting,
                    "STATE_ERROR" => Self::Error,
                    _ => Self::UnknownValue(state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Connected => serializer.serialize_i32(1),
                    Self::Connecting => serializer.serialize_i32(2),
                    Self::Error => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.edgecontainer.v1.VpnConnection.Details.State"))
            }
        }
    }

    /// Routing mode.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BgpRoutingMode {
        /// Unknown.
        Unspecified,
        /// Regional mode.
        Regional,
        /// Global mode.
        Global,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BgpRoutingMode::value] or
        /// [BgpRoutingMode::name].
        UnknownValue(bgp_routing_mode::UnknownValue),
    }

    #[doc(hidden)]
    pub mod bgp_routing_mode {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BgpRoutingMode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Regional => std::option::Option::Some(1),
                Self::Global => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BGP_ROUTING_MODE_UNSPECIFIED"),
                Self::Regional => std::option::Option::Some("REGIONAL"),
                Self::Global => std::option::Option::Some("GLOBAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BgpRoutingMode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BgpRoutingMode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BgpRoutingMode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Regional,
                2 => Self::Global,
                _ => Self::UnknownValue(bgp_routing_mode::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for BgpRoutingMode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BGP_ROUTING_MODE_UNSPECIFIED" => Self::Unspecified,
                "REGIONAL" => Self::Regional,
                "GLOBAL" => Self::Global,
                _ => Self::UnknownValue(bgp_routing_mode::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for BgpRoutingMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Regional => serializer.serialize_i32(1),
                Self::Global => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BgpRoutingMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BgpRoutingMode>::new(
                ".google.cloud.edgecontainer.v1.VpnConnection.BgpRoutingMode"))
        }
    }
}

/// Metadata for a given
/// [google.cloud.location.Location][google.cloud.location.Location].
///
/// [google.cloud.location.Location]: location::model::Location
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LocationMetadata {

    /// The set of available Google Distributed Cloud Edge zones in the location.
    /// The map is keyed by the lowercase ID of each zone.
    pub available_zones: std::collections::HashMap<std::string::String,crate::model::ZoneMetadata>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LocationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_zones][crate::model::LocationMetadata::available_zones].
    pub fn set_available_zones<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ZoneMetadata>,
    {
        use std::iter::Iterator;
        self.available_zones = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for LocationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.LocationMetadata"
    }
}

/// A Google Distributed Cloud Edge zone where edge machines are located.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ZoneMetadata {

    /// Quota for resources in this zone.
    pub quota: std::vec::Vec<crate::model::Quota>,

    /// The map keyed by rack name and has value of RackType.
    pub rack_types: std::collections::HashMap<std::string::String,crate::model::zone_metadata::RackType>,

    /// Config data for the zone.
    pub config_data: std::option::Option<crate::model::ConfigData>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ZoneMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [quota][crate::model::ZoneMetadata::quota].
    pub fn set_quota<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Quota>
    {
        use std::iter::Iterator;
        self.quota = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [rack_types][crate::model::ZoneMetadata::rack_types].
    pub fn set_rack_types<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::zone_metadata::RackType>,
    {
        use std::iter::Iterator;
        self.rack_types = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [config_data][crate::model::ZoneMetadata::config_data].
    pub fn set_config_data<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::ConfigData>
    {
        self.config_data = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config_data][crate::model::ZoneMetadata::config_data].
    pub fn set_or_clear_config_data<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::ConfigData>
    {
        self.config_data = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ZoneMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ZoneMetadata"
    }
}

/// Defines additional types related to [ZoneMetadata].
pub mod zone_metadata {
    #[allow(unused_imports)]
    use super::*;


    /// Type of the rack.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RackType {
        /// Unspecified rack type, single rack also belongs to this type.
        Unspecified,
        /// Base rack type, a pair of two modified Config-1 racks containing
        /// Aggregation switches.
        Base,
        /// Expansion rack type, also known as standalone racks,
        /// added by customers on demand.
        Expansion,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RackType::value] or
        /// [RackType::name].
        UnknownValue(rack_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod rack_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RackType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Base => std::option::Option::Some(1),
                Self::Expansion => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RACK_TYPE_UNSPECIFIED"),
                Self::Base => std::option::Option::Some("BASE"),
                Self::Expansion => std::option::Option::Some("EXPANSION"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RackType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RackType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RackType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Base,
                2 => Self::Expansion,
                _ => Self::UnknownValue(rack_type::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for RackType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RACK_TYPE_UNSPECIFIED" => Self::Unspecified,
                "BASE" => Self::Base,
                "EXPANSION" => Self::Expansion,
                _ => Self::UnknownValue(rack_type::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for RackType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Base => serializer.serialize_i32(1),
                Self::Expansion => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RackType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RackType>::new(
                ".google.cloud.edgecontainer.v1.ZoneMetadata.RackType"))
        }
    }
}

/// Config data holds all the config related data for the zone.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ConfigData {

    /// list of available v4 ip pools for external loadbalancer
    pub available_external_lb_pools_ipv4: std::vec::Vec<std::string::String>,

    /// list of available v6 ip pools for external loadbalancer
    pub available_external_lb_pools_ipv6: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ConfigData {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [available_external_lb_pools_ipv4][crate::model::ConfigData::available_external_lb_pools_ipv4].
    pub fn set_available_external_lb_pools_ipv4<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv4 = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [available_external_lb_pools_ipv6][crate::model::ConfigData::available_external_lb_pools_ipv6].
    pub fn set_available_external_lb_pools_ipv6<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.available_external_lb_pools_ipv6 = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ConfigData {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ConfigData"
    }
}

/// Represents quota for Edge Container resources.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Quota {

    /// Name of the quota metric.
    pub metric: std::string::String,

    /// Quota limit for this metric.
    pub limit: f64,

    /// Current usage of this metric.
    pub usage: f64,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Quota {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [metric][crate::model::Quota::metric].
    pub fn set_metric<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.metric = v.into();
        self
    }

    /// Sets the value of [limit][crate::model::Quota::limit].
    pub fn set_limit<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.limit = v.into();
        self
    }

    /// Sets the value of [usage][crate::model::Quota::usage].
    pub fn set_usage<T: std::convert::Into<f64>>(mut self, v: T) -> Self {
        self.usage = v.into();
        self
    }
}

impl wkt::message::Message for Quota {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Quota"
    }
}

/// Maintenance policy configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenancePolicy {

    /// Specifies the maintenance window in which maintenance may be performed.
    pub window: std::option::Option<crate::model::MaintenanceWindow>,

    /// Optional. Exclusions to automatic maintenance. Non-emergency maintenance
    /// should not occur in these windows. Each exclusion has a unique name and may
    /// be active or expired. The max number of maintenance exclusions allowed at a
    /// given time is 3.
    pub maintenance_exclusions: std::vec::Vec<crate::model::MaintenanceExclusionWindow>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenancePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::MaintenanceWindow>
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::MaintenancePolicy::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::MaintenanceWindow>
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [maintenance_exclusions][crate::model::MaintenancePolicy::maintenance_exclusions].
    pub fn set_maintenance_exclusions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MaintenanceExclusionWindow>
    {
        use std::iter::Iterator;
        self.maintenance_exclusions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for MaintenancePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenancePolicy"
    }
}

/// Maintenance window configuration
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceWindow {

    /// Configuration of a recurring maintenance window.
    pub recurring_window: std::option::Option<crate::model::RecurringTimeWindow>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [recurring_window][crate::model::MaintenanceWindow::recurring_window].
    pub fn set_recurring_window<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::RecurringTimeWindow>
    {
        self.recurring_window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [recurring_window][crate::model::MaintenanceWindow::recurring_window].
    pub fn set_or_clear_recurring_window<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::RecurringTimeWindow>
    {
        self.recurring_window = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MaintenanceWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceWindow"
    }
}

/// Represents an arbitrary window of time that recurs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RecurringTimeWindow {

    /// The window of the first recurrence.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// An RRULE (<https://tools.ietf.org/html/rfc5545#section-3.8.5.3>) for how
    /// this window recurs. They go on for the span of time between the start and
    /// end time.
    pub recurrence: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RecurringTimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TimeWindow>
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::RecurringTimeWindow::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TimeWindow>
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recurrence][crate::model::RecurringTimeWindow::recurrence].
    pub fn set_recurrence<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.recurrence = v.into();
        self
    }
}

impl wkt::message::Message for RecurringTimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.RecurringTimeWindow"
    }
}

/// Represents a maintenance exclusion window.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MaintenanceExclusionWindow {

    /// Optional. The time window.
    pub window: std::option::Option<crate::model::TimeWindow>,

    /// Optional. A unique (per cluster) id for the window.
    pub id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MaintenanceExclusionWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [window][crate::model::MaintenanceExclusionWindow::window].
    pub fn set_window<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::TimeWindow>
    {
        self.window = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [window][crate::model::MaintenanceExclusionWindow::window].
    pub fn set_or_clear_window<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::TimeWindow>
    {
        self.window = v.map(|x| x.into());
        self
    }

    /// Sets the value of [id][crate::model::MaintenanceExclusionWindow::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }
}

impl wkt::message::Message for MaintenanceExclusionWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.MaintenanceExclusionWindow"
    }
}

/// Represents an arbitrary window of time.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TimeWindow {

    /// The time that the window first starts.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time that the window ends. The end time must take place after the
    /// start time.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TimeWindow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::TimeWindow::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::TimeWindow::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TimeWindow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.TimeWindow"
    }
}

/// Server configuration for supported versions and release channels.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServerConfig {

    /// Output only. Mapping from release channel to channel config.
    pub channels: std::collections::HashMap<std::string::String,crate::model::ChannelConfig>,

    /// Output only. Supported versions, e.g.: ["1.4.0", "1.5.0"].
    pub versions: std::vec::Vec<crate::model::Version>,

    /// Output only. Default version, e.g.: "1.4.0".
    pub default_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServerConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [channels][crate::model::ServerConfig::channels].
    pub fn set_channels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::ChannelConfig>,
    {
        use std::iter::Iterator;
        self.channels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [versions][crate::model::ServerConfig::versions].
    pub fn set_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Version>
    {
        use std::iter::Iterator;
        self.versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [default_version][crate::model::ServerConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }
}

impl wkt::message::Message for ServerConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ServerConfig"
    }
}

/// Configuration for a release channel.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ChannelConfig {

    /// Output only. Default version for this release channel, e.g.: "1.4.0".
    pub default_version: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ChannelConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_version][crate::model::ChannelConfig::default_version].
    pub fn set_default_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_version = v.into();
        self
    }
}

impl wkt::message::Message for ChannelConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ChannelConfig"
    }
}

/// Version of a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Version {

    /// Output only. Name of the version, e.g.: "1.4.0".
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Version {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Version::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Version {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.Version"
    }
}

/// Long-running operation metadata for Edge Container API methods.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {

    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// The verb executed by the operation.
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation of the operation.
    /// Operations that have successfully been cancelled have [Operation.error][]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    pub api_version: std::string::String,

    /// Warnings that do not block the operation, but still hold relevant
    /// information for the end user to receive.
    pub warnings: std::vec::Vec<std::string::String>,

    /// Machine-readable status of the operation, if any.
    pub status_reason: crate::model::operation_metadata::StatusReason,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [warnings][crate::model::OperationMetadata::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [status_reason][crate::model::OperationMetadata::status_reason].
    pub fn set_status_reason<T: std::convert::Into<crate::model::operation_metadata::StatusReason>>(mut self, v: T) -> Self {
        self.status_reason = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.OperationMetadata"
    }
}

/// Defines additional types related to [OperationMetadata].
pub mod operation_metadata {
    #[allow(unused_imports)]
    use super::*;


    /// Indicates the reason for the status of the operation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StatusReason {
        /// Reason unknown.
        Unspecified,
        /// The cluster upgrade is currently paused.
        UpgradePaused,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StatusReason::value] or
        /// [StatusReason::name].
        UnknownValue(status_reason::UnknownValue),
    }

    #[doc(hidden)]
    pub mod status_reason {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StatusReason {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UpgradePaused => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATUS_REASON_UNSPECIFIED"),
                Self::UpgradePaused => std::option::Option::Some("UPGRADE_PAUSED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StatusReason {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StatusReason {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StatusReason {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UpgradePaused,
                _ => Self::UnknownValue(status_reason::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for StatusReason {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATUS_REASON_UNSPECIFIED" => Self::Unspecified,
                "UPGRADE_PAUSED" => Self::UpgradePaused,
                _ => Self::UnknownValue(status_reason::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for StatusReason {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UpgradePaused => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StatusReason {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StatusReason>::new(
                ".google.cloud.edgecontainer.v1.OperationMetadata.StatusReason"))
        }
    }
}

/// Lists clusters in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersRequest {

    /// Required. The parent location, which owns this collection of clusters.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListClustersRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListClustersRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersRequest"
    }
}

/// List of clusters in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListClustersResponse {

    /// Clusters in the location.
    pub clusters: std::vec::Vec<crate::model::Cluster>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clusters][crate::model::ListClustersResponse::clusters].
    pub fn set_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Cluster>
    {
        use std::iter::Iterator;
        self.clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListClustersResponse {
    type PageItem = crate::model::Cluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetClusterRequest {

    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetClusterRequest"
    }
}

/// Creates a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateClusterRequest {

    /// Required. The parent location where this cluster will be created.
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the cluster.
    pub cluster_id: std::string::String,

    /// Required. The cluster to create.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cluster_id][crate::model::CreateClusterRequest::cluster_id].
    pub fn set_cluster_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster_id = v.into();
        self
    }

    /// Sets the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Cluster>
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::CreateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Cluster>
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateClusterRequest"
    }
}

/// Updates a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateClusterRequest {

    /// Field mask is used to specify the fields to be overwritten in the
    /// Cluster resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated cluster.
    pub cluster: std::option::Option<crate::model::Cluster>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters.
    /// A random UUID is recommended.
    /// This request is only idempotent if `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_cluster<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::Cluster>
    {
        self.cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cluster][crate::model::UpdateClusterRequest::cluster].
    pub fn set_or_clear_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::Cluster>
    {
        self.cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateClusterRequest"
    }
}

/// Upgrades a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeClusterRequest {

    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// Required. The version the cluster is going to be upgraded to.
    pub target_version: std::string::String,

    /// The schedule for the upgrade.
    pub schedule: crate::model::upgrade_cluster_request::Schedule,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeClusterRequest::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }

    /// Sets the value of [schedule][crate::model::UpgradeClusterRequest::schedule].
    pub fn set_schedule<T: std::convert::Into<crate::model::upgrade_cluster_request::Schedule>>(mut self, v: T) -> Self {
        self.schedule = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpgradeClusterRequest"
    }
}

/// Defines additional types related to [UpgradeClusterRequest].
pub mod upgrade_cluster_request {
    #[allow(unused_imports)]
    use super::*;


    /// Represents the schedule about when the cluster is going to be upgraded.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Schedule {
        /// Unspecified. The default is to upgrade the cluster immediately which is
        /// the only option today.
        Unspecified,
        /// The cluster is going to be upgraded immediately after receiving the
        /// request.
        Immediately,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Schedule::value] or
        /// [Schedule::name].
        UnknownValue(schedule::UnknownValue),
    }

    #[doc(hidden)]
    pub mod schedule {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Schedule {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Immediately => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SCHEDULE_UNSPECIFIED"),
                Self::Immediately => std::option::Option::Some("IMMEDIATELY"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Schedule {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Schedule {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Schedule {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Immediately,
                _ => Self::UnknownValue(schedule::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
            }
        }
    }

    impl std::convert::From<&str> for Schedule {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SCHEDULE_UNSPECIFIED" => Self::Unspecified,
                "IMMEDIATELY" => Self::Immediately,
                _ => Self::UnknownValue(schedule::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
            }
        }
    }

    impl serde::ser::Serialize for Schedule {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Immediately => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Schedule {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Schedule>::new(
                ".google.cloud.edgecontainer.v1.UpgradeClusterRequest.Schedule"))
        }
    }
}

/// Deletes a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteClusterRequest {

    /// Required. The resource name of the cluster.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteClusterRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteClusterRequest"
    }
}

/// Generates an access token for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenRequest {

    /// Required. The resource name of the cluster.
    pub cluster: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateAccessTokenRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenRequest"
    }
}

/// An access token for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenResponse {

    /// Output only. Access token to authenticate to k8s api-server.
    pub access_token: std::string::String,

    /// Output only. Timestamp at which the token will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateAccessTokenResponse"
    }
}

/// Generates an offline credential(offline) for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOfflineCredentialRequest {

    /// Required. The resource name of the cluster.
    pub cluster: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOfflineCredentialRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cluster][crate::model::GenerateOfflineCredentialRequest::cluster].
    pub fn set_cluster<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cluster = v.into();
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialRequest"
    }
}

/// An offline credential for a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateOfflineCredentialResponse {

    /// Output only. Client certificate to authenticate to k8s api-server.
    pub client_certificate: std::string::String,

    /// Output only. Client private key to authenticate to k8s api-server.
    pub client_key: std::string::String,

    /// Output only. Client's identity.
    pub user_id: std::string::String,

    /// Output only. Timestamp at which this credential will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateOfflineCredentialResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [client_certificate][crate::model::GenerateOfflineCredentialResponse::client_certificate].
    pub fn set_client_certificate<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_certificate = v.into();
        self
    }

    /// Sets the value of [client_key][crate::model::GenerateOfflineCredentialResponse::client_key].
    pub fn set_client_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.client_key = v.into();
        self
    }

    /// Sets the value of [user_id][crate::model::GenerateOfflineCredentialResponse::user_id].
    pub fn set_user_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.user_id = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateOfflineCredentialResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GenerateOfflineCredentialResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::Timestamp>
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateOfflineCredentialResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GenerateOfflineCredentialResponse"
    }
}

/// Lists node pools in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsRequest {

    /// Required. The parent cluster, which owns this collection of node pools.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListNodePoolsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListNodePoolsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListNodePoolsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListNodePoolsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListNodePoolsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListNodePoolsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsRequest"
    }
}

/// List of node pools in a cluster.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListNodePoolsResponse {

    /// Node pools in the cluster.
    pub node_pools: std::vec::Vec<crate::model::NodePool>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListNodePoolsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [node_pools][crate::model::ListNodePoolsResponse::node_pools].
    pub fn set_node_pools<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NodePool>
    {
        use std::iter::Iterator;
        self.node_pools = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListNodePoolsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListNodePoolsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListNodePoolsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListNodePoolsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListNodePoolsResponse {
    type PageItem = crate::model::NodePool;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.node_pools
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetNodePoolRequest {

    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetNodePoolRequest"
    }
}

/// Creates a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateNodePoolRequest {

    /// Required. The parent cluster where this node pool will be created.
    pub parent: std::string::String,

    /// Required. A client-specified unique identifier for the node pool.
    pub node_pool_id: std::string::String,

    /// Required. The node pool to create.
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateNodePoolRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [node_pool_id][crate::model::CreateNodePoolRequest::node_pool_id].
    pub fn set_node_pool_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.node_pool_id = v.into();
        self
    }

    /// Sets the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_node_pool<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::NodePool>
    {
        self.node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool][crate::model::CreateNodePoolRequest::node_pool].
    pub fn set_or_clear_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::NodePool>
    {
        self.node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateNodePoolRequest"
    }
}

/// Updates a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateNodePoolRequest {

    /// Field mask is used to specify the fields to be overwritten in the
    /// NodePool resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// The updated node pool.
    pub node_pool: std::option::Option<crate::model::NodePool>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateNodePoolRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateNodePoolRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<wkt::FieldMask>
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [node_pool][crate::model::UpdateNodePoolRequest::node_pool].
    pub fn set_node_pool<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::NodePool>
    {
        self.node_pool = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [node_pool][crate::model::UpdateNodePoolRequest::node_pool].
    pub fn set_or_clear_node_pool<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::NodePool>
    {
        self.node_pool = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.UpdateNodePoolRequest"
    }
}

/// Deletes a node pool.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteNodePoolRequest {

    /// Required. The resource name of the node pool.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteNodePoolRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteNodePoolRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteNodePoolRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteNodePoolRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteNodePoolRequest"
    }
}

/// Lists machines in a site.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMachinesRequest {

    /// Required. The parent site, which owns this collection of machines.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMachinesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMachinesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMachinesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMachinesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMachinesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMachinesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListMachinesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesRequest"
    }
}

/// List of machines in a site.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMachinesResponse {

    /// Machines in the site.
    pub machines: std::vec::Vec<crate::model::Machine>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMachinesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machines][crate::model::ListMachinesResponse::machines].
    pub fn set_machines<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Machine>
    {
        use std::iter::Iterator;
        self.machines = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMachinesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMachinesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMachinesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListMachinesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMachinesResponse {
    type PageItem = crate::model::Machine;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.machines
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets a machine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMachineRequest {

    /// Required. The resource name of the machine.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMachineRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMachineRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetMachineRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetMachineRequest"
    }
}

/// Lists VPN connections.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpnConnectionsRequest {

    /// Required. The parent location, which owns this collection of VPN
    /// connections.
    pub parent: std::string::String,

    /// The maximum number of resources to list.
    pub page_size: i32,

    /// A page token received from previous list request.
    pub page_token: std::string::String,

    /// Only resources matching this filter will be listed.
    pub filter: std::string::String,

    /// Specifies the order in which resources will be listed.
    pub order_by: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpnConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListVpnConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListVpnConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListVpnConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListVpnConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListVpnConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsRequest"
    }
}

/// List of VPN connections in a location.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListVpnConnectionsResponse {

    /// VpnConnections in the location.
    pub vpn_connections: std::vec::Vec<crate::model::VpnConnection>,

    /// A token to retrieve next page of results.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListVpnConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vpn_connections][crate::model::ListVpnConnectionsResponse::vpn_connections].
    pub fn set_vpn_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VpnConnection>
    {
        use std::iter::Iterator;
        self.vpn_connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListVpnConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListVpnConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListVpnConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.ListVpnConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListVpnConnectionsResponse {
    type PageItem = crate::model::VpnConnection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.vpn_connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Gets a VPN connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetVpnConnectionRequest {

    /// Required. The resource name of the vpn connection.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetVpnConnectionRequest"
    }
}

/// Creates a VPN connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateVpnConnectionRequest {

    /// Required. The parent location where this vpn connection will be created.
    pub parent: std::string::String,

    /// Required. The VPN connection identifier.
    pub vpn_connection_id: std::string::String,

    /// Required. The VPN connection to create.
    pub vpn_connection: std::option::Option<crate::model::VpnConnection>,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateVpnConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [vpn_connection_id][crate::model::CreateVpnConnectionRequest::vpn_connection_id].
    pub fn set_vpn_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpn_connection_id = v.into();
        self
    }

    /// Sets the value of [vpn_connection][crate::model::CreateVpnConnectionRequest::vpn_connection].
    pub fn set_vpn_connection<T>(mut self, v: T) -> Self
    where T: std::convert::Into<crate::model::VpnConnection>
    {
        self.vpn_connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vpn_connection][crate::model::CreateVpnConnectionRequest::vpn_connection].
    pub fn set_or_clear_vpn_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where T: std::convert::Into<crate::model::VpnConnection>
    {
        self.vpn_connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.CreateVpnConnectionRequest"
    }
}

/// Deletes a vpn connection.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteVpnConnectionRequest {

    /// Required. The resource name of the vpn connection.
    pub name: std::string::String,

    /// A unique identifier for this request. Restricted to 36 ASCII characters. A
    /// random UUID is recommended. This request is only idempotent if
    /// `request_id` is provided.
    pub request_id: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteVpnConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteVpnConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteVpnConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteVpnConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.DeleteVpnConnectionRequest"
    }
}

/// Gets the server config.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetServerConfigRequest {

    /// Required. The name (project and location) of the server config to get,
    /// specified in the format `projects/*/locations/*`.
    pub name: std::string::String,

    pub(crate) _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetServerConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetServerConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetServerConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.edgecontainer.v1.GetServerConfigRequest"
    }
}

/// Represents the accessibility state of a customer-managed KMS key used for
/// CMEK integration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum KmsKeyState {
    /// Unspecified.
    Unspecified,
    /// The key is available for use, and dependent resources should be accessible.
    KeyAvailable,
    /// The key is unavailable for an unspecified reason. Dependent resources may
    /// be inaccessible.
    KeyUnavailable,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [KmsKeyState::value] or
    /// [KmsKeyState::name].
    UnknownValue(kms_key_state::UnknownValue),
}

#[doc(hidden)]
pub mod kms_key_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl KmsKeyState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::KeyAvailable => std::option::Option::Some(1),
            Self::KeyUnavailable => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("KMS_KEY_STATE_UNSPECIFIED"),
            Self::KeyAvailable => std::option::Option::Some("KMS_KEY_STATE_KEY_AVAILABLE"),
            Self::KeyUnavailable => std::option::Option::Some("KMS_KEY_STATE_KEY_UNAVAILABLE"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for KmsKeyState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for KmsKeyState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for KmsKeyState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::KeyAvailable,
            2 => Self::KeyUnavailable,
            _ => Self::UnknownValue(kms_key_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for KmsKeyState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "KMS_KEY_STATE_UNSPECIFIED" => Self::Unspecified,
            "KMS_KEY_STATE_KEY_AVAILABLE" => Self::KeyAvailable,
            "KMS_KEY_STATE_KEY_UNAVAILABLE" => Self::KeyUnavailable,
            _ => Self::UnknownValue(kms_key_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for KmsKeyState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::KeyAvailable => serializer.serialize_i32(1),
            Self::KeyUnavailable => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for KmsKeyState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<KmsKeyState>::new(
            ".google.cloud.edgecontainer.v1.KmsKeyState"))
    }
}

/// Represents if the resource is in lock down state or pending.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ResourceState {
    /// Default value.
    Unspecified,
    /// The resource is in LOCK DOWN state.
    LockDown,
    /// The resource is pending lock down.
    LockDownPending,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ResourceState::value] or
    /// [ResourceState::name].
    UnknownValue(resource_state::UnknownValue),
}

#[doc(hidden)]
pub mod resource_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ResourceState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::LockDown => std::option::Option::Some(1),
            Self::LockDownPending => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("RESOURCE_STATE_UNSPECIFIED"),
            Self::LockDown => std::option::Option::Some("RESOURCE_STATE_LOCK_DOWN"),
            Self::LockDownPending => std::option::Option::Some("RESOURCE_STATE_LOCK_DOWN_PENDING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ResourceState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ResourceState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ResourceState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::LockDown,
            2 => Self::LockDownPending,
            _ => Self::UnknownValue(resource_state::UnknownValue(wkt::internal::UnknownEnumValue::Integer(value))),
        }
    }
}

impl std::convert::From<&str> for ResourceState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "RESOURCE_STATE_UNSPECIFIED" => Self::Unspecified,
            "RESOURCE_STATE_LOCK_DOWN" => Self::LockDown,
            "RESOURCE_STATE_LOCK_DOWN_PENDING" => Self::LockDownPending,
            _ => Self::UnknownValue(resource_state::UnknownValue(wkt::internal::UnknownEnumValue::String(value.to_string()))),
        }
    }
}

impl serde::ser::Serialize for ResourceState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::LockDown => serializer.serialize_i32(1),
            Self::LockDownPending => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ResourceState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ResourceState>::new(
            ".google.cloud.edgecontainer.v1.ResourceState"))
    }
}
