// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A workstation cluster resource in the Cloud Workstations API.
///
/// Defines a group of workstations in a particular region and the
/// VPC network they're attached to.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkstationCluster {
    /// Full name of this workstation cluster.
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation cluster.
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation
    /// cluster.
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation cluster is currently being
    /// updated to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation cluster and that are also propagated to the
    /// underlying Compute Engine resources.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation cluster was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation cluster was most recently updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation cluster was soft-deleted.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    pub etag: std::string::String,

    /// Immutable. Name of the Compute Engine network in which instances associated
    /// with this workstation cluster will be created.
    pub network: std::string::String,

    /// Immutable. Name of the Compute Engine subnetwork in which instances
    /// associated with this workstation cluster will be created. Must be part of
    /// the subnetwork specified for this workstation cluster.
    pub subnetwork: std::string::String,

    /// Output only. The private IP address of the control plane for this
    /// workstation cluster. Workstation VMs need access to this IP address to work
    /// with the service, so make sure that your firewall rules allow egress from
    /// the workstation VMs to this address.
    pub control_plane_ip: std::string::String,

    /// Optional. Configuration for private workstation cluster.
    pub private_cluster_config:
        std::option::Option<crate::model::workstation_cluster::PrivateClusterConfig>,

    /// Output only. Whether this workstation cluster is in degraded mode, in which
    /// case it may require user action to restore full functionality. Details can
    /// be found in
    /// [conditions][google.cloud.workstations.v1.WorkstationCluster.conditions].
    ///
    /// [google.cloud.workstations.v1.WorkstationCluster.conditions]: crate::model::WorkstationCluster::conditions
    pub degraded: bool,

    /// Output only. Status conditions describing the workstation cluster's current
    /// state.
    pub conditions: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkstationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkstationCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkstationCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkstationCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::WorkstationCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkstationCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::WorkstationCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkstationCluster::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkstationCluster::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkstationCluster::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkstationCluster::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkstationCluster::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::WorkstationCluster::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::WorkstationCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [network][crate::model::WorkstationCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::WorkstationCluster::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [control_plane_ip][crate::model::WorkstationCluster::control_plane_ip].
    pub fn set_control_plane_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_ip = v.into();
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::WorkstationCluster::private_cluster_config].
    pub fn set_private_cluster_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workstation_cluster::PrivateClusterConfig>,
    {
        self.private_cluster_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [private_cluster_config][crate::model::WorkstationCluster::private_cluster_config].
    pub fn set_or_clear_private_cluster_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workstation_cluster::PrivateClusterConfig>,
    {
        self.private_cluster_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [degraded][crate::model::WorkstationCluster::degraded].
    pub fn set_degraded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.degraded = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::WorkstationCluster::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkstationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.WorkstationCluster"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkstationCluster {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __reconciling,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __delete_time,
            __etag,
            __network,
            __subnetwork,
            __control_plane_ip,
            __private_cluster_config,
            __degraded,
            __conditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkstationCluster")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "controlPlaneIp" => Ok(__FieldTag::__control_plane_ip),
                            "control_plane_ip" => Ok(__FieldTag::__control_plane_ip),
                            "privateClusterConfig" => Ok(__FieldTag::__private_cluster_config),
                            "private_cluster_config" => Ok(__FieldTag::__private_cluster_config),
                            "degraded" => Ok(__FieldTag::__degraded),
                            "conditions" => Ok(__FieldTag::__conditions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkstationCluster;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkstationCluster")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__control_plane_ip => {
                            if !fields.insert(__FieldTag::__control_plane_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for control_plane_ip",
                                ));
                            }
                            result.control_plane_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__private_cluster_config => {
                            if !fields.insert(__FieldTag::__private_cluster_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for private_cluster_config",
                                ));
                            }
                            result.private_cluster_config = map.next_value::<std::option::Option<
                                crate::model::workstation_cluster::PrivateClusterConfig,
                            >>()?;
                        }
                        __FieldTag::__degraded => {
                            if !fields.insert(__FieldTag::__degraded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for degraded",
                                ));
                            }
                            result.degraded = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkstationCluster {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.control_plane_ip.is_empty() {
            state.serialize_entry("controlPlaneIp", &self.control_plane_ip)?;
        }
        if self.private_cluster_config.is_some() {
            state.serialize_entry("privateClusterConfig", &self.private_cluster_config)?;
        }
        if !wkt::internal::is_default(&self.degraded) {
            state.serialize_entry("degraded", &self.degraded)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkstationCluster].
pub mod workstation_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration options for private workstation clusters.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PrivateClusterConfig {
        /// Immutable. Whether Workstations endpoint is private.
        pub enable_private_endpoint: bool,

        /// Output only. Hostname for the workstation cluster. This field will be
        /// populated only when private endpoint is enabled. To access workstations
        /// in the workstation cluster, create a new DNS zone mapping this domain
        /// name to an internal IP address and a forwarding rule mapping that address
        /// to the service attachment.
        pub cluster_hostname: std::string::String,

        /// Output only. Service attachment URI for the workstation cluster. The
        /// service attachemnt is created when private endpoint is enabled. To access
        /// workstations in the workstation cluster, configure access to the managed
        /// service using [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
        pub service_attachment_uri: std::string::String,

        /// Optional. Additional projects that are allowed to attach to the
        /// workstation cluster's service attachment. By default, the workstation
        /// cluster's project and the VPC host project (if different) are allowed.
        pub allowed_projects: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PrivateClusterConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_private_endpoint][crate::model::workstation_cluster::PrivateClusterConfig::enable_private_endpoint].
        pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_private_endpoint = v.into();
            self
        }

        /// Sets the value of [cluster_hostname][crate::model::workstation_cluster::PrivateClusterConfig::cluster_hostname].
        pub fn set_cluster_hostname<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_hostname = v.into();
            self
        }

        /// Sets the value of [service_attachment_uri][crate::model::workstation_cluster::PrivateClusterConfig::service_attachment_uri].
        pub fn set_service_attachment_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment_uri = v.into();
            self
        }

        /// Sets the value of [allowed_projects][crate::model::workstation_cluster::PrivateClusterConfig::allowed_projects].
        pub fn set_allowed_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_projects = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrivateClusterConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationCluster.PrivateClusterConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PrivateClusterConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __enable_private_endpoint,
                __cluster_hostname,
                __service_attachment_uri,
                __allowed_projects,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PrivateClusterConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "enablePrivateEndpoint" => {
                                    Ok(__FieldTag::__enable_private_endpoint)
                                }
                                "enable_private_endpoint" => {
                                    Ok(__FieldTag::__enable_private_endpoint)
                                }
                                "clusterHostname" => Ok(__FieldTag::__cluster_hostname),
                                "cluster_hostname" => Ok(__FieldTag::__cluster_hostname),
                                "serviceAttachmentUri" => Ok(__FieldTag::__service_attachment_uri),
                                "service_attachment_uri" => {
                                    Ok(__FieldTag::__service_attachment_uri)
                                }
                                "allowedProjects" => Ok(__FieldTag::__allowed_projects),
                                "allowed_projects" => Ok(__FieldTag::__allowed_projects),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PrivateClusterConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PrivateClusterConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__enable_private_endpoint => {
                                if !fields.insert(__FieldTag::__enable_private_endpoint) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for enable_private_endpoint",
                                    ));
                                }
                                result.enable_private_endpoint = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_hostname => {
                                if !fields.insert(__FieldTag::__cluster_hostname) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_hostname",
                                    ));
                                }
                                result.cluster_hostname = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__service_attachment_uri => {
                                if !fields.insert(__FieldTag::__service_attachment_uri) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for service_attachment_uri",
                                    ));
                                }
                                result.service_attachment_uri = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__allowed_projects => {
                                if !fields.insert(__FieldTag::__allowed_projects) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for allowed_projects",
                                    ));
                                }
                                result.allowed_projects = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PrivateClusterConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.enable_private_endpoint) {
                state.serialize_entry("enablePrivateEndpoint", &self.enable_private_endpoint)?;
            }
            if !self.cluster_hostname.is_empty() {
                state.serialize_entry("clusterHostname", &self.cluster_hostname)?;
            }
            if !self.service_attachment_uri.is_empty() {
                state.serialize_entry("serviceAttachmentUri", &self.service_attachment_uri)?;
            }
            if !self.allowed_projects.is_empty() {
                state.serialize_entry("allowedProjects", &self.allowed_projects)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A workstation configuration resource in the Cloud Workstations API.
///
/// Workstation configurations act as templates for workstations. The workstation
/// configuration defines details such as the workstation virtual machine (VM)
/// instance type, persistent storage, container image defining environment,
/// which IDE or Code Editor to use, and more. Administrators and platform teams
/// can also use [Identity and Access Management
/// (IAM)](https://cloud.google.com/iam/docs/overview) rules to grant access to
/// teams or to individual developers.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkstationConfig {
    /// Full name of this workstation configuration.
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation configuration.
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation
    /// configuration.
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation configuration is currently
    /// being updated to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation configuration and that are also propagated
    /// to the underlying Compute Engine resources.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation configuration was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation configuration was most recently
    /// updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation configuration was soft-deleted.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    pub etag: std::string::String,

    /// Optional. Number of seconds to wait before automatically stopping a
    /// workstation after it last received user traffic.
    ///
    /// A value of `"0s"` indicates that Cloud Workstations VMs created with this
    /// configuration should never time out due to idleness.
    /// Provide
    /// [duration](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration)
    /// terminated by `s` for seconds—for example, `"7200s"` (2 hours).
    /// The default is `"1200s"` (20 minutes).
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Number of seconds that a workstation can run until it is
    /// automatically shut down. We recommend that workstations be shut down daily
    /// to reduce costs and so that security updates can be applied upon restart.
    /// The
    /// [idle_timeout][google.cloud.workstations.v1.WorkstationConfig.idle_timeout]
    /// and
    /// [running_timeout][google.cloud.workstations.v1.WorkstationConfig.running_timeout]
    /// fields are independent of each other. Note that the
    /// [running_timeout][google.cloud.workstations.v1.WorkstationConfig.running_timeout]
    /// field shuts down VMs after the specified time, regardless of whether or not
    /// the VMs are idle.
    ///
    /// Provide duration terminated by `s` for seconds—for example, `"54000s"`
    /// (15 hours). Defaults to `"43200s"` (12 hours). A value of `"0s"` indicates
    /// that workstations using this configuration should never time out. If
    /// [encryption_key][google.cloud.workstations.v1.WorkstationConfig.encryption_key]
    /// is set, it must be greater than `"0s"` and less than
    /// `"86400s"` (24 hours).
    ///
    /// Warning: A value of `"0s"` indicates that Cloud Workstations VMs created
    /// with this configuration have no maximum running time. This is strongly
    /// discouraged because you incur costs and will not pick up security updates.
    ///
    /// [google.cloud.workstations.v1.WorkstationConfig.encryption_key]: crate::model::WorkstationConfig::encryption_key
    /// [google.cloud.workstations.v1.WorkstationConfig.idle_timeout]: crate::model::WorkstationConfig::idle_timeout
    /// [google.cloud.workstations.v1.WorkstationConfig.running_timeout]: crate::model::WorkstationConfig::running_timeout
    pub running_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Runtime host for the workstation.
    pub host: std::option::Option<crate::model::workstation_config::Host>,

    /// Optional. Directories to persist across workstation sessions.
    pub persistent_directories:
        std::vec::Vec<crate::model::workstation_config::PersistentDirectory>,

    /// Optional. Container that runs upon startup for each workstation using this
    /// workstation configuration.
    pub container: std::option::Option<crate::model::workstation_config::Container>,

    /// Immutable. Encrypts resources of this workstation configuration using a
    /// customer-managed encryption key (CMEK).
    ///
    /// If specified, the boot disk of the Compute Engine instance and the
    /// persistent disk are encrypted using this encryption key. If
    /// this field is not set, the disks are encrypted using a generated
    /// key. Customer-managed encryption keys do not protect disk metadata.
    ///
    /// If the customer-managed encryption key is rotated, when the workstation
    /// instance is stopped, the system attempts to recreate the
    /// persistent disk with the new version of the key. Be sure to keep
    /// older versions of the key until the persistent disk is recreated.
    /// Otherwise, data on the persistent disk might be lost.
    ///
    /// If the encryption key is revoked, the workstation session automatically
    /// stops within 7 hours.
    ///
    /// Immutable after the workstation configuration is created.
    pub encryption_key:
        std::option::Option<crate::model::workstation_config::CustomerEncryptionKey>,

    /// Optional. Readiness checks to perform when starting a workstation using
    /// this workstation configuration. Mark a workstation as running only after
    /// all specified readiness checks return 200 status codes.
    pub readiness_checks: std::vec::Vec<crate::model::workstation_config::ReadinessCheck>,

    /// Optional. Immutable. Specifies the zones used to replicate the VM and disk
    /// resources within the region. If set, exactly two zones within the
    /// workstation cluster's region must be specified—for example,
    /// `['us-central1-a', 'us-central1-f']`. If this field is empty, two default
    /// zones within the region are used.
    ///
    /// Immutable after the workstation configuration is created.
    pub replica_zones: std::vec::Vec<std::string::String>,

    /// Output only. Whether this resource is degraded, in which case it may
    /// require user action to restore full functionality. See also the
    /// [conditions][google.cloud.workstations.v1.WorkstationConfig.conditions]
    /// field.
    ///
    /// [google.cloud.workstations.v1.WorkstationConfig.conditions]: crate::model::WorkstationConfig::conditions
    pub degraded: bool,

    /// Output only. Status conditions describing the current resource state.
    pub conditions: std::vec::Vec<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkstationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkstationConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkstationConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkstationConfig::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::WorkstationConfig::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkstationConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::WorkstationConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkstationConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkstationConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkstationConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkstationConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkstationConfig::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::WorkstationConfig::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::WorkstationConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [idle_timeout][crate::model::WorkstationConfig::idle_timeout].
    pub fn set_idle_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_timeout][crate::model::WorkstationConfig::idle_timeout].
    pub fn set_or_clear_idle_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [running_timeout][crate::model::WorkstationConfig::running_timeout].
    pub fn set_running_timeout<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.running_timeout = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [running_timeout][crate::model::WorkstationConfig::running_timeout].
    pub fn set_or_clear_running_timeout<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.running_timeout = v.map(|x| x.into());
        self
    }

    /// Sets the value of [host][crate::model::WorkstationConfig::host].
    pub fn set_host<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::Host>,
    {
        self.host = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [host][crate::model::WorkstationConfig::host].
    pub fn set_or_clear_host<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::Host>,
    {
        self.host = v.map(|x| x.into());
        self
    }

    /// Sets the value of [persistent_directories][crate::model::WorkstationConfig::persistent_directories].
    pub fn set_persistent_directories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::workstation_config::PersistentDirectory>,
    {
        use std::iter::Iterator;
        self.persistent_directories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [container][crate::model::WorkstationConfig::container].
    pub fn set_container<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::Container>,
    {
        self.container = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [container][crate::model::WorkstationConfig::container].
    pub fn set_or_clear_container<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::Container>,
    {
        self.container = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption_key][crate::model::WorkstationConfig::encryption_key].
    pub fn set_encryption_key<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::CustomerEncryptionKey>,
    {
        self.encryption_key = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption_key][crate::model::WorkstationConfig::encryption_key].
    pub fn set_or_clear_encryption_key<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::workstation_config::CustomerEncryptionKey>,
    {
        self.encryption_key = v.map(|x| x.into());
        self
    }

    /// Sets the value of [readiness_checks][crate::model::WorkstationConfig::readiness_checks].
    pub fn set_readiness_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::workstation_config::ReadinessCheck>,
    {
        use std::iter::Iterator;
        self.readiness_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [replica_zones][crate::model::WorkstationConfig::replica_zones].
    pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [degraded][crate::model::WorkstationConfig::degraded].
    pub fn set_degraded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.degraded = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::WorkstationConfig::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for WorkstationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkstationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __reconciling,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __delete_time,
            __etag,
            __idle_timeout,
            __running_timeout,
            __host,
            __persistent_directories,
            __container,
            __encryption_key,
            __readiness_checks,
            __replica_zones,
            __degraded,
            __conditions,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkstationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "idleTimeout" => Ok(__FieldTag::__idle_timeout),
                            "idle_timeout" => Ok(__FieldTag::__idle_timeout),
                            "runningTimeout" => Ok(__FieldTag::__running_timeout),
                            "running_timeout" => Ok(__FieldTag::__running_timeout),
                            "host" => Ok(__FieldTag::__host),
                            "persistentDirectories" => Ok(__FieldTag::__persistent_directories),
                            "persistent_directories" => Ok(__FieldTag::__persistent_directories),
                            "container" => Ok(__FieldTag::__container),
                            "encryptionKey" => Ok(__FieldTag::__encryption_key),
                            "encryption_key" => Ok(__FieldTag::__encryption_key),
                            "readinessChecks" => Ok(__FieldTag::__readiness_checks),
                            "readiness_checks" => Ok(__FieldTag::__readiness_checks),
                            "replicaZones" => Ok(__FieldTag::__replica_zones),
                            "replica_zones" => Ok(__FieldTag::__replica_zones),
                            "degraded" => Ok(__FieldTag::__degraded),
                            "conditions" => Ok(__FieldTag::__conditions),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkstationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkstationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__idle_timeout => {
                            if !fields.insert(__FieldTag::__idle_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_timeout",
                                ));
                            }
                            result.idle_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__running_timeout => {
                            if !fields.insert(__FieldTag::__running_timeout) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for running_timeout",
                                ));
                            }
                            result.running_timeout =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map.next_value::<std::option::Option<crate::model::workstation_config::Host>>()?
                                ;
                        }
                        __FieldTag::__persistent_directories => {
                            if !fields.insert(__FieldTag::__persistent_directories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for persistent_directories",
                                ));
                            }
                            result.persistent_directories = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::workstation_config::PersistentDirectory,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container => {
                            if !fields.insert(__FieldTag::__container) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container",
                                ));
                            }
                            result.container =
                                map.next_value::<std::option::Option<
                                    crate::model::workstation_config::Container,
                                >>()?;
                        }
                        __FieldTag::__encryption_key => {
                            if !fields.insert(__FieldTag::__encryption_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption_key",
                                ));
                            }
                            result.encryption_key = map.next_value::<std::option::Option<
                                crate::model::workstation_config::CustomerEncryptionKey,
                            >>()?;
                        }
                        __FieldTag::__readiness_checks => {
                            if !fields.insert(__FieldTag::__readiness_checks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for readiness_checks",
                                ));
                            }
                            result.readiness_checks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::workstation_config::ReadinessCheck>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_zones => {
                            if !fields.insert(__FieldTag::__replica_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_zones",
                                ));
                            }
                            result.replica_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__degraded => {
                            if !fields.insert(__FieldTag::__degraded) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for degraded",
                                ));
                            }
                            result.degraded = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__conditions => {
                            if !fields.insert(__FieldTag::__conditions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for conditions",
                                ));
                            }
                            result.conditions = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkstationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if self.idle_timeout.is_some() {
            state.serialize_entry("idleTimeout", &self.idle_timeout)?;
        }
        if self.running_timeout.is_some() {
            state.serialize_entry("runningTimeout", &self.running_timeout)?;
        }
        if self.host.is_some() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self.persistent_directories.is_empty() {
            state.serialize_entry("persistentDirectories", &self.persistent_directories)?;
        }
        if self.container.is_some() {
            state.serialize_entry("container", &self.container)?;
        }
        if self.encryption_key.is_some() {
            state.serialize_entry("encryptionKey", &self.encryption_key)?;
        }
        if !self.readiness_checks.is_empty() {
            state.serialize_entry("readinessChecks", &self.readiness_checks)?;
        }
        if !self.replica_zones.is_empty() {
            state.serialize_entry("replicaZones", &self.replica_zones)?;
        }
        if !wkt::internal::is_default(&self.degraded) {
            state.serialize_entry("degraded", &self.degraded)?;
        }
        if !self.conditions.is_empty() {
            state.serialize_entry("conditions", &self.conditions)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkstationConfig].
pub mod workstation_config {
    #[allow(unused_imports)]
    use super::*;

    /// Runtime host for a workstation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Host {
        /// Type of host that will be used for the workstation's runtime.
        pub config: std::option::Option<crate::model::workstation_config::host::Config>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Host {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [config][crate::model::workstation_config::Host::config].
        ///
        /// Note that all the setters affecting `config` are mutually
        /// exclusive.
        pub fn set_config<
            T: std::convert::Into<std::option::Option<crate::model::workstation_config::host::Config>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = v.into();
            self
        }

        /// The value of [config][crate::model::workstation_config::Host::config]
        /// if it holds a `GceInstance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gce_instance(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::workstation_config::host::GceInstance>,
        > {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::workstation_config::host::Config::GceInstance(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::workstation_config::Host::config]
        /// to hold a `GceInstance`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_gce_instance<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::workstation_config::host::GceInstance>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::workstation_config::host::Config::GceInstance(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Host {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Host {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __gce_instance,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Host")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "gceInstance" => Ok(__FieldTag::__gce_instance),
                                "gce_instance" => Ok(__FieldTag::__gce_instance),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Host;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Host")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__gce_instance => {
                                if !fields.insert(__FieldTag::__gce_instance) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gce_instance",
                                    ));
                                }
                                if result.config.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `config`, a oneof with full ID .google.cloud.workstations.v1.WorkstationConfig.Host.gce_instance, latest field was gceInstance",
                                    ));
                                }
                                result.config = std::option::Option::Some(
                                    crate::model::workstation_config::host::Config::GceInstance(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<
                                                crate::model::workstation_config::host::GceInstance,
                                            >,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Host {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.gce_instance() {
                state.serialize_entry("gceInstance", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Host].
    pub mod host {
        #[allow(unused_imports)]
        use super::*;

        /// A runtime using a Compute Engine instance.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GceInstance {
            /// Optional. The type of machine to use for VM instances—for example,
            /// `"e2-standard-4"`. For more information about machine types that
            /// Cloud Workstations supports, see the list of
            /// [available machine
            /// types](https://cloud.google.com/workstations/docs/available-machine-types).
            pub machine_type: std::string::String,

            /// Optional. The email address of the service account for Cloud
            /// Workstations VMs created with this configuration. When specified, be
            /// sure that the service account has `logginglogEntries.create` permission
            /// on the project so it can write logs out to Cloud Logging. If using a
            /// custom container image, the service account must have permissions to
            /// pull the specified image.
            ///
            /// If you as the administrator want to be able to `ssh` into the
            /// underlying VM, you need to set this value to a service account
            /// for which you have the `iam.serviceAccounts.actAs` permission.
            /// Conversely, if you don't want anyone to be able to `ssh` into the
            /// underlying VM, use a service account where no one has that
            /// permission.
            ///
            /// If not set, VMs run with a service account provided by the
            /// Cloud Workstations service, and the image must be publicly
            /// accessible.
            pub service_account: std::string::String,

            /// Optional. Scopes to grant to the
            /// [service_account][google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.service_account].
            /// Various scopes are automatically added based on feature usage. When
            /// specified, users of workstations under this configuration must have
            /// `iam.serviceAccounts.actAs` on the service account.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.service_account]: crate::model::workstation_config::host::GceInstance::service_account
            pub service_account_scopes: std::vec::Vec<std::string::String>,

            /// Optional. Network tags to add to the Compute Engine VMs backing the
            /// workstations. This option applies
            /// [network
            /// tags](https://cloud.google.com/vpc/docs/add-remove-network-tags) to VMs
            /// created with this configuration. These network tags enable the creation
            /// of [firewall
            /// rules](https://cloud.google.com/workstations/docs/configure-firewall-rules).
            pub tags: std::vec::Vec<std::string::String>,

            /// Optional. The number of VMs that the system should keep idle so that
            /// new workstations can be started quickly for new users. Defaults to `0`
            /// in the API.
            pub pool_size: i32,

            /// Output only. Number of instances currently available in the pool for
            /// faster workstation startup.
            pub pooled_instances: i32,

            /// Optional. When set to true, disables public IP addresses for VMs. If
            /// you disable public IP addresses, you must set up Private Google Access
            /// or Cloud NAT on your network. If you use Private Google Access and you
            /// use `private.googleapis.com` or `restricted.googleapis.com` for
            /// Container Registry and Artifact Registry, make sure that you set
            /// up DNS records for domains `*.gcr.io` and `*.pkg.dev`.
            /// Defaults to false (VMs have public IP addresses).
            pub disable_public_ip_addresses: bool,

            /// Optional. Whether to enable nested virtualization on Cloud Workstations
            /// VMs created under this workstation configuration.
            ///
            /// Nested virtualization lets you run virtual machine (VM) instances
            /// inside your workstation. Before enabling nested virtualization,
            /// consider the following important considerations. Cloud Workstations
            /// instances are subject to the [same restrictions as Compute Engine
            /// instances](https://cloud.google.com/compute/docs/instances/nested-virtualization/overview#restrictions):
            ///
            /// * **Organization policy**: projects, folders, or
            ///   organizations may be restricted from creating nested VMs if the
            ///   **Disable VM nested virtualization** constraint is enforced in
            ///   the organization policy. For more information, see the
            ///   Compute Engine section,
            ///   [Checking whether nested virtualization is
            ///   allowed](https://cloud.google.com/compute/docs/instances/nested-virtualization/managing-constraint#checking_whether_nested_virtualization_is_allowed).
            /// * **Performance**: nested VMs might experience a 10% or greater
            ///   decrease in performance for workloads that are CPU-bound and
            ///   possibly greater than a 10% decrease for workloads that are
            ///   input/output bound.
            /// * **Machine Type**: nested virtualization can only be enabled on
            ///   workstation configurations that specify a
            ///   [machine_type][google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.machine_type]
            ///   in the N1 or N2 machine series.
            /// * **GPUs**: nested virtualization may not be enabled on workstation
            ///   configurations with accelerators.
            /// * **Operating System**: Because
            ///   [Container-Optimized
            ///   OS](https://cloud.google.com/compute/docs/images/os-details#container-optimized_os_cos)
            ///   does not support nested virtualization, when nested virtualization is
            ///   enabled, the underlying Compute Engine VM instances boot from an
            ///   [Ubuntu
            ///   LTS](https://cloud.google.com/compute/docs/images/os-details#ubuntu_lts)
            ///   image.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.machine_type]: crate::model::workstation_config::host::GceInstance::machine_type
            pub enable_nested_virtualization: bool,

            /// Optional. A set of Compute Engine Shielded instance options.
            pub shielded_instance_config: std::option::Option<
                crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig,
            >,

            /// Optional. A set of Compute Engine Confidential VM instance options.
            pub confidential_instance_config: std::option::Option<
                crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig,
            >,

            /// Optional. The size of the boot disk for the VM in gigabytes (GB).
            /// The minimum boot disk size is `30` GB. Defaults to `50` GB.
            pub boot_disk_size_gb: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GceInstance {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [machine_type][crate::model::workstation_config::host::GceInstance::machine_type].
            pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.machine_type = v.into();
                self
            }

            /// Sets the value of [service_account][crate::model::workstation_config::host::GceInstance::service_account].
            pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.service_account = v.into();
                self
            }

            /// Sets the value of [service_account_scopes][crate::model::workstation_config::host::GceInstance::service_account_scopes].
            pub fn set_service_account_scopes<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.service_account_scopes = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [tags][crate::model::workstation_config::host::GceInstance::tags].
            pub fn set_tags<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.tags = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [pool_size][crate::model::workstation_config::host::GceInstance::pool_size].
            pub fn set_pool_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pool_size = v.into();
                self
            }

            /// Sets the value of [pooled_instances][crate::model::workstation_config::host::GceInstance::pooled_instances].
            pub fn set_pooled_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pooled_instances = v.into();
                self
            }

            /// Sets the value of [disable_public_ip_addresses][crate::model::workstation_config::host::GceInstance::disable_public_ip_addresses].
            pub fn set_disable_public_ip_addresses<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.disable_public_ip_addresses = v.into();
                self
            }

            /// Sets the value of [enable_nested_virtualization][crate::model::workstation_config::host::GceInstance::enable_nested_virtualization].
            pub fn set_enable_nested_virtualization<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.enable_nested_virtualization = v.into();
                self
            }

            /// Sets the value of [shielded_instance_config][crate::model::workstation_config::host::GceInstance::shielded_instance_config].
            pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig>
            {
                self.shielded_instance_config = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [shielded_instance_config][crate::model::workstation_config::host::GceInstance::shielded_instance_config].
            pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig>
            {
                self.shielded_instance_config = v.map(|x| x.into());
                self
            }

            /// Sets the value of [confidential_instance_config][crate::model::workstation_config::host::GceInstance::confidential_instance_config].
            pub fn set_confidential_instance_config<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig>
            {
                self.confidential_instance_config = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [confidential_instance_config][crate::model::workstation_config::host::GceInstance::confidential_instance_config].
            pub fn set_or_clear_confidential_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig>
            {
                self.confidential_instance_config = v.map(|x| x.into());
                self
            }

            /// Sets the value of [boot_disk_size_gb][crate::model::workstation_config::host::GceInstance::boot_disk_size_gb].
            pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.boot_disk_size_gb = v.into();
                self
            }
        }

        impl wkt::message::Message for GceInstance {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GceInstance {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __machine_type,
                    __service_account,
                    __service_account_scopes,
                    __tags,
                    __pool_size,
                    __pooled_instances,
                    __disable_public_ip_addresses,
                    __enable_nested_virtualization,
                    __shielded_instance_config,
                    __confidential_instance_config,
                    __boot_disk_size_gb,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GceInstance")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "machineType" => Ok(__FieldTag::__machine_type),
                                    "machine_type" => Ok(__FieldTag::__machine_type),
                                    "serviceAccount" => Ok(__FieldTag::__service_account),
                                    "service_account" => Ok(__FieldTag::__service_account),
                                    "serviceAccountScopes" => {
                                        Ok(__FieldTag::__service_account_scopes)
                                    }
                                    "service_account_scopes" => {
                                        Ok(__FieldTag::__service_account_scopes)
                                    }
                                    "tags" => Ok(__FieldTag::__tags),
                                    "poolSize" => Ok(__FieldTag::__pool_size),
                                    "pool_size" => Ok(__FieldTag::__pool_size),
                                    "pooledInstances" => Ok(__FieldTag::__pooled_instances),
                                    "pooled_instances" => Ok(__FieldTag::__pooled_instances),
                                    "disablePublicIpAddresses" => {
                                        Ok(__FieldTag::__disable_public_ip_addresses)
                                    }
                                    "disable_public_ip_addresses" => {
                                        Ok(__FieldTag::__disable_public_ip_addresses)
                                    }
                                    "enableNestedVirtualization" => {
                                        Ok(__FieldTag::__enable_nested_virtualization)
                                    }
                                    "enable_nested_virtualization" => {
                                        Ok(__FieldTag::__enable_nested_virtualization)
                                    }
                                    "shieldedInstanceConfig" => {
                                        Ok(__FieldTag::__shielded_instance_config)
                                    }
                                    "shielded_instance_config" => {
                                        Ok(__FieldTag::__shielded_instance_config)
                                    }
                                    "confidentialInstanceConfig" => {
                                        Ok(__FieldTag::__confidential_instance_config)
                                    }
                                    "confidential_instance_config" => {
                                        Ok(__FieldTag::__confidential_instance_config)
                                    }
                                    "bootDiskSizeGb" => Ok(__FieldTag::__boot_disk_size_gb),
                                    "boot_disk_size_gb" => Ok(__FieldTag::__boot_disk_size_gb),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GceInstance;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GceInstance")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__machine_type => {
                                    if !fields.insert(__FieldTag::__machine_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for machine_type",
                                            ),
                                        );
                                    }
                                    result.machine_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__service_account => {
                                    if !fields.insert(__FieldTag::__service_account) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for service_account",
                                            ),
                                        );
                                    }
                                    result.service_account = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__service_account_scopes => {
                                    if !fields.insert(__FieldTag::__service_account_scopes) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for service_account_scopes",
                                            ),
                                        );
                                    }
                                    result.service_account_scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__tags => {
                                    if !fields.insert(__FieldTag::__tags) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for tags"),
                                        );
                                    }
                                    result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__pool_size => {
                                    if !fields.insert(__FieldTag::__pool_size) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pool_size",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.pool_size =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__pooled_instances => {
                                    if !fields.insert(__FieldTag::__pooled_instances) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for pooled_instances",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.pooled_instances =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__disable_public_ip_addresses => {
                                    if !fields.insert(__FieldTag::__disable_public_ip_addresses) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disable_public_ip_addresses",
                                            ),
                                        );
                                    }
                                    result.disable_public_ip_addresses = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__enable_nested_virtualization => {
                                    if !fields.insert(__FieldTag::__enable_nested_virtualization) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for enable_nested_virtualization",
                                            ),
                                        );
                                    }
                                    result.enable_nested_virtualization = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__shielded_instance_config => {
                                    if !fields.insert(__FieldTag::__shielded_instance_config) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for shielded_instance_config",
                                            ),
                                        );
                                    }
                                    result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig>>()?
                                        ;
                                }
                                __FieldTag::__confidential_instance_config => {
                                    if !fields.insert(__FieldTag::__confidential_instance_config) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for confidential_instance_config",
                                            ),
                                        );
                                    }
                                    result.confidential_instance_config = map.next_value::<std::option::Option<crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig>>()?
                                        ;
                                }
                                __FieldTag::__boot_disk_size_gb => {
                                    if !fields.insert(__FieldTag::__boot_disk_size_gb) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for boot_disk_size_gb",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.boot_disk_size_gb =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GceInstance {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.machine_type.is_empty() {
                    state.serialize_entry("machineType", &self.machine_type)?;
                }
                if !self.service_account.is_empty() {
                    state.serialize_entry("serviceAccount", &self.service_account)?;
                }
                if !self.service_account_scopes.is_empty() {
                    state.serialize_entry("serviceAccountScopes", &self.service_account_scopes)?;
                }
                if !self.tags.is_empty() {
                    state.serialize_entry("tags", &self.tags)?;
                }
                if !wkt::internal::is_default(&self.pool_size) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("poolSize", &__With(&self.pool_size))?;
                }
                if !wkt::internal::is_default(&self.pooled_instances) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("pooledInstances", &__With(&self.pooled_instances))?;
                }
                if !wkt::internal::is_default(&self.disable_public_ip_addresses) {
                    state.serialize_entry(
                        "disablePublicIpAddresses",
                        &self.disable_public_ip_addresses,
                    )?;
                }
                if !wkt::internal::is_default(&self.enable_nested_virtualization) {
                    state.serialize_entry(
                        "enableNestedVirtualization",
                        &self.enable_nested_virtualization,
                    )?;
                }
                if self.shielded_instance_config.is_some() {
                    state.serialize_entry(
                        "shieldedInstanceConfig",
                        &self.shielded_instance_config,
                    )?;
                }
                if self.confidential_instance_config.is_some() {
                    state.serialize_entry(
                        "confidentialInstanceConfig",
                        &self.confidential_instance_config,
                    )?;
                }
                if !wkt::internal::is_default(&self.boot_disk_size_gb) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("bootDiskSizeGb", &__With(&self.boot_disk_size_gb))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [GceInstance].
        pub mod gce_instance {
            #[allow(unused_imports)]
            use super::*;

            /// A set of Compute Engine Shielded instance options.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct GceShieldedInstanceConfig {
                /// Optional. Whether the instance has Secure Boot enabled.
                pub enable_secure_boot: bool,

                /// Optional. Whether the instance has the vTPM enabled.
                pub enable_vtpm: bool,

                /// Optional. Whether the instance has integrity monitoring enabled.
                pub enable_integrity_monitoring: bool,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GceShieldedInstanceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enable_secure_boot][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_secure_boot].
                pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.enable_secure_boot = v.into();
                    self
                }

                /// Sets the value of [enable_vtpm][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_vtpm].
                pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.enable_vtpm = v.into();
                    self
                }

                /// Sets the value of [enable_integrity_monitoring][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_integrity_monitoring].
                pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enable_integrity_monitoring = v.into();
                    self
                }
            }

            impl wkt::message::Message for GceShieldedInstanceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.GceShieldedInstanceConfig"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for GceShieldedInstanceConfig {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __enable_secure_boot,
                        __enable_vtpm,
                        __enable_integrity_monitoring,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter
                                        .write_str("a field name for GceShieldedInstanceConfig")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "enableSecureBoot" => Ok(__FieldTag::__enable_secure_boot),
                                        "enable_secure_boot" => {
                                            Ok(__FieldTag::__enable_secure_boot)
                                        }
                                        "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                                        "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                                        "enableIntegrityMonitoring" => {
                                            Ok(__FieldTag::__enable_integrity_monitoring)
                                        }
                                        "enable_integrity_monitoring" => {
                                            Ok(__FieldTag::__enable_integrity_monitoring)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GceShieldedInstanceConfig;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct GceShieldedInstanceConfig")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__enable_secure_boot => {
                                        if !fields.insert(__FieldTag::__enable_secure_boot) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for enable_secure_boot",
                                                ),
                                            );
                                        }
                                        result.enable_secure_boot = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__enable_vtpm => {
                                        if !fields.insert(__FieldTag::__enable_vtpm) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for enable_vtpm",
                                                ),
                                            );
                                        }
                                        result.enable_vtpm = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__enable_integrity_monitoring => {
                                        if !fields.insert(__FieldTag::__enable_integrity_monitoring)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for enable_integrity_monitoring",
                                                ),
                                            );
                                        }
                                        result.enable_integrity_monitoring = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for GceShieldedInstanceConfig {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.enable_secure_boot) {
                        state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
                    }
                    if !wkt::internal::is_default(&self.enable_vtpm) {
                        state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
                    }
                    if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
                        state.serialize_entry(
                            "enableIntegrityMonitoring",
                            &self.enable_integrity_monitoring,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            /// A set of Compute Engine Confidential VM instance options.
            #[derive(Clone, Debug, Default, PartialEq)]
            #[non_exhaustive]
            pub struct GceConfidentialInstanceConfig {
                /// Optional. Whether the instance has confidential compute enabled.
                pub enable_confidential_compute: bool,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl GceConfidentialInstanceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enable_confidential_compute][crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig::enable_confidential_compute].
                pub fn set_enable_confidential_compute<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enable_confidential_compute = v.into();
                    self
                }
            }

            impl wkt::message::Message for GceConfidentialInstanceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.GceConfidentialInstanceConfig"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for GceConfidentialInstanceConfig {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __enable_confidential_compute,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter
                                        .write_str("a field name for GceConfidentialInstanceConfig")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "enableConfidentialCompute" => {
                                            Ok(__FieldTag::__enable_confidential_compute)
                                        }
                                        "enable_confidential_compute" => {
                                            Ok(__FieldTag::__enable_confidential_compute)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = GceConfidentialInstanceConfig;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct GceConfidentialInstanceConfig")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__enable_confidential_compute => {
                                        if !fields.insert(__FieldTag::__enable_confidential_compute)
                                        {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for enable_confidential_compute",
                                                ),
                                            );
                                        }
                                        result.enable_confidential_compute = map
                                            .next_value::<std::option::Option<bool>>()?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for GceConfidentialInstanceConfig {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !wkt::internal::is_default(&self.enable_confidential_compute) {
                        state.serialize_entry(
                            "enableConfidentialCompute",
                            &self.enable_confidential_compute,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }
        }

        /// Type of host that will be used for the workstation's runtime.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Config {
            /// Specifies a Compute Engine instance as the host.
            GceInstance(std::boxed::Box<crate::model::workstation_config::host::GceInstance>),
        }
    }

    /// A directory to persist across workstation sessions.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct PersistentDirectory {
        /// Optional. Location of this directory in the running workstation.
        pub mount_path: std::string::String,

        /// How a persistent directory should be implemented.
        pub directory_type: std::option::Option<
            crate::model::workstation_config::persistent_directory::DirectoryType,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl PersistentDirectory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mount_path][crate::model::workstation_config::PersistentDirectory::mount_path].
        pub fn set_mount_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mount_path = v.into();
            self
        }

        /// Sets the value of [directory_type][crate::model::workstation_config::PersistentDirectory::directory_type].
        ///
        /// Note that all the setters affecting `directory_type` are mutually
        /// exclusive.
        pub fn set_directory_type<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::workstation_config::persistent_directory::DirectoryType,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.directory_type = v.into();
            self
        }

        /// The value of [directory_type][crate::model::workstation_config::PersistentDirectory::directory_type]
        /// if it holds a `GcePd`, `None` if the field is not set or
        /// holds a different branch.
        pub fn gce_pd(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.directory_type.as_ref().and_then(|v| match v {
                crate::model::workstation_config::persistent_directory::DirectoryType::GcePd(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [directory_type][crate::model::workstation_config::PersistentDirectory::directory_type]
        /// to hold a `GcePd`.
        ///
        /// Note that all the setters affecting `directory_type` are
        /// mutually exclusive.
        pub fn set_gce_pd<T: std::convert::Into<std::boxed::Box<crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk>>>(mut self, v: T) -> Self{
            self.directory_type = std::option::Option::Some(
                crate::model::workstation_config::persistent_directory::DirectoryType::GcePd(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for PersistentDirectory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for PersistentDirectory {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __gce_pd,
                __mount_path,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for PersistentDirectory")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "gcePd" => Ok(__FieldTag::__gce_pd),
                                "gce_pd" => Ok(__FieldTag::__gce_pd),
                                "mountPath" => Ok(__FieldTag::__mount_path),
                                "mount_path" => Ok(__FieldTag::__mount_path),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = PersistentDirectory;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct PersistentDirectory")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__gce_pd => {
                                if !fields.insert(__FieldTag::__gce_pd) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for gce_pd",
                                    ));
                                }
                                if result.directory_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `directory_type`, a oneof with full ID .google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.gce_pd, latest field was gcePd",
                                    ));
                                }
                                result.directory_type = std::option::Option::Some(
                                    crate::model::workstation_config::persistent_directory::DirectoryType::GcePd(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__mount_path => {
                                if !fields.insert(__FieldTag::__mount_path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for mount_path",
                                    ));
                                }
                                result.mount_path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for PersistentDirectory {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.gce_pd() {
                state.serialize_entry("gcePd", value)?;
            }
            if !self.mount_path.is_empty() {
                state.serialize_entry("mountPath", &self.mount_path)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [PersistentDirectory].
    pub mod persistent_directory {
        #[allow(unused_imports)]
        use super::*;

        /// A PersistentDirectory backed by a Compute Engine regional persistent
        /// disk. The
        /// [persistent_directories][google.cloud.workstations.v1.WorkstationConfig.persistent_directories]
        /// field is repeated, but it may contain only one entry. It creates a
        /// [persistent
        /// disk](https://cloud.google.com/compute/docs/disks/persistent-disks) that
        /// mounts to the workstation VM at `/home` when the session starts and
        /// detaches when the session ends. If this field is empty, workstations
        /// created with this configuration do not have a persistent home
        /// directory.
        ///
        /// [google.cloud.workstations.v1.WorkstationConfig.persistent_directories]: crate::model::WorkstationConfig::persistent_directories
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct GceRegionalPersistentDisk {

            /// Optional. The GB capacity of a persistent home directory for each
            /// workstation created with this configuration. Must be empty if
            /// [source_snapshot][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
            /// is set.
            ///
            /// Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`.
            /// Defaults to `200`. If less than `200` GB, the
            /// [disk_type][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.disk_type]
            /// must be
            /// `"pd-balanced"` or `"pd-ssd"`.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.disk_type]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::disk_type
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot
            pub size_gb: i32,

            /// Optional. Type of file system that the disk should be formatted with.
            /// The workstation image must support this file system type. Must be empty
            /// if
            /// [source_snapshot][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
            /// is set. Defaults to `"ext4"`.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot
            pub fs_type: std::string::String,

            /// Optional. The [type of the persistent
            /// disk](https://cloud.google.com/compute/docs/disks#disk-types) for the
            /// home directory. Defaults to `"pd-standard"`.
            pub disk_type: std::string::String,

            /// Optional. Name of the snapshot to use as the source for the disk. If
            /// set,
            /// [size_gb][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.size_gb]
            /// and
            /// [fs_type][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.fs_type]
            /// must be empty.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.fs_type]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::fs_type
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.size_gb]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::size_gb
            pub source_snapshot: std::string::String,

            /// Optional. Whether the persistent disk should be deleted when the
            /// workstation is deleted. Valid values are `DELETE` and `RETAIN`.
            /// Defaults to `DELETE`.
            pub reclaim_policy: crate::model::workstation_config::persistent_directory::gce_regional_persistent_disk::ReclaimPolicy,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl GceRegionalPersistentDisk {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [size_gb][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::size_gb].
            pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.size_gb = v.into();
                self
            }

            /// Sets the value of [fs_type][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::fs_type].
            pub fn set_fs_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.fs_type = v.into();
                self
            }

            /// Sets the value of [disk_type][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::disk_type].
            pub fn set_disk_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.disk_type = v.into();
                self
            }

            /// Sets the value of [source_snapshot][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot].
            pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.source_snapshot = v.into();
                self
            }

            /// Sets the value of [reclaim_policy][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::reclaim_policy].
            pub fn set_reclaim_policy<T: std::convert::Into<crate::model::workstation_config::persistent_directory::gce_regional_persistent_disk::ReclaimPolicy>>(mut self, v: T) -> Self{
                self.reclaim_policy = v.into();
                self
            }
        }

        impl wkt::message::Message for GceRegionalPersistentDisk {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for GceRegionalPersistentDisk {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __size_gb,
                    __fs_type,
                    __disk_type,
                    __source_snapshot,
                    __reclaim_policy,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for GceRegionalPersistentDisk")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "sizeGb" => Ok(__FieldTag::__size_gb),
                                    "size_gb" => Ok(__FieldTag::__size_gb),
                                    "fsType" => Ok(__FieldTag::__fs_type),
                                    "fs_type" => Ok(__FieldTag::__fs_type),
                                    "diskType" => Ok(__FieldTag::__disk_type),
                                    "disk_type" => Ok(__FieldTag::__disk_type),
                                    "sourceSnapshot" => Ok(__FieldTag::__source_snapshot),
                                    "source_snapshot" => Ok(__FieldTag::__source_snapshot),
                                    "reclaimPolicy" => Ok(__FieldTag::__reclaim_policy),
                                    "reclaim_policy" => Ok(__FieldTag::__reclaim_policy),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = GceRegionalPersistentDisk;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct GceRegionalPersistentDisk")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__size_gb => {
                                    if !fields.insert(__FieldTag::__size_gb) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for size_gb",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.size_gb =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::__fs_type => {
                                    if !fields.insert(__FieldTag::__fs_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for fs_type",
                                            ),
                                        );
                                    }
                                    result.fs_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__disk_type => {
                                    if !fields.insert(__FieldTag::__disk_type) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for disk_type",
                                            ),
                                        );
                                    }
                                    result.disk_type = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__source_snapshot => {
                                    if !fields.insert(__FieldTag::__source_snapshot) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for source_snapshot",
                                            ),
                                        );
                                    }
                                    result.source_snapshot = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__reclaim_policy => {
                                    if !fields.insert(__FieldTag::__reclaim_policy) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for reclaim_policy",
                                            ),
                                        );
                                    }
                                    result.reclaim_policy = map.next_value::<std::option::Option<crate::model::workstation_config::persistent_directory::gce_regional_persistent_disk::ReclaimPolicy>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for GceRegionalPersistentDisk {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !wkt::internal::is_default(&self.size_gb) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
                }
                if !self.fs_type.is_empty() {
                    state.serialize_entry("fsType", &self.fs_type)?;
                }
                if !self.disk_type.is_empty() {
                    state.serialize_entry("diskType", &self.disk_type)?;
                }
                if !self.source_snapshot.is_empty() {
                    state.serialize_entry("sourceSnapshot", &self.source_snapshot)?;
                }
                if !wkt::internal::is_default(&self.reclaim_policy) {
                    state.serialize_entry("reclaimPolicy", &self.reclaim_policy)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [GceRegionalPersistentDisk].
        pub mod gce_regional_persistent_disk {
            #[allow(unused_imports)]
            use super::*;

            /// Value representing what should happen to the disk after the workstation
            /// is deleted.
            ///
            /// # Working with unknown values
            ///
            /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
            /// additional enum variants at any time. Adding new variants is not considered
            /// a breaking change. Applications should write their code in anticipation of:
            ///
            /// - New values appearing in future releases of the client library, **and**
            /// - New values received dynamically, without application changes.
            ///
            /// Please consult the [Working with enums] section in the user guide for some
            /// guidelines.
            ///
            /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum ReclaimPolicy {
                /// Do not use.
                Unspecified,
                /// Delete the persistent disk when deleting the workstation.
                Delete,
                /// Keep the persistent disk when deleting the workstation.
                /// An administrator must manually delete the disk.
                Retain,
                /// If set, the enum was initialized with an unknown value.
                ///
                /// Applications can examine the value using [ReclaimPolicy::value] or
                /// [ReclaimPolicy::name].
                UnknownValue(reclaim_policy::UnknownValue),
            }

            #[doc(hidden)]
            pub mod reclaim_policy {
                #[allow(unused_imports)]
                use super::*;
                #[derive(Clone, Debug, PartialEq)]
                pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
            }

            impl ReclaimPolicy {
                /// Gets the enum value.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the string representation of enums.
                pub fn value(&self) -> std::option::Option<i32> {
                    match self {
                        Self::Unspecified => std::option::Option::Some(0),
                        Self::Delete => std::option::Option::Some(1),
                        Self::Retain => std::option::Option::Some(2),
                        Self::UnknownValue(u) => u.0.value(),
                    }
                }

                /// Gets the enum value as a string.
                ///
                /// Returns `None` if the enum contains an unknown value deserialized from
                /// the integer representation of enums.
                pub fn name(&self) -> std::option::Option<&str> {
                    match self {
                        Self::Unspecified => {
                            std::option::Option::Some("RECLAIM_POLICY_UNSPECIFIED")
                        }
                        Self::Delete => std::option::Option::Some("DELETE"),
                        Self::Retain => std::option::Option::Some("RETAIN"),
                        Self::UnknownValue(u) => u.0.name(),
                    }
                }
            }

            impl std::default::Default for ReclaimPolicy {
                fn default() -> Self {
                    use std::convert::From;
                    Self::from(0)
                }
            }

            impl std::fmt::Display for ReclaimPolicy {
                fn fmt(
                    &self,
                    f: &mut std::fmt::Formatter<'_>,
                ) -> std::result::Result<(), std::fmt::Error> {
                    wkt::internal::display_enum(f, self.name(), self.value())
                }
            }

            impl std::convert::From<i32> for ReclaimPolicy {
                fn from(value: i32) -> Self {
                    match value {
                        0 => Self::Unspecified,
                        1 => Self::Delete,
                        2 => Self::Retain,
                        _ => Self::UnknownValue(reclaim_policy::UnknownValue(
                            wkt::internal::UnknownEnumValue::Integer(value),
                        )),
                    }
                }
            }

            impl std::convert::From<&str> for ReclaimPolicy {
                fn from(value: &str) -> Self {
                    use std::string::ToString;
                    match value {
                        "RECLAIM_POLICY_UNSPECIFIED" => Self::Unspecified,
                        "DELETE" => Self::Delete,
                        "RETAIN" => Self::Retain,
                        _ => Self::UnknownValue(reclaim_policy::UnknownValue(
                            wkt::internal::UnknownEnumValue::String(value.to_string()),
                        )),
                    }
                }
            }

            impl serde::ser::Serialize for ReclaimPolicy {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::Serializer,
                {
                    match self {
                        Self::Unspecified => serializer.serialize_i32(0),
                        Self::Delete => serializer.serialize_i32(1),
                        Self::Retain => serializer.serialize_i32(2),
                        Self::UnknownValue(u) => u.0.serialize(serializer),
                    }
                }
            }

            impl<'de> serde::de::Deserialize<'de> for ReclaimPolicy {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    deserializer.deserialize_any(wkt::internal::EnumVisitor::<ReclaimPolicy>::new(
                        ".google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.ReclaimPolicy"))
                }
            }
        }

        /// How a persistent directory should be implemented.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum DirectoryType {
            /// A PersistentDirectory backed by a Compute Engine persistent disk.
            GcePd(std::boxed::Box<crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk>),
        }
    }

    /// A Docker container.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Container {
        /// Optional. A Docker container image that defines a custom environment.
        ///
        /// Cloud Workstations provides a number of
        /// [preconfigured
        /// images](https://cloud.google.com/workstations/docs/preconfigured-base-images),
        /// but you can create your own
        /// [custom container
        /// images](https://cloud.google.com/workstations/docs/custom-container-images).
        /// If using a private image, the `host.gceInstance.serviceAccount` field
        /// must be specified in the workstation configuration and must have
        /// permission to pull the specified image. Otherwise, the image must be
        /// publicly accessible.
        pub image: std::string::String,

        /// Optional. If set, overrides the default ENTRYPOINT specified by the
        /// image.
        pub command: std::vec::Vec<std::string::String>,

        /// Optional. Arguments passed to the entrypoint.
        pub args: std::vec::Vec<std::string::String>,

        /// Optional. Environment variables passed to the container's entrypoint.
        pub env: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. If set, overrides the default DIR specified by the image.
        pub working_dir: std::string::String,

        /// Optional. If set, overrides the USER specified in the image with the
        /// given uid.
        pub run_as_user: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Container {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::workstation_config::Container::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [command][crate::model::workstation_config::Container::command].
        pub fn set_command<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.command = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [args][crate::model::workstation_config::Container::args].
        pub fn set_args<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.args = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [env][crate::model::workstation_config::Container::env].
        pub fn set_env<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.env = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }

        /// Sets the value of [working_dir][crate::model::workstation_config::Container::working_dir].
        pub fn set_working_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.working_dir = v.into();
            self
        }

        /// Sets the value of [run_as_user][crate::model::workstation_config::Container::run_as_user].
        pub fn set_run_as_user<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.run_as_user = v.into();
            self
        }
    }

    impl wkt::message::Message for Container {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Container"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Container {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __image,
                __command,
                __args,
                __env,
                __working_dir,
                __run_as_user,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Container")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "image" => Ok(__FieldTag::__image),
                                "command" => Ok(__FieldTag::__command),
                                "args" => Ok(__FieldTag::__args),
                                "env" => Ok(__FieldTag::__env),
                                "workingDir" => Ok(__FieldTag::__working_dir),
                                "working_dir" => Ok(__FieldTag::__working_dir),
                                "runAsUser" => Ok(__FieldTag::__run_as_user),
                                "run_as_user" => Ok(__FieldTag::__run_as_user),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Container;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Container")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__image => {
                                if !fields.insert(__FieldTag::__image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for image",
                                    ));
                                }
                                result.image = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__command => {
                                if !fields.insert(__FieldTag::__command) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for command",
                                    ));
                                }
                                result.command = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__args => {
                                if !fields.insert(__FieldTag::__args) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for args",
                                    ));
                                }
                                result.args = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__env => {
                                if !fields.insert(__FieldTag::__env) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for env",
                                    ));
                                }
                                result.env = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__working_dir => {
                                if !fields.insert(__FieldTag::__working_dir) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for working_dir",
                                    ));
                                }
                                result.working_dir = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__run_as_user => {
                                if !fields.insert(__FieldTag::__run_as_user) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for run_as_user",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.run_as_user =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Container {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.image.is_empty() {
                state.serialize_entry("image", &self.image)?;
            }
            if !self.command.is_empty() {
                state.serialize_entry("command", &self.command)?;
            }
            if !self.args.is_empty() {
                state.serialize_entry("args", &self.args)?;
            }
            if !self.env.is_empty() {
                state.serialize_entry("env", &self.env)?;
            }
            if !self.working_dir.is_empty() {
                state.serialize_entry("workingDir", &self.working_dir)?;
            }
            if !wkt::internal::is_default(&self.run_as_user) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("runAsUser", &__With(&self.run_as_user))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A customer-managed encryption key (CMEK) for the Compute Engine
    /// resources of the associated workstation configuration. Specify the name of
    /// your Cloud KMS encryption key and the default service account.
    /// We recommend that you use a separate service account and follow
    /// [Cloud KMS best
    /// practices](https://cloud.google.com/kms/docs/separation-of-duties).
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CustomerEncryptionKey {
        /// Immutable. The name of the Google Cloud KMS encryption key. For example,
        /// `"projects/PROJECT_ID/locations/REGION/keyRings/KEY_RING/cryptoKeys/KEY_NAME"`.
        /// The key must be in the same region as the workstation configuration.
        pub kms_key: std::string::String,

        /// Immutable. The service account to use with the specified
        /// KMS key. We recommend that you use a separate service account
        /// and follow KMS best practices. For more information, see
        /// [Separation of
        /// duties](https://cloud.google.com/kms/docs/separation-of-duties) and
        /// `gcloud kms keys add-iam-policy-binding`
        /// [`--member`](https://cloud.google.com/sdk/gcloud/reference/kms/keys/add-iam-policy-binding#--member).
        pub kms_key_service_account: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CustomerEncryptionKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::workstation_config::CustomerEncryptionKey::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_service_account][crate::model::workstation_config::CustomerEncryptionKey::kms_key_service_account].
        pub fn set_kms_key_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomerEncryptionKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.CustomerEncryptionKey"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CustomerEncryptionKey {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __kms_key,
                __kms_key_service_account,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CustomerEncryptionKey")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "kmsKey" => Ok(__FieldTag::__kms_key),
                                "kms_key" => Ok(__FieldTag::__kms_key),
                                "kmsKeyServiceAccount" => Ok(__FieldTag::__kms_key_service_account),
                                "kms_key_service_account" => {
                                    Ok(__FieldTag::__kms_key_service_account)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CustomerEncryptionKey;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CustomerEncryptionKey")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__kms_key => {
                                if !fields.insert(__FieldTag::__kms_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key",
                                    ));
                                }
                                result.kms_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__kms_key_service_account => {
                                if !fields.insert(__FieldTag::__kms_key_service_account) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for kms_key_service_account",
                                    ));
                                }
                                result.kms_key_service_account = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CustomerEncryptionKey {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.kms_key.is_empty() {
                state.serialize_entry("kmsKey", &self.kms_key)?;
            }
            if !self.kms_key_service_account.is_empty() {
                state.serialize_entry("kmsKeyServiceAccount", &self.kms_key_service_account)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// A readiness check to be performed on a workstation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ReadinessCheck {
        /// Optional. Path to which the request should be sent.
        pub path: std::string::String,

        /// Optional. Port to which the request should be sent.
        pub port: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ReadinessCheck {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::workstation_config::ReadinessCheck::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::workstation_config::ReadinessCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }
    }

    impl wkt::message::Message for ReadinessCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.ReadinessCheck"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ReadinessCheck {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __path,
                __port,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ReadinessCheck")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "path" => Ok(__FieldTag::__path),
                                "port" => Ok(__FieldTag::__port),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ReadinessCheck;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ReadinessCheck")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__port => {
                                if !fields.insert(__FieldTag::__port) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for port",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.port = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ReadinessCheck {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !wkt::internal::is_default(&self.port) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("port", &__With(&self.port))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// A single instance of a developer workstation with its own persistent storage.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Workstation {
    /// Full name of this workstation.
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation.
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation.
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation is currently being updated
    /// to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation and that are also propagated to the
    /// underlying Compute Engine resources.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was most recently updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was most recently successfully
    /// started, regardless of the workstation's initial state.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was soft-deleted.
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    pub etag: std::string::String,

    /// Output only. Current state of the workstation.
    pub state: crate::model::workstation::State,

    /// Output only. Host to which clients can send HTTPS traffic that will be
    /// received by the workstation. Authorized traffic will be received to the
    /// workstation as HTTP on port 80. To send traffic to a different port,
    /// clients may prefix the host with the destination port in the format
    /// `{port}-{host}`.
    pub host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Workstation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workstation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Workstation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Workstation::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Workstation::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Workstation::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Workstation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Workstation::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Workstation::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Workstation::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Workstation::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::Workstation::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::Workstation::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Workstation::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Workstation::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Workstation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Workstation::state].
    pub fn set_state<T: std::convert::Into<crate::model::workstation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [host][crate::model::Workstation::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }
}

impl wkt::message::Message for Workstation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.Workstation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Workstation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __uid,
            __reconciling,
            __annotations,
            __labels,
            __create_time,
            __update_time,
            __start_time,
            __delete_time,
            __etag,
            __state,
            __host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Workstation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "uid" => Ok(__FieldTag::__uid),
                            "reconciling" => Ok(__FieldTag::__reconciling),
                            "annotations" => Ok(__FieldTag::__annotations),
                            "labels" => Ok(__FieldTag::__labels),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "deleteTime" => Ok(__FieldTag::__delete_time),
                            "delete_time" => Ok(__FieldTag::__delete_time),
                            "etag" => Ok(__FieldTag::__etag),
                            "state" => Ok(__FieldTag::__state),
                            "host" => Ok(__FieldTag::__host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Workstation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Workstation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uid => {
                            if !fields.insert(__FieldTag::__uid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uid",
                                ));
                            }
                            result.uid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reconciling => {
                            if !fields.insert(__FieldTag::__reconciling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reconciling",
                                ));
                            }
                            result.reconciling = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__annotations => {
                            if !fields.insert(__FieldTag::__annotations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for annotations",
                                ));
                            }
                            result.annotations = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__delete_time => {
                            if !fields.insert(__FieldTag::__delete_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for delete_time",
                                ));
                            }
                            result.delete_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::workstation::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__host => {
                            if !fields.insert(__FieldTag::__host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for host",
                                ));
                            }
                            result.host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Workstation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.uid.is_empty() {
            state.serialize_entry("uid", &self.uid)?;
        }
        if !wkt::internal::is_default(&self.reconciling) {
            state.serialize_entry("reconciling", &self.reconciling)?;
        }
        if !self.annotations.is_empty() {
            state.serialize_entry("annotations", &self.annotations)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.delete_time.is_some() {
            state.serialize_entry("deleteTime", &self.delete_time)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.host.is_empty() {
            state.serialize_entry("host", &self.host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Workstation].
pub mod workstation {
    #[allow(unused_imports)]
    use super::*;

    /// Whether a workstation is running and ready to receive user requests.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Do not use.
        Unspecified,
        /// The workstation is not yet ready to accept requests from users but will
        /// be soon.
        Starting,
        /// The workstation is ready to accept requests from users.
        Running,
        /// The workstation is being stopped.
        Stopping,
        /// The workstation is stopped and will not be able to receive requests until
        /// it is started.
        Stopped,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Starting => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Stopping => std::option::Option::Some(3),
                Self::Stopped => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Starting => std::option::Option::Some("STATE_STARTING"),
                Self::Running => std::option::Option::Some("STATE_RUNNING"),
                Self::Stopping => std::option::Option::Some("STATE_STOPPING"),
                Self::Stopped => std::option::Option::Some("STATE_STOPPED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Starting,
                2 => Self::Running,
                3 => Self::Stopping,
                4 => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STATE_STARTING" => Self::Starting,
                "STATE_RUNNING" => Self::Running,
                "STATE_STOPPING" => Self::Stopping,
                "STATE_STOPPED" => Self::Stopped,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Starting => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Stopping => serializer.serialize_i32(3),
                Self::Stopped => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.workstations.v1.Workstation.State",
            ))
        }
    }
}

/// Request message for GetWorkstationCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkstationClusterRequest {
    /// Required. Name of the requested resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkstationClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkstationClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkstationClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkstationClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkstationClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListWorkstationClusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationClustersRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationClustersRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationClustersRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationClustersRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationClustersRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationClustersRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationClustersRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListWorkstationClusters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationClustersResponse {
    /// The requested workstation clusters.
    pub workstation_clusters: std::vec::Vec<crate::model::WorkstationCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_clusters][crate::model::ListWorkstationClustersResponse::workstation_clusters].
    pub fn set_workstation_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationCluster>,
    {
        use std::iter::Iterator;
        self.workstation_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationClustersResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkstationClustersResponse {
    type PageItem = crate::model::WorkstationCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationClustersResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation_clusters,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationClustersResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstationClusters" => Ok(__FieldTag::__workstation_clusters),
                            "workstation_clusters" => Ok(__FieldTag::__workstation_clusters),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationClustersResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationClustersResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation_clusters => {
                            if !fields.insert(__FieldTag::__workstation_clusters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_clusters",
                                ));
                            }
                            result.workstation_clusters = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkstationCluster>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationClustersResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workstation_clusters.is_empty() {
            state.serialize_entry("workstationClusters", &self.workstation_clusters)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a CreateWorkstationCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkstationClusterRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Required. ID to use for the workstation cluster.
    pub workstation_cluster_id: std::string::String,

    /// Required. Workstation cluster to create.
    pub workstation_cluster: std::option::Option<crate::model::WorkstationCluster>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_cluster_id][crate::model::CreateWorkstationClusterRequest::workstation_cluster_id].
    pub fn set_workstation_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_cluster_id = v.into();
        self
    }

    /// Sets the value of [workstation_cluster][crate::model::CreateWorkstationClusterRequest::workstation_cluster].
    pub fn set_workstation_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationCluster>,
    {
        self.workstation_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation_cluster][crate::model::CreateWorkstationClusterRequest::workstation_cluster].
    pub fn set_or_clear_workstation_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationCluster>,
    {
        self.workstation_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkstationClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workstation_cluster_id,
            __workstation_cluster,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkstationClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workstationClusterId" => Ok(__FieldTag::__workstation_cluster_id),
                            "workstation_cluster_id" => Ok(__FieldTag::__workstation_cluster_id),
                            "workstationCluster" => Ok(__FieldTag::__workstation_cluster),
                            "workstation_cluster" => Ok(__FieldTag::__workstation_cluster),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkstationClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkstationClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation_cluster_id => {
                            if !fields.insert(__FieldTag::__workstation_cluster_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_cluster_id",
                                ));
                            }
                            result.workstation_cluster_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation_cluster => {
                            if !fields.insert(__FieldTag::__workstation_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_cluster",
                                ));
                            }
                            result.workstation_cluster = map.next_value::<std::option::Option<crate::model::WorkstationCluster>>()?
                                ;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkstationClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.workstation_cluster_id.is_empty() {
            state.serialize_entry("workstationClusterId", &self.workstation_cluster_id)?;
        }
        if self.workstation_cluster.is_some() {
            state.serialize_entry("workstationCluster", &self.workstation_cluster)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateWorkstationCluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkstationClusterRequest {
    /// Required. Workstation cluster to update.
    pub workstation_cluster: std::option::Option<crate::model::WorkstationCluster>,

    /// Required. Mask that specifies which fields in the workstation cluster
    /// should be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, and the workstation cluster is not found, a new
    /// workstation cluster will be created. In this situation, update_mask is
    /// ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_cluster][crate::model::UpdateWorkstationClusterRequest::workstation_cluster].
    pub fn set_workstation_cluster<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationCluster>,
    {
        self.workstation_cluster = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation_cluster][crate::model::UpdateWorkstationClusterRequest::workstation_cluster].
    pub fn set_or_clear_workstation_cluster<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationCluster>,
    {
        self.workstation_cluster = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationClusterRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkstationClusterRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkstationClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation_cluster,
            __update_mask,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkstationClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstationCluster" => Ok(__FieldTag::__workstation_cluster),
                            "workstation_cluster" => Ok(__FieldTag::__workstation_cluster),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkstationClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkstationClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation_cluster => {
                            if !fields.insert(__FieldTag::__workstation_cluster) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_cluster",
                                ));
                            }
                            result.workstation_cluster = map.next_value::<std::option::Option<crate::model::WorkstationCluster>>()?
                                ;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkstationClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.workstation_cluster.is_some() {
            state.serialize_entry("workstationCluster", &self.workstation_cluster)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a workstation cluster.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkstationClusterRequest {
    /// Required. Name of the workstation cluster to delete.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation cluster on the server does not have this ETag.
    pub etag: std::string::String,

    /// Optional. If set, any workstation configurations and workstations in the
    /// workstation cluster are also deleted. Otherwise, the request only
    /// works if the workstation cluster has no configurations or workstations.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteWorkstationClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationClusterRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkstationClusterRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkstationClusterRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkstationClusterRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkstationClusterRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkstationClusterRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetWorkstationConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkstationConfigRequest {
    /// Required. Name of the requested resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkstationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkstationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkstationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkstationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkstationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListWorkstationConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationConfigsRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListWorkstationConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationConfigsResponse {
    /// The requested configs.
    pub workstation_configs: std::vec::Vec<crate::model::WorkstationConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_configs][crate::model::ListWorkstationConfigsResponse::workstation_configs].
    pub fn set_workstation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationConfig>,
    {
        use std::iter::Iterator;
        self.workstation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkstationConfigsResponse {
    type PageItem = crate::model::WorkstationConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstationConfigs" => Ok(__FieldTag::__workstation_configs),
                            "workstation_configs" => Ok(__FieldTag::__workstation_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation_configs => {
                            if !fields.insert(__FieldTag::__workstation_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_configs",
                                ));
                            }
                            result.workstation_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkstationConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workstation_configs.is_empty() {
            state.serialize_entry("workstationConfigs", &self.workstation_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListUsableWorkstationConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableWorkstationConfigsRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableWorkstationConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableWorkstationConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableWorkstationConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableWorkstationConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableWorkstationConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableWorkstationConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableWorkstationConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableWorkstationConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableWorkstationConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListUsableWorkstationConfigs.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableWorkstationConfigsResponse {
    /// The requested configs.
    pub workstation_configs: std::vec::Vec<crate::model::WorkstationConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableWorkstationConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_configs][crate::model::ListUsableWorkstationConfigsResponse::workstation_configs].
    pub fn set_workstation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationConfig>,
    {
        use std::iter::Iterator;
        self.workstation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableWorkstationConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsableWorkstationConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsableWorkstationConfigsResponse {
    type PageItem = crate::model::WorkstationConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableWorkstationConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableWorkstationConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstationConfigs" => Ok(__FieldTag::__workstation_configs),
                            "workstation_configs" => Ok(__FieldTag::__workstation_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableWorkstationConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableWorkstationConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation_configs => {
                            if !fields.insert(__FieldTag::__workstation_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_configs",
                                ));
                            }
                            result.workstation_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkstationConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableWorkstationConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workstation_configs.is_empty() {
            state.serialize_entry("workstationConfigs", &self.workstation_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a CreateWorkstationConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkstationConfigRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Required. ID to use for the workstation configuration.
    pub workstation_config_id: std::string::String,

    /// Required. Config to create.
    pub workstation_config: std::option::Option<crate::model::WorkstationConfig>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_config_id][crate::model::CreateWorkstationConfigRequest::workstation_config_id].
    pub fn set_workstation_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_config_id = v.into();
        self
    }

    /// Sets the value of [workstation_config][crate::model::CreateWorkstationConfigRequest::workstation_config].
    pub fn set_workstation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationConfig>,
    {
        self.workstation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation_config][crate::model::CreateWorkstationConfigRequest::workstation_config].
    pub fn set_or_clear_workstation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationConfig>,
    {
        self.workstation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkstationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workstation_config_id,
            __workstation_config,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkstationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workstationConfigId" => Ok(__FieldTag::__workstation_config_id),
                            "workstation_config_id" => Ok(__FieldTag::__workstation_config_id),
                            "workstationConfig" => Ok(__FieldTag::__workstation_config),
                            "workstation_config" => Ok(__FieldTag::__workstation_config),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkstationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkstationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation_config_id => {
                            if !fields.insert(__FieldTag::__workstation_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_config_id",
                                ));
                            }
                            result.workstation_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation_config => {
                            if !fields.insert(__FieldTag::__workstation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_config",
                                ));
                            }
                            result.workstation_config = map
                                .next_value::<std::option::Option<crate::model::WorkstationConfig>>(
                                )?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkstationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.workstation_config_id.is_empty() {
            state.serialize_entry("workstationConfigId", &self.workstation_config_id)?;
        }
        if self.workstation_config.is_some() {
            state.serialize_entry("workstationConfig", &self.workstation_config)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateWorkstationConfig.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkstationConfigRequest {
    /// Required. Config to update.
    pub workstation_config: std::option::Option<crate::model::WorkstationConfig>,

    /// Required. Mask specifying which fields in the workstation configuration
    /// should be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set and the workstation configuration is not found, a new
    /// workstation configuration will be created. In this situation,
    /// update_mask is ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_config][crate::model::UpdateWorkstationConfigRequest::workstation_config].
    pub fn set_workstation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationConfig>,
    {
        self.workstation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation_config][crate::model::UpdateWorkstationConfigRequest::workstation_config].
    pub fn set_or_clear_workstation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkstationConfig>,
    {
        self.workstation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkstationConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationConfigRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkstationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation_config,
            __update_mask,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkstationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstationConfig" => Ok(__FieldTag::__workstation_config),
                            "workstation_config" => Ok(__FieldTag::__workstation_config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkstationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkstationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation_config => {
                            if !fields.insert(__FieldTag::__workstation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_config",
                                ));
                            }
                            result.workstation_config = map
                                .next_value::<std::option::Option<crate::model::WorkstationConfig>>(
                                )?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkstationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.workstation_config.is_some() {
            state.serialize_entry("workstationConfig", &self.workstation_config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for deleting a workstation configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkstationConfigRequest {
    /// Required. Name of the workstation configuration to delete.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request is rejected if the latest version of the
    /// workstation configuration on the server does not have this ETag.
    pub etag: std::string::String,

    /// Optional. If set, any workstations in the workstation configuration are
    /// also deleted. Otherwise, the request works only if the workstation
    /// configuration has no workstations.
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteWorkstationConfigRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkstationConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkstationConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkstationConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkstationConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkstationConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GetWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkstationRequest {
    /// Required. Name of the requested resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListWorkstations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationsRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListWorkstations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkstationsResponse {
    /// The requested workstations.
    pub workstations: std::vec::Vec<crate::model::Workstation>,

    /// Optional. Token to retrieve the next page of results, or empty if there are
    /// no more results in the list.
    pub next_page_token: std::string::String,

    /// Optional. Unreachable resources.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkstationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstations][crate::model::ListWorkstationsResponse::workstations].
    pub fn set_workstations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workstation>,
    {
        use std::iter::Iterator;
        self.workstations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkstationsResponse {
    type PageItem = crate::model::Workstation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkstationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkstationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstations" => Ok(__FieldTag::__workstations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkstationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkstationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstations => {
                            if !fields.insert(__FieldTag::__workstations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstations",
                                ));
                            }
                            result.workstations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Workstation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkstationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workstations.is_empty() {
            state.serialize_entry("workstations", &self.workstations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for ListUsableWorkstations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableWorkstationsRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableWorkstationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableWorkstationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableWorkstationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableWorkstationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableWorkstationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableWorkstationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableWorkstationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableWorkstationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableWorkstationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for ListUsableWorkstations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUsableWorkstationsResponse {
    /// The requested workstations.
    pub workstations: std::vec::Vec<crate::model::Workstation>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUsableWorkstationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstations][crate::model::ListUsableWorkstationsResponse::workstations].
    pub fn set_workstations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workstation>,
    {
        use std::iter::Iterator;
        self.workstations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableWorkstationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsableWorkstationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUsableWorkstationsResponse {
    type PageItem = crate::model::Workstation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUsableWorkstationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUsableWorkstationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstations" => Ok(__FieldTag::__workstations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUsableWorkstationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUsableWorkstationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstations => {
                            if !fields.insert(__FieldTag::__workstations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstations",
                                ));
                            }
                            result.workstations = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Workstation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUsableWorkstationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workstations.is_empty() {
            state.serialize_entry("workstations", &self.workstations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Message for creating a CreateWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkstationRequest {
    /// Required. Parent resource name.
    pub parent: std::string::String,

    /// Required. ID to use for the workstation.
    pub workstation_id: std::string::String,

    /// Required. Workstation to create.
    pub workstation: std::option::Option<crate::model::Workstation>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_id][crate::model::CreateWorkstationRequest::workstation_id].
    pub fn set_workstation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workstation_id = v.into();
        self
    }

    /// Sets the value of [workstation][crate::model::CreateWorkstationRequest::workstation].
    pub fn set_workstation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Workstation>,
    {
        self.workstation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation][crate::model::CreateWorkstationRequest::workstation].
    pub fn set_or_clear_workstation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Workstation>,
    {
        self.workstation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workstation_id,
            __workstation,
            __validate_only,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workstationId" => Ok(__FieldTag::__workstation_id),
                            "workstation_id" => Ok(__FieldTag::__workstation_id),
                            "workstation" => Ok(__FieldTag::__workstation),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation_id => {
                            if !fields.insert(__FieldTag::__workstation_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation_id",
                                ));
                            }
                            result.workstation_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workstation => {
                            if !fields.insert(__FieldTag::__workstation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation",
                                ));
                            }
                            result.workstation =
                                map.next_value::<std::option::Option<crate::model::Workstation>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.workstation_id.is_empty() {
            state.serialize_entry("workstationId", &self.workstation_id)?;
        }
        if self.workstation.is_some() {
            state.serialize_entry("workstation", &self.workstation)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for UpdateWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkstationRequest {
    /// Required. Workstation to update.
    pub workstation: std::option::Option<crate::model::Workstation>,

    /// Required. Mask specifying which fields in the workstation configuration
    /// should be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set and the workstation configuration is not found, a new
    /// workstation configuration is created. In this situation, update_mask
    /// is ignored.
    pub allow_missing: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation][crate::model::UpdateWorkstationRequest::workstation].
    pub fn set_workstation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Workstation>,
    {
        self.workstation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workstation][crate::model::UpdateWorkstationRequest::workstation].
    pub fn set_or_clear_workstation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Workstation>,
    {
        self.workstation = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkstationRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workstation,
            __update_mask,
            __validate_only,
            __allow_missing,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workstation" => Ok(__FieldTag::__workstation),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "allowMissing" => Ok(__FieldTag::__allow_missing),
                            "allow_missing" => Ok(__FieldTag::__allow_missing),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workstation => {
                            if !fields.insert(__FieldTag::__workstation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation",
                                ));
                            }
                            result.workstation =
                                map.next_value::<std::option::Option<crate::model::Workstation>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__allow_missing => {
                            if !fields.insert(__FieldTag::__allow_missing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for allow_missing",
                                ));
                            }
                            result.allow_missing = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.workstation.is_some() {
            state.serialize_entry("workstation", &self.workstation)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !wkt::internal::is_default(&self.allow_missing) {
            state.serialize_entry("allowMissing", &self.allow_missing)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for DeleteWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkstationRequest {
    /// Required. Name of the workstation to delete.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for StartWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartWorkstationRequest {
    /// Required. Name of the workstation to start.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::StartWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::StartWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for StartWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.StartWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for StopWorkstation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopWorkstationRequest {
    /// Required. Name of the workstation to stop.
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::StopWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::StopWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for StopWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.StopWorkstationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopWorkstationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __validate_only,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopWorkstationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "validateOnly" => Ok(__FieldTag::__validate_only),
                            "validate_only" => Ok(__FieldTag::__validate_only),
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopWorkstationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopWorkstationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__validate_only => {
                            if !fields.insert(__FieldTag::__validate_only) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for validate_only",
                                ));
                            }
                            result.validate_only = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopWorkstationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.validate_only) {
            state.serialize_entry("validateOnly", &self.validate_only)?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for GenerateAccessToken.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenRequest {
    /// Required. Name of the workstation for which the access token should be
    /// generated.
    pub workstation: std::string::String,

    /// Desired expiration or lifetime of the access token.
    pub expiration: std::option::Option<crate::model::generate_access_token_request::Expiration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation][crate::model::GenerateAccessTokenRequest::workstation].
    pub fn set_workstation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workstation = v.into();
        self
    }

    /// Sets the value of [expiration][crate::model::GenerateAccessTokenRequest::expiration].
    ///
    /// Note that all the setters affecting `expiration` are mutually
    /// exclusive.
    pub fn set_expiration<
        T: std::convert::Into<
                std::option::Option<crate::model::generate_access_token_request::Expiration>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::generate_access_token_request::Expiration::ExpireTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::generate_access_token_request::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// The value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::generate_access_token_request::Expiration::Ttl(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::generate_access_token_request::Expiration::Ttl(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GenerateAccessTokenRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAccessTokenRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __expire_time,
            __ttl,
            __workstation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAccessTokenRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            "ttl" => Ok(__FieldTag::__ttl),
                            "workstation" => Ok(__FieldTag::__workstation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAccessTokenRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAccessTokenRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.workstations.v1.GenerateAccessTokenRequest.expire_time, latest field was expireTime",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::generate_access_token_request::Expiration::ExpireTime(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Timestamp>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ttl => {
                            if !fields.insert(__FieldTag::__ttl) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ttl",
                                ));
                            }
                            if result.expiration.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `expiration`, a oneof with full ID .google.cloud.workstations.v1.GenerateAccessTokenRequest.ttl, latest field was ttl",
                                ));
                            }
                            result.expiration = std::option::Option::Some(
                                crate::model::generate_access_token_request::Expiration::Ttl(
                                    map.next_value::<std::option::Option<std::boxed::Box<wkt::Duration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__workstation => {
                            if !fields.insert(__FieldTag::__workstation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workstation",
                                ));
                            }
                            result.workstation = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAccessTokenRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.expire_time() {
            state.serialize_entry("expireTime", value)?;
        }
        if let Some(value) = self.ttl() {
            state.serialize_entry("ttl", value)?;
        }
        if !self.workstation.is_empty() {
            state.serialize_entry("workstation", &self.workstation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GenerateAccessTokenRequest].
pub mod generate_access_token_request {
    #[allow(unused_imports)]
    use super::*;

    /// Desired expiration or lifetime of the access token.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Expiration {
        /// Desired expiration time of the access token. This value must
        /// be at most 24 hours in the future. If a value is not specified, the
        /// token's expiration time will be set to a default value of 1 hour in the
        /// future.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Desired lifetime duration of the access token. This value must
        /// be at most 24 hours. If a value is not specified, the token's lifetime
        /// will be set to a default value of 1 hour.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// Response message for GenerateAccessToken.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GenerateAccessTokenResponse {
    /// The generated bearer access token. To use this token, include it in an
    /// Authorization header of an HTTP request sent to the associated
    /// workstation's hostname—for example, `Authorization: Bearer
    /// <access_token>`.
    pub access_token: std::string::String,

    /// Time at which the generated token will expire.
    pub expire_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GenerateAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_expire_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expire_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GenerateAccessTokenResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GenerateAccessTokenResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_token,
            __expire_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GenerateAccessTokenResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessToken" => Ok(__FieldTag::__access_token),
                            "access_token" => Ok(__FieldTag::__access_token),
                            "expireTime" => Ok(__FieldTag::__expire_time),
                            "expire_time" => Ok(__FieldTag::__expire_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GenerateAccessTokenResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GenerateAccessTokenResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_token => {
                            if !fields.insert(__FieldTag::__access_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_token",
                                ));
                            }
                            result.access_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__expire_time => {
                            if !fields.insert(__FieldTag::__expire_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expire_time",
                                ));
                            }
                            result.expire_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GenerateAccessTokenResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.access_token.is_empty() {
            state.serialize_entry("accessToken", &self.access_token)?;
        }
        if self.expire_time.is_some() {
            state.serialize_entry("expireTime", &self.expire_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Metadata for long-running operations.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. Time that the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time that the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation.
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
