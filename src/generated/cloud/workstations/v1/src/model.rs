// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// A workstation cluster resource in the Cloud Workstations API.
///
/// Defines a group of workstations in a particular region and the
/// VPC network they're attached to.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkstationCluster {
    /// Full name of this workstation cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation
    /// cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation cluster is currently being
    /// updated to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation cluster and that are also propagated to the
    /// underlying Compute Engine resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation cluster was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation cluster was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation cluster was soft-deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Immutable. Name of the Compute Engine network in which instances associated
    /// with this workstation cluster will be created.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Immutable. Name of the Compute Engine subnetwork in which instances
    /// associated with this workstation cluster will be created. Must be part of
    /// the subnetwork specified for this workstation cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// Output only. The private IP address of the control plane for this
    /// workstation cluster. Workstation VMs need access to this IP address to work
    /// with the service, so make sure that your firewall rules allow egress from
    /// the workstation VMs to this address.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub control_plane_ip: std::string::String,

    /// Optional. Configuration for private workstation cluster.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub private_cluster_config:
        std::option::Option<crate::model::workstation_cluster::PrivateClusterConfig>,

    /// Output only. Whether this workstation cluster is in degraded mode, in which
    /// case it may require user action to restore full functionality. Details can
    /// be found in
    /// [conditions][google.cloud.workstations.v1.WorkstationCluster.conditions].
    ///
    /// [google.cloud.workstations.v1.WorkstationCluster.conditions]: crate::model::WorkstationCluster::conditions
    pub degraded: bool,

    /// Output only. Status conditions describing the workstation cluster's current
    /// state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<rpc::model::Status>,
}

impl WorkstationCluster {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkstationCluster::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkstationCluster::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkstationCluster::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::WorkstationCluster::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkstationCluster::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::WorkstationCluster::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkstationCluster::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::WorkstationCluster::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [network][crate::model::WorkstationCluster::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::WorkstationCluster::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [control_plane_ip][crate::model::WorkstationCluster::control_plane_ip].
    pub fn set_control_plane_ip<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.control_plane_ip = v.into();
        self
    }

    /// Sets the value of [private_cluster_config][crate::model::WorkstationCluster::private_cluster_config].
    pub fn set_private_cluster_config<
        T: std::convert::Into<
            std::option::Option<crate::model::workstation_cluster::PrivateClusterConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.private_cluster_config = v.into();
        self
    }

    /// Sets the value of [degraded][crate::model::WorkstationCluster::degraded].
    pub fn set_degraded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.degraded = v.into();
        self
    }

    /// Sets the value of [conditions][crate::model::WorkstationCluster::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkstationCluster::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::WorkstationCluster::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for WorkstationCluster {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.WorkstationCluster"
    }
}

/// Defines additional types related to WorkstationCluster
pub mod workstation_cluster {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration options for private workstation clusters.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PrivateClusterConfig {
        /// Immutable. Whether Workstations endpoint is private.
        pub enable_private_endpoint: bool,

        /// Output only. Hostname for the workstation cluster. This field will be
        /// populated only when private endpoint is enabled. To access workstations
        /// in the workstation cluster, create a new DNS zone mapping this domain
        /// name to an internal IP address and a forwarding rule mapping that address
        /// to the service attachment.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub cluster_hostname: std::string::String,

        /// Output only. Service attachment URI for the workstation cluster. The
        /// service attachemnt is created when private endpoint is enabled. To access
        /// workstations in the workstation cluster, configure access to the managed
        /// service using [Private Service
        /// Connect](https://cloud.google.com/vpc/docs/configure-private-service-connect-services).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub service_attachment_uri: std::string::String,

        /// Optional. Additional projects that are allowed to attach to the
        /// workstation cluster's service attachment. By default, the workstation
        /// cluster's project and the VPC host project (if different) are allowed.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub allowed_projects: std::vec::Vec<std::string::String>,
    }

    impl PrivateClusterConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [enable_private_endpoint][crate::model::workstation_cluster::PrivateClusterConfig::enable_private_endpoint].
        pub fn set_enable_private_endpoint<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.enable_private_endpoint = v.into();
            self
        }

        /// Sets the value of [cluster_hostname][crate::model::workstation_cluster::PrivateClusterConfig::cluster_hostname].
        pub fn set_cluster_hostname<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.cluster_hostname = v.into();
            self
        }

        /// Sets the value of [service_attachment_uri][crate::model::workstation_cluster::PrivateClusterConfig::service_attachment_uri].
        pub fn set_service_attachment_uri<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.service_attachment_uri = v.into();
            self
        }

        /// Sets the value of [allowed_projects][crate::model::workstation_cluster::PrivateClusterConfig::allowed_projects].
        pub fn set_allowed_projects<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.allowed_projects = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for PrivateClusterConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationCluster.PrivateClusterConfig"
        }
    }
}

/// A workstation configuration resource in the Cloud Workstations API.
///
/// Workstation configurations act as templates for workstations. The workstation
/// configuration defines details such as the workstation virtual machine (VM)
/// instance type, persistent storage, container image defining environment,
/// which IDE or Code Editor to use, and more. Administrators and platform teams
/// can also use [Identity and Access Management
/// (IAM)](https://cloud.google.com/iam/docs/overview) rules to grant access to
/// teams or to individual developers.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct WorkstationConfig {
    /// Full name of this workstation configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation
    /// configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation configuration is currently
    /// being updated to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation configuration and that are also propagated
    /// to the underlying Compute Engine resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation configuration was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation configuration was most recently
    /// updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation configuration was soft-deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. Number of seconds to wait before automatically stopping a
    /// workstation after it last received user traffic.
    ///
    /// A value of `"0s"` indicates that Cloud Workstations VMs created with this
    /// configuration should never time out due to idleness.
    /// Provide
    /// [duration](https://developers.google.com/protocol-buffers/docs/reference/google.protobuf#duration)
    /// terminated by `s` for seconds—for example, `"7200s"` (2 hours).
    /// The default is `"1200s"` (20 minutes).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Number of seconds that a workstation can run until it is
    /// automatically shut down. We recommend that workstations be shut down daily
    /// to reduce costs and so that security updates can be applied upon restart.
    /// The
    /// [idle_timeout][google.cloud.workstations.v1.WorkstationConfig.idle_timeout]
    /// and
    /// [running_timeout][google.cloud.workstations.v1.WorkstationConfig.running_timeout]
    /// fields are independent of each other. Note that the
    /// [running_timeout][google.cloud.workstations.v1.WorkstationConfig.running_timeout]
    /// field shuts down VMs after the specified time, regardless of whether or not
    /// the VMs are idle.
    ///
    /// Provide duration terminated by `s` for seconds—for example, `"54000s"`
    /// (15 hours). Defaults to `"43200s"` (12 hours). A value of `"0s"` indicates
    /// that workstations using this configuration should never time out. If
    /// [encryption_key][google.cloud.workstations.v1.WorkstationConfig.encryption_key]
    /// is set, it must be greater than `"0s"` and less than
    /// `"86400s"` (24 hours).
    ///
    /// Warning: A value of `"0s"` indicates that Cloud Workstations VMs created
    /// with this configuration have no maximum running time. This is strongly
    /// discouraged because you incur costs and will not pick up security updates.
    ///
    /// [google.cloud.workstations.v1.WorkstationConfig.encryption_key]: crate::model::WorkstationConfig::encryption_key
    /// [google.cloud.workstations.v1.WorkstationConfig.idle_timeout]: crate::model::WorkstationConfig::idle_timeout
    /// [google.cloud.workstations.v1.WorkstationConfig.running_timeout]: crate::model::WorkstationConfig::running_timeout
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub running_timeout: std::option::Option<wkt::Duration>,

    /// Optional. Runtime host for the workstation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub host: std::option::Option<crate::model::workstation_config::Host>,

    /// Optional. Directories to persist across workstation sessions.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub persistent_directories:
        std::vec::Vec<crate::model::workstation_config::PersistentDirectory>,

    /// Optional. Container that runs upon startup for each workstation using this
    /// workstation configuration.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub container: std::option::Option<crate::model::workstation_config::Container>,

    /// Immutable. Encrypts resources of this workstation configuration using a
    /// customer-managed encryption key (CMEK).
    ///
    /// If specified, the boot disk of the Compute Engine instance and the
    /// persistent disk are encrypted using this encryption key. If
    /// this field is not set, the disks are encrypted using a generated
    /// key. Customer-managed encryption keys do not protect disk metadata.
    ///
    /// If the customer-managed encryption key is rotated, when the workstation
    /// instance is stopped, the system attempts to recreate the
    /// persistent disk with the new version of the key. Be sure to keep
    /// older versions of the key until the persistent disk is recreated.
    /// Otherwise, data on the persistent disk might be lost.
    ///
    /// If the encryption key is revoked, the workstation session automatically
    /// stops within 7 hours.
    ///
    /// Immutable after the workstation configuration is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub encryption_key:
        std::option::Option<crate::model::workstation_config::CustomerEncryptionKey>,

    /// Optional. Readiness checks to perform when starting a workstation using
    /// this workstation configuration. Mark a workstation as running only after
    /// all specified readiness checks return 200 status codes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub readiness_checks: std::vec::Vec<crate::model::workstation_config::ReadinessCheck>,

    /// Optional. Immutable. Specifies the zones used to replicate the VM and disk
    /// resources within the region. If set, exactly two zones within the
    /// workstation cluster's region must be specified—for example,
    /// `['us-central1-a', 'us-central1-f']`. If this field is empty, two default
    /// zones within the region are used.
    ///
    /// Immutable after the workstation configuration is created.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replica_zones: std::vec::Vec<std::string::String>,

    /// Output only. Whether this resource is degraded, in which case it may
    /// require user action to restore full functionality. See also the
    /// [conditions][google.cloud.workstations.v1.WorkstationConfig.conditions]
    /// field.
    ///
    /// [google.cloud.workstations.v1.WorkstationConfig.conditions]: crate::model::WorkstationConfig::conditions
    pub degraded: bool,

    /// Output only. Status conditions describing the current resource state.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub conditions: std::vec::Vec<rpc::model::Status>,
}

impl WorkstationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkstationConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::WorkstationConfig::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::WorkstationConfig::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::WorkstationConfig::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkstationConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::WorkstationConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::WorkstationConfig::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::WorkstationConfig::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [idle_timeout][crate::model::WorkstationConfig::idle_timeout].
    pub fn set_idle_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.idle_timeout = v.into();
        self
    }

    /// Sets the value of [running_timeout][crate::model::WorkstationConfig::running_timeout].
    pub fn set_running_timeout<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.running_timeout = v.into();
        self
    }

    /// Sets the value of [host][crate::model::WorkstationConfig::host].
    pub fn set_host<
        T: std::convert::Into<std::option::Option<crate::model::workstation_config::Host>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [container][crate::model::WorkstationConfig::container].
    pub fn set_container<
        T: std::convert::Into<std::option::Option<crate::model::workstation_config::Container>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.container = v.into();
        self
    }

    /// Sets the value of [encryption_key][crate::model::WorkstationConfig::encryption_key].
    pub fn set_encryption_key<
        T: std::convert::Into<
            std::option::Option<crate::model::workstation_config::CustomerEncryptionKey>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.encryption_key = v.into();
        self
    }

    /// Sets the value of [degraded][crate::model::WorkstationConfig::degraded].
    pub fn set_degraded<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.degraded = v.into();
        self
    }

    /// Sets the value of [persistent_directories][crate::model::WorkstationConfig::persistent_directories].
    pub fn set_persistent_directories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::workstation_config::PersistentDirectory>,
    {
        use std::iter::Iterator;
        self.persistent_directories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [readiness_checks][crate::model::WorkstationConfig::readiness_checks].
    pub fn set_readiness_checks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::workstation_config::ReadinessCheck>,
    {
        use std::iter::Iterator;
        self.readiness_checks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [replica_zones][crate::model::WorkstationConfig::replica_zones].
    pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [conditions][crate::model::WorkstationConfig::conditions].
    pub fn set_conditions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.conditions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [annotations][crate::model::WorkstationConfig::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::WorkstationConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for WorkstationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig"
    }
}

/// Defines additional types related to WorkstationConfig
pub mod workstation_config {
    #[allow(unused_imports)]
    use super::*;

    /// Runtime host for a workstation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Host {
        /// Type of host that will be used for the workstation's runtime.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub config: std::option::Option<crate::model::workstation_config::host::Config>,
    }

    impl Host {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `config`.
        pub fn set_config<
            T: std::convert::Into<std::option::Option<crate::model::workstation_config::host::Config>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = v.into();
            self
        }

        /// The value of [config][crate::model::workstation_config::Host::config]
        /// if it holds a `GceInstance`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gce_instance(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::workstation_config::host::GceInstance>,
        > {
            #[allow(unreachable_patterns)]
            self.config.as_ref().and_then(|v| match v {
                crate::model::workstation_config::host::Config::GceInstance(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [config][crate::model::workstation_config::Host::config]
        /// to hold a `GceInstance`.
        ///
        /// Note that all the setters affecting `config` are
        /// mutually exclusive.
        pub fn set_gce_instance<
            T: std::convert::Into<
                std::boxed::Box<crate::model::workstation_config::host::GceInstance>,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.config = std::option::Option::Some(
                crate::model::workstation_config::host::Config::GceInstance(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for Host {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host"
        }
    }

    /// Defines additional types related to Host
    pub mod host {
        #[allow(unused_imports)]
        use super::*;

        /// A runtime using a Compute Engine instance.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GceInstance {
            /// Optional. The type of machine to use for VM instances—for example,
            /// `"e2-standard-4"`. For more information about machine types that
            /// Cloud Workstations supports, see the list of
            /// [available machine
            /// types](https://cloud.google.com/workstations/docs/available-machine-types).
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub machine_type: std::string::String,

            /// Optional. The email address of the service account for Cloud
            /// Workstations VMs created with this configuration. When specified, be
            /// sure that the service account has `logginglogEntries.create` permission
            /// on the project so it can write logs out to Cloud Logging. If using a
            /// custom container image, the service account must have permissions to
            /// pull the specified image.
            ///
            /// If you as the administrator want to be able to `ssh` into the
            /// underlying VM, you need to set this value to a service account
            /// for which you have the `iam.serviceAccounts.actAs` permission.
            /// Conversely, if you don't want anyone to be able to `ssh` into the
            /// underlying VM, use a service account where no one has that
            /// permission.
            ///
            /// If not set, VMs run with a service account provided by the
            /// Cloud Workstations service, and the image must be publicly
            /// accessible.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub service_account: std::string::String,

            /// Optional. Scopes to grant to the
            /// [service_account][google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.service_account].
            /// Various scopes are automatically added based on feature usage. When
            /// specified, users of workstations under this configuration must have
            /// `iam.serviceAccounts.actAs` on the service account.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.service_account]: crate::model::workstation_config::host::GceInstance::service_account
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub service_account_scopes: std::vec::Vec<std::string::String>,

            /// Optional. Network tags to add to the Compute Engine VMs backing the
            /// workstations. This option applies
            /// [network
            /// tags](https://cloud.google.com/vpc/docs/add-remove-network-tags) to VMs
            /// created with this configuration. These network tags enable the creation
            /// of [firewall
            /// rules](https://cloud.google.com/workstations/docs/configure-firewall-rules).
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub tags: std::vec::Vec<std::string::String>,

            /// Optional. The number of VMs that the system should keep idle so that
            /// new workstations can be started quickly for new users. Defaults to `0`
            /// in the API.
            pub pool_size: i32,

            /// Output only. Number of instances currently available in the pool for
            /// faster workstation startup.
            pub pooled_instances: i32,

            /// Optional. When set to true, disables public IP addresses for VMs. If
            /// you disable public IP addresses, you must set up Private Google Access
            /// or Cloud NAT on your network. If you use Private Google Access and you
            /// use `private.googleapis.com` or `restricted.googleapis.com` for
            /// Container Registry and Artifact Registry, make sure that you set
            /// up DNS records for domains `*.gcr.io` and `*.pkg.dev`.
            /// Defaults to false (VMs have public IP addresses).
            pub disable_public_ip_addresses: bool,

            /// Optional. Whether to enable nested virtualization on Cloud Workstations
            /// VMs created under this workstation configuration.
            ///
            /// Nested virtualization lets you run virtual machine (VM) instances
            /// inside your workstation. Before enabling nested virtualization,
            /// consider the following important considerations. Cloud Workstations
            /// instances are subject to the [same restrictions as Compute Engine
            /// instances](https://cloud.google.com/compute/docs/instances/nested-virtualization/overview#restrictions):
            ///
            /// * **Organization policy**: projects, folders, or
            ///   organizations may be restricted from creating nested VMs if the
            ///   **Disable VM nested virtualization** constraint is enforced in
            ///   the organization policy. For more information, see the
            ///   Compute Engine section,
            ///   [Checking whether nested virtualization is
            ///   allowed](https://cloud.google.com/compute/docs/instances/nested-virtualization/managing-constraint#checking_whether_nested_virtualization_is_allowed).
            /// * **Performance**: nested VMs might experience a 10% or greater
            ///   decrease in performance for workloads that are CPU-bound and
            ///   possibly greater than a 10% decrease for workloads that are
            ///   input/output bound.
            /// * **Machine Type**: nested virtualization can only be enabled on
            ///   workstation configurations that specify a
            ///   [machine_type][google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.machine_type]
            ///   in the N1 or N2 machine series.
            /// * **GPUs**: nested virtualization may not be enabled on workstation
            ///   configurations with accelerators.
            /// * **Operating System**: Because
            ///   [Container-Optimized
            ///   OS](https://cloud.google.com/compute/docs/images/os-details#container-optimized_os_cos)
            ///   does not support nested virtualization, when nested virtualization is
            ///   enabled, the underlying Compute Engine VM instances boot from an
            ///   [Ubuntu
            ///   LTS](https://cloud.google.com/compute/docs/images/os-details#ubuntu_lts)
            ///   image.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.machine_type]: crate::model::workstation_config::host::GceInstance::machine_type
            pub enable_nested_virtualization: bool,

            /// Optional. A set of Compute Engine Shielded instance options.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub shielded_instance_config: std::option::Option<
                crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig,
            >,

            /// Optional. A set of Compute Engine Confidential VM instance options.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub confidential_instance_config: std::option::Option<
                crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig,
            >,

            /// Optional. The size of the boot disk for the VM in gigabytes (GB).
            /// The minimum boot disk size is `30` GB. Defaults to `50` GB.
            pub boot_disk_size_gb: i32,
        }

        impl GceInstance {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [machine_type][crate::model::workstation_config::host::GceInstance::machine_type].
            pub fn set_machine_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.machine_type = v.into();
                self
            }

            /// Sets the value of [service_account][crate::model::workstation_config::host::GceInstance::service_account].
            pub fn set_service_account<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.service_account = v.into();
                self
            }

            /// Sets the value of [pool_size][crate::model::workstation_config::host::GceInstance::pool_size].
            pub fn set_pool_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pool_size = v.into();
                self
            }

            /// Sets the value of [pooled_instances][crate::model::workstation_config::host::GceInstance::pooled_instances].
            pub fn set_pooled_instances<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.pooled_instances = v.into();
                self
            }

            /// Sets the value of [disable_public_ip_addresses][crate::model::workstation_config::host::GceInstance::disable_public_ip_addresses].
            pub fn set_disable_public_ip_addresses<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.disable_public_ip_addresses = v.into();
                self
            }

            /// Sets the value of [enable_nested_virtualization][crate::model::workstation_config::host::GceInstance::enable_nested_virtualization].
            pub fn set_enable_nested_virtualization<T: std::convert::Into<bool>>(
                mut self,
                v: T,
            ) -> Self {
                self.enable_nested_virtualization = v.into();
                self
            }

            /// Sets the value of [shielded_instance_config][crate::model::workstation_config::host::GceInstance::shielded_instance_config].
            pub fn set_shielded_instance_config<T: std::convert::Into<std::option::Option<crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig>>>(mut self, v: T) -> Self{
                self.shielded_instance_config = v.into();
                self
            }

            /// Sets the value of [confidential_instance_config][crate::model::workstation_config::host::GceInstance::confidential_instance_config].
            pub fn set_confidential_instance_config<T: std::convert::Into<std::option::Option<crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig>>>(mut self, v: T) -> Self{
                self.confidential_instance_config = v.into();
                self
            }

            /// Sets the value of [boot_disk_size_gb][crate::model::workstation_config::host::GceInstance::boot_disk_size_gb].
            pub fn set_boot_disk_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.boot_disk_size_gb = v.into();
                self
            }

            /// Sets the value of [service_account_scopes][crate::model::workstation_config::host::GceInstance::service_account_scopes].
            pub fn set_service_account_scopes<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.service_account_scopes = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [tags][crate::model::workstation_config::host::GceInstance::tags].
            pub fn set_tags<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.tags = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for GceInstance {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance"
            }
        }

        /// Defines additional types related to GceInstance
        pub mod gce_instance {
            #[allow(unused_imports)]
            use super::*;

            /// A set of Compute Engine Shielded instance options.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GceShieldedInstanceConfig {
                /// Optional. Whether the instance has Secure Boot enabled.
                pub enable_secure_boot: bool,

                /// Optional. Whether the instance has the vTPM enabled.
                pub enable_vtpm: bool,

                /// Optional. Whether the instance has integrity monitoring enabled.
                pub enable_integrity_monitoring: bool,
            }

            impl GceShieldedInstanceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enable_secure_boot][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_secure_boot].
                pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.enable_secure_boot = v.into();
                    self
                }

                /// Sets the value of [enable_vtpm][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_vtpm].
                pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                    self.enable_vtpm = v.into();
                    self
                }

                /// Sets the value of [enable_integrity_monitoring][crate::model::workstation_config::host::gce_instance::GceShieldedInstanceConfig::enable_integrity_monitoring].
                pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enable_integrity_monitoring = v.into();
                    self
                }
            }

            impl wkt::message::Message for GceShieldedInstanceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.GceShieldedInstanceConfig"
                }
            }

            /// A set of Compute Engine Confidential VM instance options.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct GceConfidentialInstanceConfig {
                /// Optional. Whether the instance has confidential compute enabled.
                pub enable_confidential_compute: bool,
            }

            impl GceConfidentialInstanceConfig {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [enable_confidential_compute][crate::model::workstation_config::host::gce_instance::GceConfidentialInstanceConfig::enable_confidential_compute].
                pub fn set_enable_confidential_compute<T: std::convert::Into<bool>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.enable_confidential_compute = v.into();
                    self
                }
            }

            impl wkt::message::Message for GceConfidentialInstanceConfig {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Host.GceInstance.GceConfidentialInstanceConfig"
                }
            }
        }

        /// Type of host that will be used for the workstation's runtime.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum Config {
            /// Specifies a Compute Engine instance as the host.
            GceInstance(std::boxed::Box<crate::model::workstation_config::host::GceInstance>),
        }
    }

    /// A directory to persist across workstation sessions.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PersistentDirectory {
        /// Optional. Location of this directory in the running workstation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub mount_path: std::string::String,

        /// How a persistent directory should be implemented.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub directory_type: std::option::Option<
            crate::model::workstation_config::persistent_directory::DirectoryType,
        >,
    }

    impl PersistentDirectory {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mount_path][crate::model::workstation_config::PersistentDirectory::mount_path].
        pub fn set_mount_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.mount_path = v.into();
            self
        }

        /// Sets the value of `directory_type`.
        pub fn set_directory_type<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::workstation_config::persistent_directory::DirectoryType,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.directory_type = v.into();
            self
        }

        /// The value of [directory_type][crate::model::workstation_config::PersistentDirectory::directory_type]
        /// if it holds a `GcePd`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_gce_pd(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.directory_type.as_ref().and_then(|v| match v {
                crate::model::workstation_config::persistent_directory::DirectoryType::GcePd(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [directory_type][crate::model::workstation_config::PersistentDirectory::directory_type]
        /// to hold a `GcePd`.
        ///
        /// Note that all the setters affecting `directory_type` are
        /// mutually exclusive.
        pub fn set_gce_pd<T: std::convert::Into<std::boxed::Box<crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk>>>(mut self, v: T) -> Self{
            self.directory_type = std::option::Option::Some(
                crate::model::workstation_config::persistent_directory::DirectoryType::GcePd(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for PersistentDirectory {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory"
        }
    }

    /// Defines additional types related to PersistentDirectory
    pub mod persistent_directory {
        #[allow(unused_imports)]
        use super::*;

        /// A PersistentDirectory backed by a Compute Engine regional persistent
        /// disk. The
        /// [persistent_directories][google.cloud.workstations.v1.WorkstationConfig.persistent_directories]
        /// field is repeated, but it may contain only one entry. It creates a
        /// [persistent
        /// disk](https://cloud.google.com/compute/docs/disks/persistent-disks) that
        /// mounts to the workstation VM at `/home` when the session starts and
        /// detaches when the session ends. If this field is empty, workstations
        /// created with this configuration do not have a persistent home
        /// directory.
        ///
        /// [google.cloud.workstations.v1.WorkstationConfig.persistent_directories]: crate::model::WorkstationConfig::persistent_directories
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct GceRegionalPersistentDisk {

            /// Optional. The GB capacity of a persistent home directory for each
            /// workstation created with this configuration. Must be empty if
            /// [source_snapshot][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
            /// is set.
            ///
            /// Valid values are `10`, `50`, `100`, `200`, `500`, or `1000`.
            /// Defaults to `200`. If less than `200` GB, the
            /// [disk_type][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.disk_type]
            /// must be
            /// `"pd-balanced"` or `"pd-ssd"`.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.disk_type]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::disk_type
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot
            pub size_gb: i32,

            /// Optional. Type of file system that the disk should be formatted with.
            /// The workstation image must support this file system type. Must be empty
            /// if
            /// [source_snapshot][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]
            /// is set. Defaults to `"ext4"`.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.source_snapshot]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub fs_type: std::string::String,

            /// Optional. The [type of the persistent
            /// disk](https://cloud.google.com/compute/docs/disks#disk-types) for the
            /// home directory. Defaults to `"pd-standard"`.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub disk_type: std::string::String,

            /// Optional. Name of the snapshot to use as the source for the disk. If
            /// set,
            /// [size_gb][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.size_gb]
            /// and
            /// [fs_type][google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.fs_type]
            /// must be empty.
            ///
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.fs_type]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::fs_type
            /// [google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk.size_gb]: crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::size_gb
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub source_snapshot: std::string::String,

            /// Optional. Whether the persistent disk should be deleted when the
            /// workstation is deleted. Valid values are `DELETE` and `RETAIN`.
            /// Defaults to `DELETE`.
            pub reclaim_policy: crate::model::workstation_config::persistent_directory::gce_regional_persistent_disk::ReclaimPolicy,
        }

        impl GceRegionalPersistentDisk {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [size_gb][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::size_gb].
            pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.size_gb = v.into();
                self
            }

            /// Sets the value of [fs_type][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::fs_type].
            pub fn set_fs_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.fs_type = v.into();
                self
            }

            /// Sets the value of [disk_type][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::disk_type].
            pub fn set_disk_type<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.disk_type = v.into();
                self
            }

            /// Sets the value of [source_snapshot][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::source_snapshot].
            pub fn set_source_snapshot<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.source_snapshot = v.into();
                self
            }

            /// Sets the value of [reclaim_policy][crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk::reclaim_policy].
            pub fn set_reclaim_policy<T: std::convert::Into<crate::model::workstation_config::persistent_directory::gce_regional_persistent_disk::ReclaimPolicy>>(mut self, v: T) -> Self{
                self.reclaim_policy = v.into();
                self
            }
        }

        impl wkt::message::Message for GceRegionalPersistentDisk {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.PersistentDirectory.GceRegionalPersistentDisk"
            }
        }

        /// Defines additional types related to GceRegionalPersistentDisk
        pub mod gce_regional_persistent_disk {
            #[allow(unused_imports)]
            use super::*;

            /// Value representing what should happen to the disk after the workstation
            /// is deleted.
            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            pub struct ReclaimPolicy(i32);

            impl ReclaimPolicy {
                /// Do not use.
                pub const RECLAIM_POLICY_UNSPECIFIED: ReclaimPolicy = ReclaimPolicy::new(0);

                /// Delete the persistent disk when deleting the workstation.
                pub const DELETE: ReclaimPolicy = ReclaimPolicy::new(1);

                /// Keep the persistent disk when deleting the workstation.
                /// An administrator must manually delete the disk.
                pub const RETAIN: ReclaimPolicy = ReclaimPolicy::new(2);

                /// Creates a new ReclaimPolicy instance.
                pub(crate) const fn new(value: i32) -> Self {
                    Self(value)
                }

                /// Gets the enum value.
                pub fn value(&self) -> i32 {
                    self.0
                }

                /// Gets the enum value as a string.
                pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
                    match self.0 {
                        0 => std::borrow::Cow::Borrowed("RECLAIM_POLICY_UNSPECIFIED"),
                        1 => std::borrow::Cow::Borrowed("DELETE"),
                        2 => std::borrow::Cow::Borrowed("RETAIN"),
                        _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
                    }
                }

                /// Creates an enum value from the value name.
                pub fn from_str_name(name: &str) -> std::option::Option<Self> {
                    match name {
                        "RECLAIM_POLICY_UNSPECIFIED" => {
                            std::option::Option::Some(Self::RECLAIM_POLICY_UNSPECIFIED)
                        }
                        "DELETE" => std::option::Option::Some(Self::DELETE),
                        "RETAIN" => std::option::Option::Some(Self::RETAIN),
                        _ => std::option::Option::None,
                    }
                }
            }

            impl std::convert::From<i32> for ReclaimPolicy {
                fn from(value: i32) -> Self {
                    Self::new(value)
                }
            }

            impl std::default::Default for ReclaimPolicy {
                fn default() -> Self {
                    Self::new(0)
                }
            }
        }

        /// How a persistent directory should be implemented.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum DirectoryType {
            /// A PersistentDirectory backed by a Compute Engine persistent disk.
            GcePd(std::boxed::Box<crate::model::workstation_config::persistent_directory::GceRegionalPersistentDisk>),
        }
    }

    /// A Docker container.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Container {
        /// Optional. A Docker container image that defines a custom environment.
        ///
        /// Cloud Workstations provides a number of
        /// [preconfigured
        /// images](https://cloud.google.com/workstations/docs/preconfigured-base-images),
        /// but you can create your own
        /// [custom container
        /// images](https://cloud.google.com/workstations/docs/custom-container-images).
        /// If using a private image, the `host.gceInstance.serviceAccount` field
        /// must be specified in the workstation configuration and must have
        /// permission to pull the specified image. Otherwise, the image must be
        /// publicly accessible.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub image: std::string::String,

        /// Optional. If set, overrides the default ENTRYPOINT specified by the
        /// image.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub command: std::vec::Vec<std::string::String>,

        /// Optional. Arguments passed to the entrypoint.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub args: std::vec::Vec<std::string::String>,

        /// Optional. Environment variables passed to the container's entrypoint.
        #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
        pub env: std::collections::HashMap<std::string::String, std::string::String>,

        /// Optional. If set, overrides the default DIR specified by the image.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub working_dir: std::string::String,

        /// Optional. If set, overrides the USER specified in the image with the
        /// given uid.
        pub run_as_user: i32,
    }

    impl Container {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [image][crate::model::workstation_config::Container::image].
        pub fn set_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.image = v.into();
            self
        }

        /// Sets the value of [working_dir][crate::model::workstation_config::Container::working_dir].
        pub fn set_working_dir<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.working_dir = v.into();
            self
        }

        /// Sets the value of [run_as_user][crate::model::workstation_config::Container::run_as_user].
        pub fn set_run_as_user<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.run_as_user = v.into();
            self
        }

        /// Sets the value of [command][crate::model::workstation_config::Container::command].
        pub fn set_command<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.command = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [args][crate::model::workstation_config::Container::args].
        pub fn set_args<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.args = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [env][crate::model::workstation_config::Container::env].
        pub fn set_env<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.env = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Container {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.Container"
        }
    }

    /// A customer-managed encryption key (CMEK) for the Compute Engine
    /// resources of the associated workstation configuration. Specify the name of
    /// your Cloud KMS encryption key and the default service account.
    /// We recommend that you use a separate service account and follow
    /// [Cloud KMS best
    /// practices](https://cloud.google.com/kms/docs/separation-of-duties).
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct CustomerEncryptionKey {
        /// Immutable. The name of the Google Cloud KMS encryption key. For example,
        /// `"projects/PROJECT_ID/locations/REGION/keyRings/KEY_RING/cryptoKeys/KEY_NAME"`.
        /// The key must be in the same region as the workstation configuration.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key: std::string::String,

        /// Immutable. The service account to use with the specified
        /// KMS key. We recommend that you use a separate service account
        /// and follow KMS best practices. For more information, see
        /// [Separation of
        /// duties](https://cloud.google.com/kms/docs/separation-of-duties) and
        /// `gcloud kms keys add-iam-policy-binding`
        /// [`--member`](https://cloud.google.com/sdk/gcloud/reference/kms/keys/add-iam-policy-binding#--member).
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub kms_key_service_account: std::string::String,
    }

    impl CustomerEncryptionKey {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [kms_key][crate::model::workstation_config::CustomerEncryptionKey::kms_key].
        pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.kms_key = v.into();
            self
        }

        /// Sets the value of [kms_key_service_account][crate::model::workstation_config::CustomerEncryptionKey::kms_key_service_account].
        pub fn set_kms_key_service_account<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.kms_key_service_account = v.into();
            self
        }
    }

    impl wkt::message::Message for CustomerEncryptionKey {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.CustomerEncryptionKey"
        }
    }

    /// A readiness check to be performed on a workstation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct ReadinessCheck {
        /// Optional. Path to which the request should be sent.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub path: std::string::String,

        /// Optional. Port to which the request should be sent.
        pub port: i32,
    }

    impl ReadinessCheck {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::workstation_config::ReadinessCheck::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [port][crate::model::workstation_config::ReadinessCheck::port].
        pub fn set_port<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.port = v.into();
            self
        }
    }

    impl wkt::message::Message for ReadinessCheck {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.workstations.v1.WorkstationConfig.ReadinessCheck"
        }
    }
}

/// A single instance of a developer workstation with its own persistent storage.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Workstation {
    /// Full name of this workstation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Human-readable name for this workstation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. A system-assigned unique identifier for this workstation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. Indicates whether this workstation is currently being updated
    /// to match its intended state.
    pub reconciling: bool,

    /// Optional. Client-specified annotations.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional.
    /// [Labels](https://cloud.google.com/workstations/docs/label-resources) that
    /// are applied to the workstation and that are also propagated to the
    /// underlying Compute Engine resources.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Time when this workstation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was most recently updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was most recently successfully
    /// started, regardless of the workstation's initial state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time when this workstation was soft-deleted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Checksum computed by the server. May be sent on update and delete
    /// requests to make sure that the client has an up-to-date value before
    /// proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Current state of the workstation.
    pub state: crate::model::workstation::State,

    /// Output only. Host to which clients can send HTTPS traffic that will be
    /// received by the workstation. Authorized traffic will be received to the
    /// workstation as HTTP on port 80. To send traffic to a different port,
    /// clients may prefix the host with the destination port in the format
    /// `{port}-{host}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host: std::string::String,
}

impl Workstation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workstation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Workstation::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Workstation::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Workstation::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workstation::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Workstation::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::Workstation::start_time].
    pub fn set_start_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.start_time = v.into();
        self
    }

    /// Sets the value of [delete_time][crate::model::Workstation::delete_time].
    pub fn set_delete_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.delete_time = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Workstation::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Workstation::state].
    pub fn set_state<T: std::convert::Into<crate::model::workstation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [host][crate::model::Workstation::host].
    pub fn set_host<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Workstation::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Workstation::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Workstation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.Workstation"
    }
}

/// Defines additional types related to Workstation
pub mod workstation {
    #[allow(unused_imports)]
    use super::*;

    /// Whether a workstation is running and ready to receive user requests.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Do not use.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The workstation is not yet ready to accept requests from users but will
        /// be soon.
        pub const STATE_STARTING: State = State::new(1);

        /// The workstation is ready to accept requests from users.
        pub const STATE_RUNNING: State = State::new(2);

        /// The workstation is being stopped.
        pub const STATE_STOPPING: State = State::new(3);

        /// The workstation is stopped and will not be able to receive requests until
        /// it is started.
        pub const STATE_STOPPED: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("STATE_STARTING"),
                2 => std::borrow::Cow::Borrowed("STATE_RUNNING"),
                3 => std::borrow::Cow::Borrowed("STATE_STOPPING"),
                4 => std::borrow::Cow::Borrowed("STATE_STOPPED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "STATE_STARTING" => std::option::Option::Some(Self::STATE_STARTING),
                "STATE_RUNNING" => std::option::Option::Some(Self::STATE_RUNNING),
                "STATE_STOPPING" => std::option::Option::Some(Self::STATE_STOPPING),
                "STATE_STOPPED" => std::option::Option::Some(Self::STATE_STOPPED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request message for GetWorkstationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkstationClusterRequest {
    /// Required. Name of the requested resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationClusterRequest"
    }
}

/// Request message for ListWorkstationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationClustersRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListWorkstationClustersRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationClustersRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationClustersRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationClustersRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationClustersRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationClustersRequest"
    }
}

/// Response message for ListWorkstationClusters.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationClustersResponse {
    /// The requested workstation clusters.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workstation_clusters: std::vec::Vec<crate::model::WorkstationCluster>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListWorkstationClustersResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationClustersResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workstation_clusters][crate::model::ListWorkstationClustersResponse::workstation_clusters].
    pub fn set_workstation_clusters<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationCluster>,
    {
        use std::iter::Iterator;
        self.workstation_clusters = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationClustersResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationClustersResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationClustersResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListWorkstationClustersResponse {
    type PageItem = crate::model::WorkstationCluster;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_clusters
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for creating a CreateWorkstationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkstationClusterRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID to use for the workstation cluster.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workstation_cluster_id: std::string::String,

    /// Required. Workstation cluster to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation_cluster: std::option::Option<crate::model::WorkstationCluster>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,
}

impl CreateWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationClusterRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_cluster_id][crate::model::CreateWorkstationClusterRequest::workstation_cluster_id].
    pub fn set_workstation_cluster_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_cluster_id = v.into();
        self
    }

    /// Sets the value of [workstation_cluster][crate::model::CreateWorkstationClusterRequest::workstation_cluster].
    pub fn set_workstation_cluster<
        T: std::convert::Into<std::option::Option<crate::model::WorkstationCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_cluster = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationClusterRequest"
    }
}

/// Request message for UpdateWorkstationCluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkstationClusterRequest {
    /// Required. Workstation cluster to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation_cluster: std::option::Option<crate::model::WorkstationCluster>,

    /// Required. Mask that specifies which fields in the workstation cluster
    /// should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, and the workstation cluster is not found, a new
    /// workstation cluster will be created. In this situation, update_mask is
    /// ignored.
    pub allow_missing: bool,
}

impl UpdateWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_cluster][crate::model::UpdateWorkstationClusterRequest::workstation_cluster].
    pub fn set_workstation_cluster<
        T: std::convert::Into<std::option::Option<crate::model::WorkstationCluster>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_cluster = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationClusterRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationClusterRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationClusterRequest"
    }
}

/// Message for deleting a workstation cluster.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkstationClusterRequest {
    /// Required. Name of the workstation cluster to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation cluster on the server does not have this ETag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set, any workstation configurations and workstations in the
    /// workstation cluster are also deleted. Otherwise, the request only
    /// works if the workstation cluster has no configurations or workstations.
    pub force: bool,
}

impl DeleteWorkstationClusterRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationClusterRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationClusterRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationClusterRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteWorkstationClusterRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationClusterRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationClusterRequest"
    }
}

/// Request message for GetWorkstationConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkstationConfigRequest {
    /// Required. Name of the requested resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationConfigRequest"
    }
}

/// Request message for ListWorkstationConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationConfigsRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListWorkstationConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationConfigsRequest"
    }
}

/// Response message for ListWorkstationConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationConfigsResponse {
    /// The requested configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workstation_configs: std::vec::Vec<crate::model::WorkstationConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListWorkstationConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workstation_configs][crate::model::ListWorkstationConfigsResponse::workstation_configs].
    pub fn set_workstation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationConfig>,
    {
        use std::iter::Iterator;
        self.workstation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationConfigsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListWorkstationConfigsResponse {
    type PageItem = crate::model::WorkstationConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_configs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for ListUsableWorkstationConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableWorkstationConfigsRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUsableWorkstationConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableWorkstationConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableWorkstationConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableWorkstationConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationConfigsRequest"
    }
}

/// Response message for ListUsableWorkstationConfigs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableWorkstationConfigsResponse {
    /// The requested configs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workstation_configs: std::vec::Vec<crate::model::WorkstationConfig>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListUsableWorkstationConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableWorkstationConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workstation_configs][crate::model::ListUsableWorkstationConfigsResponse::workstation_configs].
    pub fn set_workstation_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkstationConfig>,
    {
        use std::iter::Iterator;
        self.workstation_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsableWorkstationConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationConfigsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListUsableWorkstationConfigsResponse {
    type PageItem = crate::model::WorkstationConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstation_configs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for creating a CreateWorkstationConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkstationConfigRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID to use for the workstation configuration.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workstation_config_id: std::string::String,

    /// Required. Config to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation_config: std::option::Option<crate::model::WorkstationConfig>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,
}

impl CreateWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_config_id][crate::model::CreateWorkstationConfigRequest::workstation_config_id].
    pub fn set_workstation_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_config_id = v.into();
        self
    }

    /// Sets the value of [workstation_config][crate::model::CreateWorkstationConfigRequest::workstation_config].
    pub fn set_workstation_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkstationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_config = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationConfigRequest"
    }
}

/// Request message for UpdateWorkstationConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkstationConfigRequest {
    /// Required. Config to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation_config: std::option::Option<crate::model::WorkstationConfig>,

    /// Required. Mask specifying which fields in the workstation configuration
    /// should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set and the workstation configuration is not found, a new
    /// workstation configuration will be created. In this situation,
    /// update_mask is ignored.
    pub allow_missing: bool,
}

impl UpdateWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation_config][crate::model::UpdateWorkstationConfigRequest::workstation_config].
    pub fn set_workstation_config<
        T: std::convert::Into<std::option::Option<crate::model::WorkstationConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation_config = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationConfigRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationConfigRequest"
    }
}

/// Message for deleting a workstation configuration.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkstationConfigRequest {
    /// Required. Name of the workstation configuration to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request is rejected if the latest version of the
    /// workstation configuration on the server does not have this ETag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Optional. If set, any workstations in the workstation configuration are
    /// also deleted. Otherwise, the request works only if the workstation
    /// configuration has no workstations.
    pub force: bool,
}

impl DeleteWorkstationConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationConfigRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationConfigRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteWorkstationConfigRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationConfigRequest"
    }
}

/// Request message for GetWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetWorkstationRequest {
    /// Required. Name of the requested resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GetWorkstationRequest"
    }
}

/// Request message for ListWorkstations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationsRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListWorkstationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkstationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkstationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkstationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkstationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationsRequest"
    }
}

/// Response message for ListWorkstations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListWorkstationsResponse {
    /// The requested workstations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workstations: std::vec::Vec<crate::model::Workstation>,

    /// Optional. Token to retrieve the next page of results, or empty if there are
    /// no more results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Optional. Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListWorkstationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkstationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workstations][crate::model::ListWorkstationsResponse::workstations].
    pub fn set_workstations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workstation>,
    {
        use std::iter::Iterator;
        self.workstations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkstationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkstationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListWorkstationsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListWorkstationsResponse {
    type PageItem = crate::model::Workstation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstations
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for ListUsableWorkstations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableWorkstationsRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum number of items to return.
    pub page_size: i32,

    /// Optional. next_page_token value returned from a previous List request, if
    /// any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl ListUsableWorkstationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUsableWorkstationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUsableWorkstationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUsableWorkstationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationsRequest"
    }
}

/// Response message for ListUsableWorkstations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUsableWorkstationsResponse {
    /// The requested workstations.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub workstations: std::vec::Vec<crate::model::Workstation>,

    /// Token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Unreachable resources.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListUsableWorkstationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListUsableWorkstationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [workstations][crate::model::ListUsableWorkstationsResponse::workstations].
    pub fn set_workstations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workstation>,
    {
        use std::iter::Iterator;
        self.workstations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUsableWorkstationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUsableWorkstationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.ListUsableWorkstationsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListUsableWorkstationsResponse {
    type PageItem = crate::model::Workstation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workstations
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for creating a CreateWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateWorkstationRequest {
    /// Required. Parent resource name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. ID to use for the workstation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workstation_id: std::string::String,

    /// Required. Workstation to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation: std::option::Option<crate::model::Workstation>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,
}

impl CreateWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkstationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workstation_id][crate::model::CreateWorkstationRequest::workstation_id].
    pub fn set_workstation_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workstation_id = v.into();
        self
    }

    /// Sets the value of [workstation][crate::model::CreateWorkstationRequest::workstation].
    pub fn set_workstation<
        T: std::convert::Into<std::option::Option<crate::model::Workstation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.CreateWorkstationRequest"
    }
}

/// Request message for UpdateWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateWorkstationRequest {
    /// Required. Workstation to update.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub workstation: std::option::Option<crate::model::Workstation>,

    /// Required. Mask specifying which fields in the workstation configuration
    /// should be updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set and the workstation configuration is not found, a new
    /// workstation configuration is created. In this situation, update_mask
    /// is ignored.
    pub allow_missing: bool,
}

impl UpdateWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation][crate::model::UpdateWorkstationRequest::workstation].
    pub fn set_workstation<
        T: std::convert::Into<std::option::Option<crate::model::Workstation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.workstation = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkstationRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateWorkstationRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }
}

impl wkt::message::Message for UpdateWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.UpdateWorkstationRequest"
    }
}

/// Request message for DeleteWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteWorkstationRequest {
    /// Required. Name of the workstation to delete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl DeleteWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.DeleteWorkstationRequest"
    }
}

/// Request message for StartWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartWorkstationRequest {
    /// Required. Name of the workstation to start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl StartWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::StartWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::StartWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for StartWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.StartWorkstationRequest"
    }
}

/// Request message for StopWorkstation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopWorkstationRequest {
    /// Required. Name of the workstation to stop.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. If set, validate the request and preview the review, but do not
    /// actually apply it.
    pub validate_only: bool,

    /// Optional. If set, the request will be rejected if the latest version of the
    /// workstation on the server does not have this ETag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl StopWorkstationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopWorkstationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::StopWorkstationRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::StopWorkstationRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for StopWorkstationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.StopWorkstationRequest"
    }
}

/// Request message for GenerateAccessToken.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAccessTokenRequest {
    /// Required. Name of the workstation for which the access token should be
    /// generated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub workstation: std::string::String,

    /// Desired expiration or lifetime of the access token.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub expiration: std::option::Option<crate::model::generate_access_token_request::Expiration>,
}

impl GenerateAccessTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workstation][crate::model::GenerateAccessTokenRequest::workstation].
    pub fn set_workstation<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workstation = v.into();
        self
    }

    /// Sets the value of `expiration`.
    pub fn set_expiration<
        T: std::convert::Into<
            std::option::Option<crate::model::generate_access_token_request::Expiration>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = v.into();
        self
    }

    /// The value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// if it holds a `ExpireTime`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_expire_time(&self) -> std::option::Option<&std::boxed::Box<wkt::Timestamp>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::generate_access_token_request::Expiration::ExpireTime(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// The value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// if it holds a `Ttl`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_ttl(&self) -> std::option::Option<&std::boxed::Box<wkt::Duration>> {
        #[allow(unreachable_patterns)]
        self.expiration.as_ref().and_then(|v| match v {
            crate::model::generate_access_token_request::Expiration::Ttl(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// to hold a `ExpireTime`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_expire_time<T: std::convert::Into<std::boxed::Box<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::generate_access_token_request::Expiration::ExpireTime(v.into()),
        );
        self
    }

    /// Sets the value of [expiration][crate::model::GenerateAccessTokenRequest::expiration]
    /// to hold a `Ttl`.
    ///
    /// Note that all the setters affecting `expiration` are
    /// mutually exclusive.
    pub fn set_ttl<T: std::convert::Into<std::boxed::Box<wkt::Duration>>>(mut self, v: T) -> Self {
        self.expiration = std::option::Option::Some(
            crate::model::generate_access_token_request::Expiration::Ttl(v.into()),
        );
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GenerateAccessTokenRequest"
    }
}

/// Defines additional types related to GenerateAccessTokenRequest
pub mod generate_access_token_request {
    #[allow(unused_imports)]
    use super::*;

    /// Desired expiration or lifetime of the access token.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Expiration {
        /// Desired expiration time of the access token. This value must
        /// be at most 24 hours in the future. If a value is not specified, the
        /// token's expiration time will be set to a default value of 1 hour in the
        /// future.
        ExpireTime(std::boxed::Box<wkt::Timestamp>),
        /// Desired lifetime duration of the access token. This value must
        /// be at most 24 hours. If a value is not specified, the token's lifetime
        /// will be set to a default value of 1 hour.
        Ttl(std::boxed::Box<wkt::Duration>),
    }
}

/// Response message for GenerateAccessToken.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GenerateAccessTokenResponse {
    /// The generated bearer access token. To use this token, include it in an
    /// Authorization header of an HTTP request sent to the associated
    /// workstation's hostname—for example, `Authorization: Bearer
    /// <access_token>`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub access_token: std::string::String,

    /// Time at which the generated token will expire.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expire_time: std::option::Option<wkt::Timestamp>,
}

impl GenerateAccessTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_token][crate::model::GenerateAccessTokenResponse::access_token].
    pub fn set_access_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.access_token = v.into();
        self
    }

    /// Sets the value of [expire_time][crate::model::GenerateAccessTokenResponse::expire_time].
    pub fn set_expire_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.expire_time = v.into();
        self
    }
}

impl wkt::message::Message for GenerateAccessTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.GenerateAccessTokenResponse"
    }
}

/// Metadata for long-running operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. Time that the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Time that the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation.
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.workstations.v1.OperationMetadata"
    }
}
