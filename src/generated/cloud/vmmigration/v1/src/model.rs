// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// ReplicationCycle contains information about the current replication cycle
/// status.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationCycle {
    /// The identifier of the ReplicationCycle.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The cycle's ordinal number.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub cycle_number: i32,

    /// The time the replication cycle has started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the replication cycle has ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The accumulated duration the replication cycle was paused.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub total_pause_duration: std::option::Option<wkt::Duration>,

    /// The current progress in percentage of this cycle.
    /// Was replaced by 'steps' field, which breaks down the cycle progression more
    /// accurately.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    #[deprecated]
    pub progress_percent: i32,

    /// The cycle's steps list representing its progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::CycleStep>,

    /// State of the ReplicationCycle.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::replication_cycle::State,

    /// Provides details on the state of the cycle in case of an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationCycle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplicationCycle::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cycle_number][crate::model::ReplicationCycle::cycle_number].
    pub fn set_cycle_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cycle_number = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_total_pause_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_or_clear_total_pause_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::ReplicationCycle::progress_percent].
    #[deprecated]
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::ReplicationCycle::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CycleStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ReplicationCycle::state].
    pub fn set_state<T: std::convert::Into<crate::model::replication_cycle::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicationCycle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationCycle"
    }
}

/// Defines additional types related to [ReplicationCycle].
pub mod replication_cycle {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a replication cycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The replication cycle is running.
        Running,
        /// The replication cycle is paused.
        Paused,
        /// The replication cycle finished with errors.
        Failed,
        /// The replication cycle finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                3 => Self::Failed,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.ReplicationCycle.State",
            ))
        }
    }
}

/// CycleStep holds information about a step progress.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CycleStep {
    /// The time the cycle step has started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the cycle step has ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step: std::option::Option<crate::model::cycle_step::Step>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CycleStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CycleStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::cycle_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `InitializingReplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn initializing_replication(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InitializingReplicationStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::InitializingReplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `InitializingReplication`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_initializing_replication<
        T: std::convert::Into<std::boxed::Box<crate::model::InitializingReplicationStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cycle_step::Step::InitializingReplication(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `Replicating`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replicating(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicatingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::Replicating(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `Replicating`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_replicating<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicatingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::Replicating(v.into()));
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `PostProcessing`, `None` if the field is not set or
    /// holds a different branch.
    pub fn post_processing(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostProcessingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::PostProcessing(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `PostProcessing`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_post_processing<
        T: std::convert::Into<std::boxed::Box<crate::model::PostProcessingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::PostProcessing(v.into()));
        self
    }
}

impl wkt::message::Message for CycleStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CycleStep"
    }
}

/// Defines additional types related to [CycleStep].
pub mod cycle_step {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Step {
        /// Initializing replication step.
        InitializingReplication(std::boxed::Box<crate::model::InitializingReplicationStep>),
        /// Replicating step.
        Replicating(std::boxed::Box<crate::model::ReplicatingStep>),
        /// Post processing step.
        PostProcessing(std::boxed::Box<crate::model::PostProcessingStep>),
    }
}

/// InitializingReplicationStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InitializingReplicationStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializingReplicationStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializingReplicationStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InitializingReplicationStep"
    }
}

/// ReplicatingStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicatingStep {
    /// Total bytes to be handled in the step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub total_bytes: i64,

    /// Replicated bytes in the step.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub replicated_bytes: i64,

    /// The source disks replication rate for the last 2 minutes in bytes per
    /// second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub last_two_minutes_average_bytes_per_second: i64,

    /// The source disks replication rate for the last 30 minutes in bytes per
    /// second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub last_thirty_minutes_average_bytes_per_second: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicatingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_bytes][crate::model::ReplicatingStep::total_bytes].
    pub fn set_total_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_bytes = v.into();
        self
    }

    /// Sets the value of [replicated_bytes][crate::model::ReplicatingStep::replicated_bytes].
    pub fn set_replicated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replicated_bytes = v.into();
        self
    }

    /// Sets the value of [last_two_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_two_minutes_average_bytes_per_second].
    pub fn set_last_two_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_two_minutes_average_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [last_thirty_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_thirty_minutes_average_bytes_per_second].
    pub fn set_last_thirty_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_thirty_minutes_average_bytes_per_second = v.into();
        self
    }
}

impl wkt::message::Message for ReplicatingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicatingStep"
    }
}

/// PostProcessingStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PostProcessingStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostProcessingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PostProcessingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PostProcessingStep"
    }
}

/// ReplicationSync contain information about the last replica sync to the cloud.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReplicationSync {
    /// The most updated snapshot created time in the source that finished
    /// replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_sync_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_last_sync_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_or_clear_last_sync_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicationSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationSync"
    }
}

/// MigratingVm describes the VM that will be migrated from a Source environment
/// and its replication state.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigratingVm {
    /// Output only. The identifier of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The unique ID of the VM in the source.
    /// The VM's name in vSphere can be changed, so this is not the VM's name but
    /// rather its moRef id. This id is of the form vm-\<num\>.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_vm_id: std::string::String,

    /// The display name attached to the MigratingVm by the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The description attached to the migrating VM by the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// The replication schedule policy.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub policy: std::option::Option<crate::model::SchedulePolicy>,

    /// Output only. The time the migrating VM was created (this refers to this
    /// resource and not to the time it was installed in the source).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the migrating VM resource was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most updated snapshot created time in the source that
    /// finished replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_sync: std::option::Option<crate::model::ReplicationSync>,

    /// Output only. State of the MigratingVm.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::migrating_vm::State,

    /// Output only. The last time the migrating VM state was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The percentage progress of the current running replication
    /// cycle.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub current_sync_info: std::option::Option<crate::model::ReplicationCycle>,

    /// Output only. The group this migrating vm is included in, if any. The group
    /// is represented by the full path of the appropriate
    /// [Group][google.cloud.vmmigration.v1.Group] resource.
    ///
    /// [google.cloud.vmmigration.v1.Group]: crate::model::Group
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// The labels of the migrating VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The recent [clone jobs][google.cloud.vmmigration.v1.CloneJob]
    /// performed on the migrating VM. This field holds the vm's last completed
    /// clone job and the vm's running clone job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    ///
    /// [google.cloud.vmmigration.v1.CloneJob]: crate::model::CloneJob
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub recent_clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. Provides details on the state of the Migrating VM in case of
    /// an error in replication.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The recent cutover jobs performed on the migrating VM.
    /// This field holds the vm's last completed cutover job and the vm's
    /// running cutover job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub recent_cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_vm_defaults: std::option::Option<crate::model::migrating_vm::TargetVmDefaults>,

    /// Details about the source VM.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_vm_details: std::option::Option<crate::model::migrating_vm::SourceVmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigratingVm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigratingVm::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_vm_id][crate::model::MigratingVm::source_vm_id].
    pub fn set_source_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigratingVm::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MigratingVm::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_last_sync<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_or_clear_last_sync<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::MigratingVm::state].
    pub fn set_state<T: std::convert::Into<crate::model::migrating_vm::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_current_sync_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_or_clear_current_sync_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::MigratingVm::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MigratingVm::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [recent_clone_jobs][crate::model::MigratingVm::recent_clone_jobs].
    pub fn set_recent_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.recent_clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error][crate::model::MigratingVm::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::MigratingVm::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recent_cutover_jobs][crate::model::MigratingVm::recent_cutover_jobs].
    pub fn set_recent_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.recent_cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults].
    ///
    /// Note that all the setters affecting `target_vm_defaults` are mutually
    /// exclusive.
    pub fn set_target_vm_defaults<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::TargetVmDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = v.into();
        self
    }

    /// The value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// if it holds a `ComputeEngineTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDefaults>> {
        #[allow(unreachable_patterns)]
        self.target_vm_defaults.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// to hold a `ComputeEngineTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_vm_defaults` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = std::option::Option::Some(
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v.into()),
        );
        self
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details].
    ///
    /// Note that all the setters affecting `source_vm_details` are mutually
    /// exclusive.
    pub fn set_source_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::SourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = v.into();
        self
    }

    /// The value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// if it holds a `AwsSourceVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_source_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceVmDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vm_details.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// to hold a `AwsSourceVmDetails`.
    ///
    /// Note that all the setters affecting `source_vm_details` are
    /// mutually exclusive.
    pub fn set_aws_source_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = std::option::Option::Some(
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigratingVm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigratingVm"
    }
}

/// Defines additional types related to [MigratingVm].
pub mod migrating_vm {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state/health of source VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The VM in the source is being verified.
        Pending,
        /// The source VM was verified, and it's ready to start replication.
        Ready,
        /// Migration is going through the first sync cycle.
        FirstSync,
        /// The replication is active, and it's running or scheduled to run.
        Active,
        /// The source VM is being turned off, and a final replication is currently
        /// running.
        CuttingOver,
        /// The source VM was stopped and replicated. The replication is currently
        /// paused.
        Cutover,
        /// A cutover job is active and replication cycle is running the final sync.
        FinalSync,
        /// The replication was paused by the user and no cycles are scheduled to
        /// run.
        Paused,
        /// The migrating VM is being finalized and migration resources are being
        /// removed.
        Finalizing,
        /// The replication process is done. The migrating VM is finalized and no
        /// longer consumes billable resources.
        Finalized,
        /// The replication process encountered an unrecoverable error and was
        /// aborted.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::FirstSync => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::CuttingOver => std::option::Option::Some(7),
                Self::Cutover => std::option::Option::Some(8),
                Self::FinalSync => std::option::Option::Some(9),
                Self::Paused => std::option::Option::Some(10),
                Self::Finalizing => std::option::Option::Some(11),
                Self::Finalized => std::option::Option::Some(12),
                Self::Error => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::FirstSync => std::option::Option::Some("FIRST_SYNC"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::CuttingOver => std::option::Option::Some("CUTTING_OVER"),
                Self::Cutover => std::option::Option::Some("CUTOVER"),
                Self::FinalSync => std::option::Option::Some("FINAL_SYNC"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Finalizing => std::option::Option::Some("FINALIZING"),
                Self::Finalized => std::option::Option::Some("FINALIZED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Ready,
                3 => Self::FirstSync,
                4 => Self::Active,
                7 => Self::CuttingOver,
                8 => Self::Cutover,
                9 => Self::FinalSync,
                10 => Self::Paused,
                11 => Self::Finalizing,
                12 => Self::Finalized,
                13 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "READY" => Self::Ready,
                "FIRST_SYNC" => Self::FirstSync,
                "ACTIVE" => Self::Active,
                "CUTTING_OVER" => Self::CuttingOver,
                "CUTOVER" => Self::Cutover,
                "FINAL_SYNC" => Self::FinalSync,
                "PAUSED" => Self::Paused,
                "FINALIZING" => Self::Finalizing,
                "FINALIZED" => Self::Finalized,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::FirstSync => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::CuttingOver => serializer.serialize_i32(7),
                Self::Cutover => serializer.serialize_i32(8),
                Self::FinalSync => serializer.serialize_i32(9),
                Self::Paused => serializer.serialize_i32(10),
                Self::Finalizing => serializer.serialize_i32(11),
                Self::Finalized => serializer.serialize_i32(12),
                Self::Error => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.MigratingVm.State",
            ))
        }
    }

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetVmDefaults {
        /// Details of the target VM in Compute Engine.
        ComputeEngineTargetDefaults(std::boxed::Box<crate::model::ComputeEngineTargetDefaults>),
    }

    /// Details about the source VM.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceVmDetails {
        /// Output only. Details of the VM from an AWS source.
        AwsSourceVmDetails(std::boxed::Box<crate::model::AwsSourceVmDetails>),
    }
}

/// CloneJob describes the process of creating a clone of a
/// [MigratingVM][google.cloud.vmmigration.v1.MigratingVm] to the
/// requested target based on the latest successful uploaded snapshots.
/// While the migration cycles of a MigratingVm take place, it is possible to
/// verify the uploaded VM can be started in the cloud, by creating a clone. The
/// clone can be created without any downtime, and it is created using the latest
/// snapshots which are already in the cloud. The cloneJob is only responsible
/// for its work, not its products, which means once it is finished, it will
/// never touch the instance it created. It will only delete it in case of the
/// CloneJob being cancelled or upon failure to clone.
///
/// [google.cloud.vmmigration.v1.MigratingVm]: crate::model::MigratingVm
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloneJob {
    /// Output only. The time the clone job was created (as an API call, not when
    /// it was actually created in the target).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the clone job was ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the clone.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the clone job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::clone_job::State,

    /// Output only. The time the state was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details for the errors that led to the Clone Job's
    /// state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The clone steps list representing its progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::CloneStep>,

    /// Details of the VM to create as the target of this clone job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_vm_details: std::option::Option<crate::model::clone_job::TargetVmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CloneJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloneJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::clone_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::CloneJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CloneJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::CloneJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::clone_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneJob"
    }
}

/// Defines additional types related to [CloneJob].
pub mod clone_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the clone job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The clone job has not yet started.
        Pending,
        /// The clone job is active and running.
        Active,
        /// The clone job finished with errors.
        Failed,
        /// The clone job finished successfully.
        Succeeded,
        /// The clone job was cancelled.
        Cancelled,
        /// The clone job is being cancelled.
        Cancelling,
        /// OS adaptation is running as part of the clone job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Cancelling => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Failed,
                4 => Self::Succeeded,
                5 => Self::Cancelled,
                6 => Self::Cancelling,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Cancelling => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CloneJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this clone job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
    }
}

/// CloneStep holds information about the clone step progress.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CloneStep {
    /// The time the step has started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step: std::option::Option<crate::model::clone_step::Step>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CloneStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::clone_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `AdaptingOs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn adapting_os(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdaptingOSStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::AdaptingOs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `AdaptingOs`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_adapting_os<T: std::convert::Into<std::boxed::Box<crate::model::AdaptingOSStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(crate::model::clone_step::Step::AdaptingOs(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::clone_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::clone_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneStep"
    }
}

/// Defines additional types related to [CloneStep].
pub mod clone_step {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Step {
        /// Adapting OS step.
        AdaptingOs(std::boxed::Box<crate::model::AdaptingOSStep>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// AdaptingOSStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AdaptingOSStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptingOSStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdaptingOSStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AdaptingOSStep"
    }
}

/// PreparingVMDisksStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PreparingVMDisksStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PreparingVMDisksStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PreparingVMDisksStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PreparingVMDisksStep"
    }
}

/// InstantiatingMigratedVMStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstantiatingMigratedVMStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiatingMigratedVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InstantiatingMigratedVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InstantiatingMigratedVMStep"
    }
}

/// CutoverJob message describes a cutover of a migrating VM. The CutoverJob is
/// the operation of shutting down the VM, creating a snapshot and
/// clonning the VM using the replicated snapshot.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CutoverJob {
    /// Output only. The time the cutover job was created (as an API call, not when
    /// it was actually created in the target).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the cutover job had finished.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the cutover job.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. State of the cutover job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::cutover_job::State,

    /// Output only. The time the state was last updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current progress in percentage of the cutover job.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub progress_percent: i32,

    /// Output only. Provides details for the errors that led to the Cutover Job's
    /// state.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. A message providing possible extra details about the current
    /// state.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_message: std::string::String,

    /// Output only. The cutover steps list representing its progress.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::CutoverStep>,

    /// Details of the VM to create as the target of this cutover job.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub target_vm_details: std::option::Option<crate::model::cutover_job::TargetVmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CutoverJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CutoverJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::cutover_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::CutoverJob::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CutoverJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CutoverJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_message][crate::model::CutoverJob::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::CutoverJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::cutover_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverJob"
    }
}

/// Defines additional types related to [CutoverJob].
pub mod cutover_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the cutover job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The cutover job has not yet started.
        Pending,
        /// The cutover job finished with errors.
        Failed,
        /// The cutover job finished successfully.
        Succeeded,
        /// The cutover job was cancelled.
        Cancelled,
        /// The cutover job is being cancelled.
        Cancelling,
        /// The cutover job is active and running.
        Active,
        /// OS adaptation is running as part of the cutover job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Succeeded,
                4 => Self::Cancelled,
                5 => Self::Cancelling,
                6 => Self::Active,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ACTIVE" => Self::Active,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CutoverJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this cutover job.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
    }
}

/// CutoverStep holds information about the cutover step progress.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CutoverStep {
    /// The time the step has started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub step: std::option::Option<crate::model::cutover_step::Step>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CutoverStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<
        T: std::convert::Into<std::option::Option<crate::model::cutover_step::Step>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreviousReplicationCycle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn previous_replication_cycle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreviousReplicationCycle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreviousReplicationCycle`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_previous_replication_cycle<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::PreviousReplicationCycle(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `ShuttingDownSourceVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shutting_down_source_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ShuttingDownSourceVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `ShuttingDownSourceVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_shutting_down_source_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::ShuttingDownSourceVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `FinalSync`, `None` if the field is not set or
    /// holds a different branch.
    pub fn final_sync(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::FinalSync(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `FinalSync`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_final_sync<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::FinalSync(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverStep"
    }
}

/// Defines additional types related to [CutoverStep].
pub mod cutover_step {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Step {
        /// A replication cycle prior cutover step.
        PreviousReplicationCycle(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Shutting down VM step.
        ShuttingDownSourceVm(std::boxed::Box<crate::model::ShuttingDownSourceVMStep>),
        /// Final sync step.
        FinalSync(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// ShuttingDownSourceVMStep contains specific step details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShuttingDownSourceVMStep {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShuttingDownSourceVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ShuttingDownSourceVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ShuttingDownSourceVMStep"
    }
}

/// Request message for 'CreateCloneJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCloneJobRequest {
    /// Required. The Clone's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The clone job identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub clone_job_id: std::string::String,

    /// Required. The clone request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub clone_job: std::option::Option<crate::model::CloneJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloneJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [clone_job_id][crate::model::CreateCloneJobRequest::clone_job_id].
    pub fn set_clone_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_job_id = v.into();
        self
    }

    /// Sets the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_clone_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_or_clear_clone_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloneJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCloneJobRequest"
    }
}

/// Request message for 'CancelCloneJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCloneJobRequest {
    /// Required. The clone job id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobRequest"
    }
}

/// Response message for 'CancelCloneJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCloneJobResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCloneJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobResponse"
    }
}

/// Request message for 'ListCloneJobsRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloneJobsRequest {
    /// Required. The parent, which owns this collection of source VMs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of clone jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 clone jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCloneJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCloneJobs` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloneJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloneJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloneJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloneJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCloneJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCloneJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsRequest"
    }
}

/// Response message for 'ListCloneJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCloneJobsResponse {
    /// Output only. The list of clone jobs response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_jobs][crate::model::ListCloneJobsResponse::clone_jobs].
    pub fn set_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloneJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCloneJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCloneJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloneJobsResponse {
    type PageItem = crate::model::CloneJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clone_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetCloneJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCloneJobRequest {
    /// Required. The name of the CloneJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCloneJobRequest"
    }
}

/// Source message describes a specific vm migration Source resource. It contains
/// the source environment information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Source {
    /// Output only. The Source name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels of the source.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-provided description of the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_details: std::option::Option<crate::model::source::SourceDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Source::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Source::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Source::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Source::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Source::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [source_details][crate::model::Source::source_details].
    ///
    /// Note that all the setters affecting `source_details` are mutually
    /// exclusive.
    pub fn set_source_details<
        T: std::convert::Into<std::option::Option<crate::model::source::SourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_details = v.into();
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Vmware`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Vmware(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Vmware`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_vmware<T: std::convert::Into<std::boxed::Box<crate::model::VmwareSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Vmware(v.into()));
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Aws`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Aws(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Aws`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_aws<T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Aws(v.into()));
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Source"
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceDetails {
        /// Vmware type source details.
        Vmware(std::boxed::Box<crate::model::VmwareSourceDetails>),
        /// AWS type source details.
        Aws(std::boxed::Box<crate::model::AwsSourceDetails>),
    }
}

/// VmwareSourceDetails message describes a specific source details for the
/// vmware source type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareSourceDetails {
    /// The credentials username.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    /// Input only. The credentials password. This is write only and can not be
    /// read in a GET operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    /// The ip address of the vcenter this Source represents.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vcenter_ip: std::string::String,

    /// The thumbprint representing the certificate for the vcenter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub thumbprint: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::VmwareSourceDetails::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::VmwareSourceDetails::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [vcenter_ip][crate::model::VmwareSourceDetails::vcenter_ip].
    pub fn set_vcenter_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_ip = v.into();
        self
    }

    /// Sets the value of [thumbprint][crate::model::VmwareSourceDetails::thumbprint].
    pub fn set_thumbprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.thumbprint = v.into();
        self
    }
}

impl wkt::message::Message for VmwareSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareSourceDetails"
    }
}

/// AwsSourceDetails message describes a specific source details for the
/// AWS source type.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsSourceDetails {
    /// Immutable. The AWS region that the source VMs will be migrated from.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub aws_region: std::string::String,

    /// Output only. State of the source as determined by the health check.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::aws_source_details::State,

    /// Output only. Provides details on the state of the Source in case of an
    /// error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// AWS resource tags to limit the scope of the source inventory.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inventory_tag_list: std::vec::Vec<crate::model::aws_source_details::Tag>,

    /// AWS security group names to limit the scope of the source
    /// inventory.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub inventory_security_group_names: std::vec::Vec<std::string::String>,

    /// User specified tags to add to every M2VM generated resource in AWS.
    /// These tags will be set in addition to the default tags that are set as part
    /// of the migration process. The tags must not begin with the reserved prefix
    /// `m2vm`.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub migration_resources_user_tags:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The source's public IP. All communication initiated by this
    /// source will originate from this IP.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub public_ip: std::string::String,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub credentials_type: std::option::Option<crate::model::aws_source_details::CredentialsType>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_region][crate::model::AwsSourceDetails::aws_region].
    pub fn set_aws_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_region = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsSourceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_source_details::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inventory_tag_list][crate::model::AwsSourceDetails::inventory_tag_list].
    pub fn set_inventory_tag_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::aws_source_details::Tag>,
    {
        use std::iter::Iterator;
        self.inventory_tag_list = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inventory_security_group_names][crate::model::AwsSourceDetails::inventory_security_group_names].
    pub fn set_inventory_security_group_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inventory_security_group_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [migration_resources_user_tags][crate::model::AwsSourceDetails::migration_resources_user_tags].
    pub fn set_migration_resources_user_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.migration_resources_user_tags =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [public_ip][crate::model::AwsSourceDetails::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type].
    ///
    /// Note that all the setters affecting `credentials_type` are mutually
    /// exclusive.
    pub fn set_credentials_type<
        T: std::convert::Into<std::option::Option<crate::model::aws_source_details::CredentialsType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = v.into();
        self
    }

    /// The value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// if it holds a `AccessKeyCreds`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_key_creds(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.credentials_type.as_ref().and_then(|v| match v {
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// to hold a `AccessKeyCreds`.
    ///
    /// Note that all the setters affecting `credentials_type` are
    /// mutually exclusive.
    pub fn set_access_key_creds<
        T: std::convert::Into<std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = std::option::Option::Some(
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails"
    }
}

/// Defines additional types related to [AwsSourceDetails].
pub mod aws_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing AWS Credentials using access key id and secret.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AccessKeyCredentials {
        /// AWS access key ID.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub access_key_id: std::string::String,

        /// Input only. AWS secret access key.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub secret_access_key: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessKeyCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_key_id][crate::model::aws_source_details::AccessKeyCredentials::access_key_id].
        pub fn set_access_key_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_key_id = v.into();
            self
        }

        /// Sets the value of [secret_access_key][crate::model::aws_source_details::AccessKeyCredentials::secret_access_key].
        pub fn set_secret_access_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_access_key = v.into();
            self
        }
    }

    impl wkt::message::Message for AccessKeyCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.AccessKeyCredentials"
        }
    }

    /// Tag is an AWS tag representation.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Tag {
        /// Key of tag.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub key: std::string::String,

        /// Value of tag.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub value: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Tag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::aws_source_details::Tag::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::aws_source_details::Tag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Tag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.Tag"
        }
    }

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source is available but might not be usable yet due to invalid
        /// credentials or another reason.
        /// The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.AwsSourceDetails.State",
            ))
        }
    }

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum CredentialsType {
        /// AWS Credentials using access key id and secret.
        AccessKeyCreds(std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>),
    }
}

/// DatacenterConnector message describes a connector between the Source and
/// Google Cloud, which is installed on a vmware datacenter (an OVA vm installed
/// by the user) to connect the Datacenter to Google Cloud and support vm
/// migration data transfer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DatacenterConnector {
    /// Output only. The time the connector was created (as an API call, not when
    /// it was actually installed).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the connector was updated with an API call.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The connector's name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Immutable. A unique key for this connector. This key is internal to the OVA
    /// connector and is supplied with its creation during the registration process
    /// and can not be modified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub registration_id: std::string::String,

    /// The service account to use in the connector when communicating with the
    /// cloud.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The version running in the DatacenterConnector. This is supplied by the OVA
    /// connector during the registration process and can not be modified.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The communication channel between the datacenter connector and
    /// Google Cloud.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub bucket: std::string::String,

    /// Output only. State of the DatacenterConnector, as determined by the health
    /// checks.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::datacenter_connector::State,

    /// Output only. The time the state was last set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the Datacenter Connector in
    /// case of an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Appliance OVA version.
    /// This is the OVA which is manually installed by the user and contains the
    /// infrastructure for the automatically updatable components on the appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub appliance_infrastructure_version: std::string::String,

    /// Output only. Appliance last installed update bundle version.
    /// This is the version of the automatically updatable components on the
    /// appliance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub appliance_software_version: std::string::String,

    /// Output only. The available versions for updating this appliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub available_versions: std::option::Option<crate::model::AvailableUpdates>,

    /// Output only. The status of the current / last upgradeAppliance operation.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub upgrade_status: std::option::Option<crate::model::UpgradeStatus>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatacenterConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::DatacenterConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [registration_id][crate::model::DatacenterConnector::registration_id].
    pub fn set_registration_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.registration_id = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DatacenterConnector::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatacenterConnector::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::DatacenterConnector::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatacenterConnector::state].
    pub fn set_state<T: std::convert::Into<crate::model::datacenter_connector::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [appliance_infrastructure_version][crate::model::DatacenterConnector::appliance_infrastructure_version].
    pub fn set_appliance_infrastructure_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_infrastructure_version = v.into();
        self
    }

    /// Sets the value of [appliance_software_version][crate::model::DatacenterConnector::appliance_software_version].
    pub fn set_appliance_software_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_software_version = v.into();
        self
    }

    /// Sets the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_available_versions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_or_clear_available_versions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_upgrade_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_or_clear_upgrade_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatacenterConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DatacenterConnector"
    }
}

/// Defines additional types related to [DatacenterConnector].
pub mod datacenter_connector {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source was sampled by health checks and is not available.
        Offline,
        /// The source is available but might not be usable yet due to unvalidated
        /// credentials or another reason. The credentials referred to are the ones
        /// to the Source. The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Offline,
                3 => Self::Failed,
                4 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "OFFLINE" => Self::Offline,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.DatacenterConnector.State",
            ))
        }
    }
}

/// UpgradeStatus contains information about upgradeAppliance operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeStatus {
    /// The version to upgrade to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// The state of the upgradeAppliance operation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::upgrade_status::State,

    /// Provides details on the state of the upgrade operation in case of an error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// The time the operation was started.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The version from which we upgraded.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub previous_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpgradeStatus::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [previous_version][crate::model::UpgradeStatus::previous_version].
    pub fn set_previous_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.previous_version = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeStatus"
    }
}

/// Defines additional types related to [UpgradeStatus].
pub mod upgrade_status {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The upgrade has started.
        Running,
        /// The upgrade failed.
        Failed,
        /// The upgrade finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Failed,
                3 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UpgradeStatus.State",
            ))
        }
    }
}

/// Holds informatiom about the available versions for upgrade.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AvailableUpdates {
    /// The newest deployable version of the appliance.
    /// The current appliance can't be updated into this version, and the owner
    /// must manually deploy this OVA to a new appliance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub new_deployable_appliance: std::option::Option<crate::model::ApplianceVersion>,

    /// The latest version for in place update.
    /// The current appliance can be updated to this version using the API or m4c
    /// CLI.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub in_place_update: std::option::Option<crate::model::ApplianceVersion>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvailableUpdates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_new_deployable_appliance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_or_clear_new_deployable_appliance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_in_place_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_or_clear_in_place_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AvailableUpdates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AvailableUpdates"
    }
}

/// Describes an appliance version.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApplianceVersion {
    /// The appliance version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// A link for downloading the version.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uri: std::string::String,

    /// Determine whether it's critical to upgrade the appliance to this version.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub critical: bool,

    /// Link to a page that contains the version release notes.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub release_notes_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::ApplianceVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ApplianceVersion::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [critical][crate::model::ApplianceVersion::critical].
    pub fn set_critical<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.critical = v.into();
        self
    }

    /// Sets the value of [release_notes_uri][crate::model::ApplianceVersion::release_notes_uri].
    pub fn set_release_notes_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_notes_uri = v.into();
        self
    }
}

impl wkt::message::Message for ApplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ApplianceVersion"
    }
}

/// Request message for 'ListSources' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. The parent, which owns this collection of sources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of sources to return. The service may return
    /// fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListSources` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSources` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesRequest"
    }
}

/// Response message for 'ListSources' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// Output only. The list of sources response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub sources: std::vec::Vec<crate::model::Source>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetSource' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. The Source name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetSourceRequest"
    }
}

/// Request message for 'CreateSource' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. The Source's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The source identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_id: std::string::String,

    /// Required. The create request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CreateSourceRequest::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateSourceRequest"
    }
}

/// Update message for 'UpdateSources' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Source resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateSourceRequest"
    }
}

/// Request message for 'DeleteSource' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteSourceRequest {
    /// Required. The Source name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteSourceRequest"
    }
}

/// Request message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchInventoryRequest {
    /// Required. The name of the Source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source: std::string::String,

    /// If this flag is set to true, the source will be queried instead of using
    /// cached results. Using this flag will make the call slower.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub force_refresh: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::FetchInventoryRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [force_refresh][crate::model::FetchInventoryRequest::force_refresh].
    pub fn set_force_refresh<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_refresh = v.into();
        self
    }
}

impl wkt::message::Message for FetchInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryRequest"
    }
}

/// VmwareVmDetails describes a VM in vCenter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareVmDetails {
    /// The VM's id in the source (note that this is not the MigratingVm's id).
    /// This is the moref id of the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_id: std::string::String,

    /// The id of the vCenter's datacenter this VM is contained in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datacenter_id: std::string::String,

    /// The descriptive name of the vCenter's datacenter this VM is contained in.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datacenter_description: std::string::String,

    /// The unique identifier of the VM in vCenter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uuid: std::string::String,

    /// The display name of the VM. Note that this is not necessarily unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The power state of the VM at the moment list was taken.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub power_state: crate::model::vmware_vm_details::PowerState,

    /// The number of cpus in the VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub cpu_count: i32,

    /// The size of the memory of the VM in MB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub memory_mb: i32,

    /// The number of disks the VM has.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub committed_storage_mb: i64,

    /// The VM's OS. See for example
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>
    /// for types of strings this might hold.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub guest_description: std::string::String,

    /// Output only. The VM Boot Option.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_option: crate::model::vmware_vm_details::BootOption,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmwareVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [datacenter_id][crate::model::VmwareVmDetails::datacenter_id].
    pub fn set_datacenter_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datacenter_id = v.into();
        self
    }

    /// Sets the value of [datacenter_description][crate::model::VmwareVmDetails::datacenter_description].
    pub fn set_datacenter_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_description = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::VmwareVmDetails::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::VmwareVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::VmwareVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::vmware_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::VmwareVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::VmwareVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::VmwareVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::VmwareVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [guest_description][crate::model::VmwareVmDetails::guest_description].
    pub fn set_guest_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.guest_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::VmwareVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::vmware_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }
}

impl wkt::message::Message for VmwareVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmDetails"
    }
}

/// Defines additional types related to [VmwareVmDetails].
pub mod vmware_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned ON.
        On,
        /// The VM is turned OFF.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep mode.
        Suspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.PowerState",
            ))
        }
    }

    /// Possible values for vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is EFI.
        Efi,
        /// The boot option is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.BootOption",
            ))
        }
    }
}

/// AwsVmDetails describes a VM in AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsVmDetails {
    /// The VM ID in AWS.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_id: std::string::String,

    /// The display name of the VM. Note that this value is not necessarily unique.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// The id of the AWS's source this VM is connected to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_id: std::string::String,

    /// The descriptive name of the AWS's source this VM is connected to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub source_description: std::string::String,

    /// Output only. The power state of the VM at the moment list was taken.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub power_state: crate::model::aws_vm_details::PowerState,

    /// The number of cpus the VM has.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub cpu_count: i32,

    /// The memory size of the VM in MB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub memory_mb: i32,

    /// The number of disks the VM has.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub committed_storage_mb: i64,

    /// The VM's OS.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_description: std::string::String,

    /// The VM Boot Option.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_option: crate::model::aws_vm_details::BootOption,

    /// The instance type of the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_type: std::string::String,

    /// The VPC ID the VM belongs to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vpc_id: std::string::String,

    /// The security groups the VM belongs to.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub security_groups: std::vec::Vec<crate::model::AwsSecurityGroup>,

    /// The tags of the VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The AWS zone of the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// The virtualization type.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub virtualization_type: crate::model::aws_vm_details::VmVirtualizationType,

    /// The CPU architecture.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub architecture: crate::model::aws_vm_details::VmArchitecture,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::AwsVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AwsVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::AwsVmDetails::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source_description][crate::model::AwsVmDetails::source_description].
    pub fn set_source_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_description = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::AwsVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::aws_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::AwsVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::AwsVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::AwsVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::AwsVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [os_description][crate::model::AwsVmDetails::os_description].
    pub fn set_os_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::AwsVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::aws_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::AwsVmDetails::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [vpc_id][crate::model::AwsVmDetails::vpc_id].
    pub fn set_vpc_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_id = v.into();
        self
    }

    /// Sets the value of [security_groups][crate::model::AwsVmDetails::security_groups].
    pub fn set_security_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsSecurityGroup>,
    {
        use std::iter::Iterator;
        self.security_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsVmDetails::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [zone][crate::model::AwsVmDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [virtualization_type][crate::model::AwsVmDetails::virtualization_type].
    pub fn set_virtualization_type<
        T: std::convert::Into<crate::model::aws_vm_details::VmVirtualizationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.virtualization_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AwsVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::aws_vm_details::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for AwsVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmDetails"
    }
}

/// Defines additional types related to [AwsVmDetails].
pub mod aws_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned on.
        On,
        /// The VM is turned off.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep
        /// mode.
        Suspended,
        /// The VM is starting.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::Pending => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                4 => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::Pending => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.PowerState",
            ))
        }
    }

    /// The possible values for the vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is UEFI.
        Efi,
        /// The boot option is LEGACY-BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.BootOption",
            ))
        }
    }

    /// Possible values for the virtualization types of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmVirtualizationType {
        /// The virtualization type is unknown.
        Unspecified,
        /// The virtualziation type is HVM.
        Hvm,
        /// The virtualziation type is PARAVIRTUAL.
        Paravirtual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmVirtualizationType::value] or
        /// [VmVirtualizationType::name].
        UnknownValue(vm_virtualization_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_virtualization_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmVirtualizationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hvm => std::option::Option::Some(1),
                Self::Paravirtual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VM_VIRTUALIZATION_TYPE_UNSPECIFIED")
                }
                Self::Hvm => std::option::Option::Some("HVM"),
                Self::Paravirtual => std::option::Option::Some("PARAVIRTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmVirtualizationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmVirtualizationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmVirtualizationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hvm,
                2 => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmVirtualizationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_VIRTUALIZATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HVM" => Self::Hvm,
                "PARAVIRTUAL" => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmVirtualizationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hvm => serializer.serialize_i32(1),
                Self::Paravirtual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmVirtualizationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmVirtualizationType>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmVirtualizationType",
            ))
        }
    }

    /// Possible values for the architectures of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmArchitecture {
        /// The architecture is unknown.
        Unspecified,
        /// The architecture is I386.
        I386,
        /// The architecture is X86_64.
        X8664,
        /// The architecture is ARM64.
        Arm64,
        /// The architecture is X86_64_MAC.
        X8664Mac,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmArchitecture::value] or
        /// [VmArchitecture::name].
        UnknownValue(vm_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::I386 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::Arm64 => std::option::Option::Some(3),
                Self::X8664Mac => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
                Self::I386 => std::option::Option::Some("I386"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664Mac => std::option::Option::Some("X86_64_MAC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::I386,
                2 => Self::X8664,
                3 => Self::Arm64,
                4 => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "I386" => Self::I386,
                "X86_64" => Self::X8664,
                "ARM64" => Self::Arm64,
                "X86_64_MAC" => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::I386 => serializer.serialize_i32(1),
                Self::X8664 => serializer.serialize_i32(2),
                Self::Arm64 => serializer.serialize_i32(3),
                Self::X8664Mac => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmArchitecture",
            ))
        }
    }
}

/// AwsSecurityGroup describes a security group of an AWS VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsSecurityGroup {
    /// The AWS security group id.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// The AWS security group name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSecurityGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AwsSecurityGroup::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AwsSecurityGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AwsSecurityGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSecurityGroup"
    }
}

/// VmwareVmsDetails describes VMs in vCenter.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmwareVmsDetails {
    /// The details of the vmware VMs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub details: std::vec::Vec<crate::model::VmwareVmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::VmwareVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmwareVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VmwareVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmsDetails"
    }
}

/// AWSVmsDetails describes VMs in AWS.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsVmsDetails {
    /// The details of the AWS VMs.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub details: std::vec::Vec<crate::model::AwsVmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::AwsVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmsDetails"
    }
}

/// Response message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchInventoryResponse {
    /// Output only. The timestamp when the source was last queried (if the result
    /// is from the cache).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub source_vms: std::option::Option<crate::model::fetch_inventory_response::SourceVms>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms].
    ///
    /// Note that all the setters affecting `source_vms` are mutually
    /// exclusive.
    pub fn set_source_vms<
        T: std::convert::Into<std::option::Option<crate::model::fetch_inventory_response::SourceVms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = v.into();
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `VmwareVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `VmwareVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_vmware_vms<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmsDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v.into()),
        );
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `AwsVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_vms(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `AwsVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_aws_vms<T: std::convert::Into<std::boxed::Box<crate::model::AwsVmsDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FetchInventoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryResponse"
    }
}

/// Defines additional types related to [FetchInventoryResponse].
pub mod fetch_inventory_response {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum SourceVms {
        /// The description of the VMs in a Source of type Vmware.
        VmwareVms(std::boxed::Box<crate::model::VmwareVmsDetails>),
        /// The description of the VMs in a Source of type AWS.
        AwsVms(std::boxed::Box<crate::model::AwsVmsDetails>),
    }
}

/// Utilization report details the utilization (CPU, memory, etc.) of selected
/// source VMs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UtilizationReport {
    /// Output only. The report unique name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The report display name, as assigned by the user.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    /// Output only. Current state of the report.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub state: crate::model::utilization_report::State,

    /// Output only. The time the state was last set.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the report in case of an
    /// error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The time the report was created (this refers to the time of
    /// the request, not the time the report creation completed).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time frame of the report.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub time_frame: crate::model::utilization_report::TimeFrame,

    /// Output only. The point in time when the time frame ends. Notice that the
    /// time frame is counted backwards. For instance if the "frame_end_time" value
    /// is 2021/01/20 and the time frame is WEEK then the report covers the week
    /// between 2021/01/20 and 2021/01/14.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub frame_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Total number of VMs included in the report.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub vm_count: i32,

    /// List of utilization information per VM.
    /// When sent as part of the request, the "vm_id" field is used in order to
    /// specify which VMs to include in the report. In that case all other fields
    /// are ignored.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub vms: std::vec::Vec<crate::model::VmUtilizationInfo>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UtilizationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UtilizationReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::UtilizationReport::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UtilizationReport::state].
    pub fn set_state<T: std::convert::Into<crate::model::utilization_report::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::UtilizationReport::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UtilizationReport::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_frame][crate::model::UtilizationReport::time_frame].
    pub fn set_time_frame<T: std::convert::Into<crate::model::utilization_report::TimeFrame>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_frame = v.into();
        self
    }

    /// Sets the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_frame_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_or_clear_frame_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_count][crate::model::UtilizationReport::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [vms][crate::model::UtilizationReport::vms].
    pub fn set_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmUtilizationInfo>,
    {
        use std::iter::Iterator;
        self.vms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UtilizationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UtilizationReport"
    }
}

/// Defines additional types related to [UtilizationReport].
pub mod utilization_report {
    #[allow(unused_imports)]
    use super::*;

    /// Utilization report state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This value is not in use.
        Unspecified,
        /// The report is in the making.
        Creating,
        /// Report creation completed successfully.
        Succeeded,
        /// Report creation failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.State",
            ))
        }
    }

    /// Report time frame options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeFrame {
        /// The time frame was not specified and will default to WEEK.
        Unspecified,
        /// One week.
        Week,
        /// One month.
        Month,
        /// One year.
        Year,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeFrame::value] or
        /// [TimeFrame::name].
        UnknownValue(time_frame::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_frame {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeFrame {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Week => std::option::Option::Some(1),
                Self::Month => std::option::Option::Some(2),
                Self::Year => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_FRAME_UNSPECIFIED"),
                Self::Week => std::option::Option::Some("WEEK"),
                Self::Month => std::option::Option::Some("MONTH"),
                Self::Year => std::option::Option::Some("YEAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeFrame {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeFrame {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeFrame {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Week,
                2 => Self::Month,
                3 => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeFrame {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_FRAME_UNSPECIFIED" => Self::Unspecified,
                "WEEK" => Self::Week,
                "MONTH" => Self::Month,
                "YEAR" => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeFrame {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Week => serializer.serialize_i32(1),
                Self::Month => serializer.serialize_i32(2),
                Self::Year => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeFrame {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeFrame>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.TimeFrame",
            ))
        }
    }
}

/// Utilization information of a single VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmUtilizationInfo {
    /// The VM's ID in the source.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_id: std::string::String,

    /// Utilization metrics for this VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub utilization: std::option::Option<crate::model::VmUtilizationMetrics>,

    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub vm_details: std::option::Option<crate::model::vm_utilization_info::VmDetails>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmUtilizationInfo::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_or_clear_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details].
    ///
    /// Note that all the setters affecting `vm_details` are mutually
    /// exclusive.
    pub fn set_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::vm_utilization_info::VmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = v.into();
        self
    }

    /// The value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// if it holds a `VmwareVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmDetails>> {
        #[allow(unreachable_patterns)]
        self.vm_details.as_ref().and_then(|v| match v {
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// to hold a `VmwareVmDetails`.
    ///
    /// Note that all the setters affecting `vm_details` are
    /// mutually exclusive.
    pub fn set_vmware_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = std::option::Option::Some(
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VmUtilizationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationInfo"
    }
}

/// Defines additional types related to [VmUtilizationInfo].
pub mod vm_utilization_info {
    #[allow(unused_imports)]
    use super::*;

    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum VmDetails {
        /// The description of the VM in a Source of type Vmware.
        VmwareVmDetails(std::boxed::Box<crate::model::VmwareVmDetails>),
    }
}

/// Utilization metrics values for a single VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmUtilizationMetrics {
    /// Max CPU usage, percent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub cpu_max_percent: i32,

    /// Average CPU usage, percent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub cpu_average_percent: i32,

    /// Max memory usage, percent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub memory_max_percent: i32,

    /// Average memory usage, percent.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub memory_average_percent: i32,

    /// Max disk IO rate, in kilobytes per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub disk_io_rate_max_kbps: i64,

    /// Average disk IO rate, in kilobytes per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub disk_io_rate_average_kbps: i64,

    /// Max network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub network_throughput_max_kbps: i64,

    /// Average network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub network_throughput_average_kbps: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_max_percent][crate::model::VmUtilizationMetrics::cpu_max_percent].
    pub fn set_cpu_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_max_percent = v.into();
        self
    }

    /// Sets the value of [cpu_average_percent][crate::model::VmUtilizationMetrics::cpu_average_percent].
    pub fn set_cpu_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_average_percent = v.into();
        self
    }

    /// Sets the value of [memory_max_percent][crate::model::VmUtilizationMetrics::memory_max_percent].
    pub fn set_memory_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_max_percent = v.into();
        self
    }

    /// Sets the value of [memory_average_percent][crate::model::VmUtilizationMetrics::memory_average_percent].
    pub fn set_memory_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_average_percent = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_max_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_max_kbps].
    pub fn set_disk_io_rate_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_max_kbps = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_average_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_average_kbps].
    pub fn set_disk_io_rate_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_average_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_max_kbps][crate::model::VmUtilizationMetrics::network_throughput_max_kbps].
    pub fn set_network_throughput_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_max_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_average_kbps][crate::model::VmUtilizationMetrics::network_throughput_average_kbps].
    pub fn set_network_throughput_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_average_kbps = v.into();
        self
    }
}

impl wkt::message::Message for VmUtilizationMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationMetrics"
    }
}

/// Request message for 'ListUtilizationReports' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUtilizationReportsRequest {
    /// Required. The Utilization Reports parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The level of details of each report.
    /// Defaults to BASIC.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::UtilizationReportView,

    /// Optional. The maximum number of reports to return. The service may return
    /// fewer than this value. If unspecified, at most 500 reports will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListUtilizationReports`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListUtilizationReports`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUtilizationReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListUtilizationReportsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUtilizationReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUtilizationReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUtilizationReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUtilizationReportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsRequest"
    }
}

/// Response message for 'ListUtilizationReports' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListUtilizationReportsResponse {
    /// Output only. The list of reports.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub utilization_reports: std::vec::Vec<crate::model::UtilizationReport>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilization_reports][crate::model::ListUtilizationReportsResponse::utilization_reports].
    pub fn set_utilization_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UtilizationReport>,
    {
        use std::iter::Iterator;
        self.utilization_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUtilizationReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUtilizationReportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUtilizationReportsResponse {
    type PageItem = crate::model::UtilizationReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.utilization_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetUtilizationReport' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetUtilizationReportRequest {
    /// Required. The Utilization Report name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The level of details of the report.
    /// Defaults to FULL
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::UtilizationReportView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetUtilizationReportRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetUtilizationReportRequest"
    }
}

/// Request message for 'CreateUtilizationReport' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateUtilizationReportRequest {
    /// Required. The Utilization Report's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The report to create.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub utilization_report: std::option::Option<crate::model::UtilizationReport>,

    /// Required. The ID to use for the report, which will become the final
    /// component of the reports's resource name.
    ///
    /// This value maximum length is 63 characters, and valid characters
    /// are /[a-z][0-9]-/. It must start with an english letter and must not
    /// end with a hyphen.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub utilization_report_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUtilizationReportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_utilization_report<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_or_clear_utilization_report<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = v.map(|x| x.into());
        self
    }

    /// Sets the value of [utilization_report_id][crate::model::CreateUtilizationReportRequest::utilization_report_id].
    pub fn set_utilization_report_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.utilization_report_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateUtilizationReportRequest"
    }
}

/// Request message for 'DeleteUtilizationReport' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteUtilizationReportRequest {
    /// Required. The Utilization Report name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteUtilizationReportRequest"
    }
}

/// Response message for 'ListDatacenterConnectors' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatacenterConnectorsResponse {
    /// Output only. The list of sources response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datacenter_connectors: std::vec::Vec<crate::model::DatacenterConnector>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connectors][crate::model::ListDatacenterConnectorsResponse::datacenter_connectors].
    pub fn set_datacenter_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatacenterConnector>,
    {
        use std::iter::Iterator;
        self.datacenter_connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatacenterConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatacenterConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatacenterConnectorsResponse {
    type PageItem = crate::model::DatacenterConnector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datacenter_connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetDatacenterConnector' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatacenterConnectorRequest {
    /// Required. The name of the DatacenterConnector.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetDatacenterConnectorRequest"
    }
}

/// Request message for 'CreateDatacenterConnector' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatacenterConnectorRequest {
    /// Required. The DatacenterConnector's parent.
    /// Required. The Source in where the new DatacenterConnector will be created.
    /// For example:
    /// `projects/my-project/locations/us-central1/sources/my-source`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The datacenterConnector identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datacenter_connector_id: std::string::String,

    /// Required. The create request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub datacenter_connector: std::option::Option<crate::model::DatacenterConnector>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatacenterConnectorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [datacenter_connector_id][crate::model::CreateDatacenterConnectorRequest::datacenter_connector_id].
    pub fn set_datacenter_connector_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector_id = v.into();
        self
    }

    /// Sets the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_datacenter_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_or_clear_datacenter_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateDatacenterConnectorRequest"
    }
}

/// Request message for 'DeleteDatacenterConnector' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatacenterConnectorRequest {
    /// Required. The DatacenterConnector name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteDatacenterConnectorRequest"
    }
}

/// Request message for 'UpgradeAppliance' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeApplianceRequest {
    /// Required. The DatacenterConnector name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub datacenter_connector: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connector][crate::model::UpgradeApplianceRequest::datacenter_connector].
    pub fn set_datacenter_connector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeApplianceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeApplianceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceRequest"
    }
}

/// Response message for 'UpgradeAppliance' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeApplianceResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpgradeApplianceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceResponse"
    }
}

/// Request message for 'ListDatacenterConnectors' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatacenterConnectorsRequest {
    /// Required. The parent, which owns this collection of connectors.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of connectors to return. The service may
    /// return fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListDatacenterConnectors`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDatacenterConnectors` must match the call that provided the page
    /// token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatacenterConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatacenterConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatacenterConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatacenterConnectorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatacenterConnectorsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsRequest"
    }
}

/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a
/// target Compute Engine project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeEngineTargetDefaults {
    /// The name of the VM to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// The full path of the resource of type TargetProject which represents the
    /// Compute Engine project in which to create this VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_project: std::string::String,

    /// The zone in which to create the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// A map of network tags to associate with the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// The service account to associate the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// Output only. The OS license returned from the adaptation module report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub secure_boot: bool,

    /// Output only. The VM Boot Option, as set in the source vm.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDefaults::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::ComputeEngineTargetDefaults::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDefaults::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDefaults::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDefaults::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDefaults::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDefaults::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDefaults::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDefaults::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDefaults::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDefaults::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDefaults::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDefaults::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDefaults::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDefaults"
    }
}

/// ComputeEngineTargetDetails is a collection of details for creating a VM in a
/// target Compute Engine project.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeEngineTargetDetails {
    /// The name of the VM to create.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_name: std::string::String,

    /// The Google Cloud target project ID or project name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The zone in which to create the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// A map of network tags to associate with the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// The service account to associate the VM with.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// The OS license returned from the adaptation module report.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub secure_boot: bool,

    /// The VM Boot Option, as set in the source vm.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub hostname: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDetails::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::ComputeEngineTargetDetails::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDetails::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDetails::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDetails::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDetails::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDetails::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDetails::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDetails::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDetails::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDetails::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDetails::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDetails::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDetails"
    }
}

/// NetworkInterface represents a NIC of a VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkInterface {
    /// The network to connect the NIC to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// The subnetwork to connect the NIC to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnetwork: std::string::String,

    /// The internal IP to define in the NIC.
    /// The formats accepted are: `ephemeral` \ ipv4 address \ a named address
    /// resource full path.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub internal_ip: std::string::String,

    /// The external IP to define in the NIC.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub external_ip: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::NetworkInterface::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::NetworkInterface::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.NetworkInterface"
    }
}

/// AppliedLicense holds the license data returned by adaptation module report.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AppliedLicense {
    /// The license type that was used in OS adaptation.
    #[serde(rename = "type")]
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub r#type: crate::model::applied_license::Type,

    /// The OS license returned from the adaptation module's report.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub os_license: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppliedLicense {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AppliedLicense::type].
    pub fn set_type<T: std::convert::Into<crate::model::applied_license::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [os_license][crate::model::AppliedLicense::os_license].
    pub fn set_os_license<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_license = v.into();
        self
    }
}

impl wkt::message::Message for AppliedLicense {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AppliedLicense"
    }
}

/// Defines additional types related to [AppliedLicense].
pub mod applied_license {
    #[allow(unused_imports)]
    use super::*;

    /// License types used in OS adaptation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified license for the OS.
        Unspecified,
        /// No license available for the OS.
        None,
        /// The license type is Pay As You Go license type.
        Payg,
        /// The license type is Bring Your Own License type.
        Byol,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Payg => std::option::Option::Some(2),
                Self::Byol => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Payg => std::option::Option::Some("PAYG"),
                Self::Byol => std::option::Option::Some("BYOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Payg,
                3 => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PAYG" => Self::Payg,
                "BYOL" => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Payg => serializer.serialize_i32(2),
                Self::Byol => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmmigration.v1.AppliedLicense.Type",
            ))
        }
    }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled. Based on
/// <https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling>
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SchedulingNodeAffinity {
    /// The label key of Node resource to reference.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key: std::string::String,

    /// The operator to use for the node resources specified in the `values`
    /// parameter.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub operator: crate::model::scheduling_node_affinity::Operator,

    /// Corresponds to the label values of Node resource.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub values: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulingNodeAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_operator<T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>>(
        mut self,
        v: T,
    ) -> Self {
        self.operator = v.into();
        self
    }

    /// Sets the value of [values][crate::model::SchedulingNodeAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchedulingNodeAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulingNodeAffinity"
    }
}

/// Defines additional types related to [SchedulingNodeAffinity].
pub mod scheduling_node_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of node selection operators. Valid operators are IN for
    /// affinity and NOT_IN for anti-affinity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operator {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// The node resource group should be in these resources affinity.
        In,
        /// The node resource group should not be in these resources affinity.
        NotIn,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operator::value] or
        /// [Operator::name].
        UnknownValue(operator::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::In => std::option::Option::Some(1),
                Self::NotIn => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                Self::In => std::option::Option::Some("IN"),
                Self::NotIn => std::option::Option::Some("NOT_IN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::In,
                2 => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                "IN" => Self::In,
                "NOT_IN" => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::In => serializer.serialize_i32(1),
                Self::NotIn => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                ".google.cloud.vmmigration.v1.SchedulingNodeAffinity.Operator",
            ))
        }
    }
}

/// Scheduling information for VM on maintenance/restart behaviour and
/// node allocation in sole tenant nodes.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ComputeScheduling {
    /// How the instance should behave when the host machine undergoes
    /// maintenance that may temporarily impact instance performance.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub on_host_maintenance: crate::model::compute_scheduling::OnHostMaintenance,

    /// Whether the Instance should be automatically restarted whenever it is
    /// terminated by Compute Engine (not terminated by user).
    /// This configuration is identical to `automaticRestart` field in Compute
    /// Engine create instance under scheduling.
    /// It was changed to an enum (instead of a boolean) to match the default
    /// value in Compute Engine which is automatic restart.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub restart_type: crate::model::compute_scheduling::RestartType,

    /// A set of node affinity and anti-affinity configurations for sole tenant
    /// nodes.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub node_affinities: std::vec::Vec<crate::model::SchedulingNodeAffinity>,

    /// The minimum number of virtual CPUs this instance will consume when
    /// running on a sole-tenant node. Ignored if no node_affinites are
    /// configured.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub min_node_cpus: i32,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [on_host_maintenance][crate::model::ComputeScheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<
        T: std::convert::Into<crate::model::compute_scheduling::OnHostMaintenance>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.on_host_maintenance = v.into();
        self
    }

    /// Sets the value of [restart_type][crate::model::ComputeScheduling::restart_type].
    pub fn set_restart_type<
        T: std::convert::Into<crate::model::compute_scheduling::RestartType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restart_type = v.into();
        self
    }

    /// Sets the value of [node_affinities][crate::model::ComputeScheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchedulingNodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::ComputeScheduling::min_node_cpus].
    pub fn set_min_node_cpus<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_cpus = v.into();
        self
    }
}

impl wkt::message::Message for ComputeScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeScheduling"
    }
}

/// Defines additional types related to [ComputeScheduling].
pub mod compute_scheduling {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// Terminate the instance when the host machine undergoes maintenance.
        Terminate,
        /// Migrate the instance when the host machine undergoes maintenance.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::Migrate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ON_HOST_MAINTENANCE_UNSPECIFIED"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Terminate,
                2 => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Self::Unspecified,
                "TERMINATE" => Self::Terminate,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Terminate => serializer.serialize_i32(1),
                Self::Migrate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.OnHostMaintenance",
            ))
        }
    }

    /// Defines whether the Instance should be automatically restarted whenever
    /// it is terminated by Compute Engine (not terminated by user).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RestartType {
        /// Unspecified behavior. This will use the default.
        Unspecified,
        /// The Instance should be automatically restarted whenever it is
        /// terminated by Compute Engine.
        AutomaticRestart,
        /// The Instance isn't automatically restarted whenever it is
        /// terminated by Compute Engine.
        NoAutomaticRestart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RestartType::value] or
        /// [RestartType::name].
        UnknownValue(restart_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod restart_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RestartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AutomaticRestart => std::option::Option::Some(1),
                Self::NoAutomaticRestart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESTART_TYPE_UNSPECIFIED"),
                Self::AutomaticRestart => std::option::Option::Some("AUTOMATIC_RESTART"),
                Self::NoAutomaticRestart => std::option::Option::Some("NO_AUTOMATIC_RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RestartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RestartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RestartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AutomaticRestart,
                2 => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RestartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESTART_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC_RESTART" => Self::AutomaticRestart,
                "NO_AUTOMATIC_RESTART" => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RestartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AutomaticRestart => serializer.serialize_i32(1),
                Self::NoAutomaticRestart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RestartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestartType>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.RestartType",
            ))
        }
    }
}

/// A policy for scheduling replications.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SchedulePolicy {
    /// The idle duration between replication stages.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub idle_duration: std::option::Option<wkt::Duration>,

    /// A flag to indicate whether to skip OS adaptation during the replication
    /// sync. OS adaptation is a process where the VM's operating system undergoes
    /// changes and adaptations to fully function on Compute Engine.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub skip_os_adaptation: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_idle_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_or_clear_idle_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_os_adaptation][crate::model::SchedulePolicy::skip_os_adaptation].
    pub fn set_skip_os_adaptation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_os_adaptation = v.into();
        self
    }
}

impl wkt::message::Message for SchedulePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulePolicy"
    }
}

/// Request message for 'CreateMigratingVm' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMigratingVmRequest {
    /// Required. The MigratingVm's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The migratingVm identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm_id: std::string::String,

    /// Required. The create request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigratingVmRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migrating_vm_id][crate::model::CreateMigratingVmRequest::migrating_vm_id].
    pub fn set_migrating_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm_id = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateMigratingVmRequest"
    }
}

/// Request message for 'LisMigratingVmsRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigratingVmsRequest {
    /// Required. The parent, which owns this collection of MigratingVms.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of migrating VMs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 migrating VMs
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListMigratingVms` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigratingVms`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. The level of details of each migrating VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::MigratingVmView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigratingVmsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigratingVmsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigratingVmsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigratingVmsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigratingVmsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListMigratingVmsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsRequest"
    }
}

/// Response message for 'ListMigratingVms' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListMigratingVmsResponse {
    /// Output only. The list of Migrating VMs response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub migrating_vms: std::vec::Vec<crate::model::MigratingVm>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vms][crate::model::ListMigratingVmsResponse::migrating_vms].
    pub fn set_migrating_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigratingVm>,
    {
        use std::iter::Iterator;
        self.migrating_vms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigratingVmsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigratingVmsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigratingVmsResponse {
    type PageItem = crate::model::MigratingVm;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migrating_vms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetMigratingVm' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The level of details of the migrating VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub view: crate::model::MigratingVmView,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetMigratingVmRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetMigratingVmRequest"
    }
}

/// Request message for 'UpdateMigratingVm' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateMigratingVmRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// MigratingVm resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateMigratingVmRequest"
    }
}

/// Request message for 'DeleteMigratingVm' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteMigratingVmRequest"
    }
}

/// Request message for 'StartMigrationRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartMigrationRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::StartMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationRequest"
    }
}

/// Response message for 'StartMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationResponse"
    }
}

/// Request message for 'PauseMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseMigrationRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::PauseMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for PauseMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationRequest"
    }
}

/// Response message for 'PauseMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PauseMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PauseMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationResponse"
    }
}

/// Request message for 'ResumeMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeMigrationRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::ResumeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationRequest"
    }
}

/// Response message for 'ResumeMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResumeMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResumeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationResponse"
    }
}

/// Request message for 'FinalizeMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FinalizeMigrationRequest {
    /// Required. The name of the MigratingVm.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::FinalizeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for FinalizeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationRequest"
    }
}

/// Response message for 'FinalizeMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FinalizeMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for FinalizeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationResponse"
    }
}

/// TargetProject message represents a target Compute Engine project for a
/// migration or a clone.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct TargetProject {
    /// Output only. The name of the target project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// The target project ID (number) or project name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The target project's description.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Output only. The time this target project resource was created (not related
    /// to when the Compute Engine project it points to was created).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the target project resource was updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetProject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TargetProject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::TargetProject::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TargetProject::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetProject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.TargetProject"
    }
}

/// Request message for 'GetTargetProject' call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetTargetProjectRequest {
    /// Required. The TargetProject name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetTargetProjectRequest"
    }
}

/// Request message for 'ListTargetProjects' call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetProjectsRequest {
    /// Required. The parent, which owns this collection of targets.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of targets to return. The service may return
    /// fewer than this value. If unspecified, at most 500 targets will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTargets` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetProjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetProjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetProjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTargetProjectsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTargetProjectsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsRequest"
    }
}

/// Response message for 'ListTargetProjects' call.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListTargetProjectsResponse {
    /// Output only. The list of target response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_projects: std::vec::Vec<crate::model::TargetProject>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_projects][crate::model::ListTargetProjectsResponse::target_projects].
    pub fn set_target_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetProject>,
    {
        use std::iter::Iterator;
        self.target_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetProjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTargetProjectsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetProjectsResponse {
    type PageItem = crate::model::TargetProject;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.target_projects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'CreateTargetProject' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateTargetProjectRequest {
    /// Required. The TargetProject's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The target_project identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_project_id: std::string::String,

    /// Required. The create request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetProjectRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_project_id][crate::model::CreateTargetProjectRequest::target_project_id].
    pub fn set_target_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_project_id = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateTargetProjectRequest"
    }
}

/// Update message for 'UpdateTargetProject' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateTargetProjectRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// TargetProject resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateTargetProjectRequest"
    }
}

/// Request message for 'DeleteTargetProject' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteTargetProjectRequest {
    /// Required. The TargetProject name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteTargetProjectRequest"
    }
}

/// Describes message for 'Group' resource. The Group is a collections of several
/// MigratingVms.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Group {
    /// Output only. The Group name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-provided description of the group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub description: std::string::String,

    /// Display name is a user defined name for this group which can be updated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub display_name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Group::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Group::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Group::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Group::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Group::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Group"
    }
}

/// Request message for 'ListGroups' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. The parent, which owns this collection of groups.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service may return
    /// fewer than this value. If unspecified, at most 500 groups will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListGroups` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListGroups` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsRequest"
    }
}

/// Response message for 'ListGroups' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// Output only. The list of groups response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub groups: std::vec::Vec<crate::model::Group>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [groups][crate::model::ListGroupsResponse::groups].
    pub fn set_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGroupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetGroup' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. The group name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetGroupRequest"
    }
}

/// Request message for 'CreateGroup' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. The Group's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The group identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group_id: std::string::String,

    /// Required. The create request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CreateGroupRequest::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateGroupRequest"
    }
}

/// Update message for 'UpdateGroups' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Group resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateGroupRequest"
    }
}

/// Request message for 'DeleteGroup' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. The Group name.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteGroupRequest"
    }
}

/// Request message for 'AddGroupMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddGroupMigrationRequest {
    /// Required. The full path name of the Group to add to.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// The full path name of the MigratingVm to add.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AddGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::AddGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for AddGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationRequest"
    }
}

/// Response message for 'AddGroupMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AddGroupMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationResponse"
    }
}

/// Request message for 'RemoveMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveGroupMigrationRequest {
    /// Required. The name of the Group.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub group: std::string::String,

    /// The MigratingVm to remove.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub migrating_vm: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::RemoveGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::RemoveGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for RemoveGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationRequest"
    }
}

/// Response message for 'RemoveMigration' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RemoveGroupMigrationResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationResponse"
    }
}

/// Request message for 'CreateCutoverJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateCutoverJobRequest {
    /// Required. The Cutover's parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The cutover job identifier.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub cutover_job_id: std::string::String,

    /// Required. The cutover request body.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub cutover_job: std::option::Option<crate::model::CutoverJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCutoverJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cutover_job_id][crate::model::CreateCutoverJobRequest::cutover_job_id].
    pub fn set_cutover_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cutover_job_id = v.into();
        self
    }

    /// Sets the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_cutover_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_or_clear_cutover_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCutoverJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCutoverJobRequest"
    }
}

/// Request message for 'CancelCutoverJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCutoverJobRequest {
    /// Required. The cutover job id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobRequest"
    }
}

/// Response message for 'CancelCutoverJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CancelCutoverJobResponse {
    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCutoverJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobResponse"
    }
}

/// Request message for 'ListCutoverJobsRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCutoverJobsRequest {
    /// Required. The parent, which owns this collection of migrating VMs.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of cutover jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 cutover jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCutoverJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCutoverJobs` must
    /// match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCutoverJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCutoverJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCutoverJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCutoverJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCutoverJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsRequest"
    }
}

/// Response message for 'ListCutoverJobs' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListCutoverJobsResponse {
    /// Output only. The list of cutover jobs response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cutover_jobs][crate::model::ListCutoverJobsResponse::cutover_jobs].
    pub fn set_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCutoverJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCutoverJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCutoverJobsResponse {
    type PageItem = crate::model::CutoverJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cutover_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetCutoverJob' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetCutoverJobRequest {
    /// Required. The name of the CutoverJob.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCutoverJobRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.OperationMetadata"
    }
}

/// Represents migration resource error information that can be used with
/// google.rpc.Status message. MigrationError is used to present the user with
/// error information in migration operations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct MigrationError {
    /// Output only. The error code.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub code: crate::model::migration_error::ErrorCode,

    /// Output only. The localized error message.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_message: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. Suggested action for solving the error.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub action_item: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. URL(s) pointing to additional information on handling the
    /// current error.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub help_links: std::vec::Vec<rpc::model::help::Link>,

    /// Output only. The time the error occurred.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub error_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MigrationError::code].
    pub fn set_code<T: std::convert::Into<crate::model::migration_error::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_error_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_or_clear_error_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_action_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_or_clear_action_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [help_links][crate::model::MigrationError::help_links].
    pub fn set_help_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::help::Link>,
    {
        use std::iter::Iterator;
        self.help_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigrationError"
    }
}

/// Defines additional types related to [MigrationError].
pub mod migration_error {
    #[allow(unused_imports)]
    use super::*;

    /// Represents resource error codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Default value. This value is not used.
        Unspecified,
        /// Migrate for Compute encountered an unknown error.
        UnknownError,
        /// Migrate for Compute encountered an error while validating replication
        /// source health.
        SourceValidationError,
        /// Migrate for Compute encountered an error during source data operation.
        SourceReplicationError,
        /// Migrate for Compute encountered an error during target data operation.
        TargetReplicationError,
        /// Migrate for Compute encountered an error during OS adaptation.
        OsAdaptationError,
        /// Migrate for Compute encountered an error in clone operation.
        CloneError,
        /// Migrate for Compute encountered an error in cutover operation.
        CutoverError,
        /// Migrate for Compute encountered an error during utilization report
        /// creation.
        UtilizationReportError,
        /// Migrate for Compute encountered an error during appliance upgrade.
        ApplianceUpgradeError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownError => std::option::Option::Some(1),
                Self::SourceValidationError => std::option::Option::Some(2),
                Self::SourceReplicationError => std::option::Option::Some(3),
                Self::TargetReplicationError => std::option::Option::Some(4),
                Self::OsAdaptationError => std::option::Option::Some(5),
                Self::CloneError => std::option::Option::Some(6),
                Self::CutoverError => std::option::Option::Some(7),
                Self::UtilizationReportError => std::option::Option::Some(8),
                Self::ApplianceUpgradeError => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::UnknownError => std::option::Option::Some("UNKNOWN_ERROR"),
                Self::SourceValidationError => std::option::Option::Some("SOURCE_VALIDATION_ERROR"),
                Self::SourceReplicationError => {
                    std::option::Option::Some("SOURCE_REPLICATION_ERROR")
                }
                Self::TargetReplicationError => {
                    std::option::Option::Some("TARGET_REPLICATION_ERROR")
                }
                Self::OsAdaptationError => std::option::Option::Some("OS_ADAPTATION_ERROR"),
                Self::CloneError => std::option::Option::Some("CLONE_ERROR"),
                Self::CutoverError => std::option::Option::Some("CUTOVER_ERROR"),
                Self::UtilizationReportError => {
                    std::option::Option::Some("UTILIZATION_REPORT_ERROR")
                }
                Self::ApplianceUpgradeError => std::option::Option::Some("APPLIANCE_UPGRADE_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownError,
                2 => Self::SourceValidationError,
                3 => Self::SourceReplicationError,
                4 => Self::TargetReplicationError,
                5 => Self::OsAdaptationError,
                6 => Self::CloneError,
                7 => Self::CutoverError,
                8 => Self::UtilizationReportError,
                9 => Self::ApplianceUpgradeError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_ERROR" => Self::UnknownError,
                "SOURCE_VALIDATION_ERROR" => Self::SourceValidationError,
                "SOURCE_REPLICATION_ERROR" => Self::SourceReplicationError,
                "TARGET_REPLICATION_ERROR" => Self::TargetReplicationError,
                "OS_ADAPTATION_ERROR" => Self::OsAdaptationError,
                "CLONE_ERROR" => Self::CloneError,
                "CUTOVER_ERROR" => Self::CutoverError,
                "UTILIZATION_REPORT_ERROR" => Self::UtilizationReportError,
                "APPLIANCE_UPGRADE_ERROR" => Self::ApplianceUpgradeError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownError => serializer.serialize_i32(1),
                Self::SourceValidationError => serializer.serialize_i32(2),
                Self::SourceReplicationError => serializer.serialize_i32(3),
                Self::TargetReplicationError => serializer.serialize_i32(4),
                Self::OsAdaptationError => serializer.serialize_i32(5),
                Self::CloneError => serializer.serialize_i32(6),
                Self::CutoverError => serializer.serialize_i32(7),
                Self::UtilizationReportError => serializer.serialize_i32(8),
                Self::ApplianceUpgradeError => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.vmmigration.v1.MigrationError.ErrorCode",
            ))
        }
    }
}

/// Represent the source AWS VM details.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AwsSourceVmDetails {
    /// The firmware type of the source VM.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub firmware: crate::model::aws_source_vm_details::Firmware,

    /// The total size of the disks being migrated in bytes.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub committed_storage_bytes: i64,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firmware][crate::model::AwsSourceVmDetails::firmware].
    pub fn set_firmware<T: std::convert::Into<crate::model::aws_source_vm_details::Firmware>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware = v.into();
        self
    }

    /// Sets the value of [committed_storage_bytes][crate::model::AwsSourceVmDetails::committed_storage_bytes].
    pub fn set_committed_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_bytes = v.into();
        self
    }
}

impl wkt::message::Message for AwsSourceVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceVmDetails"
    }
}

/// Defines additional types related to [AwsSourceVmDetails].
pub mod aws_source_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for AWS VM firmware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified,
        /// The firmware is EFI.
        Efi,
        /// The firmware is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Firmware::value] or
        /// [Firmware::name].
        UnknownValue(firmware::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Firmware {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Firmware {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Firmware {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Firmware {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Firmware {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Firmware {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Firmware {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Firmware>::new(
                ".google.cloud.vmmigration.v1.AwsSourceVmDetails.Firmware",
            ))
        }
    }
}

/// Request message for 'LisReplicationCyclesRequest' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReplicationCyclesRequest {
    /// Required. The parent, which owns this collection of ReplicationCycles.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of replication cycles to return. The service
    /// may return fewer than this value. If unspecified, at most 100 migrating VMs
    /// will be returned. The maximum value is 100; values above 100 will be
    /// coerced to 100.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListReplicationCycles`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReplicationCycles`
    /// must match the call that provided the page token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. The filter request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReplicationCyclesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReplicationCyclesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReplicationCyclesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReplicationCyclesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReplicationCyclesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesRequest"
    }
}

/// Response message for 'ListReplicationCycles' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListReplicationCyclesResponse {
    /// Output only. The list of replication cycles response.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub replication_cycles: std::vec::Vec<crate::model::ReplicationCycle>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication_cycles][crate::model::ListReplicationCyclesResponse::replication_cycles].
    pub fn set_replication_cycles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicationCycle>,
    {
        use std::iter::Iterator;
        self.replication_cycles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReplicationCyclesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReplicationCyclesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReplicationCyclesResponse {
    type PageItem = crate::model::ReplicationCycle;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.replication_cycles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for 'GetReplicationCycle' request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetReplicationCycleRequest {
    /// Required. The name of the ReplicationCycle.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReplicationCycleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReplicationCycleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReplicationCycleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetReplicationCycleRequest"
    }
}

/// Controls the level of details of a Utilization Report.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UtilizationReportView {
    /// The default / unset value.
    /// The API will default to FULL on single report request and BASIC for
    /// multiple reports request.
    Unspecified,
    /// Get the report metadata, without the list of VMs and their utilization
    /// info.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UtilizationReportView::value] or
    /// [UtilizationReportView::name].
    UnknownValue(utilization_report_view::UnknownValue),
}

#[doc(hidden)]
pub mod utilization_report_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UtilizationReportView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UTILIZATION_REPORT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UtilizationReportView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UtilizationReportView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UtilizationReportView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UtilizationReportView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UTILIZATION_REPORT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UtilizationReportView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UtilizationReportView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UtilizationReportView>::new(
            ".google.cloud.vmmigration.v1.UtilizationReportView",
        ))
    }
}

/// Controls the level of details of a Migrating VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigratingVmView {
    /// View is unspecified. The API will fallback to the default value.
    Unspecified,
    /// Get the migrating VM basic details.
    /// The basic details do not include the recent clone jobs and recent cutover
    /// jobs lists.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigratingVmView::value] or
    /// [MigratingVmView::name].
    UnknownValue(migrating_vm_view::UnknownValue),
}

#[doc(hidden)]
pub mod migrating_vm_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigratingVmView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATING_VM_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("MIGRATING_VM_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("MIGRATING_VM_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigratingVmView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigratingVmView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigratingVmView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigratingVmView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATING_VM_VIEW_UNSPECIFIED" => Self::Unspecified,
            "MIGRATING_VM_VIEW_BASIC" => Self::Basic,
            "MIGRATING_VM_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigratingVmView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigratingVmView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigratingVmView>::new(
            ".google.cloud.vmmigration.v1.MigratingVmView",
        ))
    }
}

/// Types of disks supported for Compute Engine VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineDiskType {
    /// An unspecified disk type. Will be used as STANDARD.
    Unspecified,
    /// A Standard disk type.
    Standard,
    /// SSD hard disk type.
    Ssd,
    /// An alternative to SSD persistent disks that balance performance and
    /// cost.
    Balanced,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineDiskType::value] or
    /// [ComputeEngineDiskType::name].
    UnknownValue(compute_engine_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Ssd => std::option::Option::Some(2),
            Self::Balanced => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_STANDARD"),
            Self::Ssd => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_SSD"),
            Self::Balanced => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_BALANCED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Ssd,
            3 => Self::Balanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_DISK_TYPE_STANDARD" => Self::Standard,
            "COMPUTE_ENGINE_DISK_TYPE_SSD" => Self::Ssd,
            "COMPUTE_ENGINE_DISK_TYPE_BALANCED" => Self::Balanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Ssd => serializer.serialize_i32(2),
            Self::Balanced => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineDiskType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineDiskType",
        ))
    }
}

/// Types of licenses used in OS adaptation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineLicenseType {
    /// The license type is the default for the OS.
    Default,
    /// The license type is Pay As You Go license type.
    Payg,
    /// The license type is Bring Your Own License type.
    Byol,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineLicenseType::value] or
    /// [ComputeEngineLicenseType::name].
    UnknownValue(compute_engine_license_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_license_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineLicenseType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Default => std::option::Option::Some(0),
            Self::Payg => std::option::Option::Some(1),
            Self::Byol => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Default => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT"),
            Self::Payg => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_PAYG"),
            Self::Byol => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_BYOL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineLicenseType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineLicenseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineLicenseType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Default,
            1 => Self::Payg,
            2 => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineLicenseType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT" => Self::Default,
            "COMPUTE_ENGINE_LICENSE_TYPE_PAYG" => Self::Payg,
            "COMPUTE_ENGINE_LICENSE_TYPE_BYOL" => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineLicenseType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Default => serializer.serialize_i32(0),
            Self::Payg => serializer.serialize_i32(1),
            Self::Byol => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineLicenseType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineLicenseType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineLicenseType",
        ))
    }
}

/// Possible values for vm boot option.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineBootOption {
    /// The boot option is unknown.
    Unspecified,
    /// The boot option is EFI.
    Efi,
    /// The boot option is BIOS.
    Bios,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineBootOption::value] or
    /// [ComputeEngineBootOption::name].
    UnknownValue(compute_engine_boot_option::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_boot_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineBootOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Efi => std::option::Option::Some(1),
            Self::Bios => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED")
            }
            Self::Efi => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_EFI"),
            Self::Bios => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_BIOS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineBootOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineBootOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineBootOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Efi,
            2 => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineBootOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_BOOT_OPTION_EFI" => Self::Efi,
            "COMPUTE_ENGINE_BOOT_OPTION_BIOS" => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineBootOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Efi => serializer.serialize_i32(1),
            Self::Bios => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineBootOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineBootOption>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineBootOption",
        ))
    }
}
