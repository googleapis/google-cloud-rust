// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// ReplicationCycle contains information about the current replication cycle
/// status.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationCycle {
    /// The identifier of the ReplicationCycle.
    pub name: std::string::String,

    /// The cycle's ordinal number.
    pub cycle_number: i32,

    /// The time the replication cycle has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the replication cycle has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The accumulated duration the replication cycle was paused.
    pub total_pause_duration: std::option::Option<wkt::Duration>,

    /// The current progress in percentage of this cycle.
    /// Was replaced by 'steps' field, which breaks down the cycle progression more
    /// accurately.
    #[deprecated]
    pub progress_percent: i32,

    /// The cycle's steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CycleStep>,

    /// State of the ReplicationCycle.
    pub state: crate::model::replication_cycle::State,

    /// Provides details on the state of the cycle in case of an error.
    pub error: std::option::Option<rpc::model::Status>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationCycle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplicationCycle::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cycle_number][crate::model::ReplicationCycle::cycle_number].
    pub fn set_cycle_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cycle_number = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_total_pause_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_or_clear_total_pause_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::ReplicationCycle::progress_percent].
    #[deprecated]
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::ReplicationCycle::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CycleStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ReplicationCycle::state].
    pub fn set_state<T: std::convert::Into<crate::model::replication_cycle::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicationCycle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationCycle"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationCycle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cycle_number,
            __start_time,
            __end_time,
            __total_pause_duration,
            __progress_percent,
            __steps,
            __state,
            __error,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationCycle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cycleNumber" => Ok(__FieldTag::__cycle_number),
                            "cycle_number" => Ok(__FieldTag::__cycle_number),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "totalPauseDuration" => Ok(__FieldTag::__total_pause_duration),
                            "total_pause_duration" => Ok(__FieldTag::__total_pause_duration),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "steps" => Ok(__FieldTag::__steps),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationCycle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationCycle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cycle_number => {
                            if !fields.insert(__FieldTag::__cycle_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cycle_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cycle_number = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__total_pause_duration => {
                            if !fields.insert(__FieldTag::__total_pause_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_pause_duration",
                                ));
                            }
                            result.total_pause_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CycleStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::replication_cycle::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationCycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.cycle_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cycleNumber", &__With(&self.cycle_number))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.total_pause_duration.is_some() {
            state.serialize_entry("totalPauseDuration", &self.total_pause_duration)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicationCycle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationCycle");
        debug_struct.field("name", &self.name);
        debug_struct.field("cycle_number", &self.cycle_number);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("total_pause_duration", &self.total_pause_duration);
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReplicationCycle].
pub mod replication_cycle {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a replication cycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The replication cycle is running.
        Running,
        /// The replication cycle is paused.
        Paused,
        /// The replication cycle finished with errors.
        Failed,
        /// The replication cycle finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                3 => Self::Failed,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.ReplicationCycle.State",
            ))
        }
    }
}

/// CycleStep holds information about a step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CycleStep {
    /// The time the cycle step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the cycle step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::cycle_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CycleStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CycleStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::cycle_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `InitializingReplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn initializing_replication(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InitializingReplicationStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::InitializingReplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `InitializingReplication`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_initializing_replication<
        T: std::convert::Into<std::boxed::Box<crate::model::InitializingReplicationStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cycle_step::Step::InitializingReplication(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `Replicating`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replicating(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicatingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::Replicating(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `Replicating`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_replicating<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicatingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::Replicating(v.into()));
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `PostProcessing`, `None` if the field is not set or
    /// holds a different branch.
    pub fn post_processing(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostProcessingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::PostProcessing(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `PostProcessing`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_post_processing<
        T: std::convert::Into<std::boxed::Box<crate::model::PostProcessingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::PostProcessing(v.into()));
        self
    }
}

impl wkt::message::Message for CycleStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CycleStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CycleStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initializing_replication,
            __replicating,
            __post_processing,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CycleStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initializingReplication" => Ok(__FieldTag::__initializing_replication),
                            "initializing_replication" => {
                                Ok(__FieldTag::__initializing_replication)
                            }
                            "replicating" => Ok(__FieldTag::__replicating),
                            "postProcessing" => Ok(__FieldTag::__post_processing),
                            "post_processing" => Ok(__FieldTag::__post_processing),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CycleStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CycleStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initializing_replication => {
                            if !fields.insert(__FieldTag::__initializing_replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initializing_replication",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.initializing_replication, latest field was initializingReplication",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::InitializingReplication(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InitializingReplicationStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__replicating => {
                            if !fields.insert(__FieldTag::__replicating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicating",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.replicating, latest field was replicating",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::Replicating(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicatingStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__post_processing => {
                            if !fields.insert(__FieldTag::__post_processing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_processing",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.post_processing, latest field was postProcessing",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::PostProcessing(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostProcessingStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CycleStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.initializing_replication() {
            state.serialize_entry("initializingReplication", value)?;
        }
        if let Some(value) = self.replicating() {
            state.serialize_entry("replicating", value)?;
        }
        if let Some(value) = self.post_processing() {
            state.serialize_entry("postProcessing", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CycleStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CycleStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CycleStep].
pub mod cycle_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Initializing replication step.
        InitializingReplication(std::boxed::Box<crate::model::InitializingReplicationStep>),
        /// Replicating step.
        Replicating(std::boxed::Box<crate::model::ReplicatingStep>),
        /// Post processing step.
        PostProcessing(std::boxed::Box<crate::model::PostProcessingStep>),
    }
}

/// InitializingReplicationStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializingReplicationStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializingReplicationStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializingReplicationStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InitializingReplicationStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializingReplicationStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializingReplicationStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializingReplicationStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializingReplicationStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializingReplicationStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializingReplicationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializingReplicationStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReplicatingStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicatingStep {
    /// Total bytes to be handled in the step.
    pub total_bytes: i64,

    /// Replicated bytes in the step.
    pub replicated_bytes: i64,

    /// The source disks replication rate for the last 2 minutes in bytes per
    /// second.
    pub last_two_minutes_average_bytes_per_second: i64,

    /// The source disks replication rate for the last 30 minutes in bytes per
    /// second.
    pub last_thirty_minutes_average_bytes_per_second: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicatingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_bytes][crate::model::ReplicatingStep::total_bytes].
    pub fn set_total_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_bytes = v.into();
        self
    }

    /// Sets the value of [replicated_bytes][crate::model::ReplicatingStep::replicated_bytes].
    pub fn set_replicated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replicated_bytes = v.into();
        self
    }

    /// Sets the value of [last_two_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_two_minutes_average_bytes_per_second].
    pub fn set_last_two_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_two_minutes_average_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [last_thirty_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_thirty_minutes_average_bytes_per_second].
    pub fn set_last_thirty_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_thirty_minutes_average_bytes_per_second = v.into();
        self
    }
}

impl wkt::message::Message for ReplicatingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicatingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicatingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_bytes,
            __replicated_bytes,
            __last_two_minutes_average_bytes_per_second,
            __last_thirty_minutes_average_bytes_per_second,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicatingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalBytes" => Ok(__FieldTag::__total_bytes),
                            "total_bytes" => Ok(__FieldTag::__total_bytes),
                            "replicatedBytes" => Ok(__FieldTag::__replicated_bytes),
                            "replicated_bytes" => Ok(__FieldTag::__replicated_bytes),
                            "lastTwoMinutesAverageBytesPerSecond" => {
                                Ok(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            }
                            "last_two_minutes_average_bytes_per_second" => {
                                Ok(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            }
                            "lastThirtyMinutesAverageBytesPerSecond" => {
                                Ok(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            }
                            "last_thirty_minutes_average_bytes_per_second" => {
                                Ok(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicatingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicatingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_bytes => {
                            if !fields.insert(__FieldTag::__total_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replicated_bytes => {
                            if !fields.insert(__FieldTag::__replicated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replicated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_two_minutes_average_bytes_per_second => {
                            if !fields
                                .insert(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_two_minutes_average_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_two_minutes_average_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_thirty_minutes_average_bytes_per_second => {
                            if !fields
                                .insert(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_thirty_minutes_average_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_thirty_minutes_average_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicatingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBytes", &__With(&self.total_bytes))?;
        }
        if !wkt::internal::is_default(&self.replicated_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("replicatedBytes", &__With(&self.replicated_bytes))?;
        }
        if !wkt::internal::is_default(&self.last_two_minutes_average_bytes_per_second) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "lastTwoMinutesAverageBytesPerSecond",
                &__With(&self.last_two_minutes_average_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.last_thirty_minutes_average_bytes_per_second) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "lastThirtyMinutesAverageBytesPerSecond",
                &__With(&self.last_thirty_minutes_average_bytes_per_second),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicatingStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicatingStep");
        debug_struct.field("total_bytes", &self.total_bytes);
        debug_struct.field("replicated_bytes", &self.replicated_bytes);
        debug_struct.field(
            "last_two_minutes_average_bytes_per_second",
            &self.last_two_minutes_average_bytes_per_second,
        );
        debug_struct.field(
            "last_thirty_minutes_average_bytes_per_second",
            &self.last_thirty_minutes_average_bytes_per_second,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostProcessingStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostProcessingStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostProcessingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PostProcessingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PostProcessingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostProcessingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostProcessingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostProcessingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostProcessingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostProcessingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostProcessingStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostProcessingStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReplicationSync contain information about the last replica sync to the cloud.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationSync {
    /// The most updated snapshot created time in the source that finished
    /// replication.
    pub last_sync_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_last_sync_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_or_clear_last_sync_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicationSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationSync"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationSync {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_sync_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationSync")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastSyncTime" => Ok(__FieldTag::__last_sync_time),
                            "last_sync_time" => Ok(__FieldTag::__last_sync_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationSync;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationSync")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_sync_time => {
                            if !fields.insert(__FieldTag::__last_sync_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync_time",
                                ));
                            }
                            result.last_sync_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationSync {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_sync_time.is_some() {
            state.serialize_entry("lastSyncTime", &self.last_sync_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicationSync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationSync");
        debug_struct.field("last_sync_time", &self.last_sync_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MigratingVm describes the VM that will be migrated from a Source environment
/// and its replication state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigratingVm {
    /// Output only. The identifier of the MigratingVm.
    pub name: std::string::String,

    /// The unique ID of the VM in the source.
    /// The VM's name in vSphere can be changed, so this is not the VM's name but
    /// rather its moRef id. This id is of the form vm-\<num\>.
    pub source_vm_id: std::string::String,

    /// The display name attached to the MigratingVm by the user.
    pub display_name: std::string::String,

    /// The description attached to the migrating VM by the user.
    pub description: std::string::String,

    /// The replication schedule policy.
    pub policy: std::option::Option<crate::model::SchedulePolicy>,

    /// Output only. The time the migrating VM was created (this refers to this
    /// resource and not to the time it was installed in the source).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the migrating VM resource was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most updated snapshot created time in the source that
    /// finished replication.
    pub last_sync: std::option::Option<crate::model::ReplicationSync>,

    /// Output only. State of the MigratingVm.
    pub state: crate::model::migrating_vm::State,

    /// Output only. The last time the migrating VM state was updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The percentage progress of the current running replication
    /// cycle.
    pub current_sync_info: std::option::Option<crate::model::ReplicationCycle>,

    /// Output only. The group this migrating vm is included in, if any. The group
    /// is represented by the full path of the appropriate
    /// [Group][google.cloud.vmmigration.v1.Group] resource.
    ///
    /// [google.cloud.vmmigration.v1.Group]: crate::model::Group
    pub group: std::string::String,

    /// The labels of the migrating VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The recent [clone jobs][google.cloud.vmmigration.v1.CloneJob]
    /// performed on the migrating VM. This field holds the vm's last completed
    /// clone job and the vm's running clone job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    ///
    /// [google.cloud.vmmigration.v1.CloneJob]: crate::model::CloneJob
    pub recent_clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. Provides details on the state of the Migrating VM in case of
    /// an error in replication.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The recent cutover jobs performed on the migrating VM.
    /// This field holds the vm's last completed cutover job and the vm's
    /// running cutover job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    pub recent_cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    pub target_vm_defaults: std::option::Option<crate::model::migrating_vm::TargetVmDefaults>,

    /// Details about the source VM.
    pub source_vm_details: std::option::Option<crate::model::migrating_vm::SourceVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigratingVm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigratingVm::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_vm_id][crate::model::MigratingVm::source_vm_id].
    pub fn set_source_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigratingVm::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MigratingVm::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_last_sync<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_or_clear_last_sync<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::MigratingVm::state].
    pub fn set_state<T: std::convert::Into<crate::model::migrating_vm::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_current_sync_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_or_clear_current_sync_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::MigratingVm::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MigratingVm::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [recent_clone_jobs][crate::model::MigratingVm::recent_clone_jobs].
    pub fn set_recent_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.recent_clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error][crate::model::MigratingVm::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::MigratingVm::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recent_cutover_jobs][crate::model::MigratingVm::recent_cutover_jobs].
    pub fn set_recent_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.recent_cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults].
    ///
    /// Note that all the setters affecting `target_vm_defaults` are mutually
    /// exclusive.
    pub fn set_target_vm_defaults<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::TargetVmDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = v.into();
        self
    }

    /// The value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// if it holds a `ComputeEngineTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDefaults>> {
        #[allow(unreachable_patterns)]
        self.target_vm_defaults.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// to hold a `ComputeEngineTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_vm_defaults` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = std::option::Option::Some(
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v.into()),
        );
        self
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details].
    ///
    /// Note that all the setters affecting `source_vm_details` are mutually
    /// exclusive.
    pub fn set_source_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::SourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = v.into();
        self
    }

    /// The value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// if it holds a `AwsSourceVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_source_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceVmDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vm_details.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// to hold a `AwsSourceVmDetails`.
    ///
    /// Note that all the setters affecting `source_vm_details` are
    /// mutually exclusive.
    pub fn set_aws_source_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = std::option::Option::Some(
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigratingVm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigratingVm"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigratingVm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_defaults,
            __aws_source_vm_details,
            __name,
            __source_vm_id,
            __display_name,
            __description,
            __policy,
            __create_time,
            __update_time,
            __last_sync,
            __state,
            __state_time,
            __current_sync_info,
            __group,
            __labels,
            __recent_clone_jobs,
            __error,
            __recent_cutover_jobs,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigratingVm")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDefaults" => {
                                Ok(__FieldTag::__compute_engine_target_defaults)
                            }
                            "compute_engine_target_defaults" => {
                                Ok(__FieldTag::__compute_engine_target_defaults)
                            }
                            "awsSourceVmDetails" => Ok(__FieldTag::__aws_source_vm_details),
                            "aws_source_vm_details" => Ok(__FieldTag::__aws_source_vm_details),
                            "name" => Ok(__FieldTag::__name),
                            "sourceVmId" => Ok(__FieldTag::__source_vm_id),
                            "source_vm_id" => Ok(__FieldTag::__source_vm_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "policy" => Ok(__FieldTag::__policy),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastSync" => Ok(__FieldTag::__last_sync),
                            "last_sync" => Ok(__FieldTag::__last_sync),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "currentSyncInfo" => Ok(__FieldTag::__current_sync_info),
                            "current_sync_info" => Ok(__FieldTag::__current_sync_info),
                            "group" => Ok(__FieldTag::__group),
                            "labels" => Ok(__FieldTag::__labels),
                            "recentCloneJobs" => Ok(__FieldTag::__recent_clone_jobs),
                            "recent_clone_jobs" => Ok(__FieldTag::__recent_clone_jobs),
                            "error" => Ok(__FieldTag::__error),
                            "recentCutoverJobs" => Ok(__FieldTag::__recent_cutover_jobs),
                            "recent_cutover_jobs" => Ok(__FieldTag::__recent_cutover_jobs),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigratingVm;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigratingVm")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_defaults => {
                            if !fields.insert(__FieldTag::__compute_engine_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_defaults",
                                ));
                            }
                            if result.target_vm_defaults.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_defaults`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.compute_engine_target_defaults, latest field was computeEngineTargetDefaults",
                                ));
                            }
                            result.target_vm_defaults = std::option::Option::Some(
                                crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDefaults>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__aws_source_vm_details => {
                            if !fields.insert(__FieldTag::__aws_source_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_source_vm_details",
                                ));
                            }
                            if result.source_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.aws_source_vm_details, latest field was awsSourceVmDetails",
                                ));
                            }
                            result.source_vm_details = std::option::Option::Some(
                                crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsSourceVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_vm_id => {
                            if !fields.insert(__FieldTag::__source_vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_vm_id",
                                ));
                            }
                            result.source_vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<crate::model::SchedulePolicy>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_sync => {
                            if !fields.insert(__FieldTag::__last_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync",
                                ));
                            }
                            result.last_sync = map
                                .next_value::<std::option::Option<crate::model::ReplicationSync>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migrating_vm::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_sync_info => {
                            if !fields.insert(__FieldTag::__current_sync_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_sync_info",
                                ));
                            }
                            result.current_sync_info = map
                                .next_value::<std::option::Option<crate::model::ReplicationCycle>>(
                                )?;
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recent_clone_jobs => {
                            if !fields.insert(__FieldTag::__recent_clone_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_clone_jobs",
                                ));
                            }
                            result.recent_clone_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__recent_cutover_jobs => {
                            if !fields.insert(__FieldTag::__recent_cutover_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_cutover_jobs",
                                ));
                            }
                            result.recent_cutover_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigratingVm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_defaults() {
            state.serialize_entry("computeEngineTargetDefaults", value)?;
        }
        if let Some(value) = self.aws_source_vm_details() {
            state.serialize_entry("awsSourceVmDetails", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_vm_id.is_empty() {
            state.serialize_entry("sourceVmId", &self.source_vm_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_sync.is_some() {
            state.serialize_entry("lastSync", &self.last_sync)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.current_sync_info.is_some() {
            state.serialize_entry("currentSyncInfo", &self.current_sync_info)?;
        }
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.recent_clone_jobs.is_empty() {
            state.serialize_entry("recentCloneJobs", &self.recent_clone_jobs)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.recent_cutover_jobs.is_empty() {
            state.serialize_entry("recentCutoverJobs", &self.recent_cutover_jobs)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigratingVm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigratingVm");
        debug_struct.field("name", &self.name);
        debug_struct.field("source_vm_id", &self.source_vm_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("policy", &self.policy);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("last_sync", &self.last_sync);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("current_sync_info", &self.current_sync_info);
        debug_struct.field("group", &self.group);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("recent_clone_jobs", &self.recent_clone_jobs);
        debug_struct.field("error", &self.error);
        debug_struct.field("recent_cutover_jobs", &self.recent_cutover_jobs);
        debug_struct.field("target_vm_defaults", &self.target_vm_defaults);
        debug_struct.field("source_vm_details", &self.source_vm_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigratingVm].
pub mod migrating_vm {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state/health of source VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The VM in the source is being verified.
        Pending,
        /// The source VM was verified, and it's ready to start replication.
        Ready,
        /// Migration is going through the first sync cycle.
        FirstSync,
        /// The replication is active, and it's running or scheduled to run.
        Active,
        /// The source VM is being turned off, and a final replication is currently
        /// running.
        CuttingOver,
        /// The source VM was stopped and replicated. The replication is currently
        /// paused.
        Cutover,
        /// A cutover job is active and replication cycle is running the final sync.
        FinalSync,
        /// The replication was paused by the user and no cycles are scheduled to
        /// run.
        Paused,
        /// The migrating VM is being finalized and migration resources are being
        /// removed.
        Finalizing,
        /// The replication process is done. The migrating VM is finalized and no
        /// longer consumes billable resources.
        Finalized,
        /// The replication process encountered an unrecoverable error and was
        /// aborted.
        Error,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::FirstSync => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::CuttingOver => std::option::Option::Some(7),
                Self::Cutover => std::option::Option::Some(8),
                Self::FinalSync => std::option::Option::Some(9),
                Self::Paused => std::option::Option::Some(10),
                Self::Finalizing => std::option::Option::Some(11),
                Self::Finalized => std::option::Option::Some(12),
                Self::Error => std::option::Option::Some(13),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::FirstSync => std::option::Option::Some("FIRST_SYNC"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::CuttingOver => std::option::Option::Some("CUTTING_OVER"),
                Self::Cutover => std::option::Option::Some("CUTOVER"),
                Self::FinalSync => std::option::Option::Some("FINAL_SYNC"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Finalizing => std::option::Option::Some("FINALIZING"),
                Self::Finalized => std::option::Option::Some("FINALIZED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Ready,
                3 => Self::FirstSync,
                4 => Self::Active,
                7 => Self::CuttingOver,
                8 => Self::Cutover,
                9 => Self::FinalSync,
                10 => Self::Paused,
                11 => Self::Finalizing,
                12 => Self::Finalized,
                13 => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "READY" => Self::Ready,
                "FIRST_SYNC" => Self::FirstSync,
                "ACTIVE" => Self::Active,
                "CUTTING_OVER" => Self::CuttingOver,
                "CUTOVER" => Self::Cutover,
                "FINAL_SYNC" => Self::FinalSync,
                "PAUSED" => Self::Paused,
                "FINALIZING" => Self::Finalizing,
                "FINALIZED" => Self::Finalized,
                "ERROR" => Self::Error,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::FirstSync => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::CuttingOver => serializer.serialize_i32(7),
                Self::Cutover => serializer.serialize_i32(8),
                Self::FinalSync => serializer.serialize_i32(9),
                Self::Paused => serializer.serialize_i32(10),
                Self::Finalizing => serializer.serialize_i32(11),
                Self::Finalized => serializer.serialize_i32(12),
                Self::Error => serializer.serialize_i32(13),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.MigratingVm.State",
            ))
        }
    }

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDefaults {
        /// Details of the target VM in Compute Engine.
        ComputeEngineTargetDefaults(std::boxed::Box<crate::model::ComputeEngineTargetDefaults>),
    }

    /// Details about the source VM.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceVmDetails {
        /// Output only. Details of the VM from an AWS source.
        AwsSourceVmDetails(std::boxed::Box<crate::model::AwsSourceVmDetails>),
    }
}

/// CloneJob describes the process of creating a clone of a
/// [MigratingVM][google.cloud.vmmigration.v1.MigratingVm] to the
/// requested target based on the latest successful uploaded snapshots.
/// While the migration cycles of a MigratingVm take place, it is possible to
/// verify the uploaded VM can be started in the cloud, by creating a clone. The
/// clone can be created without any downtime, and it is created using the latest
/// snapshots which are already in the cloud. The cloneJob is only responsible
/// for its work, not its products, which means once it is finished, it will
/// never touch the instance it created. It will only delete it in case of the
/// CloneJob being cancelled or upon failure to clone.
///
/// [google.cloud.vmmigration.v1.MigratingVm]: crate::model::MigratingVm
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneJob {
    /// Output only. The time the clone job was created (as an API call, not when
    /// it was actually created in the target).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the clone job was ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the clone.
    pub name: std::string::String,

    /// Output only. State of the clone job.
    pub state: crate::model::clone_job::State,

    /// Output only. The time the state was last updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details for the errors that led to the Clone Job's
    /// state.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The clone steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CloneStep>,

    /// Details of the VM to create as the target of this clone job.
    pub target_vm_details: std::option::Option<crate::model::clone_job::TargetVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CloneJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloneJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::clone_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::CloneJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CloneJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::CloneJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::clone_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_details,
            __create_time,
            __end_time,
            __name,
            __state,
            __state_time,
            __error,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "compute_engine_target_details" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CloneJob.compute_engine_target_details, latest field was computeEngineTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::clone_job::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_details() {
            state.serialize_entry("computeEngineTargetDetails", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloneJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneJob");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("target_vm_details", &self.target_vm_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloneJob].
pub mod clone_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the clone job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The clone job has not yet started.
        Pending,
        /// The clone job is active and running.
        Active,
        /// The clone job finished with errors.
        Failed,
        /// The clone job finished successfully.
        Succeeded,
        /// The clone job was cancelled.
        Cancelled,
        /// The clone job is being cancelled.
        Cancelling,
        /// OS adaptation is running as part of the clone job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Cancelling => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Failed,
                4 => Self::Succeeded,
                5 => Self::Cancelled,
                6 => Self::Cancelling,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Cancelling => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CloneJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this clone job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
    }
}

/// CloneStep holds information about the clone step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneStep {
    /// The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::clone_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CloneStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::clone_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `AdaptingOs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn adapting_os(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdaptingOSStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::AdaptingOs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `AdaptingOs`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_adapting_os<T: std::convert::Into<std::boxed::Box<crate::model::AdaptingOSStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(crate::model::clone_step::Step::AdaptingOs(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::clone_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::clone_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adapting_os,
            __preparing_vm_disks,
            __instantiating_migrated_vm,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptingOs" => Ok(__FieldTag::__adapting_os),
                            "adapting_os" => Ok(__FieldTag::__adapting_os),
                            "preparingVmDisks" => Ok(__FieldTag::__preparing_vm_disks),
                            "preparing_vm_disks" => Ok(__FieldTag::__preparing_vm_disks),
                            "instantiatingMigratedVm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "instantiating_migrated_vm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adapting_os => {
                            if !fields.insert(__FieldTag::__adapting_os) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adapting_os",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.adapting_os, latest field was adaptingOs",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::AdaptingOs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdaptingOSStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__preparing_vm_disks => {
                            if !fields.insert(__FieldTag::__preparing_vm_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preparing_vm_disks",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.preparing_vm_disks, latest field was preparingVmDisks",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::PreparingVmDisks(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PreparingVMDisksStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__instantiating_migrated_vm => {
                            if !fields.insert(__FieldTag::__instantiating_migrated_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instantiating_migrated_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.instantiating_migrated_vm, latest field was instantiatingMigratedVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::InstantiatingMigratedVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstantiatingMigratedVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.adapting_os() {
            state.serialize_entry("adaptingOs", value)?;
        }
        if let Some(value) = self.preparing_vm_disks() {
            state.serialize_entry("preparingVmDisks", value)?;
        }
        if let Some(value) = self.instantiating_migrated_vm() {
            state.serialize_entry("instantiatingMigratedVm", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloneStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloneStep].
pub mod clone_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Adapting OS step.
        AdaptingOs(std::boxed::Box<crate::model::AdaptingOSStep>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// AdaptingOSStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptingOSStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptingOSStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdaptingOSStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AdaptingOSStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptingOSStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptingOSStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptingOSStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptingOSStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptingOSStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdaptingOSStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdaptingOSStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PreparingVMDisksStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreparingVMDisksStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PreparingVMDisksStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PreparingVMDisksStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PreparingVMDisksStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PreparingVMDisksStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PreparingVMDisksStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PreparingVMDisksStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PreparingVMDisksStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PreparingVMDisksStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PreparingVMDisksStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PreparingVMDisksStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// InstantiatingMigratedVMStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstantiatingMigratedVMStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiatingMigratedVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InstantiatingMigratedVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InstantiatingMigratedVMStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstantiatingMigratedVMStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstantiatingMigratedVMStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstantiatingMigratedVMStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstantiatingMigratedVMStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstantiatingMigratedVMStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InstantiatingMigratedVMStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstantiatingMigratedVMStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CutoverJob message describes a cutover of a migrating VM. The CutoverJob is
/// the operation of shutting down the VM, creating a snapshot and
/// clonning the VM using the replicated snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CutoverJob {
    /// Output only. The time the cutover job was created (as an API call, not when
    /// it was actually created in the target).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the cutover job had finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the cutover job.
    pub name: std::string::String,

    /// Output only. State of the cutover job.
    pub state: crate::model::cutover_job::State,

    /// Output only. The time the state was last updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current progress in percentage of the cutover job.
    pub progress_percent: i32,

    /// Output only. Provides details for the errors that led to the Cutover Job's
    /// state.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. A message providing possible extra details about the current
    /// state.
    pub state_message: std::string::String,

    /// Output only. The cutover steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CutoverStep>,

    /// Details of the VM to create as the target of this cutover job.
    pub target_vm_details: std::option::Option<crate::model::cutover_job::TargetVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CutoverJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CutoverJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::cutover_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::CutoverJob::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CutoverJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CutoverJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_message][crate::model::CutoverJob::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::CutoverJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::cutover_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CutoverJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_details,
            __create_time,
            __end_time,
            __name,
            __state,
            __state_time,
            __progress_percent,
            __error,
            __state_message,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CutoverJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "compute_engine_target_details" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "error" => Ok(__FieldTag::__error),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CutoverJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CutoverJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverJob.compute_engine_target_details, latest field was computeEngineTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::cutover_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CutoverJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_details() {
            state.serialize_entry("computeEngineTargetDetails", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CutoverJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CutoverJob");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("error", &self.error);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("target_vm_details", &self.target_vm_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CutoverJob].
pub mod cutover_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the cutover job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The cutover job has not yet started.
        Pending,
        /// The cutover job finished with errors.
        Failed,
        /// The cutover job finished successfully.
        Succeeded,
        /// The cutover job was cancelled.
        Cancelled,
        /// The cutover job is being cancelled.
        Cancelling,
        /// The cutover job is active and running.
        Active,
        /// OS adaptation is running as part of the cutover job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Succeeded,
                4 => Self::Cancelled,
                5 => Self::Cancelling,
                6 => Self::Active,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ACTIVE" => Self::Active,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CutoverJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this cutover job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
    }
}

/// CutoverStep holds information about the cutover step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CutoverStep {
    /// The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::cutover_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CutoverStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<
        T: std::convert::Into<std::option::Option<crate::model::cutover_step::Step>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreviousReplicationCycle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn previous_replication_cycle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreviousReplicationCycle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreviousReplicationCycle`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_previous_replication_cycle<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::PreviousReplicationCycle(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `ShuttingDownSourceVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shutting_down_source_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ShuttingDownSourceVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `ShuttingDownSourceVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_shutting_down_source_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::ShuttingDownSourceVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `FinalSync`, `None` if the field is not set or
    /// holds a different branch.
    pub fn final_sync(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::FinalSync(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `FinalSync`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_final_sync<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::FinalSync(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CutoverStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __previous_replication_cycle,
            __shutting_down_source_vm,
            __final_sync,
            __preparing_vm_disks,
            __instantiating_migrated_vm,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CutoverStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "previousReplicationCycle" => {
                                Ok(__FieldTag::__previous_replication_cycle)
                            }
                            "previous_replication_cycle" => {
                                Ok(__FieldTag::__previous_replication_cycle)
                            }
                            "shuttingDownSourceVm" => Ok(__FieldTag::__shutting_down_source_vm),
                            "shutting_down_source_vm" => Ok(__FieldTag::__shutting_down_source_vm),
                            "finalSync" => Ok(__FieldTag::__final_sync),
                            "final_sync" => Ok(__FieldTag::__final_sync),
                            "preparingVmDisks" => Ok(__FieldTag::__preparing_vm_disks),
                            "preparing_vm_disks" => Ok(__FieldTag::__preparing_vm_disks),
                            "instantiatingMigratedVm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "instantiating_migrated_vm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CutoverStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CutoverStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__previous_replication_cycle => {
                            if !fields.insert(__FieldTag::__previous_replication_cycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_replication_cycle",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.previous_replication_cycle, latest field was previousReplicationCycle",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::PreviousReplicationCycle(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicationCycle>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__shutting_down_source_vm => {
                            if !fields.insert(__FieldTag::__shutting_down_source_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shutting_down_source_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.shutting_down_source_vm, latest field was shuttingDownSourceVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::ShuttingDownSourceVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ShuttingDownSourceVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__final_sync => {
                            if !fields.insert(__FieldTag::__final_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for final_sync",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.final_sync, latest field was finalSync",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::FinalSync(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicationCycle>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__preparing_vm_disks => {
                            if !fields.insert(__FieldTag::__preparing_vm_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preparing_vm_disks",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.preparing_vm_disks, latest field was preparingVmDisks",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::PreparingVmDisks(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PreparingVMDisksStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__instantiating_migrated_vm => {
                            if !fields.insert(__FieldTag::__instantiating_migrated_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instantiating_migrated_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.instantiating_migrated_vm, latest field was instantiatingMigratedVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::InstantiatingMigratedVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstantiatingMigratedVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CutoverStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.previous_replication_cycle() {
            state.serialize_entry("previousReplicationCycle", value)?;
        }
        if let Some(value) = self.shutting_down_source_vm() {
            state.serialize_entry("shuttingDownSourceVm", value)?;
        }
        if let Some(value) = self.final_sync() {
            state.serialize_entry("finalSync", value)?;
        }
        if let Some(value) = self.preparing_vm_disks() {
            state.serialize_entry("preparingVmDisks", value)?;
        }
        if let Some(value) = self.instantiating_migrated_vm() {
            state.serialize_entry("instantiatingMigratedVm", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CutoverStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CutoverStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CutoverStep].
pub mod cutover_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// A replication cycle prior cutover step.
        PreviousReplicationCycle(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Shutting down VM step.
        ShuttingDownSourceVm(std::boxed::Box<crate::model::ShuttingDownSourceVMStep>),
        /// Final sync step.
        FinalSync(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// ShuttingDownSourceVMStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShuttingDownSourceVMStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShuttingDownSourceVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ShuttingDownSourceVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ShuttingDownSourceVMStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShuttingDownSourceVMStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShuttingDownSourceVMStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShuttingDownSourceVMStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShuttingDownSourceVMStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShuttingDownSourceVMStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ShuttingDownSourceVMStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShuttingDownSourceVMStep");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloneJobRequest {
    /// Required. The Clone's parent.
    pub parent: std::string::String,

    /// Required. The clone job identifier.
    pub clone_job_id: std::string::String,

    /// Required. The clone request body.
    pub clone_job: std::option::Option<crate::model::CloneJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloneJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [clone_job_id][crate::model::CreateCloneJobRequest::clone_job_id].
    pub fn set_clone_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_job_id = v.into();
        self
    }

    /// Sets the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_clone_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_or_clear_clone_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloneJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __clone_job_id,
            __clone_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloneJobId" => Ok(__FieldTag::__clone_job_id),
                            "clone_job_id" => Ok(__FieldTag::__clone_job_id),
                            "cloneJob" => Ok(__FieldTag::__clone_job),
                            "clone_job" => Ok(__FieldTag::__clone_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_job_id => {
                            if !fields.insert(__FieldTag::__clone_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_job_id",
                                ));
                            }
                            result.clone_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_job => {
                            if !fields.insert(__FieldTag::__clone_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_job",
                                ));
                            }
                            result.clone_job =
                                map.next_value::<std::option::Option<crate::model::CloneJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.clone_job_id.is_empty() {
            state.serialize_entry("cloneJobId", &self.clone_job_id)?;
        }
        if self.clone_job.is_some() {
            state.serialize_entry("cloneJob", &self.clone_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCloneJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("clone_job_id", &self.clone_job_id);
        debug_struct.field("clone_job", &self.clone_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCloneJobRequest {
    /// Required. The clone job id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCloneJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCloneJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCloneJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCloneJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCloneJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCloneJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCloneJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCloneJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCloneJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCloneJobResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListCloneJobsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloneJobsRequest {
    /// Required. The parent, which owns this collection of source VMs.
    pub parent: std::string::String,

    /// Optional. The maximum number of clone jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 clone jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCloneJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCloneJobs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloneJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloneJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloneJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloneJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCloneJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCloneJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloneJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloneJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloneJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloneJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloneJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloneJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloneJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListCloneJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloneJobsResponse {
    /// Output only. The list of clone jobs response.
    pub clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_jobs][crate::model::ListCloneJobsResponse::clone_jobs].
    pub fn set_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloneJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCloneJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCloneJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloneJobsResponse {
    type PageItem = crate::model::CloneJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clone_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloneJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clone_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloneJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloneJobs" => Ok(__FieldTag::__clone_jobs),
                            "clone_jobs" => Ok(__FieldTag::__clone_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloneJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloneJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clone_jobs => {
                            if !fields.insert(__FieldTag::__clone_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_jobs",
                                ));
                            }
                            result.clone_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloneJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clone_jobs.is_empty() {
            state.serialize_entry("cloneJobs", &self.clone_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloneJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloneJobsResponse");
        debug_struct.field("clone_jobs", &self.clone_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloneJobRequest {
    /// Required. The name of the CloneJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloneJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Source message describes a specific vm migration Source resource. It contains
/// the source environment information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// Output only. The Source name.
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels of the source.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-provided description of the source.
    pub description: std::string::String,

    pub source_details: std::option::Option<crate::model::source::SourceDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Source::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Source::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Source::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Source::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Source::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [source_details][crate::model::Source::source_details].
    ///
    /// Note that all the setters affecting `source_details` are mutually
    /// exclusive.
    pub fn set_source_details<
        T: std::convert::Into<std::option::Option<crate::model::source::SourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_details = v.into();
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Vmware`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Vmware(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Vmware`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_vmware<T: std::convert::Into<std::boxed::Box<crate::model::VmwareSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Vmware(v.into()));
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Aws`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Aws(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Aws`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_aws<T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Aws(v.into()));
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware,
            __aws,
            __name,
            __create_time,
            __update_time,
            __labels,
            __description,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmware" => Ok(__FieldTag::__vmware),
                            "aws" => Ok(__FieldTag::__aws),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware => {
                            if !fields.insert(__FieldTag::__vmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware",
                                ));
                            }
                            if result.source_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_details`, a oneof with full ID .google.cloud.vmmigration.v1.Source.vmware, latest field was vmware",
                                ));
                            }
                            result.source_details = std::option::Option::Some(
                                crate::model::source::SourceDetails::Vmware(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws => {
                            if !fields.insert(__FieldTag::__aws) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws",
                                ));
                            }
                            if result.source_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_details`, a oneof with full ID .google.cloud.vmmigration.v1.Source.aws, latest field was aws",
                                ));
                            }
                            result.source_details = std::option::Option::Some(
                                crate::model::source::SourceDetails::Aws(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware() {
            state.serialize_entry("vmware", value)?;
        }
        if let Some(value) = self.aws() {
            state.serialize_entry("aws", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("source_details", &self.source_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceDetails {
        /// Vmware type source details.
        Vmware(std::boxed::Box<crate::model::VmwareSourceDetails>),
        /// AWS type source details.
        Aws(std::boxed::Box<crate::model::AwsSourceDetails>),
    }
}

/// VmwareSourceDetails message describes a specific source details for the
/// vmware source type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareSourceDetails {
    /// The credentials username.
    pub username: std::string::String,

    /// Input only. The credentials password. This is write only and can not be
    /// read in a GET operation.
    pub password: std::string::String,

    /// The ip address of the vcenter this Source represents.
    pub vcenter_ip: std::string::String,

    /// The thumbprint representing the certificate for the vcenter.
    pub thumbprint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::VmwareSourceDetails::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::VmwareSourceDetails::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [vcenter_ip][crate::model::VmwareSourceDetails::vcenter_ip].
    pub fn set_vcenter_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_ip = v.into();
        self
    }

    /// Sets the value of [thumbprint][crate::model::VmwareSourceDetails::thumbprint].
    pub fn set_thumbprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.thumbprint = v.into();
        self
    }
}

impl wkt::message::Message for VmwareSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password,
            __vcenter_ip,
            __thumbprint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "vcenterIp" => Ok(__FieldTag::__vcenter_ip),
                            "vcenter_ip" => Ok(__FieldTag::__vcenter_ip),
                            "thumbprint" => Ok(__FieldTag::__thumbprint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcenter_ip => {
                            if !fields.insert(__FieldTag::__vcenter_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_ip",
                                ));
                            }
                            result.vcenter_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__thumbprint => {
                            if !fields.insert(__FieldTag::__thumbprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thumbprint",
                                ));
                            }
                            result.thumbprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.vcenter_ip.is_empty() {
            state.serialize_entry("vcenterIp", &self.vcenter_ip)?;
        }
        if !self.thumbprint.is_empty() {
            state.serialize_entry("thumbprint", &self.thumbprint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareSourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareSourceDetails");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("vcenter_ip", &self.vcenter_ip);
        debug_struct.field("thumbprint", &self.thumbprint);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AwsSourceDetails message describes a specific source details for the
/// AWS source type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSourceDetails {
    /// Immutable. The AWS region that the source VMs will be migrated from.
    pub aws_region: std::string::String,

    /// Output only. State of the source as determined by the health check.
    pub state: crate::model::aws_source_details::State,

    /// Output only. Provides details on the state of the Source in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// AWS resource tags to limit the scope of the source inventory.
    pub inventory_tag_list: std::vec::Vec<crate::model::aws_source_details::Tag>,

    /// AWS security group names to limit the scope of the source
    /// inventory.
    pub inventory_security_group_names: std::vec::Vec<std::string::String>,

    /// User specified tags to add to every M2VM generated resource in AWS.
    /// These tags will be set in addition to the default tags that are set as part
    /// of the migration process. The tags must not begin with the reserved prefix
    /// `m2vm`.
    pub migration_resources_user_tags:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The source's public IP. All communication initiated by this
    /// source will originate from this IP.
    pub public_ip: std::string::String,

    pub credentials_type: std::option::Option<crate::model::aws_source_details::CredentialsType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_region][crate::model::AwsSourceDetails::aws_region].
    pub fn set_aws_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_region = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsSourceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_source_details::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inventory_tag_list][crate::model::AwsSourceDetails::inventory_tag_list].
    pub fn set_inventory_tag_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::aws_source_details::Tag>,
    {
        use std::iter::Iterator;
        self.inventory_tag_list = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inventory_security_group_names][crate::model::AwsSourceDetails::inventory_security_group_names].
    pub fn set_inventory_security_group_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inventory_security_group_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [migration_resources_user_tags][crate::model::AwsSourceDetails::migration_resources_user_tags].
    pub fn set_migration_resources_user_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.migration_resources_user_tags =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [public_ip][crate::model::AwsSourceDetails::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type].
    ///
    /// Note that all the setters affecting `credentials_type` are mutually
    /// exclusive.
    pub fn set_credentials_type<
        T: std::convert::Into<std::option::Option<crate::model::aws_source_details::CredentialsType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = v.into();
        self
    }

    /// The value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// if it holds a `AccessKeyCreds`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_key_creds(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.credentials_type.as_ref().and_then(|v| match v {
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// to hold a `AccessKeyCreds`.
    ///
    /// Note that all the setters affecting `credentials_type` are
    /// mutually exclusive.
    pub fn set_access_key_creds<
        T: std::convert::Into<std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = std::option::Option::Some(
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_key_creds,
            __aws_region,
            __state,
            __error,
            __inventory_tag_list,
            __inventory_security_group_names,
            __migration_resources_user_tags,
            __public_ip,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessKeyCreds" => Ok(__FieldTag::__access_key_creds),
                            "access_key_creds" => Ok(__FieldTag::__access_key_creds),
                            "awsRegion" => Ok(__FieldTag::__aws_region),
                            "aws_region" => Ok(__FieldTag::__aws_region),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "inventoryTagList" => Ok(__FieldTag::__inventory_tag_list),
                            "inventory_tag_list" => Ok(__FieldTag::__inventory_tag_list),
                            "inventorySecurityGroupNames" => {
                                Ok(__FieldTag::__inventory_security_group_names)
                            }
                            "inventory_security_group_names" => {
                                Ok(__FieldTag::__inventory_security_group_names)
                            }
                            "migrationResourcesUserTags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "migration_resources_user_tags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "publicIp" => Ok(__FieldTag::__public_ip),
                            "public_ip" => Ok(__FieldTag::__public_ip),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_key_creds => {
                            if !fields.insert(__FieldTag::__access_key_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_key_creds",
                                ));
                            }
                            if result.credentials_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credentials_type`, a oneof with full ID .google.cloud.vmmigration.v1.AwsSourceDetails.access_key_creds, latest field was accessKeyCreds",
                                ));
                            }
                            result.credentials_type = std::option::Option::Some(
                                crate::model::aws_source_details::CredentialsType::AccessKeyCreds(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::aws_source_details::AccessKeyCredentials,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_region => {
                            if !fields.insert(__FieldTag::__aws_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_region",
                                ));
                            }
                            result.aws_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::aws_source_details::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__inventory_tag_list => {
                            if !fields.insert(__FieldTag::__inventory_tag_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory_tag_list",
                                ));
                            }
                            result.inventory_tag_list = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::aws_source_details::Tag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inventory_security_group_names => {
                            if !fields.insert(__FieldTag::__inventory_security_group_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory_security_group_names",
                                ));
                            }
                            result.inventory_security_group_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__migration_resources_user_tags => {
                            if !fields.insert(__FieldTag::__migration_resources_user_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_resources_user_tags",
                                ));
                            }
                            result.migration_resources_user_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip => {
                            if !fields.insert(__FieldTag::__public_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip",
                                ));
                            }
                            result.public_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.access_key_creds() {
            state.serialize_entry("accessKeyCreds", value)?;
        }
        if !self.aws_region.is_empty() {
            state.serialize_entry("awsRegion", &self.aws_region)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.inventory_tag_list.is_empty() {
            state.serialize_entry("inventoryTagList", &self.inventory_tag_list)?;
        }
        if !self.inventory_security_group_names.is_empty() {
            state.serialize_entry(
                "inventorySecurityGroupNames",
                &self.inventory_security_group_names,
            )?;
        }
        if !self.migration_resources_user_tags.is_empty() {
            state.serialize_entry(
                "migrationResourcesUserTags",
                &self.migration_resources_user_tags,
            )?;
        }
        if !self.public_ip.is_empty() {
            state.serialize_entry("publicIp", &self.public_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSourceDetails");
        debug_struct.field("aws_region", &self.aws_region);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("inventory_tag_list", &self.inventory_tag_list);
        debug_struct.field(
            "inventory_security_group_names",
            &self.inventory_security_group_names,
        );
        debug_struct.field(
            "migration_resources_user_tags",
            &self.migration_resources_user_tags,
        );
        debug_struct.field("public_ip", &self.public_ip);
        debug_struct.field("credentials_type", &self.credentials_type);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsSourceDetails].
pub mod aws_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing AWS Credentials using access key id and secret.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessKeyCredentials {
        /// AWS access key ID.
        pub access_key_id: std::string::String,

        /// Input only. AWS secret access key.
        pub secret_access_key: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessKeyCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_key_id][crate::model::aws_source_details::AccessKeyCredentials::access_key_id].
        pub fn set_access_key_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_key_id = v.into();
            self
        }

        /// Sets the value of [secret_access_key][crate::model::aws_source_details::AccessKeyCredentials::secret_access_key].
        pub fn set_secret_access_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_access_key = v.into();
            self
        }
    }

    impl wkt::message::Message for AccessKeyCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.AccessKeyCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessKeyCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __access_key_id,
                __secret_access_key,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessKeyCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accessKeyId" => Ok(__FieldTag::__access_key_id),
                                "access_key_id" => Ok(__FieldTag::__access_key_id),
                                "secretAccessKey" => Ok(__FieldTag::__secret_access_key),
                                "secret_access_key" => Ok(__FieldTag::__secret_access_key),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessKeyCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessKeyCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__access_key_id => {
                                if !fields.insert(__FieldTag::__access_key_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_key_id",
                                    ));
                                }
                                result.access_key_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__secret_access_key => {
                                if !fields.insert(__FieldTag::__secret_access_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_access_key",
                                    ));
                                }
                                result.secret_access_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessKeyCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.access_key_id.is_empty() {
                state.serialize_entry("accessKeyId", &self.access_key_id)?;
            }
            if !self.secret_access_key.is_empty() {
                state.serialize_entry("secretAccessKey", &self.secret_access_key)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AccessKeyCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AccessKeyCredentials");
            debug_struct.field("access_key_id", &self.access_key_id);
            debug_struct.field("secret_access_key", &self.secret_access_key);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Tag is an AWS tag representation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Tag {
        /// Key of tag.
        pub key: std::string::String,

        /// Value of tag.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Tag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::aws_source_details::Tag::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::aws_source_details::Tag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Tag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.Tag"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Tag {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Tag")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Tag;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Tag")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Tag {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Tag {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Tag");
            debug_struct.field("key", &self.key);
            debug_struct.field("value", &self.value);

            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source is available but might not be usable yet due to invalid
        /// credentials or another reason.
        /// The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.AwsSourceDetails.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CredentialsType {
        /// AWS Credentials using access key id and secret.
        AccessKeyCreds(std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>),
    }
}

/// DatacenterConnector message describes a connector between the Source and
/// Google Cloud, which is installed on a vmware datacenter (an OVA vm installed
/// by the user) to connect the Datacenter to Google Cloud and support vm
/// migration data transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatacenterConnector {
    /// Output only. The time the connector was created (as an API call, not when
    /// it was actually installed).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the connector was updated with an API call.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The connector's name.
    pub name: std::string::String,

    /// Immutable. A unique key for this connector. This key is internal to the OVA
    /// connector and is supplied with its creation during the registration process
    /// and can not be modified.
    pub registration_id: std::string::String,

    /// The service account to use in the connector when communicating with the
    /// cloud.
    pub service_account: std::string::String,

    /// The version running in the DatacenterConnector. This is supplied by the OVA
    /// connector during the registration process and can not be modified.
    pub version: std::string::String,

    /// Output only. The communication channel between the datacenter connector and
    /// Google Cloud.
    pub bucket: std::string::String,

    /// Output only. State of the DatacenterConnector, as determined by the health
    /// checks.
    pub state: crate::model::datacenter_connector::State,

    /// Output only. The time the state was last set.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the Datacenter Connector in
    /// case of an error.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Appliance OVA version.
    /// This is the OVA which is manually installed by the user and contains the
    /// infrastructure for the automatically updatable components on the appliance.
    pub appliance_infrastructure_version: std::string::String,

    /// Output only. Appliance last installed update bundle version.
    /// This is the version of the automatically updatable components on the
    /// appliance.
    pub appliance_software_version: std::string::String,

    /// Output only. The available versions for updating this appliance.
    pub available_versions: std::option::Option<crate::model::AvailableUpdates>,

    /// Output only. The status of the current / last upgradeAppliance operation.
    pub upgrade_status: std::option::Option<crate::model::UpgradeStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatacenterConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::DatacenterConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [registration_id][crate::model::DatacenterConnector::registration_id].
    pub fn set_registration_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.registration_id = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DatacenterConnector::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatacenterConnector::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::DatacenterConnector::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatacenterConnector::state].
    pub fn set_state<T: std::convert::Into<crate::model::datacenter_connector::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [appliance_infrastructure_version][crate::model::DatacenterConnector::appliance_infrastructure_version].
    pub fn set_appliance_infrastructure_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_infrastructure_version = v.into();
        self
    }

    /// Sets the value of [appliance_software_version][crate::model::DatacenterConnector::appliance_software_version].
    pub fn set_appliance_software_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_software_version = v.into();
        self
    }

    /// Sets the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_available_versions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_or_clear_available_versions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_upgrade_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_or_clear_upgrade_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatacenterConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DatacenterConnector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatacenterConnector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __name,
            __registration_id,
            __service_account,
            __version,
            __bucket,
            __state,
            __state_time,
            __error,
            __appliance_infrastructure_version,
            __appliance_software_version,
            __available_versions,
            __upgrade_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatacenterConnector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "name" => Ok(__FieldTag::__name),
                            "registrationId" => Ok(__FieldTag::__registration_id),
                            "registration_id" => Ok(__FieldTag::__registration_id),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "version" => Ok(__FieldTag::__version),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "applianceInfrastructureVersion" => {
                                Ok(__FieldTag::__appliance_infrastructure_version)
                            }
                            "appliance_infrastructure_version" => {
                                Ok(__FieldTag::__appliance_infrastructure_version)
                            }
                            "applianceSoftwareVersion" => {
                                Ok(__FieldTag::__appliance_software_version)
                            }
                            "appliance_software_version" => {
                                Ok(__FieldTag::__appliance_software_version)
                            }
                            "availableVersions" => Ok(__FieldTag::__available_versions),
                            "available_versions" => Ok(__FieldTag::__available_versions),
                            "upgradeStatus" => Ok(__FieldTag::__upgrade_status),
                            "upgrade_status" => Ok(__FieldTag::__upgrade_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatacenterConnector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatacenterConnector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__registration_id => {
                            if !fields.insert(__FieldTag::__registration_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for registration_id",
                                ));
                            }
                            result.registration_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::datacenter_connector::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__appliance_infrastructure_version => {
                            if !fields.insert(__FieldTag::__appliance_infrastructure_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance_infrastructure_version",
                                ));
                            }
                            result.appliance_infrastructure_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__appliance_software_version => {
                            if !fields.insert(__FieldTag::__appliance_software_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance_software_version",
                                ));
                            }
                            result.appliance_software_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_versions => {
                            if !fields.insert(__FieldTag::__available_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_versions",
                                ));
                            }
                            result.available_versions = map
                                .next_value::<std::option::Option<crate::model::AvailableUpdates>>(
                                )?;
                        }
                        __FieldTag::__upgrade_status => {
                            if !fields.insert(__FieldTag::__upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_status",
                                ));
                            }
                            result.upgrade_status = map
                                .next_value::<std::option::Option<crate::model::UpgradeStatus>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatacenterConnector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.registration_id.is_empty() {
            state.serialize_entry("registrationId", &self.registration_id)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.appliance_infrastructure_version.is_empty() {
            state.serialize_entry(
                "applianceInfrastructureVersion",
                &self.appliance_infrastructure_version,
            )?;
        }
        if !self.appliance_software_version.is_empty() {
            state.serialize_entry("applianceSoftwareVersion", &self.appliance_software_version)?;
        }
        if self.available_versions.is_some() {
            state.serialize_entry("availableVersions", &self.available_versions)?;
        }
        if self.upgrade_status.is_some() {
            state.serialize_entry("upgradeStatus", &self.upgrade_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatacenterConnector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatacenterConnector");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("registration_id", &self.registration_id);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("version", &self.version);
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field(
            "appliance_infrastructure_version",
            &self.appliance_infrastructure_version,
        );
        debug_struct.field(
            "appliance_software_version",
            &self.appliance_software_version,
        );
        debug_struct.field("available_versions", &self.available_versions);
        debug_struct.field("upgrade_status", &self.upgrade_status);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DatacenterConnector].
pub mod datacenter_connector {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source was sampled by health checks and is not available.
        Offline,
        /// The source is available but might not be usable yet due to unvalidated
        /// credentials or another reason. The credentials referred to are the ones
        /// to the Source. The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Offline,
                3 => Self::Failed,
                4 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "OFFLINE" => Self::Offline,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.DatacenterConnector.State",
            ))
        }
    }
}

/// UpgradeStatus contains information about upgradeAppliance operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeStatus {
    /// The version to upgrade to.
    pub version: std::string::String,

    /// The state of the upgradeAppliance operation.
    pub state: crate::model::upgrade_status::State,

    /// Provides details on the state of the upgrade operation in case of an error.
    pub error: std::option::Option<rpc::model::Status>,

    /// The time the operation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The version from which we upgraded.
    pub previous_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpgradeStatus::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [previous_version][crate::model::UpgradeStatus::previous_version].
    pub fn set_previous_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.previous_version = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __state,
            __error,
            __start_time,
            __previous_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "previousVersion" => Ok(__FieldTag::__previous_version),
                            "previous_version" => Ok(__FieldTag::__previous_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_status::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__previous_version => {
                            if !fields.insert(__FieldTag::__previous_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_version",
                                ));
                            }
                            result.previous_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.previous_version.is_empty() {
            state.serialize_entry("previousVersion", &self.previous_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeStatus");
        debug_struct.field("version", &self.version);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("previous_version", &self.previous_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UpgradeStatus].
pub mod upgrade_status {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The upgrade has started.
        Running,
        /// The upgrade failed.
        Failed,
        /// The upgrade finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Failed,
                3 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UpgradeStatus.State",
            ))
        }
    }
}

/// Holds informatiom about the available versions for upgrade.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AvailableUpdates {
    /// The newest deployable version of the appliance.
    /// The current appliance can't be updated into this version, and the owner
    /// must manually deploy this OVA to a new appliance.
    pub new_deployable_appliance: std::option::Option<crate::model::ApplianceVersion>,

    /// The latest version for in place update.
    /// The current appliance can be updated to this version using the API or m4c
    /// CLI.
    pub in_place_update: std::option::Option<crate::model::ApplianceVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvailableUpdates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_new_deployable_appliance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_or_clear_new_deployable_appliance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_in_place_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_or_clear_in_place_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AvailableUpdates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AvailableUpdates"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AvailableUpdates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_deployable_appliance,
            __in_place_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvailableUpdates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newDeployableAppliance" => Ok(__FieldTag::__new_deployable_appliance),
                            "new_deployable_appliance" => {
                                Ok(__FieldTag::__new_deployable_appliance)
                            }
                            "inPlaceUpdate" => Ok(__FieldTag::__in_place_update),
                            "in_place_update" => Ok(__FieldTag::__in_place_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AvailableUpdates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvailableUpdates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_deployable_appliance => {
                            if !fields.insert(__FieldTag::__new_deployable_appliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_deployable_appliance",
                                ));
                            }
                            result.new_deployable_appliance = map
                                .next_value::<std::option::Option<crate::model::ApplianceVersion>>(
                                )?;
                        }
                        __FieldTag::__in_place_update => {
                            if !fields.insert(__FieldTag::__in_place_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_place_update",
                                ));
                            }
                            result.in_place_update = map
                                .next_value::<std::option::Option<crate::model::ApplianceVersion>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AvailableUpdates {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.new_deployable_appliance.is_some() {
            state.serialize_entry("newDeployableAppliance", &self.new_deployable_appliance)?;
        }
        if self.in_place_update.is_some() {
            state.serialize_entry("inPlaceUpdate", &self.in_place_update)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AvailableUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AvailableUpdates");
        debug_struct.field("new_deployable_appliance", &self.new_deployable_appliance);
        debug_struct.field("in_place_update", &self.in_place_update);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes an appliance version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplianceVersion {
    /// The appliance version.
    pub version: std::string::String,

    /// A link for downloading the version.
    pub uri: std::string::String,

    /// Determine whether it's critical to upgrade the appliance to this version.
    pub critical: bool,

    /// Link to a page that contains the version release notes.
    pub release_notes_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::ApplianceVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ApplianceVersion::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [critical][crate::model::ApplianceVersion::critical].
    pub fn set_critical<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.critical = v.into();
        self
    }

    /// Sets the value of [release_notes_uri][crate::model::ApplianceVersion::release_notes_uri].
    pub fn set_release_notes_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_notes_uri = v.into();
        self
    }
}

impl wkt::message::Message for ApplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ApplianceVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplianceVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __uri,
            __critical,
            __release_notes_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApplianceVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "uri" => Ok(__FieldTag::__uri),
                            "critical" => Ok(__FieldTag::__critical),
                            "releaseNotesUri" => Ok(__FieldTag::__release_notes_uri),
                            "release_notes_uri" => Ok(__FieldTag::__release_notes_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplianceVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplianceVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__critical => {
                            if !fields.insert(__FieldTag::__critical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for critical",
                                ));
                            }
                            result.critical = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_notes_uri => {
                            if !fields.insert(__FieldTag::__release_notes_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_notes_uri",
                                ));
                            }
                            result.release_notes_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplianceVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.critical) {
            state.serialize_entry("critical", &self.critical)?;
        }
        if !self.release_notes_uri.is_empty() {
            state.serialize_entry("releaseNotesUri", &self.release_notes_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApplianceVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplianceVersion");
        debug_struct.field("version", &self.version);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("critical", &self.critical);
        debug_struct.field("release_notes_uri", &self.release_notes_uri);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. The parent, which owns this collection of sources.
    pub parent: std::string::String,

    /// Optional. The maximum number of sources to return. The service may return
    /// fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListSources` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSources` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// Output only. The list of sources response.
    pub sources: std::vec::Vec<crate::model::Source>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sources" => Ok(__FieldTag::__sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Source>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesResponse");
        debug_struct.field("sources", &self.sources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. The Source name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSourceRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. The Source's parent.
    pub parent: std::string::String,

    /// Required. The source identifier.
    pub source_id: std::string::String,

    /// Required. The create request body.
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CreateSourceRequest::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_id,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSourceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Source resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSourceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSourceRequest {
    /// Required. The Source name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSourceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchInventoryRequest {
    /// Required. The name of the Source.
    pub source: std::string::String,

    /// If this flag is set to true, the source will be queried instead of using
    /// cached results. Using this flag will make the call slower.
    pub force_refresh: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::FetchInventoryRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [force_refresh][crate::model::FetchInventoryRequest::force_refresh].
    pub fn set_force_refresh<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_refresh = v.into();
        self
    }
}

impl wkt::message::Message for FetchInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __force_refresh,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "forceRefresh" => Ok(__FieldTag::__force_refresh),
                            "force_refresh" => Ok(__FieldTag::__force_refresh),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force_refresh => {
                            if !fields.insert(__FieldTag::__force_refresh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force_refresh",
                                ));
                            }
                            result.force_refresh = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchInventoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.force_refresh) {
            state.serialize_entry("forceRefresh", &self.force_refresh)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchInventoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchInventoryRequest");
        debug_struct.field("source", &self.source);
        debug_struct.field("force_refresh", &self.force_refresh);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VmwareVmDetails describes a VM in vCenter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareVmDetails {
    /// The VM's id in the source (note that this is not the MigratingVm's id).
    /// This is the moref id of the VM.
    pub vm_id: std::string::String,

    /// The id of the vCenter's datacenter this VM is contained in.
    pub datacenter_id: std::string::String,

    /// The descriptive name of the vCenter's datacenter this VM is contained in.
    pub datacenter_description: std::string::String,

    /// The unique identifier of the VM in vCenter.
    pub uuid: std::string::String,

    /// The display name of the VM. Note that this is not necessarily unique.
    pub display_name: std::string::String,

    /// The power state of the VM at the moment list was taken.
    pub power_state: crate::model::vmware_vm_details::PowerState,

    /// The number of cpus in the VM.
    pub cpu_count: i32,

    /// The size of the memory of the VM in MB.
    pub memory_mb: i32,

    /// The number of disks the VM has.
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    pub committed_storage_mb: i64,

    /// The VM's OS. See for example
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>
    /// for types of strings this might hold.
    pub guest_description: std::string::String,

    /// Output only. The VM Boot Option.
    pub boot_option: crate::model::vmware_vm_details::BootOption,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmwareVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [datacenter_id][crate::model::VmwareVmDetails::datacenter_id].
    pub fn set_datacenter_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datacenter_id = v.into();
        self
    }

    /// Sets the value of [datacenter_description][crate::model::VmwareVmDetails::datacenter_description].
    pub fn set_datacenter_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_description = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::VmwareVmDetails::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::VmwareVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::VmwareVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::vmware_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::VmwareVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::VmwareVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::VmwareVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::VmwareVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [guest_description][crate::model::VmwareVmDetails::guest_description].
    pub fn set_guest_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.guest_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::VmwareVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::vmware_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }
}

impl wkt::message::Message for VmwareVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_id,
            __datacenter_id,
            __datacenter_description,
            __uuid,
            __display_name,
            __power_state,
            __cpu_count,
            __memory_mb,
            __disk_count,
            __committed_storage_mb,
            __guest_description,
            __boot_option,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "datacenterId" => Ok(__FieldTag::__datacenter_id),
                            "datacenter_id" => Ok(__FieldTag::__datacenter_id),
                            "datacenterDescription" => Ok(__FieldTag::__datacenter_description),
                            "datacenter_description" => Ok(__FieldTag::__datacenter_description),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "diskCount" => Ok(__FieldTag::__disk_count),
                            "disk_count" => Ok(__FieldTag::__disk_count),
                            "committedStorageMb" => Ok(__FieldTag::__committed_storage_mb),
                            "committed_storage_mb" => Ok(__FieldTag::__committed_storage_mb),
                            "guestDescription" => Ok(__FieldTag::__guest_description),
                            "guest_description" => Ok(__FieldTag::__guest_description),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_id => {
                            if !fields.insert(__FieldTag::__datacenter_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_id",
                                ));
                            }
                            result.datacenter_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_description => {
                            if !fields.insert(__FieldTag::__datacenter_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_description",
                                ));
                            }
                            result.datacenter_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state =
                                map.next_value::<std::option::Option<
                                    crate::model::vmware_vm_details::PowerState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_count => {
                            if !fields.insert(__FieldTag::__disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_mb => {
                            if !fields.insert(__FieldTag::__committed_storage_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_mb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__guest_description => {
                            if !fields.insert(__FieldTag::__guest_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_description",
                                ));
                            }
                            result.guest_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option =
                                map.next_value::<std::option::Option<
                                    crate::model::vmware_vm_details::BootOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if !self.datacenter_id.is_empty() {
            state.serialize_entry("datacenterId", &self.datacenter_id)?;
        }
        if !self.datacenter_description.is_empty() {
            state.serialize_entry("datacenterDescription", &self.datacenter_description)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.disk_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if !wkt::internal::is_default(&self.committed_storage_mb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("committedStorageMb", &__With(&self.committed_storage_mb))?;
        }
        if !self.guest_description.is_empty() {
            state.serialize_entry("guestDescription", &self.guest_description)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareVmDetails");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("datacenter_id", &self.datacenter_id);
        debug_struct.field("datacenter_description", &self.datacenter_description);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("disk_count", &self.disk_count);
        debug_struct.field("committed_storage_mb", &self.committed_storage_mb);
        debug_struct.field("guest_description", &self.guest_description);
        debug_struct.field("boot_option", &self.boot_option);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmwareVmDetails].
pub mod vmware_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned ON.
        On,
        /// The VM is turned OFF.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep mode.
        Suspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.PowerState",
            ))
        }
    }

    /// Possible values for vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is EFI.
        Efi,
        /// The boot option is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.BootOption",
            ))
        }
    }
}

/// AwsVmDetails describes a VM in AWS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsVmDetails {
    /// The VM ID in AWS.
    pub vm_id: std::string::String,

    /// The display name of the VM. Note that this value is not necessarily unique.
    pub display_name: std::string::String,

    /// The id of the AWS's source this VM is connected to.
    pub source_id: std::string::String,

    /// The descriptive name of the AWS's source this VM is connected to.
    pub source_description: std::string::String,

    /// Output only. The power state of the VM at the moment list was taken.
    pub power_state: crate::model::aws_vm_details::PowerState,

    /// The number of cpus the VM has.
    pub cpu_count: i32,

    /// The memory size of the VM in MB.
    pub memory_mb: i32,

    /// The number of disks the VM has.
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    pub committed_storage_mb: i64,

    /// The VM's OS.
    pub os_description: std::string::String,

    /// The VM Boot Option.
    pub boot_option: crate::model::aws_vm_details::BootOption,

    /// The instance type of the VM.
    pub instance_type: std::string::String,

    /// The VPC ID the VM belongs to.
    pub vpc_id: std::string::String,

    /// The security groups the VM belongs to.
    pub security_groups: std::vec::Vec<crate::model::AwsSecurityGroup>,

    /// The tags of the VM.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The AWS zone of the VM.
    pub zone: std::string::String,

    /// The virtualization type.
    pub virtualization_type: crate::model::aws_vm_details::VmVirtualizationType,

    /// The CPU architecture.
    pub architecture: crate::model::aws_vm_details::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::AwsVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AwsVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::AwsVmDetails::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source_description][crate::model::AwsVmDetails::source_description].
    pub fn set_source_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_description = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::AwsVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::aws_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::AwsVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::AwsVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::AwsVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::AwsVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [os_description][crate::model::AwsVmDetails::os_description].
    pub fn set_os_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::AwsVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::aws_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::AwsVmDetails::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [vpc_id][crate::model::AwsVmDetails::vpc_id].
    pub fn set_vpc_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_id = v.into();
        self
    }

    /// Sets the value of [security_groups][crate::model::AwsVmDetails::security_groups].
    pub fn set_security_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsSecurityGroup>,
    {
        use std::iter::Iterator;
        self.security_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsVmDetails::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [zone][crate::model::AwsVmDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [virtualization_type][crate::model::AwsVmDetails::virtualization_type].
    pub fn set_virtualization_type<
        T: std::convert::Into<crate::model::aws_vm_details::VmVirtualizationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.virtualization_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AwsVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::aws_vm_details::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for AwsVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_id,
            __display_name,
            __source_id,
            __source_description,
            __power_state,
            __cpu_count,
            __memory_mb,
            __disk_count,
            __committed_storage_mb,
            __os_description,
            __boot_option,
            __instance_type,
            __vpc_id,
            __security_groups,
            __tags,
            __zone,
            __virtualization_type,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "sourceDescription" => Ok(__FieldTag::__source_description),
                            "source_description" => Ok(__FieldTag::__source_description),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "diskCount" => Ok(__FieldTag::__disk_count),
                            "disk_count" => Ok(__FieldTag::__disk_count),
                            "committedStorageMb" => Ok(__FieldTag::__committed_storage_mb),
                            "committed_storage_mb" => Ok(__FieldTag::__committed_storage_mb),
                            "osDescription" => Ok(__FieldTag::__os_description),
                            "os_description" => Ok(__FieldTag::__os_description),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "vpcId" => Ok(__FieldTag::__vpc_id),
                            "vpc_id" => Ok(__FieldTag::__vpc_id),
                            "securityGroups" => Ok(__FieldTag::__security_groups),
                            "security_groups" => Ok(__FieldTag::__security_groups),
                            "tags" => Ok(__FieldTag::__tags),
                            "zone" => Ok(__FieldTag::__zone),
                            "virtualizationType" => Ok(__FieldTag::__virtualization_type),
                            "virtualization_type" => Ok(__FieldTag::__virtualization_type),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_description => {
                            if !fields.insert(__FieldTag::__source_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_description",
                                ));
                            }
                            result.source_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state = map.next_value::<std::option::Option<crate::model::aws_vm_details::PowerState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_count => {
                            if !fields.insert(__FieldTag::__disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_mb => {
                            if !fields.insert(__FieldTag::__committed_storage_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_mb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__os_description => {
                            if !fields.insert(__FieldTag::__os_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_description",
                                ));
                            }
                            result.os_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::aws_vm_details::BootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_id => {
                            if !fields.insert(__FieldTag::__vpc_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_id",
                                ));
                            }
                            result.vpc_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_groups => {
                            if !fields.insert(__FieldTag::__security_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_groups",
                                ));
                            }
                            result.security_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsSecurityGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__virtualization_type => {
                            if !fields.insert(__FieldTag::__virtualization_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtualization_type",
                                ));
                            }
                            result.virtualization_type = map
                                .next_value::<std::option::Option<
                                    crate::model::aws_vm_details::VmVirtualizationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_vm_details::VmArchitecture,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if !self.source_description.is_empty() {
            state.serialize_entry("sourceDescription", &self.source_description)?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.disk_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if !wkt::internal::is_default(&self.committed_storage_mb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("committedStorageMb", &__With(&self.committed_storage_mb))?;
        }
        if !self.os_description.is_empty() {
            state.serialize_entry("osDescription", &self.os_description)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.vpc_id.is_empty() {
            state.serialize_entry("vpcId", &self.vpc_id)?;
        }
        if !self.security_groups.is_empty() {
            state.serialize_entry("securityGroups", &self.security_groups)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.virtualization_type) {
            state.serialize_entry("virtualizationType", &self.virtualization_type)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsVmDetails");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("source_description", &self.source_description);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("disk_count", &self.disk_count);
        debug_struct.field("committed_storage_mb", &self.committed_storage_mb);
        debug_struct.field("os_description", &self.os_description);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("vpc_id", &self.vpc_id);
        debug_struct.field("security_groups", &self.security_groups);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("virtualization_type", &self.virtualization_type);
        debug_struct.field("architecture", &self.architecture);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsVmDetails].
pub mod aws_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned on.
        On,
        /// The VM is turned off.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep
        /// mode.
        Suspended,
        /// The VM is starting.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::Pending => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                4 => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::Pending => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.PowerState",
            ))
        }
    }

    /// The possible values for the vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is UEFI.
        Efi,
        /// The boot option is LEGACY-BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.BootOption",
            ))
        }
    }

    /// Possible values for the virtualization types of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmVirtualizationType {
        /// The virtualization type is unknown.
        Unspecified,
        /// The virtualziation type is HVM.
        Hvm,
        /// The virtualziation type is PARAVIRTUAL.
        Paravirtual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmVirtualizationType::value] or
        /// [VmVirtualizationType::name].
        UnknownValue(vm_virtualization_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_virtualization_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmVirtualizationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hvm => std::option::Option::Some(1),
                Self::Paravirtual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VM_VIRTUALIZATION_TYPE_UNSPECIFIED")
                }
                Self::Hvm => std::option::Option::Some("HVM"),
                Self::Paravirtual => std::option::Option::Some("PARAVIRTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmVirtualizationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmVirtualizationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmVirtualizationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hvm,
                2 => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmVirtualizationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_VIRTUALIZATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HVM" => Self::Hvm,
                "PARAVIRTUAL" => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmVirtualizationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hvm => serializer.serialize_i32(1),
                Self::Paravirtual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmVirtualizationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmVirtualizationType>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmVirtualizationType",
            ))
        }
    }

    /// Possible values for the architectures of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmArchitecture {
        /// The architecture is unknown.
        Unspecified,
        /// The architecture is I386.
        I386,
        /// The architecture is X86_64.
        X8664,
        /// The architecture is ARM64.
        Arm64,
        /// The architecture is X86_64_MAC.
        X8664Mac,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmArchitecture::value] or
        /// [VmArchitecture::name].
        UnknownValue(vm_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::I386 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::Arm64 => std::option::Option::Some(3),
                Self::X8664Mac => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
                Self::I386 => std::option::Option::Some("I386"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664Mac => std::option::Option::Some("X86_64_MAC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::I386,
                2 => Self::X8664,
                3 => Self::Arm64,
                4 => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "I386" => Self::I386,
                "X86_64" => Self::X8664,
                "ARM64" => Self::Arm64,
                "X86_64_MAC" => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::I386 => serializer.serialize_i32(1),
                Self::X8664 => serializer.serialize_i32(2),
                Self::Arm64 => serializer.serialize_i32(3),
                Self::X8664Mac => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmArchitecture",
            ))
        }
    }
}

/// AwsSecurityGroup describes a security group of an AWS VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSecurityGroup {
    /// The AWS security group id.
    pub id: std::string::String,

    /// The AWS security group name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSecurityGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AwsSecurityGroup::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AwsSecurityGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AwsSecurityGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSecurityGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSecurityGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSecurityGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSecurityGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSecurityGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSecurityGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSecurityGroup");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VmwareVmsDetails describes VMs in vCenter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareVmsDetails {
    /// The details of the vmware VMs.
    pub details: std::vec::Vec<crate::model::VmwareVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::VmwareVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmwareVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VmwareVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareVmsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareVmsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareVmsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareVmsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VmwareVmDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareVmsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareVmsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareVmsDetails");
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AWSVmsDetails describes VMs in AWS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsVmsDetails {
    /// The details of the AWS VMs.
    pub details: std::vec::Vec<crate::model::AwsVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::AwsVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsVmsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsVmsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsVmsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsVmsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AwsVmDetails>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsVmsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsVmsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsVmsDetails");
        debug_struct.field("details", &self.details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchInventoryResponse {
    /// Output only. The timestamp when the source was last queried (if the result
    /// is from the cache).
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub source_vms: std::option::Option<crate::model::fetch_inventory_response::SourceVms>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms].
    ///
    /// Note that all the setters affecting `source_vms` are mutually
    /// exclusive.
    pub fn set_source_vms<
        T: std::convert::Into<std::option::Option<crate::model::fetch_inventory_response::SourceVms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = v.into();
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `VmwareVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `VmwareVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_vmware_vms<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmsDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v.into()),
        );
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `AwsVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_vms(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `AwsVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_aws_vms<T: std::convert::Into<std::boxed::Box<crate::model::AwsVmsDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FetchInventoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchInventoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware_vms,
            __aws_vms,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchInventoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmwareVms" => Ok(__FieldTag::__vmware_vms),
                            "vmware_vms" => Ok(__FieldTag::__vmware_vms),
                            "awsVms" => Ok(__FieldTag::__aws_vms),
                            "aws_vms" => Ok(__FieldTag::__aws_vms),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchInventoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchInventoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware_vms => {
                            if !fields.insert(__FieldTag::__vmware_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_vms",
                                ));
                            }
                            if result.source_vms.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vms`, a oneof with full ID .google.cloud.vmmigration.v1.FetchInventoryResponse.vmware_vms, latest field was vmwareVms",
                                ));
                            }
                            result.source_vms = std::option::Option::Some(
                                crate::model::fetch_inventory_response::SourceVms::VmwareVms(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareVmsDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_vms => {
                            if !fields.insert(__FieldTag::__aws_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_vms",
                                ));
                            }
                            if result.source_vms.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vms`, a oneof with full ID .google.cloud.vmmigration.v1.FetchInventoryResponse.aws_vms, latest field was awsVms",
                                ));
                            }
                            result.source_vms = std::option::Option::Some(
                                crate::model::fetch_inventory_response::SourceVms::AwsVms(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsVmsDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchInventoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware_vms() {
            state.serialize_entry("vmwareVms", value)?;
        }
        if let Some(value) = self.aws_vms() {
            state.serialize_entry("awsVms", value)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchInventoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchInventoryResponse");
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("source_vms", &self.source_vms);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FetchInventoryResponse].
pub mod fetch_inventory_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceVms {
        /// The description of the VMs in a Source of type Vmware.
        VmwareVms(std::boxed::Box<crate::model::VmwareVmsDetails>),
        /// The description of the VMs in a Source of type AWS.
        AwsVms(std::boxed::Box<crate::model::AwsVmsDetails>),
    }
}

/// Utilization report details the utilization (CPU, memory, etc.) of selected
/// source VMs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UtilizationReport {
    /// Output only. The report unique name.
    pub name: std::string::String,

    /// The report display name, as assigned by the user.
    pub display_name: std::string::String,

    /// Output only. Current state of the report.
    pub state: crate::model::utilization_report::State,

    /// Output only. The time the state was last set.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the report in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The time the report was created (this refers to the time of
    /// the request, not the time the report creation completed).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time frame of the report.
    pub time_frame: crate::model::utilization_report::TimeFrame,

    /// Output only. The point in time when the time frame ends. Notice that the
    /// time frame is counted backwards. For instance if the "frame_end_time" value
    /// is 2021/01/20 and the time frame is WEEK then the report covers the week
    /// between 2021/01/20 and 2021/01/14.
    pub frame_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Total number of VMs included in the report.
    pub vm_count: i32,

    /// List of utilization information per VM.
    /// When sent as part of the request, the "vm_id" field is used in order to
    /// specify which VMs to include in the report. In that case all other fields
    /// are ignored.
    pub vms: std::vec::Vec<crate::model::VmUtilizationInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UtilizationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UtilizationReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::UtilizationReport::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UtilizationReport::state].
    pub fn set_state<T: std::convert::Into<crate::model::utilization_report::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::UtilizationReport::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UtilizationReport::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_frame][crate::model::UtilizationReport::time_frame].
    pub fn set_time_frame<T: std::convert::Into<crate::model::utilization_report::TimeFrame>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_frame = v.into();
        self
    }

    /// Sets the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_frame_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_or_clear_frame_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_count][crate::model::UtilizationReport::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [vms][crate::model::UtilizationReport::vms].
    pub fn set_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmUtilizationInfo>,
    {
        use std::iter::Iterator;
        self.vms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UtilizationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UtilizationReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UtilizationReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __state_time,
            __error,
            __create_time,
            __time_frame,
            __frame_end_time,
            __vm_count,
            __vms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UtilizationReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "timeFrame" => Ok(__FieldTag::__time_frame),
                            "time_frame" => Ok(__FieldTag::__time_frame),
                            "frameEndTime" => Ok(__FieldTag::__frame_end_time),
                            "frame_end_time" => Ok(__FieldTag::__frame_end_time),
                            "vmCount" => Ok(__FieldTag::__vm_count),
                            "vm_count" => Ok(__FieldTag::__vm_count),
                            "vms" => Ok(__FieldTag::__vms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UtilizationReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UtilizationReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::utilization_report::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__time_frame => {
                            if !fields.insert(__FieldTag::__time_frame) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_frame",
                                ));
                            }
                            result.time_frame =
                                map.next_value::<std::option::Option<
                                    crate::model::utilization_report::TimeFrame,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frame_end_time => {
                            if !fields.insert(__FieldTag::__frame_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frame_end_time",
                                ));
                            }
                            result.frame_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__vm_count => {
                            if !fields.insert(__FieldTag::__vm_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vms => {
                            if !fields.insert(__FieldTag::__vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vms",
                                ));
                            }
                            result.vms =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VmUtilizationInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UtilizationReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.time_frame) {
            state.serialize_entry("timeFrame", &self.time_frame)?;
        }
        if self.frame_end_time.is_some() {
            state.serialize_entry("frameEndTime", &self.frame_end_time)?;
        }
        if !wkt::internal::is_default(&self.vm_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vmCount", &__With(&self.vm_count))?;
        }
        if !self.vms.is_empty() {
            state.serialize_entry("vms", &self.vms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UtilizationReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UtilizationReport");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("time_frame", &self.time_frame);
        debug_struct.field("frame_end_time", &self.frame_end_time);
        debug_struct.field("vm_count", &self.vm_count);
        debug_struct.field("vms", &self.vms);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UtilizationReport].
pub mod utilization_report {
    #[allow(unused_imports)]
    use super::*;

    /// Utilization report state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This value is not in use.
        Unspecified,
        /// The report is in the making.
        Creating,
        /// Report creation completed successfully.
        Succeeded,
        /// Report creation failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.State",
            ))
        }
    }

    /// Report time frame options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeFrame {
        /// The time frame was not specified and will default to WEEK.
        Unspecified,
        /// One week.
        Week,
        /// One month.
        Month,
        /// One year.
        Year,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeFrame::value] or
        /// [TimeFrame::name].
        UnknownValue(time_frame::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_frame {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeFrame {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Week => std::option::Option::Some(1),
                Self::Month => std::option::Option::Some(2),
                Self::Year => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_FRAME_UNSPECIFIED"),
                Self::Week => std::option::Option::Some("WEEK"),
                Self::Month => std::option::Option::Some("MONTH"),
                Self::Year => std::option::Option::Some("YEAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeFrame {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeFrame {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeFrame {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Week,
                2 => Self::Month,
                3 => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeFrame {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_FRAME_UNSPECIFIED" => Self::Unspecified,
                "WEEK" => Self::Week,
                "MONTH" => Self::Month,
                "YEAR" => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeFrame {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Week => serializer.serialize_i32(1),
                Self::Month => serializer.serialize_i32(2),
                Self::Year => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeFrame {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeFrame>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.TimeFrame",
            ))
        }
    }
}

/// Utilization information of a single VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmUtilizationInfo {
    /// The VM's ID in the source.
    pub vm_id: std::string::String,

    /// Utilization metrics for this VM.
    pub utilization: std::option::Option<crate::model::VmUtilizationMetrics>,

    pub vm_details: std::option::Option<crate::model::vm_utilization_info::VmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmUtilizationInfo::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_or_clear_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details].
    ///
    /// Note that all the setters affecting `vm_details` are mutually
    /// exclusive.
    pub fn set_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::vm_utilization_info::VmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = v.into();
        self
    }

    /// The value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// if it holds a `VmwareVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmDetails>> {
        #[allow(unreachable_patterns)]
        self.vm_details.as_ref().and_then(|v| match v {
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// to hold a `VmwareVmDetails`.
    ///
    /// Note that all the setters affecting `vm_details` are
    /// mutually exclusive.
    pub fn set_vmware_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = std::option::Option::Some(
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VmUtilizationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmUtilizationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware_vm_details,
            __vm_id,
            __utilization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmUtilizationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmwareVmDetails" => Ok(__FieldTag::__vmware_vm_details),
                            "vmware_vm_details" => Ok(__FieldTag::__vmware_vm_details),
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "utilization" => Ok(__FieldTag::__utilization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmUtilizationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmUtilizationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware_vm_details => {
                            if !fields.insert(__FieldTag::__vmware_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_vm_details",
                                ));
                            }
                            if result.vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.VmUtilizationInfo.vmware_vm_details, latest field was vmwareVmDetails",
                                ));
                            }
                            result.vm_details = std::option::Option::Some(
                                crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization => {
                            if !fields.insert(__FieldTag::__utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization",
                                ));
                            }
                            result.utilization = map.next_value::<std::option::Option<crate::model::VmUtilizationMetrics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmUtilizationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware_vm_details() {
            state.serialize_entry("vmwareVmDetails", value)?;
        }
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if self.utilization.is_some() {
            state.serialize_entry("utilization", &self.utilization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmUtilizationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmUtilizationInfo");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("utilization", &self.utilization);
        debug_struct.field("vm_details", &self.vm_details);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmUtilizationInfo].
pub mod vm_utilization_info {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmDetails {
        /// The description of the VM in a Source of type Vmware.
        VmwareVmDetails(std::boxed::Box<crate::model::VmwareVmDetails>),
    }
}

/// Utilization metrics values for a single VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmUtilizationMetrics {
    /// Max CPU usage, percent.
    pub cpu_max_percent: i32,

    /// Average CPU usage, percent.
    pub cpu_average_percent: i32,

    /// Max memory usage, percent.
    pub memory_max_percent: i32,

    /// Average memory usage, percent.
    pub memory_average_percent: i32,

    /// Max disk IO rate, in kilobytes per second.
    pub disk_io_rate_max_kbps: i64,

    /// Average disk IO rate, in kilobytes per second.
    pub disk_io_rate_average_kbps: i64,

    /// Max network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    pub network_throughput_max_kbps: i64,

    /// Average network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    pub network_throughput_average_kbps: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_max_percent][crate::model::VmUtilizationMetrics::cpu_max_percent].
    pub fn set_cpu_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_max_percent = v.into();
        self
    }

    /// Sets the value of [cpu_average_percent][crate::model::VmUtilizationMetrics::cpu_average_percent].
    pub fn set_cpu_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_average_percent = v.into();
        self
    }

    /// Sets the value of [memory_max_percent][crate::model::VmUtilizationMetrics::memory_max_percent].
    pub fn set_memory_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_max_percent = v.into();
        self
    }

    /// Sets the value of [memory_average_percent][crate::model::VmUtilizationMetrics::memory_average_percent].
    pub fn set_memory_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_average_percent = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_max_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_max_kbps].
    pub fn set_disk_io_rate_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_max_kbps = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_average_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_average_kbps].
    pub fn set_disk_io_rate_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_average_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_max_kbps][crate::model::VmUtilizationMetrics::network_throughput_max_kbps].
    pub fn set_network_throughput_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_max_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_average_kbps][crate::model::VmUtilizationMetrics::network_throughput_average_kbps].
    pub fn set_network_throughput_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_average_kbps = v.into();
        self
    }
}

impl wkt::message::Message for VmUtilizationMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmUtilizationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_max_percent,
            __cpu_average_percent,
            __memory_max_percent,
            __memory_average_percent,
            __disk_io_rate_max_kbps,
            __disk_io_rate_average_kbps,
            __network_throughput_max_kbps,
            __network_throughput_average_kbps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmUtilizationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuMaxPercent" => Ok(__FieldTag::__cpu_max_percent),
                            "cpu_max_percent" => Ok(__FieldTag::__cpu_max_percent),
                            "cpuAveragePercent" => Ok(__FieldTag::__cpu_average_percent),
                            "cpu_average_percent" => Ok(__FieldTag::__cpu_average_percent),
                            "memoryMaxPercent" => Ok(__FieldTag::__memory_max_percent),
                            "memory_max_percent" => Ok(__FieldTag::__memory_max_percent),
                            "memoryAveragePercent" => Ok(__FieldTag::__memory_average_percent),
                            "memory_average_percent" => Ok(__FieldTag::__memory_average_percent),
                            "diskIoRateMaxKbps" => Ok(__FieldTag::__disk_io_rate_max_kbps),
                            "disk_io_rate_max_kbps" => Ok(__FieldTag::__disk_io_rate_max_kbps),
                            "diskIoRateAverageKbps" => Ok(__FieldTag::__disk_io_rate_average_kbps),
                            "disk_io_rate_average_kbps" => {
                                Ok(__FieldTag::__disk_io_rate_average_kbps)
                            }
                            "networkThroughputMaxKbps" => {
                                Ok(__FieldTag::__network_throughput_max_kbps)
                            }
                            "network_throughput_max_kbps" => {
                                Ok(__FieldTag::__network_throughput_max_kbps)
                            }
                            "networkThroughputAverageKbps" => {
                                Ok(__FieldTag::__network_throughput_average_kbps)
                            }
                            "network_throughput_average_kbps" => {
                                Ok(__FieldTag::__network_throughput_average_kbps)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmUtilizationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmUtilizationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_max_percent => {
                            if !fields.insert(__FieldTag::__cpu_max_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_max_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_max_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cpu_average_percent => {
                            if !fields.insert(__FieldTag::__cpu_average_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_average_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_average_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_max_percent => {
                            if !fields.insert(__FieldTag::__memory_max_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_max_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_max_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_average_percent => {
                            if !fields.insert(__FieldTag::__memory_average_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_average_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_average_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_io_rate_max_kbps => {
                            if !fields.insert(__FieldTag::__disk_io_rate_max_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_io_rate_max_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_io_rate_max_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_io_rate_average_kbps => {
                            if !fields.insert(__FieldTag::__disk_io_rate_average_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_io_rate_average_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_io_rate_average_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_throughput_max_kbps => {
                            if !fields.insert(__FieldTag::__network_throughput_max_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_throughput_max_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.network_throughput_max_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_throughput_average_kbps => {
                            if !fields.insert(__FieldTag::__network_throughput_average_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_throughput_average_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.network_throughput_average_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmUtilizationMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu_max_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuMaxPercent", &__With(&self.cpu_max_percent))?;
        }
        if !wkt::internal::is_default(&self.cpu_average_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuAveragePercent", &__With(&self.cpu_average_percent))?;
        }
        if !wkt::internal::is_default(&self.memory_max_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMaxPercent", &__With(&self.memory_max_percent))?;
        }
        if !wkt::internal::is_default(&self.memory_average_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "memoryAveragePercent",
                &__With(&self.memory_average_percent),
            )?;
        }
        if !wkt::internal::is_default(&self.disk_io_rate_max_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskIoRateMaxKbps", &__With(&self.disk_io_rate_max_kbps))?;
        }
        if !wkt::internal::is_default(&self.disk_io_rate_average_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "diskIoRateAverageKbps",
                &__With(&self.disk_io_rate_average_kbps),
            )?;
        }
        if !wkt::internal::is_default(&self.network_throughput_max_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "networkThroughputMaxKbps",
                &__With(&self.network_throughput_max_kbps),
            )?;
        }
        if !wkt::internal::is_default(&self.network_throughput_average_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "networkThroughputAverageKbps",
                &__With(&self.network_throughput_average_kbps),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmUtilizationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmUtilizationMetrics");
        debug_struct.field("cpu_max_percent", &self.cpu_max_percent);
        debug_struct.field("cpu_average_percent", &self.cpu_average_percent);
        debug_struct.field("memory_max_percent", &self.memory_max_percent);
        debug_struct.field("memory_average_percent", &self.memory_average_percent);
        debug_struct.field("disk_io_rate_max_kbps", &self.disk_io_rate_max_kbps);
        debug_struct.field("disk_io_rate_average_kbps", &self.disk_io_rate_average_kbps);
        debug_struct.field(
            "network_throughput_max_kbps",
            &self.network_throughput_max_kbps,
        );
        debug_struct.field(
            "network_throughput_average_kbps",
            &self.network_throughput_average_kbps,
        );

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListUtilizationReports' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUtilizationReportsRequest {
    /// Required. The Utilization Reports parent.
    pub parent: std::string::String,

    /// Optional. The level of details of each report.
    /// Defaults to BASIC.
    pub view: crate::model::UtilizationReportView,

    /// Optional. The maximum number of reports to return. The service may return
    /// fewer than this value. If unspecified, at most 500 reports will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListUtilizationReports`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListUtilizationReports`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUtilizationReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListUtilizationReportsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUtilizationReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUtilizationReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUtilizationReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUtilizationReportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUtilizationReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUtilizationReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUtilizationReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUtilizationReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::UtilizationReportView>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUtilizationReportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUtilizationReportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUtilizationReportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListUtilizationReports' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUtilizationReportsResponse {
    /// Output only. The list of reports.
    pub utilization_reports: std::vec::Vec<crate::model::UtilizationReport>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilization_reports][crate::model::ListUtilizationReportsResponse::utilization_reports].
    pub fn set_utilization_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UtilizationReport>,
    {
        use std::iter::Iterator;
        self.utilization_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUtilizationReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUtilizationReportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUtilizationReportsResponse {
    type PageItem = crate::model::UtilizationReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.utilization_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUtilizationReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __utilization_reports,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUtilizationReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "utilizationReports" => Ok(__FieldTag::__utilization_reports),
                            "utilization_reports" => Ok(__FieldTag::__utilization_reports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUtilizationReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUtilizationReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__utilization_reports => {
                            if !fields.insert(__FieldTag::__utilization_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_reports",
                                ));
                            }
                            result.utilization_reports =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UtilizationReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUtilizationReportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.utilization_reports.is_empty() {
            state.serialize_entry("utilizationReports", &self.utilization_reports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUtilizationReportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUtilizationReportsResponse");
        debug_struct.field("utilization_reports", &self.utilization_reports);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUtilizationReportRequest {
    /// Required. The Utilization Report name.
    pub name: std::string::String,

    /// Optional. The level of details of the report.
    /// Defaults to FULL
    pub view: crate::model::UtilizationReportView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetUtilizationReportRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::UtilizationReportView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUtilizationReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUtilizationReportRequest {
    /// Required. The Utilization Report's parent.
    pub parent: std::string::String,

    /// Required. The report to create.
    pub utilization_report: std::option::Option<crate::model::UtilizationReport>,

    /// Required. The ID to use for the report, which will become the final
    /// component of the reports's resource name.
    ///
    /// This value maximum length is 63 characters, and valid characters
    /// are /[a-z][0-9]-/. It must start with an english letter and must not
    /// end with a hyphen.
    pub utilization_report_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUtilizationReportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_utilization_report<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_or_clear_utilization_report<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = v.map(|x| x.into());
        self
    }

    /// Sets the value of [utilization_report_id][crate::model::CreateUtilizationReportRequest::utilization_report_id].
    pub fn set_utilization_report_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.utilization_report_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __utilization_report,
            __utilization_report_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "utilizationReport" => Ok(__FieldTag::__utilization_report),
                            "utilization_report" => Ok(__FieldTag::__utilization_report),
                            "utilizationReportId" => Ok(__FieldTag::__utilization_report_id),
                            "utilization_report_id" => Ok(__FieldTag::__utilization_report_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization_report => {
                            if !fields.insert(__FieldTag::__utilization_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_report",
                                ));
                            }
                            result.utilization_report = map
                                .next_value::<std::option::Option<crate::model::UtilizationReport>>(
                                )?;
                        }
                        __FieldTag::__utilization_report_id => {
                            if !fields.insert(__FieldTag::__utilization_report_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_report_id",
                                ));
                            }
                            result.utilization_report_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.utilization_report.is_some() {
            state.serialize_entry("utilizationReport", &self.utilization_report)?;
        }
        if !self.utilization_report_id.is_empty() {
            state.serialize_entry("utilizationReportId", &self.utilization_report_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUtilizationReportRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("utilization_report", &self.utilization_report);
        debug_struct.field("utilization_report_id", &self.utilization_report_id);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUtilizationReportRequest {
    /// Required. The Utilization Report name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUtilizationReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListDatacenterConnectors' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatacenterConnectorsResponse {
    /// Output only. The list of sources response.
    pub datacenter_connectors: std::vec::Vec<crate::model::DatacenterConnector>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connectors][crate::model::ListDatacenterConnectorsResponse::datacenter_connectors].
    pub fn set_datacenter_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatacenterConnector>,
    {
        use std::iter::Iterator;
        self.datacenter_connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatacenterConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatacenterConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatacenterConnectorsResponse {
    type PageItem = crate::model::DatacenterConnector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datacenter_connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatacenterConnectorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datacenter_connectors,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatacenterConnectorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datacenterConnectors" => Ok(__FieldTag::__datacenter_connectors),
                            "datacenter_connectors" => Ok(__FieldTag::__datacenter_connectors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatacenterConnectorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatacenterConnectorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datacenter_connectors => {
                            if !fields.insert(__FieldTag::__datacenter_connectors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connectors",
                                ));
                            }
                            result.datacenter_connectors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatacenterConnector>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatacenterConnectorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datacenter_connectors.is_empty() {
            state.serialize_entry("datacenterConnectors", &self.datacenter_connectors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDatacenterConnectorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDatacenterConnectorsResponse");
        debug_struct.field("datacenter_connectors", &self.datacenter_connectors);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatacenterConnectorRequest {
    /// Required. The name of the DatacenterConnector.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDatacenterConnectorRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatacenterConnectorRequest {
    /// Required. The DatacenterConnector's parent.
    /// Required. The Source in where the new DatacenterConnector will be created.
    /// For example:
    /// `projects/my-project/locations/us-central1/sources/my-source`
    pub parent: std::string::String,

    /// Required. The datacenterConnector identifier.
    pub datacenter_connector_id: std::string::String,

    /// Required. The create request body.
    pub datacenter_connector: std::option::Option<crate::model::DatacenterConnector>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatacenterConnectorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [datacenter_connector_id][crate::model::CreateDatacenterConnectorRequest::datacenter_connector_id].
    pub fn set_datacenter_connector_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector_id = v.into();
        self
    }

    /// Sets the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_datacenter_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_or_clear_datacenter_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __datacenter_connector_id,
            __datacenter_connector,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "datacenterConnectorId" => Ok(__FieldTag::__datacenter_connector_id),
                            "datacenter_connector_id" => Ok(__FieldTag::__datacenter_connector_id),
                            "datacenterConnector" => Ok(__FieldTag::__datacenter_connector),
                            "datacenter_connector" => Ok(__FieldTag::__datacenter_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_connector_id => {
                            if !fields.insert(__FieldTag::__datacenter_connector_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector_id",
                                ));
                            }
                            result.datacenter_connector_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_connector => {
                            if !fields.insert(__FieldTag::__datacenter_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector",
                                ));
                            }
                            result.datacenter_connector = map.next_value::<std::option::Option<crate::model::DatacenterConnector>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.datacenter_connector_id.is_empty() {
            state.serialize_entry("datacenterConnectorId", &self.datacenter_connector_id)?;
        }
        if self.datacenter_connector.is_some() {
            state.serialize_entry("datacenterConnector", &self.datacenter_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDatacenterConnectorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("datacenter_connector_id", &self.datacenter_connector_id);
        debug_struct.field("datacenter_connector", &self.datacenter_connector);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatacenterConnectorRequest {
    /// Required. The DatacenterConnector name.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDatacenterConnectorRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpgradeAppliance' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeApplianceRequest {
    /// Required. The DatacenterConnector name.
    pub datacenter_connector: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connector][crate::model::UpgradeApplianceRequest::datacenter_connector].
    pub fn set_datacenter_connector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeApplianceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeApplianceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeApplianceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datacenter_connector,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeApplianceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datacenterConnector" => Ok(__FieldTag::__datacenter_connector),
                            "datacenter_connector" => Ok(__FieldTag::__datacenter_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeApplianceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeApplianceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datacenter_connector => {
                            if !fields.insert(__FieldTag::__datacenter_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector",
                                ));
                            }
                            result.datacenter_connector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeApplianceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datacenter_connector.is_empty() {
            state.serialize_entry("datacenterConnector", &self.datacenter_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeApplianceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeApplianceRequest");
        debug_struct.field("datacenter_connector", &self.datacenter_connector);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'UpgradeAppliance' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeApplianceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpgradeApplianceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeApplianceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeApplianceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeApplianceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeApplianceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeApplianceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeApplianceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeApplianceResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListDatacenterConnectors' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatacenterConnectorsRequest {
    /// Required. The parent, which owns this collection of connectors.
    pub parent: std::string::String,

    /// Optional. The maximum number of connectors to return. The service may
    /// return fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListDatacenterConnectors`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDatacenterConnectors` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatacenterConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatacenterConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatacenterConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatacenterConnectorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatacenterConnectorsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatacenterConnectorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatacenterConnectorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatacenterConnectorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatacenterConnectorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatacenterConnectorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDatacenterConnectorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDatacenterConnectorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineTargetDefaults {
    /// The name of the VM to create.
    pub vm_name: std::string::String,

    /// The full path of the resource of type TargetProject which represents the
    /// Compute Engine project in which to create this VM.
    pub target_project: std::string::String,

    /// The zone in which to create the VM.
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    pub machine_type: std::string::String,

    /// A map of network tags to associate with the VM.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// The service account to associate the VM with.
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// Output only. The OS license returned from the adaptation module report.
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    pub secure_boot: bool,

    /// Output only. The VM Boot Option, as set in the source vm.
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    pub hostname: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDefaults::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::ComputeEngineTargetDefaults::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDefaults::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDefaults::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDefaults::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDefaults::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDefaults::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDefaults::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDefaults::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDefaults::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDefaults::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDefaults::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDefaults::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDefaults::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineTargetDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_name,
            __target_project,
            __zone,
            __machine_type_series,
            __machine_type,
            __network_tags,
            __network_interfaces,
            __service_account,
            __disk_type,
            __labels,
            __license_type,
            __applied_license,
            __compute_scheduling,
            __secure_boot,
            __boot_option,
            __metadata,
            __additional_licenses,
            __hostname,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineTargetDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "zone" => Ok(__FieldTag::__zone),
                            "machineTypeSeries" => Ok(__FieldTag::__machine_type_series),
                            "machine_type_series" => Ok(__FieldTag::__machine_type_series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "appliedLicense" => Ok(__FieldTag::__applied_license),
                            "applied_license" => Ok(__FieldTag::__applied_license),
                            "computeScheduling" => Ok(__FieldTag::__compute_scheduling),
                            "compute_scheduling" => Ok(__FieldTag::__compute_scheduling),
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "hostname" => Ok(__FieldTag::__hostname),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineTargetDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineTargetDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_series => {
                            if !fields.insert(__FieldTag::__machine_type_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_series",
                                ));
                            }
                            result.machine_type_series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map.next_value::<std::option::Option<crate::model::ComputeEngineLicenseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__applied_license => {
                            if !fields.insert(__FieldTag::__applied_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_license",
                                ));
                            }
                            result.applied_license = map
                                .next_value::<std::option::Option<crate::model::AppliedLicense>>(
                                )?;
                        }
                        __FieldTag::__compute_scheduling => {
                            if !fields.insert(__FieldTag::__compute_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_scheduling",
                                ));
                            }
                            result.compute_scheduling = map
                                .next_value::<std::option::Option<crate::model::ComputeScheduling>>(
                                )?;
                        }
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::ComputeEngineBootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineTargetDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.machine_type_series.is_empty() {
            state.serialize_entry("machineTypeSeries", &self.machine_type_series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if self.applied_license.is_some() {
            state.serialize_entry("appliedLicense", &self.applied_license)?;
        }
        if self.compute_scheduling.is_some() {
            state.serialize_entry("computeScheduling", &self.compute_scheduling)?;
        }
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineTargetDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineTargetDefaults");
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("machine_type_series", &self.machine_type_series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("applied_license", &self.applied_license);
        debug_struct.field("compute_scheduling", &self.compute_scheduling);
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("hostname", &self.hostname);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ComputeEngineTargetDetails is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineTargetDetails {
    /// The name of the VM to create.
    pub vm_name: std::string::String,

    /// The Google Cloud target project ID or project name.
    pub project: std::string::String,

    /// The zone in which to create the VM.
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    pub machine_type: std::string::String,

    /// A map of network tags to associate with the VM.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// The service account to associate the VM with.
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// The OS license returned from the adaptation module report.
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the vm boot option is EFI.
    pub secure_boot: bool,

    /// The VM Boot Option, as set in the source vm.
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    pub hostname: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDetails::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::ComputeEngineTargetDetails::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDetails::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDetails::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDetails::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDetails::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDetails::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDetails::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDetails::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDetails::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDetails::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDetails::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDetails::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_name,
            __project,
            __zone,
            __machine_type_series,
            __machine_type,
            __network_tags,
            __network_interfaces,
            __service_account,
            __disk_type,
            __labels,
            __license_type,
            __applied_license,
            __compute_scheduling,
            __secure_boot,
            __boot_option,
            __metadata,
            __additional_licenses,
            __hostname,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "project" => Ok(__FieldTag::__project),
                            "zone" => Ok(__FieldTag::__zone),
                            "machineTypeSeries" => Ok(__FieldTag::__machine_type_series),
                            "machine_type_series" => Ok(__FieldTag::__machine_type_series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "appliedLicense" => Ok(__FieldTag::__applied_license),
                            "applied_license" => Ok(__FieldTag::__applied_license),
                            "computeScheduling" => Ok(__FieldTag::__compute_scheduling),
                            "compute_scheduling" => Ok(__FieldTag::__compute_scheduling),
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "hostname" => Ok(__FieldTag::__hostname),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_series => {
                            if !fields.insert(__FieldTag::__machine_type_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_series",
                                ));
                            }
                            result.machine_type_series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map.next_value::<std::option::Option<crate::model::ComputeEngineLicenseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__applied_license => {
                            if !fields.insert(__FieldTag::__applied_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_license",
                                ));
                            }
                            result.applied_license = map
                                .next_value::<std::option::Option<crate::model::AppliedLicense>>(
                                )?;
                        }
                        __FieldTag::__compute_scheduling => {
                            if !fields.insert(__FieldTag::__compute_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_scheduling",
                                ));
                            }
                            result.compute_scheduling = map
                                .next_value::<std::option::Option<crate::model::ComputeScheduling>>(
                                )?;
                        }
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::ComputeEngineBootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.machine_type_series.is_empty() {
            state.serialize_entry("machineTypeSeries", &self.machine_type_series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if self.applied_license.is_some() {
            state.serialize_entry("appliedLicense", &self.applied_license)?;
        }
        if self.compute_scheduling.is_some() {
            state.serialize_entry("computeScheduling", &self.compute_scheduling)?;
        }
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineTargetDetails");
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("project", &self.project);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("machine_type_series", &self.machine_type_series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("applied_license", &self.applied_license);
        debug_struct.field("compute_scheduling", &self.compute_scheduling);
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("hostname", &self.hostname);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NetworkInterface represents a NIC of a VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// The network to connect the NIC to.
    pub network: std::string::String,

    /// The subnetwork to connect the NIC to.
    pub subnetwork: std::string::String,

    /// The internal IP to define in the NIC.
    /// The formats accepted are: `ephemeral` \ ipv4 address \ a named address
    /// resource full path.
    pub internal_ip: std::string::String,

    /// The external IP to define in the NIC.
    pub external_ip: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::NetworkInterface::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::NetworkInterface::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.NetworkInterface"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkInterface {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            __internal_ip,
            __external_ip,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInterface")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterface;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInterface")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkInterface");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("external_ip", &self.external_ip);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AppliedLicense holds the license data returned by adaptation module report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppliedLicense {
    /// The license type that was used in OS adaptation.
    pub r#type: crate::model::applied_license::Type,

    /// The OS license returned from the adaptation module's report.
    pub os_license: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppliedLicense {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AppliedLicense::type].
    pub fn set_type<T: std::convert::Into<crate::model::applied_license::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [os_license][crate::model::AppliedLicense::os_license].
    pub fn set_os_license<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_license = v.into();
        self
    }
}

impl wkt::message::Message for AppliedLicense {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AppliedLicense"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppliedLicense {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __os_license,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppliedLicense")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "osLicense" => Ok(__FieldTag::__os_license),
                            "os_license" => Ok(__FieldTag::__os_license),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppliedLicense;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppliedLicense")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::applied_license::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__os_license => {
                            if !fields.insert(__FieldTag::__os_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_license",
                                ));
                            }
                            result.os_license = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppliedLicense {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.os_license.is_empty() {
            state.serialize_entry("osLicense", &self.os_license)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AppliedLicense {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppliedLicense");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("os_license", &self.os_license);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AppliedLicense].
pub mod applied_license {
    #[allow(unused_imports)]
    use super::*;

    /// License types used in OS adaptation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified license for the OS.
        Unspecified,
        /// No license available for the OS.
        None,
        /// The license type is Pay As You Go license type.
        Payg,
        /// The license type is Bring Your Own License type.
        Byol,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Payg => std::option::Option::Some(2),
                Self::Byol => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Payg => std::option::Option::Some("PAYG"),
                Self::Byol => std::option::Option::Some("BYOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Payg,
                3 => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PAYG" => Self::Payg,
                "BYOL" => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Payg => serializer.serialize_i32(2),
                Self::Byol => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmmigration.v1.AppliedLicense.Type",
            ))
        }
    }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled. Based on
/// <https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingNodeAffinity {
    /// The label key of Node resource to reference.
    pub key: std::string::String,

    /// The operator to use for the node resources specified in the `values`
    /// parameter.
    pub operator: crate::model::scheduling_node_affinity::Operator,

    /// Corresponds to the label values of Node resource.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulingNodeAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_operator<T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>>(
        mut self,
        v: T,
    ) -> Self {
        self.operator = v.into();
        self
    }

    /// Sets the value of [values][crate::model::SchedulingNodeAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchedulingNodeAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulingNodeAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchedulingNodeAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __operator,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchedulingNodeAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "operator" => Ok(__FieldTag::__operator),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchedulingNodeAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchedulingNodeAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operator => {
                            if !fields.insert(__FieldTag::__operator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operator",
                                ));
                            }
                            result.operator = map
                                .next_value::<std::option::Option<
                                    crate::model::scheduling_node_affinity::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchedulingNodeAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !wkt::internal::is_default(&self.operator) {
            state.serialize_entry("operator", &self.operator)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchedulingNodeAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulingNodeAffinity");
        debug_struct.field("key", &self.key);
        debug_struct.field("operator", &self.operator);
        debug_struct.field("values", &self.values);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SchedulingNodeAffinity].
pub mod scheduling_node_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of node selection operators. Valid operators are IN for
    /// affinity and NOT_IN for anti-affinity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operator {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// The node resource group should be in these resources affinity.
        In,
        /// The node resource group should not be in these resources affinity.
        NotIn,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operator::value] or
        /// [Operator::name].
        UnknownValue(operator::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::In => std::option::Option::Some(1),
                Self::NotIn => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                Self::In => std::option::Option::Some("IN"),
                Self::NotIn => std::option::Option::Some("NOT_IN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::In,
                2 => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                "IN" => Self::In,
                "NOT_IN" => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::In => serializer.serialize_i32(1),
                Self::NotIn => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                ".google.cloud.vmmigration.v1.SchedulingNodeAffinity.Operator",
            ))
        }
    }
}

/// Scheduling information for VM on maintenance/restart behaviour and
/// node allocation in sole tenant nodes.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeScheduling {
    /// How the instance should behave when the host machine undergoes
    /// maintenance that may temporarily impact instance performance.
    pub on_host_maintenance: crate::model::compute_scheduling::OnHostMaintenance,

    /// Whether the Instance should be automatically restarted whenever it is
    /// terminated by Compute Engine (not terminated by user).
    /// This configuration is identical to `automaticRestart` field in Compute
    /// Engine create instance under scheduling.
    /// It was changed to an enum (instead of a boolean) to match the default
    /// value in Compute Engine which is automatic restart.
    pub restart_type: crate::model::compute_scheduling::RestartType,

    /// A set of node affinity and anti-affinity configurations for sole tenant
    /// nodes.
    pub node_affinities: std::vec::Vec<crate::model::SchedulingNodeAffinity>,

    /// The minimum number of virtual CPUs this instance will consume when
    /// running on a sole-tenant node. Ignored if no node_affinites are
    /// configured.
    pub min_node_cpus: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [on_host_maintenance][crate::model::ComputeScheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<
        T: std::convert::Into<crate::model::compute_scheduling::OnHostMaintenance>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.on_host_maintenance = v.into();
        self
    }

    /// Sets the value of [restart_type][crate::model::ComputeScheduling::restart_type].
    pub fn set_restart_type<
        T: std::convert::Into<crate::model::compute_scheduling::RestartType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restart_type = v.into();
        self
    }

    /// Sets the value of [node_affinities][crate::model::ComputeScheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchedulingNodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::ComputeScheduling::min_node_cpus].
    pub fn set_min_node_cpus<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_cpus = v.into();
        self
    }
}

impl wkt::message::Message for ComputeScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeScheduling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeScheduling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __on_host_maintenance,
            __restart_type,
            __node_affinities,
            __min_node_cpus,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeScheduling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onHostMaintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "on_host_maintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "restartType" => Ok(__FieldTag::__restart_type),
                            "restart_type" => Ok(__FieldTag::__restart_type),
                            "nodeAffinities" => Ok(__FieldTag::__node_affinities),
                            "node_affinities" => Ok(__FieldTag::__node_affinities),
                            "minNodeCpus" => Ok(__FieldTag::__min_node_cpus),
                            "min_node_cpus" => Ok(__FieldTag::__min_node_cpus),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeScheduling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeScheduling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__on_host_maintenance => {
                            if !fields.insert(__FieldTag::__on_host_maintenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for on_host_maintenance",
                                ));
                            }
                            result.on_host_maintenance = map
                                .next_value::<std::option::Option<
                                    crate::model::compute_scheduling::OnHostMaintenance,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restart_type => {
                            if !fields.insert(__FieldTag::__restart_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restart_type",
                                ));
                            }
                            result.restart_type =
                                map.next_value::<std::option::Option<
                                    crate::model::compute_scheduling::RestartType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_affinities => {
                            if !fields.insert(__FieldTag::__node_affinities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_affinities",
                                ));
                            }
                            result.node_affinities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SchedulingNodeAffinity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_cpus => {
                            if !fields.insert(__FieldTag::__min_node_cpus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_cpus",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_cpus =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeScheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.on_host_maintenance) {
            state.serialize_entry("onHostMaintenance", &self.on_host_maintenance)?;
        }
        if !wkt::internal::is_default(&self.restart_type) {
            state.serialize_entry("restartType", &self.restart_type)?;
        }
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if !wkt::internal::is_default(&self.min_node_cpus) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeScheduling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeScheduling");
        debug_struct.field("on_host_maintenance", &self.on_host_maintenance);
        debug_struct.field("restart_type", &self.restart_type);
        debug_struct.field("node_affinities", &self.node_affinities);
        debug_struct.field("min_node_cpus", &self.min_node_cpus);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ComputeScheduling].
pub mod compute_scheduling {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// Terminate the instance when the host machine undergoes maintenance.
        Terminate,
        /// Migrate the instance when the host machine undergoes maintenance.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::Migrate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ON_HOST_MAINTENANCE_UNSPECIFIED"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Terminate,
                2 => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Self::Unspecified,
                "TERMINATE" => Self::Terminate,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Terminate => serializer.serialize_i32(1),
                Self::Migrate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.OnHostMaintenance",
            ))
        }
    }

    /// Defines whether the Instance should be automatically restarted whenever
    /// it is terminated by Compute Engine (not terminated by user).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RestartType {
        /// Unspecified behavior. This will use the default.
        Unspecified,
        /// The Instance should be automatically restarted whenever it is
        /// terminated by Compute Engine.
        AutomaticRestart,
        /// The Instance isn't automatically restarted whenever it is
        /// terminated by Compute Engine.
        NoAutomaticRestart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RestartType::value] or
        /// [RestartType::name].
        UnknownValue(restart_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod restart_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RestartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AutomaticRestart => std::option::Option::Some(1),
                Self::NoAutomaticRestart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESTART_TYPE_UNSPECIFIED"),
                Self::AutomaticRestart => std::option::Option::Some("AUTOMATIC_RESTART"),
                Self::NoAutomaticRestart => std::option::Option::Some("NO_AUTOMATIC_RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RestartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RestartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RestartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AutomaticRestart,
                2 => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RestartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESTART_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC_RESTART" => Self::AutomaticRestart,
                "NO_AUTOMATIC_RESTART" => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RestartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AutomaticRestart => serializer.serialize_i32(1),
                Self::NoAutomaticRestart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RestartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestartType>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.RestartType",
            ))
        }
    }
}

/// A policy for scheduling replications.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulePolicy {
    /// The idle duration between replication stages.
    pub idle_duration: std::option::Option<wkt::Duration>,

    /// A flag to indicate whether to skip OS adaptation during the replication
    /// sync. OS adaptation is a process where the VM's operating system undergoes
    /// changes and adaptations to fully function on Compute Engine.
    pub skip_os_adaptation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_idle_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_or_clear_idle_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_os_adaptation][crate::model::SchedulePolicy::skip_os_adaptation].
    pub fn set_skip_os_adaptation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_os_adaptation = v.into();
        self
    }
}

impl wkt::message::Message for SchedulePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchedulePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __idle_duration,
            __skip_os_adaptation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchedulePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "idleDuration" => Ok(__FieldTag::__idle_duration),
                            "idle_duration" => Ok(__FieldTag::__idle_duration),
                            "skipOsAdaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            "skip_os_adaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchedulePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchedulePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__idle_duration => {
                            if !fields.insert(__FieldTag::__idle_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_duration",
                                ));
                            }
                            result.idle_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__skip_os_adaptation => {
                            if !fields.insert(__FieldTag::__skip_os_adaptation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_os_adaptation",
                                ));
                            }
                            result.skip_os_adaptation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchedulePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.idle_duration.is_some() {
            state.serialize_entry("idleDuration", &self.idle_duration)?;
        }
        if !wkt::internal::is_default(&self.skip_os_adaptation) {
            state.serialize_entry("skipOsAdaptation", &self.skip_os_adaptation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchedulePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulePolicy");
        debug_struct.field("idle_duration", &self.idle_duration);
        debug_struct.field("skip_os_adaptation", &self.skip_os_adaptation);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMigratingVmRequest {
    /// Required. The MigratingVm's parent.
    pub parent: std::string::String,

    /// Required. The migratingVm identifier.
    pub migrating_vm_id: std::string::String,

    /// Required. The create request body.
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigratingVmRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migrating_vm_id][crate::model::CreateMigratingVmRequest::migrating_vm_id].
    pub fn set_migrating_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm_id = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __migrating_vm_id,
            __migrating_vm,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "migratingVmId" => Ok(__FieldTag::__migrating_vm_id),
                            "migrating_vm_id" => Ok(__FieldTag::__migrating_vm_id),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm_id => {
                            if !fields.insert(__FieldTag::__migrating_vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm_id",
                                ));
                            }
                            result.migrating_vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm =
                                map.next_value::<std::option::Option<crate::model::MigratingVm>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.migrating_vm_id.is_empty() {
            state.serialize_entry("migratingVmId", &self.migrating_vm_id)?;
        }
        if self.migrating_vm.is_some() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMigratingVmRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("migrating_vm_id", &self.migrating_vm_id);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'LisMigratingVmsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigratingVmsRequest {
    /// Required. The parent, which owns this collection of MigratingVms.
    pub parent: std::string::String,

    /// Optional. The maximum number of migrating VMs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 migrating VMs
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListMigratingVms` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigratingVms`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    /// Optional. The level of details of each migrating VM.
    pub view: crate::model::MigratingVmView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigratingVmsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigratingVmsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigratingVmsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigratingVmsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigratingVmsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListMigratingVmsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigratingVmsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigratingVmsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigratingVmsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigratingVmsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::MigratingVmView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigratingVmsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigratingVmsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigratingVmsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListMigratingVms' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigratingVmsResponse {
    /// Output only. The list of Migrating VMs response.
    pub migrating_vms: std::vec::Vec<crate::model::MigratingVm>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vms][crate::model::ListMigratingVmsResponse::migrating_vms].
    pub fn set_migrating_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigratingVm>,
    {
        use std::iter::Iterator;
        self.migrating_vms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigratingVmsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigratingVmsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigratingVmsResponse {
    type PageItem = crate::model::MigratingVm;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migrating_vms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigratingVmsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vms,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigratingVmsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVms" => Ok(__FieldTag::__migrating_vms),
                            "migrating_vms" => Ok(__FieldTag::__migrating_vms),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigratingVmsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigratingVmsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vms => {
                            if !fields.insert(__FieldTag::__migrating_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vms",
                                ));
                            }
                            result.migrating_vms = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MigratingVm>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigratingVmsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vms.is_empty() {
            state.serialize_entry("migratingVms", &self.migrating_vms)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigratingVmsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigratingVmsResponse");
        debug_struct.field("migrating_vms", &self.migrating_vms);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    pub name: std::string::String,

    /// Optional. The level of details of the migrating VM.
    pub view: crate::model::MigratingVmView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetMigratingVmRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::MigratingVmView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMigratingVmRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMigratingVmRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// MigratingVm resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __migrating_vm,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm =
                                map.next_value::<std::option::Option<crate::model::MigratingVm>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.migrating_vm.is_some() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMigratingVmRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMigratingVmRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'StartMigrationRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::StartMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'StartMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'PauseMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::PauseMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for PauseMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'PauseMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PauseMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ResumeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::ResumeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ResumeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResumeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'FinalizeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FinalizeMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::FinalizeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for FinalizeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FinalizeMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FinalizeMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FinalizeMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FinalizeMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FinalizeMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FinalizeMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FinalizeMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'FinalizeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FinalizeMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for FinalizeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FinalizeMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FinalizeMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FinalizeMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FinalizeMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FinalizeMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FinalizeMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FinalizeMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TargetProject message represents a target Compute Engine project for a
/// migration or a clone.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetProject {
    /// Output only. The name of the target project.
    pub name: std::string::String,

    /// The target project ID (number) or project name.
    pub project: std::string::String,

    /// The target project's description.
    pub description: std::string::String,

    /// Output only. The time this target project resource was created (not related
    /// to when the Compute Engine project it points to was created).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the target project resource was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetProject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TargetProject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::TargetProject::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TargetProject::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetProject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.TargetProject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetProject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project,
            __description,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetProject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "project" => Ok(__FieldTag::__project),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetProject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetProject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetProject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetProject");
        debug_struct.field("name", &self.name);
        debug_struct.field("project", &self.project);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetTargetProject' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTargetProjectRequest {
    /// Required. The TargetProject name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTargetProjectRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListTargetProjects' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetProjectsRequest {
    /// Required. The parent, which owns this collection of targets.
    pub parent: std::string::String,

    /// Optional. The maximum number of targets to return. The service may return
    /// fewer than this value. If unspecified, at most 500 targets will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTargets` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetProjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetProjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetProjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTargetProjectsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTargetProjectsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetProjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetProjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetProjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetProjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetProjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetProjectsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetProjectsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListTargetProjects' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetProjectsResponse {
    /// Output only. The list of target response.
    pub target_projects: std::vec::Vec<crate::model::TargetProject>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_projects][crate::model::ListTargetProjectsResponse::target_projects].
    pub fn set_target_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetProject>,
    {
        use std::iter::Iterator;
        self.target_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetProjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTargetProjectsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetProjectsResponse {
    type PageItem = crate::model::TargetProject;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.target_projects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetProjectsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_projects,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetProjectsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetProjects" => Ok(__FieldTag::__target_projects),
                            "target_projects" => Ok(__FieldTag::__target_projects),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetProjectsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetProjectsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_projects => {
                            if !fields.insert(__FieldTag::__target_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_projects",
                                ));
                            }
                            result.target_projects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TargetProject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetProjectsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_projects.is_empty() {
            state.serialize_entry("targetProjects", &self.target_projects)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetProjectsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetProjectsResponse");
        debug_struct.field("target_projects", &self.target_projects);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTargetProjectRequest {
    /// Required. The TargetProject's parent.
    pub parent: std::string::String,

    /// Required. The target_project identifier.
    pub target_project_id: std::string::String,

    /// Required. The create request body.
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetProjectRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_project_id][crate::model::CreateTargetProjectRequest::target_project_id].
    pub fn set_target_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_project_id = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __target_project_id,
            __target_project,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "targetProjectId" => Ok(__FieldTag::__target_project_id),
                            "target_project_id" => Ok(__FieldTag::__target_project_id),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project_id => {
                            if !fields.insert(__FieldTag::__target_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project_id",
                                ));
                            }
                            result.target_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<crate::model::TargetProject>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.target_project_id.is_empty() {
            state.serialize_entry("targetProjectId", &self.target_project_id)?;
        }
        if self.target_project.is_some() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTargetProjectRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("target_project_id", &self.target_project_id);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTargetProjectRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// TargetProject resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __target_project,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<crate::model::TargetProject>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.target_project.is_some() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTargetProjectRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTargetProjectRequest {
    /// Required. The TargetProject name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTargetProjectRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes message for 'Group' resource. The Group is a collections of several
/// MigratingVms.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Group {
    /// Output only. The Group name.
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-provided description of the group.
    pub description: std::string::String,

    /// Display name is a user defined name for this group which can be updated.
    pub display_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Group::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Group::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Group::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Group::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Group::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Group"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Group {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __description,
            __display_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Group")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Group;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Group")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Group {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Group");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("display_name", &self.display_name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. The parent, which owns this collection of groups.
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service may return
    /// fewer than this value. If unspecified, at most 500 groups will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListGroups` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListGroups` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// Output only. The list of groups response.
    pub groups: std::vec::Vec<crate::model::Group>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [groups][crate::model::ListGroupsResponse::groups].
    pub fn set_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGroupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __groups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groups" => Ok(__FieldTag::__groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__groups => {
                            if !fields.insert(__FieldTag::__groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for groups",
                                ));
                            }
                            result.groups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Group>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.groups.is_empty() {
            state.serialize_entry("groups", &self.groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsResponse");
        debug_struct.field("groups", &self.groups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. The group name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGroupRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. The Group's parent.
    pub parent: std::string::String,

    /// Required. The group identifier.
    pub group_id: std::string::String,

    /// Required. The create request body.
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CreateGroupRequest::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __group_id,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            result.group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.group_id.is_empty() {
            state.serialize_entry("groupId", &self.group_id)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGroupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("group_id", &self.group_id);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Group resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGroupRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. The Group name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'AddGroupMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddGroupMigrationRequest {
    /// Required. The full path name of the Group to add to.
    pub group: std::string::String,

    /// The full path name of the MigratingVm to add.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AddGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::AddGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for AddGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddGroupMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddGroupMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddGroupMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddGroupMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddGroupMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddGroupMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddGroupMigrationRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'AddGroupMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddGroupMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddGroupMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddGroupMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddGroupMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddGroupMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddGroupMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddGroupMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddGroupMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'RemoveMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveGroupMigrationRequest {
    /// Required. The name of the Group.
    pub group: std::string::String,

    /// The MigratingVm to remove.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::RemoveGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::RemoveGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for RemoveGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveGroupMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveGroupMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveGroupMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveGroupMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveGroupMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveGroupMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveGroupMigrationRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("migrating_vm", &self.migrating_vm);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'RemoveMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveGroupMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveGroupMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveGroupMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveGroupMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveGroupMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveGroupMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveGroupMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveGroupMigrationResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCutoverJobRequest {
    /// Required. The Cutover's parent.
    pub parent: std::string::String,

    /// Required. The cutover job identifier.
    pub cutover_job_id: std::string::String,

    /// Required. The cutover request body.
    pub cutover_job: std::option::Option<crate::model::CutoverJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCutoverJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cutover_job_id][crate::model::CreateCutoverJobRequest::cutover_job_id].
    pub fn set_cutover_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cutover_job_id = v.into();
        self
    }

    /// Sets the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_cutover_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_or_clear_cutover_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCutoverJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cutover_job_id,
            __cutover_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cutoverJobId" => Ok(__FieldTag::__cutover_job_id),
                            "cutover_job_id" => Ok(__FieldTag::__cutover_job_id),
                            "cutoverJob" => Ok(__FieldTag::__cutover_job),
                            "cutover_job" => Ok(__FieldTag::__cutover_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cutover_job_id => {
                            if !fields.insert(__FieldTag::__cutover_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_job_id",
                                ));
                            }
                            result.cutover_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cutover_job => {
                            if !fields.insert(__FieldTag::__cutover_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_job",
                                ));
                            }
                            result.cutover_job =
                                map.next_value::<std::option::Option<crate::model::CutoverJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cutover_job_id.is_empty() {
            state.serialize_entry("cutoverJobId", &self.cutover_job_id)?;
        }
        if self.cutover_job.is_some() {
            state.serialize_entry("cutoverJob", &self.cutover_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCutoverJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cutover_job_id", &self.cutover_job_id);
        debug_struct.field("cutover_job", &self.cutover_job);
        debug_struct.field("request_id", &self.request_id);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCutoverJobRequest {
    /// Required. The cutover job id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCutoverJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCutoverJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCutoverJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCutoverJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCutoverJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCutoverJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCutoverJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCutoverJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCutoverJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCutoverJobResponse");

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListCutoverJobsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCutoverJobsRequest {
    /// Required. The parent, which owns this collection of migrating VMs.
    pub parent: std::string::String,

    /// Optional. The maximum number of cutover jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 cutover jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCutoverJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCutoverJobs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCutoverJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCutoverJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCutoverJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCutoverJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCutoverJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCutoverJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCutoverJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCutoverJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCutoverJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCutoverJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCutoverJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCutoverJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListCutoverJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCutoverJobsResponse {
    /// Output only. The list of cutover jobs response.
    pub cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cutover_jobs][crate::model::ListCutoverJobsResponse::cutover_jobs].
    pub fn set_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCutoverJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCutoverJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCutoverJobsResponse {
    type PageItem = crate::model::CutoverJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cutover_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCutoverJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cutover_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCutoverJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cutoverJobs" => Ok(__FieldTag::__cutover_jobs),
                            "cutover_jobs" => Ok(__FieldTag::__cutover_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCutoverJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCutoverJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cutover_jobs => {
                            if !fields.insert(__FieldTag::__cutover_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_jobs",
                                ));
                            }
                            result.cutover_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCutoverJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cutover_jobs.is_empty() {
            state.serialize_entry("cutoverJobs", &self.cutover_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCutoverJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCutoverJobsResponse");
        debug_struct.field("cutover_jobs", &self.cutover_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCutoverJobRequest {
    /// Required. The name of the CutoverJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCutoverJobRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents migration resource error information that can be used with
/// google.rpc.Status message. MigrationError is used to present the user with
/// error information in migration operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationError {
    /// Output only. The error code.
    pub code: crate::model::migration_error::ErrorCode,

    /// Output only. The localized error message.
    pub error_message: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. Suggested action for solving the error.
    pub action_item: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. URL(s) pointing to additional information on handling the
    /// current error.
    pub help_links: std::vec::Vec<rpc::model::help::Link>,

    /// Output only. The time the error occurred.
    pub error_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MigrationError::code].
    pub fn set_code<T: std::convert::Into<crate::model::migration_error::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_error_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_or_clear_error_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_action_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_or_clear_action_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [help_links][crate::model::MigrationError::help_links].
    pub fn set_help_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::help::Link>,
    {
        use std::iter::Iterator;
        self.help_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigrationError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __error_message,
            __action_item,
            __help_links,
            __error_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "actionItem" => Ok(__FieldTag::__action_item),
                            "action_item" => Ok(__FieldTag::__action_item),
                            "helpLinks" => Ok(__FieldTag::__help_links),
                            "help_links" => Ok(__FieldTag::__help_links),
                            "errorTime" => Ok(__FieldTag::__error_time),
                            "error_time" => Ok(__FieldTag::__error_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::migration_error::ErrorCode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__action_item => {
                            if !fields.insert(__FieldTag::__action_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_item",
                                ));
                            }
                            result.action_item = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__help_links => {
                            if !fields.insert(__FieldTag::__help_links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for help_links",
                                ));
                            }
                            result.help_links = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::help::Link>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_time => {
                            if !fields.insert(__FieldTag::__error_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_time",
                                ));
                            }
                            result.error_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if self.error_message.is_some() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if self.action_item.is_some() {
            state.serialize_entry("actionItem", &self.action_item)?;
        }
        if !self.help_links.is_empty() {
            state.serialize_entry("helpLinks", &self.help_links)?;
        }
        if self.error_time.is_some() {
            state.serialize_entry("errorTime", &self.error_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationError");
        debug_struct.field("code", &self.code);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("action_item", &self.action_item);
        debug_struct.field("help_links", &self.help_links);
        debug_struct.field("error_time", &self.error_time);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationError].
pub mod migration_error {
    #[allow(unused_imports)]
    use super::*;

    /// Represents resource error codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Default value. This value is not used.
        Unspecified,
        /// Migrate for Compute encountered an unknown error.
        UnknownError,
        /// Migrate for Compute encountered an error while validating replication
        /// source health.
        SourceValidationError,
        /// Migrate for Compute encountered an error during source data operation.
        SourceReplicationError,
        /// Migrate for Compute encountered an error during target data operation.
        TargetReplicationError,
        /// Migrate for Compute encountered an error during OS adaptation.
        OsAdaptationError,
        /// Migrate for Compute encountered an error in clone operation.
        CloneError,
        /// Migrate for Compute encountered an error in cutover operation.
        CutoverError,
        /// Migrate for Compute encountered an error during utilization report
        /// creation.
        UtilizationReportError,
        /// Migrate for Compute encountered an error during appliance upgrade.
        ApplianceUpgradeError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownError => std::option::Option::Some(1),
                Self::SourceValidationError => std::option::Option::Some(2),
                Self::SourceReplicationError => std::option::Option::Some(3),
                Self::TargetReplicationError => std::option::Option::Some(4),
                Self::OsAdaptationError => std::option::Option::Some(5),
                Self::CloneError => std::option::Option::Some(6),
                Self::CutoverError => std::option::Option::Some(7),
                Self::UtilizationReportError => std::option::Option::Some(8),
                Self::ApplianceUpgradeError => std::option::Option::Some(9),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::UnknownError => std::option::Option::Some("UNKNOWN_ERROR"),
                Self::SourceValidationError => std::option::Option::Some("SOURCE_VALIDATION_ERROR"),
                Self::SourceReplicationError => {
                    std::option::Option::Some("SOURCE_REPLICATION_ERROR")
                }
                Self::TargetReplicationError => {
                    std::option::Option::Some("TARGET_REPLICATION_ERROR")
                }
                Self::OsAdaptationError => std::option::Option::Some("OS_ADAPTATION_ERROR"),
                Self::CloneError => std::option::Option::Some("CLONE_ERROR"),
                Self::CutoverError => std::option::Option::Some("CUTOVER_ERROR"),
                Self::UtilizationReportError => {
                    std::option::Option::Some("UTILIZATION_REPORT_ERROR")
                }
                Self::ApplianceUpgradeError => std::option::Option::Some("APPLIANCE_UPGRADE_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownError,
                2 => Self::SourceValidationError,
                3 => Self::SourceReplicationError,
                4 => Self::TargetReplicationError,
                5 => Self::OsAdaptationError,
                6 => Self::CloneError,
                7 => Self::CutoverError,
                8 => Self::UtilizationReportError,
                9 => Self::ApplianceUpgradeError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_ERROR" => Self::UnknownError,
                "SOURCE_VALIDATION_ERROR" => Self::SourceValidationError,
                "SOURCE_REPLICATION_ERROR" => Self::SourceReplicationError,
                "TARGET_REPLICATION_ERROR" => Self::TargetReplicationError,
                "OS_ADAPTATION_ERROR" => Self::OsAdaptationError,
                "CLONE_ERROR" => Self::CloneError,
                "CUTOVER_ERROR" => Self::CutoverError,
                "UTILIZATION_REPORT_ERROR" => Self::UtilizationReportError,
                "APPLIANCE_UPGRADE_ERROR" => Self::ApplianceUpgradeError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownError => serializer.serialize_i32(1),
                Self::SourceValidationError => serializer.serialize_i32(2),
                Self::SourceReplicationError => serializer.serialize_i32(3),
                Self::TargetReplicationError => serializer.serialize_i32(4),
                Self::OsAdaptationError => serializer.serialize_i32(5),
                Self::CloneError => serializer.serialize_i32(6),
                Self::CutoverError => serializer.serialize_i32(7),
                Self::UtilizationReportError => serializer.serialize_i32(8),
                Self::ApplianceUpgradeError => serializer.serialize_i32(9),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.vmmigration.v1.MigrationError.ErrorCode",
            ))
        }
    }
}

/// Represent the source AWS VM details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSourceVmDetails {
    /// The firmware type of the source VM.
    pub firmware: crate::model::aws_source_vm_details::Firmware,

    /// The total size of the disks being migrated in bytes.
    pub committed_storage_bytes: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firmware][crate::model::AwsSourceVmDetails::firmware].
    pub fn set_firmware<T: std::convert::Into<crate::model::aws_source_vm_details::Firmware>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware = v.into();
        self
    }

    /// Sets the value of [committed_storage_bytes][crate::model::AwsSourceVmDetails::committed_storage_bytes].
    pub fn set_committed_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_bytes = v.into();
        self
    }
}

impl wkt::message::Message for AwsSourceVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSourceVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firmware,
            __committed_storage_bytes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSourceVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firmware" => Ok(__FieldTag::__firmware),
                            "committedStorageBytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "committed_storage_bytes" => Ok(__FieldTag::__committed_storage_bytes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSourceVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSourceVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firmware => {
                            if !fields.insert(__FieldTag::__firmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware",
                                ));
                            }
                            result.firmware =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_source_vm_details::Firmware,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_bytes => {
                            if !fields.insert(__FieldTag::__committed_storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSourceVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.firmware) {
            state.serialize_entry("firmware", &self.firmware)?;
        }
        if !wkt::internal::is_default(&self.committed_storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "committedStorageBytes",
                &__With(&self.committed_storage_bytes),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSourceVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSourceVmDetails");
        debug_struct.field("firmware", &self.firmware);
        debug_struct.field("committed_storage_bytes", &self.committed_storage_bytes);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsSourceVmDetails].
pub mod aws_source_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for AWS VM firmware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified,
        /// The firmware is EFI.
        Efi,
        /// The firmware is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Firmware::value] or
        /// [Firmware::name].
        UnknownValue(firmware::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Firmware {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Firmware {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Firmware {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Firmware {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Firmware {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Firmware {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Firmware {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Firmware>::new(
                ".google.cloud.vmmigration.v1.AwsSourceVmDetails.Firmware",
            ))
        }
    }
}

/// Request message for 'LisReplicationCyclesRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationCyclesRequest {
    /// Required. The parent, which owns this collection of ReplicationCycles.
    pub parent: std::string::String,

    /// Optional. The maximum number of replication cycles to return. The service
    /// may return fewer than this value. If unspecified, at most 100 migrating VMs
    /// will be returned. The maximum value is 100; values above 100 will be
    /// coerced to 100.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListReplicationCycles`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReplicationCycles`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReplicationCyclesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReplicationCyclesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReplicationCyclesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReplicationCyclesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReplicationCyclesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationCyclesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationCyclesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationCyclesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationCyclesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationCyclesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationCyclesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationCyclesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListReplicationCycles' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationCyclesResponse {
    /// Output only. The list of replication cycles response.
    pub replication_cycles: std::vec::Vec<crate::model::ReplicationCycle>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication_cycles][crate::model::ListReplicationCyclesResponse::replication_cycles].
    pub fn set_replication_cycles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicationCycle>,
    {
        use std::iter::Iterator;
        self.replication_cycles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReplicationCyclesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReplicationCyclesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReplicationCyclesResponse {
    type PageItem = crate::model::ReplicationCycle;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.replication_cycles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationCyclesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replication_cycles,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationCyclesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replicationCycles" => Ok(__FieldTag::__replication_cycles),
                            "replication_cycles" => Ok(__FieldTag::__replication_cycles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationCyclesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationCyclesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replication_cycles => {
                            if !fields.insert(__FieldTag::__replication_cycles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_cycles",
                                ));
                            }
                            result.replication_cycles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReplicationCycle>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationCyclesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.replication_cycles.is_empty() {
            state.serialize_entry("replicationCycles", &self.replication_cycles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationCyclesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationCyclesResponse");
        debug_struct.field("replication_cycles", &self.replication_cycles);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetReplicationCycle' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReplicationCycleRequest {
    /// Required. The name of the ReplicationCycle.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReplicationCycleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReplicationCycleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReplicationCycleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetReplicationCycleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReplicationCycleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReplicationCycleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReplicationCycleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReplicationCycleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReplicationCycleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReplicationCycleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReplicationCycleRequest");
        debug_struct.field("name", &self.name);

        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Controls the level of details of a Utilization Report.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UtilizationReportView {
    /// The default / unset value.
    /// The API will default to FULL on single report request and BASIC for
    /// multiple reports request.
    Unspecified,
    /// Get the report metadata, without the list of VMs and their utilization
    /// info.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UtilizationReportView::value] or
    /// [UtilizationReportView::name].
    UnknownValue(utilization_report_view::UnknownValue),
}

#[doc(hidden)]
pub mod utilization_report_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UtilizationReportView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UTILIZATION_REPORT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UtilizationReportView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UtilizationReportView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UtilizationReportView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UtilizationReportView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UTILIZATION_REPORT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UtilizationReportView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UtilizationReportView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UtilizationReportView>::new(
            ".google.cloud.vmmigration.v1.UtilizationReportView",
        ))
    }
}

/// Controls the level of details of a Migrating VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigratingVmView {
    /// View is unspecified. The API will fallback to the default value.
    Unspecified,
    /// Get the migrating VM basic details.
    /// The basic details do not include the recent clone jobs and recent cutover
    /// jobs lists.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigratingVmView::value] or
    /// [MigratingVmView::name].
    UnknownValue(migrating_vm_view::UnknownValue),
}

#[doc(hidden)]
pub mod migrating_vm_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigratingVmView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATING_VM_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("MIGRATING_VM_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("MIGRATING_VM_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigratingVmView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigratingVmView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigratingVmView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigratingVmView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATING_VM_VIEW_UNSPECIFIED" => Self::Unspecified,
            "MIGRATING_VM_VIEW_BASIC" => Self::Basic,
            "MIGRATING_VM_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigratingVmView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigratingVmView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigratingVmView>::new(
            ".google.cloud.vmmigration.v1.MigratingVmView",
        ))
    }
}

/// Types of disks supported for Compute Engine VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineDiskType {
    /// An unspecified disk type. Will be used as STANDARD.
    Unspecified,
    /// A Standard disk type.
    Standard,
    /// SSD hard disk type.
    Ssd,
    /// An alternative to SSD persistent disks that balance performance and
    /// cost.
    Balanced,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineDiskType::value] or
    /// [ComputeEngineDiskType::name].
    UnknownValue(compute_engine_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Ssd => std::option::Option::Some(2),
            Self::Balanced => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_STANDARD"),
            Self::Ssd => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_SSD"),
            Self::Balanced => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_BALANCED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Ssd,
            3 => Self::Balanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_DISK_TYPE_STANDARD" => Self::Standard,
            "COMPUTE_ENGINE_DISK_TYPE_SSD" => Self::Ssd,
            "COMPUTE_ENGINE_DISK_TYPE_BALANCED" => Self::Balanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Ssd => serializer.serialize_i32(2),
            Self::Balanced => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineDiskType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineDiskType",
        ))
    }
}

/// Types of licenses used in OS adaptation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineLicenseType {
    /// The license type is the default for the OS.
    Default,
    /// The license type is Pay As You Go license type.
    Payg,
    /// The license type is Bring Your Own License type.
    Byol,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineLicenseType::value] or
    /// [ComputeEngineLicenseType::name].
    UnknownValue(compute_engine_license_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_license_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineLicenseType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Default => std::option::Option::Some(0),
            Self::Payg => std::option::Option::Some(1),
            Self::Byol => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Default => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT"),
            Self::Payg => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_PAYG"),
            Self::Byol => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_BYOL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineLicenseType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineLicenseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineLicenseType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Default,
            1 => Self::Payg,
            2 => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineLicenseType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT" => Self::Default,
            "COMPUTE_ENGINE_LICENSE_TYPE_PAYG" => Self::Payg,
            "COMPUTE_ENGINE_LICENSE_TYPE_BYOL" => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineLicenseType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Default => serializer.serialize_i32(0),
            Self::Payg => serializer.serialize_i32(1),
            Self::Byol => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineLicenseType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineLicenseType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineLicenseType",
        ))
    }
}

/// Possible values for vm boot option.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineBootOption {
    /// The boot option is unknown.
    Unspecified,
    /// The boot option is EFI.
    Efi,
    /// The boot option is BIOS.
    Bios,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineBootOption::value] or
    /// [ComputeEngineBootOption::name].
    UnknownValue(compute_engine_boot_option::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_boot_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineBootOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Efi => std::option::Option::Some(1),
            Self::Bios => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED")
            }
            Self::Efi => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_EFI"),
            Self::Bios => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_BIOS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineBootOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineBootOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineBootOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Efi,
            2 => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineBootOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_BOOT_OPTION_EFI" => Self::Efi,
            "COMPUTE_ENGINE_BOOT_OPTION_BIOS" => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineBootOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Efi => serializer.serialize_i32(1),
            Self::Bios => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineBootOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineBootOption>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineBootOption",
        ))
    }
}
