// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// ReplicationCycle contains information about the current replication cycle
/// status.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationCycle {
    /// The identifier of the ReplicationCycle.
    pub name: std::string::String,

    /// The cycle's ordinal number.
    pub cycle_number: i32,

    /// The time the replication cycle has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the replication cycle has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The accumulated duration the replication cycle was paused.
    pub total_pause_duration: std::option::Option<wkt::Duration>,

    /// The current progress in percentage of this cycle.
    /// Was replaced by 'steps' field, which breaks down the cycle progression more
    /// accurately.
    #[deprecated]
    pub progress_percent: i32,

    /// The cycle's steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CycleStep>,

    /// State of the ReplicationCycle.
    pub state: crate::model::replication_cycle::State,

    /// Output only. Provides details on the state of the cycle in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Warnings that occurred during the cycle.
    pub warnings: std::vec::Vec<crate::model::MigrationWarning>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationCycle {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReplicationCycle::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [cycle_number][crate::model::ReplicationCycle::cycle_number].
    pub fn set_cycle_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cycle_number = v.into();
        self
    }

    /// Sets the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ReplicationCycle::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ReplicationCycle::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_total_pause_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [total_pause_duration][crate::model::ReplicationCycle::total_pause_duration].
    pub fn set_or_clear_total_pause_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.total_pause_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::ReplicationCycle::progress_percent].
    #[deprecated]
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::ReplicationCycle::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CycleStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ReplicationCycle::state].
    pub fn set_state<T: std::convert::Into<crate::model::replication_cycle::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::ReplicationCycle::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [warnings][crate::model::ReplicationCycle::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationWarning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReplicationCycle {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationCycle"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationCycle {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __cycle_number,
            __start_time,
            __end_time,
            __total_pause_duration,
            __progress_percent,
            __steps,
            __state,
            __error,
            __warnings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationCycle")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "cycleNumber" => Ok(__FieldTag::__cycle_number),
                            "cycle_number" => Ok(__FieldTag::__cycle_number),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "totalPauseDuration" => Ok(__FieldTag::__total_pause_duration),
                            "total_pause_duration" => Ok(__FieldTag::__total_pause_duration),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "steps" => Ok(__FieldTag::__steps),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "warnings" => Ok(__FieldTag::__warnings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationCycle;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationCycle")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cycle_number => {
                            if !fields.insert(__FieldTag::__cycle_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cycle_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cycle_number = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__total_pause_duration => {
                            if !fields.insert(__FieldTag::__total_pause_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_pause_duration",
                                ));
                            }
                            result.total_pause_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CycleStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::replication_cycle::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MigrationWarning>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationCycle {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.cycle_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cycleNumber", &__With(&self.cycle_number))?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if self.total_pause_duration.is_some() {
            state.serialize_entry("totalPauseDuration", &self.total_pause_duration)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicationCycle {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationCycle");
        debug_struct.field("name", &self.name);
        debug_struct.field("cycle_number", &self.cycle_number);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("total_pause_duration", &self.total_pause_duration);
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("warnings", &self.warnings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ReplicationCycle].
pub mod replication_cycle {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of a replication cycle.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The replication cycle is running.
        Running,
        /// The replication cycle is paused.
        Paused,
        /// The replication cycle finished with errors.
        Failed,
        /// The replication cycle finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Paused => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Paused,
                3 => Self::Failed,
                4 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "PAUSED" => Self::Paused,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Paused => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.ReplicationCycle.State",
            ))
        }
    }
}

/// CycleStep holds information about a step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CycleStep {
    /// The time the cycle step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the cycle step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::cycle_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CycleStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CycleStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CycleStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CycleStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::cycle_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `InitializingReplication`, `None` if the field is not set or
    /// holds a different branch.
    pub fn initializing_replication(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InitializingReplicationStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::InitializingReplication(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `InitializingReplication`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_initializing_replication<
        T: std::convert::Into<std::boxed::Box<crate::model::InitializingReplicationStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cycle_step::Step::InitializingReplication(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `Replicating`, `None` if the field is not set or
    /// holds a different branch.
    pub fn replicating(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicatingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::Replicating(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `Replicating`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_replicating<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicatingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::Replicating(v.into()));
        self
    }

    /// The value of [step][crate::model::CycleStep::step]
    /// if it holds a `PostProcessing`, `None` if the field is not set or
    /// holds a different branch.
    pub fn post_processing(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PostProcessingStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cycle_step::Step::PostProcessing(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CycleStep::step]
    /// to hold a `PostProcessing`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_post_processing<
        T: std::convert::Into<std::boxed::Box<crate::model::PostProcessingStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cycle_step::Step::PostProcessing(v.into()));
        self
    }
}

impl wkt::message::Message for CycleStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CycleStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CycleStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initializing_replication,
            __replicating,
            __post_processing,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CycleStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initializingReplication" => Ok(__FieldTag::__initializing_replication),
                            "initializing_replication" => {
                                Ok(__FieldTag::__initializing_replication)
                            }
                            "replicating" => Ok(__FieldTag::__replicating),
                            "postProcessing" => Ok(__FieldTag::__post_processing),
                            "post_processing" => Ok(__FieldTag::__post_processing),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CycleStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CycleStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initializing_replication => {
                            if !fields.insert(__FieldTag::__initializing_replication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initializing_replication",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.initializing_replication, latest field was initializingReplication",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::InitializingReplication(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InitializingReplicationStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__replicating => {
                            if !fields.insert(__FieldTag::__replicating) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicating",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.replicating, latest field was replicating",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::Replicating(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicatingStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__post_processing => {
                            if !fields.insert(__FieldTag::__post_processing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for post_processing",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CycleStep.post_processing, latest field was postProcessing",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cycle_step::Step::PostProcessing(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PostProcessingStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CycleStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.initializing_replication() {
            state.serialize_entry("initializingReplication", value)?;
        }
        if let Some(value) = self.replicating() {
            state.serialize_entry("replicating", value)?;
        }
        if let Some(value) = self.post_processing() {
            state.serialize_entry("postProcessing", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CycleStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CycleStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CycleStep].
pub mod cycle_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Initializing replication step.
        InitializingReplication(std::boxed::Box<crate::model::InitializingReplicationStep>),
        /// Replicating step.
        Replicating(std::boxed::Box<crate::model::ReplicatingStep>),
        /// Post processing step.
        PostProcessing(std::boxed::Box<crate::model::PostProcessingStep>),
    }
}

/// InitializingReplicationStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializingReplicationStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializingReplicationStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializingReplicationStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InitializingReplicationStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializingReplicationStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializingReplicationStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializingReplicationStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializingReplicationStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializingReplicationStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializingReplicationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializingReplicationStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReplicatingStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicatingStep {
    /// Total bytes to be handled in the step.
    pub total_bytes: i64,

    /// Replicated bytes in the step.
    pub replicated_bytes: i64,

    /// The source disks replication rate for the last 2 minutes in bytes per
    /// second.
    pub last_two_minutes_average_bytes_per_second: i64,

    /// The source disks replication rate for the last 30 minutes in bytes per
    /// second.
    pub last_thirty_minutes_average_bytes_per_second: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicatingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [total_bytes][crate::model::ReplicatingStep::total_bytes].
    pub fn set_total_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.total_bytes = v.into();
        self
    }

    /// Sets the value of [replicated_bytes][crate::model::ReplicatingStep::replicated_bytes].
    pub fn set_replicated_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.replicated_bytes = v.into();
        self
    }

    /// Sets the value of [last_two_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_two_minutes_average_bytes_per_second].
    pub fn set_last_two_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_two_minutes_average_bytes_per_second = v.into();
        self
    }

    /// Sets the value of [last_thirty_minutes_average_bytes_per_second][crate::model::ReplicatingStep::last_thirty_minutes_average_bytes_per_second].
    pub fn set_last_thirty_minutes_average_bytes_per_second<T: std::convert::Into<i64>>(
        mut self,
        v: T,
    ) -> Self {
        self.last_thirty_minutes_average_bytes_per_second = v.into();
        self
    }
}

impl wkt::message::Message for ReplicatingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicatingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicatingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __total_bytes,
            __replicated_bytes,
            __last_two_minutes_average_bytes_per_second,
            __last_thirty_minutes_average_bytes_per_second,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicatingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "totalBytes" => Ok(__FieldTag::__total_bytes),
                            "total_bytes" => Ok(__FieldTag::__total_bytes),
                            "replicatedBytes" => Ok(__FieldTag::__replicated_bytes),
                            "replicated_bytes" => Ok(__FieldTag::__replicated_bytes),
                            "lastTwoMinutesAverageBytesPerSecond" => {
                                Ok(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            }
                            "last_two_minutes_average_bytes_per_second" => {
                                Ok(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            }
                            "lastThirtyMinutesAverageBytesPerSecond" => {
                                Ok(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            }
                            "last_thirty_minutes_average_bytes_per_second" => {
                                Ok(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicatingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicatingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__total_bytes => {
                            if !fields.insert(__FieldTag::__total_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for total_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.total_bytes = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__replicated_bytes => {
                            if !fields.insert(__FieldTag::__replicated_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replicated_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.replicated_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_two_minutes_average_bytes_per_second => {
                            if !fields
                                .insert(__FieldTag::__last_two_minutes_average_bytes_per_second)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_two_minutes_average_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_two_minutes_average_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__last_thirty_minutes_average_bytes_per_second => {
                            if !fields
                                .insert(__FieldTag::__last_thirty_minutes_average_bytes_per_second)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_thirty_minutes_average_bytes_per_second",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.last_thirty_minutes_average_bytes_per_second =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicatingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.total_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("totalBytes", &__With(&self.total_bytes))?;
        }
        if !wkt::internal::is_default(&self.replicated_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("replicatedBytes", &__With(&self.replicated_bytes))?;
        }
        if !wkt::internal::is_default(&self.last_two_minutes_average_bytes_per_second) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "lastTwoMinutesAverageBytesPerSecond",
                &__With(&self.last_two_minutes_average_bytes_per_second),
            )?;
        }
        if !wkt::internal::is_default(&self.last_thirty_minutes_average_bytes_per_second) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "lastThirtyMinutesAverageBytesPerSecond",
                &__With(&self.last_thirty_minutes_average_bytes_per_second),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicatingStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicatingStep");
        debug_struct.field("total_bytes", &self.total_bytes);
        debug_struct.field("replicated_bytes", &self.replicated_bytes);
        debug_struct.field(
            "last_two_minutes_average_bytes_per_second",
            &self.last_two_minutes_average_bytes_per_second,
        );
        debug_struct.field(
            "last_thirty_minutes_average_bytes_per_second",
            &self.last_thirty_minutes_average_bytes_per_second,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PostProcessingStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PostProcessingStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PostProcessingStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PostProcessingStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PostProcessingStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PostProcessingStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PostProcessingStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PostProcessingStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PostProcessingStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PostProcessingStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PostProcessingStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PostProcessingStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ReplicationSync contain information about the last replica sync to the cloud.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ReplicationSync {
    /// The most updated snapshot created time in the source that finished
    /// replication.
    pub last_sync_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReplicationSync {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_last_sync_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync_time][crate::model::ReplicationSync::last_sync_time].
    pub fn set_or_clear_last_sync_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_sync_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReplicationSync {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ReplicationSync"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReplicationSync {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __last_sync_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReplicationSync")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "lastSyncTime" => Ok(__FieldTag::__last_sync_time),
                            "last_sync_time" => Ok(__FieldTag::__last_sync_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReplicationSync;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReplicationSync")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__last_sync_time => {
                            if !fields.insert(__FieldTag::__last_sync_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync_time",
                                ));
                            }
                            result.last_sync_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReplicationSync {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.last_sync_time.is_some() {
            state.serialize_entry("lastSyncTime", &self.last_sync_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ReplicationSync {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ReplicationSync");
        debug_struct.field("last_sync_time", &self.last_sync_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// MigratingVm describes the VM that will be migrated from a Source environment
/// and its replication state.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigratingVm {
    /// Output only. The identifier of the MigratingVm.
    pub name: std::string::String,

    /// The unique ID of the VM in the source.
    /// The VM's name in vSphere can be changed, so this is not the VM's name but
    /// rather its moRef id. This id is of the form vm-\<num\>.
    pub source_vm_id: std::string::String,

    /// The display name attached to the MigratingVm by the user.
    pub display_name: std::string::String,

    /// The description attached to the migrating VM by the user.
    pub description: std::string::String,

    /// The replication schedule policy.
    pub policy: std::option::Option<crate::model::SchedulePolicy>,

    /// Output only. The time the migrating VM was created (this refers to this
    /// resource and not to the time it was installed in the source).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the migrating VM resource was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The most updated snapshot created time in the source that
    /// finished replication.
    pub last_sync: std::option::Option<crate::model::ReplicationSync>,

    /// Output only. State of the MigratingVm.
    pub state: crate::model::migrating_vm::State,

    /// Output only. The last time the migrating VM state was updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Details of the current running replication cycle.
    pub current_sync_info: std::option::Option<crate::model::ReplicationCycle>,

    /// Output only. Details of the last replication cycle. This will be updated
    /// whenever a replication cycle is finished and is not to be confused with
    /// last_sync which is only updated on successful replication cycles.
    pub last_replication_cycle: std::option::Option<crate::model::ReplicationCycle>,

    /// Output only. The group this migrating vm is included in, if any. The group
    /// is represented by the full path of the appropriate
    /// [Group][google.cloud.vmmigration.v1.Group] resource.
    ///
    /// [google.cloud.vmmigration.v1.Group]: crate::model::Group
    pub group: std::string::String,

    /// The labels of the migrating VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The recent [clone jobs][google.cloud.vmmigration.v1.CloneJob]
    /// performed on the migrating VM. This field holds the vm's last completed
    /// clone job and the vm's running clone job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    ///
    /// [google.cloud.vmmigration.v1.CloneJob]: crate::model::CloneJob
    pub recent_clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. Provides details on the state of the Migrating VM in case of
    /// an error in replication.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The recent cutover jobs performed on the migrating VM.
    /// This field holds the vm's last completed cutover job and the vm's
    /// running cutover job, if one exists.
    /// Note: To have this field populated you need to explicitly request it via
    /// the "view" parameter of the Get/List request.
    pub recent_cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// Output only. Provides details of future CutoverJobs of a MigratingVm.
    /// Set to empty when cutover forecast is unavailable.
    pub cutover_forecast: std::option::Option<crate::model::CutoverForecast>,

    /// Output only. Provides details about the expiration state of the migrating
    /// VM.
    pub expiration: std::option::Option<crate::model::migrating_vm::Expiration>,

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    pub target_vm_defaults: std::option::Option<crate::model::migrating_vm::TargetVmDefaults>,

    /// Details about the source VM.
    pub source_vm_details: std::option::Option<crate::model::migrating_vm::SourceVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigratingVm {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::MigratingVm::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [source_vm_id][crate::model::MigratingVm::source_vm_id].
    pub fn set_source_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::MigratingVm::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MigratingVm::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_policy<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [policy][crate::model::MigratingVm::policy].
    pub fn set_or_clear_policy<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::SchedulePolicy>,
    {
        self.policy = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::MigratingVm::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::MigratingVm::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_last_sync<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_sync][crate::model::MigratingVm::last_sync].
    pub fn set_or_clear_last_sync<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationSync>,
    {
        self.last_sync = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::MigratingVm::state].
    pub fn set_state<T: std::convert::Into<crate::model::migrating_vm::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::MigratingVm::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_current_sync_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [current_sync_info][crate::model::MigratingVm::current_sync_info].
    pub fn set_or_clear_current_sync_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.current_sync_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [last_replication_cycle][crate::model::MigratingVm::last_replication_cycle].
    pub fn set_last_replication_cycle<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.last_replication_cycle = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_replication_cycle][crate::model::MigratingVm::last_replication_cycle].
    pub fn set_or_clear_last_replication_cycle<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReplicationCycle>,
    {
        self.last_replication_cycle = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::MigratingVm::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::MigratingVm::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [recent_clone_jobs][crate::model::MigratingVm::recent_clone_jobs].
    pub fn set_recent_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.recent_clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error][crate::model::MigratingVm::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::MigratingVm::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recent_cutover_jobs][crate::model::MigratingVm::recent_cutover_jobs].
    pub fn set_recent_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.recent_cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [cutover_forecast][crate::model::MigratingVm::cutover_forecast].
    pub fn set_cutover_forecast<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CutoverForecast>,
    {
        self.cutover_forecast = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cutover_forecast][crate::model::MigratingVm::cutover_forecast].
    pub fn set_or_clear_cutover_forecast<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CutoverForecast>,
    {
        self.cutover_forecast = v.map(|x| x.into());
        self
    }

    /// Sets the value of [expiration][crate::model::MigratingVm::expiration].
    pub fn set_expiration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::migrating_vm::Expiration>,
    {
        self.expiration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration][crate::model::MigratingVm::expiration].
    pub fn set_or_clear_expiration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::migrating_vm::Expiration>,
    {
        self.expiration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults].
    ///
    /// Note that all the setters affecting `target_vm_defaults` are mutually
    /// exclusive.
    pub fn set_target_vm_defaults<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::TargetVmDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = v.into();
        self
    }

    /// The value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// if it holds a `ComputeEngineTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDefaults>> {
        #[allow(unreachable_patterns)]
        self.target_vm_defaults.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// to hold a `ComputeEngineTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_vm_defaults` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = std::option::Option::Some(
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(v.into()),
        );
        self
    }

    /// The value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// if it holds a `ComputeEngineDisksTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_disks_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineDisksTargetDefaults>> {
        #[allow(unreachable_patterns)]
        self.target_vm_defaults.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineDisksTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_defaults][crate::model::MigratingVm::target_vm_defaults]
    /// to hold a `ComputeEngineDisksTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_vm_defaults` are
    /// mutually exclusive.
    pub fn set_compute_engine_disks_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineDisksTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_defaults = std::option::Option::Some(
            crate::model::migrating_vm::TargetVmDefaults::ComputeEngineDisksTargetDefaults(
                v.into(),
            ),
        );
        self
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details].
    ///
    /// Note that all the setters affecting `source_vm_details` are mutually
    /// exclusive.
    pub fn set_source_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::migrating_vm::SourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = v.into();
        self
    }

    /// The value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// if it holds a `VmwareSourceVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_source_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareSourceVmDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vm_details.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::SourceVmDetails::VmwareSourceVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// to hold a `VmwareSourceVmDetails`.
    ///
    /// Note that all the setters affecting `source_vm_details` are
    /// mutually exclusive.
    pub fn set_vmware_source_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareSourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = std::option::Option::Some(
            crate::model::migrating_vm::SourceVmDetails::VmwareSourceVmDetails(v.into()),
        );
        self
    }

    /// The value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// if it holds a `AwsSourceVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_source_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceVmDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vm_details.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// to hold a `AwsSourceVmDetails`.
    ///
    /// Note that all the setters affecting `source_vm_details` are
    /// mutually exclusive.
    pub fn set_aws_source_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = std::option::Option::Some(
            crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(v.into()),
        );
        self
    }

    /// The value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// if it holds a `AzureSourceVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_source_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureSourceVmDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vm_details.as_ref().and_then(|v| match v {
            crate::model::migrating_vm::SourceVmDetails::AzureSourceVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vm_details][crate::model::MigratingVm::source_vm_details]
    /// to hold a `AzureSourceVmDetails`.
    ///
    /// Note that all the setters affecting `source_vm_details` are
    /// mutually exclusive.
    pub fn set_azure_source_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AzureSourceVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vm_details = std::option::Option::Some(
            crate::model::migrating_vm::SourceVmDetails::AzureSourceVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for MigratingVm {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigratingVm"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigratingVm {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_defaults,
            __compute_engine_disks_target_defaults,
            __vmware_source_vm_details,
            __aws_source_vm_details,
            __azure_source_vm_details,
            __name,
            __source_vm_id,
            __display_name,
            __description,
            __policy,
            __create_time,
            __update_time,
            __last_sync,
            __state,
            __state_time,
            __current_sync_info,
            __last_replication_cycle,
            __group,
            __labels,
            __recent_clone_jobs,
            __error,
            __recent_cutover_jobs,
            __cutover_forecast,
            __expiration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigratingVm")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDefaults" => {
                                Ok(__FieldTag::__compute_engine_target_defaults)
                            }
                            "compute_engine_target_defaults" => {
                                Ok(__FieldTag::__compute_engine_target_defaults)
                            }
                            "computeEngineDisksTargetDefaults" => {
                                Ok(__FieldTag::__compute_engine_disks_target_defaults)
                            }
                            "compute_engine_disks_target_defaults" => {
                                Ok(__FieldTag::__compute_engine_disks_target_defaults)
                            }
                            "vmwareSourceVmDetails" => Ok(__FieldTag::__vmware_source_vm_details),
                            "vmware_source_vm_details" => {
                                Ok(__FieldTag::__vmware_source_vm_details)
                            }
                            "awsSourceVmDetails" => Ok(__FieldTag::__aws_source_vm_details),
                            "aws_source_vm_details" => Ok(__FieldTag::__aws_source_vm_details),
                            "azureSourceVmDetails" => Ok(__FieldTag::__azure_source_vm_details),
                            "azure_source_vm_details" => Ok(__FieldTag::__azure_source_vm_details),
                            "name" => Ok(__FieldTag::__name),
                            "sourceVmId" => Ok(__FieldTag::__source_vm_id),
                            "source_vm_id" => Ok(__FieldTag::__source_vm_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "description" => Ok(__FieldTag::__description),
                            "policy" => Ok(__FieldTag::__policy),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "lastSync" => Ok(__FieldTag::__last_sync),
                            "last_sync" => Ok(__FieldTag::__last_sync),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "currentSyncInfo" => Ok(__FieldTag::__current_sync_info),
                            "current_sync_info" => Ok(__FieldTag::__current_sync_info),
                            "lastReplicationCycle" => Ok(__FieldTag::__last_replication_cycle),
                            "last_replication_cycle" => Ok(__FieldTag::__last_replication_cycle),
                            "group" => Ok(__FieldTag::__group),
                            "labels" => Ok(__FieldTag::__labels),
                            "recentCloneJobs" => Ok(__FieldTag::__recent_clone_jobs),
                            "recent_clone_jobs" => Ok(__FieldTag::__recent_clone_jobs),
                            "error" => Ok(__FieldTag::__error),
                            "recentCutoverJobs" => Ok(__FieldTag::__recent_cutover_jobs),
                            "recent_cutover_jobs" => Ok(__FieldTag::__recent_cutover_jobs),
                            "cutoverForecast" => Ok(__FieldTag::__cutover_forecast),
                            "cutover_forecast" => Ok(__FieldTag::__cutover_forecast),
                            "expiration" => Ok(__FieldTag::__expiration),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigratingVm;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigratingVm")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_defaults => {
                            if !fields.insert(__FieldTag::__compute_engine_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_defaults",
                                ));
                            }
                            if result.target_vm_defaults.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_defaults`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.compute_engine_target_defaults, latest field was computeEngineTargetDefaults",
                                ));
                            }
                            result.target_vm_defaults = std::option::Option::Some(
                                crate::model::migrating_vm::TargetVmDefaults::ComputeEngineTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDefaults>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__compute_engine_disks_target_defaults => {
                            if !fields.insert(__FieldTag::__compute_engine_disks_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_disks_target_defaults",
                                ));
                            }
                            if result.target_vm_defaults.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_defaults`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.compute_engine_disks_target_defaults, latest field was computeEngineDisksTargetDefaults",
                                ));
                            }
                            result.target_vm_defaults = std::option::Option::Some(
                                crate::model::migrating_vm::TargetVmDefaults::ComputeEngineDisksTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineDisksTargetDefaults>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vmware_source_vm_details => {
                            if !fields.insert(__FieldTag::__vmware_source_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_source_vm_details",
                                ));
                            }
                            if result.source_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.vmware_source_vm_details, latest field was vmwareSourceVmDetails",
                                ));
                            }
                            result.source_vm_details = std::option::Option::Some(
                                crate::model::migrating_vm::SourceVmDetails::VmwareSourceVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareSourceVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_source_vm_details => {
                            if !fields.insert(__FieldTag::__aws_source_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_source_vm_details",
                                ));
                            }
                            if result.source_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.aws_source_vm_details, latest field was awsSourceVmDetails",
                                ));
                            }
                            result.source_vm_details = std::option::Option::Some(
                                crate::model::migrating_vm::SourceVmDetails::AwsSourceVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsSourceVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_source_vm_details => {
                            if !fields.insert(__FieldTag::__azure_source_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_source_vm_details",
                                ));
                            }
                            if result.source_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.MigratingVm.azure_source_vm_details, latest field was azureSourceVmDetails",
                                ));
                            }
                            result.source_vm_details = std::option::Option::Some(
                                crate::model::migrating_vm::SourceVmDetails::AzureSourceVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureSourceVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_vm_id => {
                            if !fields.insert(__FieldTag::__source_vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_vm_id",
                                ));
                            }
                            result.source_vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__policy => {
                            if !fields.insert(__FieldTag::__policy) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for policy",
                                ));
                            }
                            result.policy = map
                                .next_value::<std::option::Option<crate::model::SchedulePolicy>>(
                                )?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__last_sync => {
                            if !fields.insert(__FieldTag::__last_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_sync",
                                ));
                            }
                            result.last_sync = map
                                .next_value::<std::option::Option<crate::model::ReplicationSync>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::migrating_vm::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__current_sync_info => {
                            if !fields.insert(__FieldTag::__current_sync_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for current_sync_info",
                                ));
                            }
                            result.current_sync_info = map
                                .next_value::<std::option::Option<crate::model::ReplicationCycle>>(
                                )?;
                        }
                        __FieldTag::__last_replication_cycle => {
                            if !fields.insert(__FieldTag::__last_replication_cycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_replication_cycle",
                                ));
                            }
                            result.last_replication_cycle = map
                                .next_value::<std::option::Option<crate::model::ReplicationCycle>>(
                                )?;
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recent_clone_jobs => {
                            if !fields.insert(__FieldTag::__recent_clone_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_clone_jobs",
                                ));
                            }
                            result.recent_clone_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__recent_cutover_jobs => {
                            if !fields.insert(__FieldTag::__recent_cutover_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_cutover_jobs",
                                ));
                            }
                            result.recent_cutover_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cutover_forecast => {
                            if !fields.insert(__FieldTag::__cutover_forecast) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_forecast",
                                ));
                            }
                            result.cutover_forecast = map
                                .next_value::<std::option::Option<crate::model::CutoverForecast>>(
                                )?;
                        }
                        __FieldTag::__expiration => {
                            if !fields.insert(__FieldTag::__expiration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for expiration",
                                ));
                            }
                            result.expiration = map.next_value::<std::option::Option<crate::model::migrating_vm::Expiration>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigratingVm {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_defaults() {
            state.serialize_entry("computeEngineTargetDefaults", value)?;
        }
        if let Some(value) = self.compute_engine_disks_target_defaults() {
            state.serialize_entry("computeEngineDisksTargetDefaults", value)?;
        }
        if let Some(value) = self.vmware_source_vm_details() {
            state.serialize_entry("vmwareSourceVmDetails", value)?;
        }
        if let Some(value) = self.aws_source_vm_details() {
            state.serialize_entry("awsSourceVmDetails", value)?;
        }
        if let Some(value) = self.azure_source_vm_details() {
            state.serialize_entry("azureSourceVmDetails", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.source_vm_id.is_empty() {
            state.serialize_entry("sourceVmId", &self.source_vm_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.policy.is_some() {
            state.serialize_entry("policy", &self.policy)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.last_sync.is_some() {
            state.serialize_entry("lastSync", &self.last_sync)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.current_sync_info.is_some() {
            state.serialize_entry("currentSyncInfo", &self.current_sync_info)?;
        }
        if self.last_replication_cycle.is_some() {
            state.serialize_entry("lastReplicationCycle", &self.last_replication_cycle)?;
        }
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.recent_clone_jobs.is_empty() {
            state.serialize_entry("recentCloneJobs", &self.recent_clone_jobs)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.recent_cutover_jobs.is_empty() {
            state.serialize_entry("recentCutoverJobs", &self.recent_cutover_jobs)?;
        }
        if self.cutover_forecast.is_some() {
            state.serialize_entry("cutoverForecast", &self.cutover_forecast)?;
        }
        if self.expiration.is_some() {
            state.serialize_entry("expiration", &self.expiration)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigratingVm {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigratingVm");
        debug_struct.field("name", &self.name);
        debug_struct.field("source_vm_id", &self.source_vm_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("description", &self.description);
        debug_struct.field("policy", &self.policy);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("last_sync", &self.last_sync);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("current_sync_info", &self.current_sync_info);
        debug_struct.field("last_replication_cycle", &self.last_replication_cycle);
        debug_struct.field("group", &self.group);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("recent_clone_jobs", &self.recent_clone_jobs);
        debug_struct.field("error", &self.error);
        debug_struct.field("recent_cutover_jobs", &self.recent_cutover_jobs);
        debug_struct.field("cutover_forecast", &self.cutover_forecast);
        debug_struct.field("expiration", &self.expiration);
        debug_struct.field("target_vm_defaults", &self.target_vm_defaults);
        debug_struct.field("source_vm_details", &self.source_vm_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigratingVm].
pub mod migrating_vm {
    #[allow(unused_imports)]
    use super::*;

    /// Expiration holds information about the expiration of a MigratingVm.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Expiration {
        /// Output only. Timestamp of when this resource is considered expired.
        pub expire_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The number of times expiration was extended.
        pub extension_count: i32,

        /// Output only. Describes whether the expiration can be extended.
        pub extendable: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Expiration {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [expire_time][crate::model::migrating_vm::Expiration::expire_time].
        pub fn set_expire_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [expire_time][crate::model::migrating_vm::Expiration::expire_time].
        pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.expire_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [extension_count][crate::model::migrating_vm::Expiration::extension_count].
        pub fn set_extension_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.extension_count = v.into();
            self
        }

        /// Sets the value of [extendable][crate::model::migrating_vm::Expiration::extendable].
        pub fn set_extendable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.extendable = v.into();
            self
        }
    }

    impl wkt::message::Message for Expiration {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.MigratingVm.Expiration"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Expiration {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __expire_time,
                __extension_count,
                __extendable,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Expiration")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "expireTime" => Ok(__FieldTag::__expire_time),
                                "expire_time" => Ok(__FieldTag::__expire_time),
                                "extensionCount" => Ok(__FieldTag::__extension_count),
                                "extension_count" => Ok(__FieldTag::__extension_count),
                                "extendable" => Ok(__FieldTag::__extendable),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Expiration;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Expiration")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__expire_time => {
                                if !fields.insert(__FieldTag::__expire_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for expire_time",
                                    ));
                                }
                                result.expire_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__extension_count => {
                                if !fields.insert(__FieldTag::__extension_count) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for extension_count",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.extension_count =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__extendable => {
                                if !fields.insert(__FieldTag::__extendable) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for extendable",
                                    ));
                                }
                                result.extendable = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Expiration {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.expire_time.is_some() {
                state.serialize_entry("expireTime", &self.expire_time)?;
            }
            if !wkt::internal::is_default(&self.extension_count) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("extensionCount", &__With(&self.extension_count))?;
            }
            if !wkt::internal::is_default(&self.extendable) {
                state.serialize_entry("extendable", &self.extendable)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Expiration {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Expiration");
            debug_struct.field("expire_time", &self.expire_time);
            debug_struct.field("extension_count", &self.extension_count);
            debug_struct.field("extendable", &self.extendable);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The possible values of the state/health of source VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The VM in the source is being verified.
        Pending,
        /// The source VM was verified, and it's ready to start replication.
        Ready,
        /// Migration is going through the first sync cycle.
        FirstSync,
        /// The replication is active, and it's running or scheduled to run.
        Active,
        /// The source VM is being turned off, and a final replication is currently
        /// running.
        CuttingOver,
        /// The source VM was stopped and replicated. The replication is currently
        /// paused.
        Cutover,
        /// A cutover job is active and replication cycle is running the final sync.
        FinalSync,
        /// The replication was paused by the user and no cycles are scheduled to
        /// run.
        Paused,
        /// The migrating VM is being finalized and migration resources are being
        /// removed.
        Finalizing,
        /// The replication process is done. The migrating VM is finalized and no
        /// longer consumes billable resources.
        Finalized,
        /// The replication process encountered an unrecoverable error and was
        /// aborted.
        Error,
        /// The migrating VM has passed its expiration date. It might be possible to
        /// bring it back to "Active" state by updating the TTL field. For more
        /// information, see the documentation.
        Expired,
        /// The migrating VM's has been finalized and migration resources have been
        /// removed.
        FinalizedExpired,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::FirstSync => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::CuttingOver => std::option::Option::Some(7),
                Self::Cutover => std::option::Option::Some(8),
                Self::FinalSync => std::option::Option::Some(9),
                Self::Paused => std::option::Option::Some(10),
                Self::Finalizing => std::option::Option::Some(11),
                Self::Finalized => std::option::Option::Some(12),
                Self::Error => std::option::Option::Some(13),
                Self::Expired => std::option::Option::Some(14),
                Self::FinalizedExpired => std::option::Option::Some(17),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::FirstSync => std::option::Option::Some("FIRST_SYNC"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::CuttingOver => std::option::Option::Some("CUTTING_OVER"),
                Self::Cutover => std::option::Option::Some("CUTOVER"),
                Self::FinalSync => std::option::Option::Some("FINAL_SYNC"),
                Self::Paused => std::option::Option::Some("PAUSED"),
                Self::Finalizing => std::option::Option::Some("FINALIZING"),
                Self::Finalized => std::option::Option::Some("FINALIZED"),
                Self::Error => std::option::Option::Some("ERROR"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::FinalizedExpired => std::option::Option::Some("FINALIZED_EXPIRED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Ready,
                3 => Self::FirstSync,
                4 => Self::Active,
                7 => Self::CuttingOver,
                8 => Self::Cutover,
                9 => Self::FinalSync,
                10 => Self::Paused,
                11 => Self::Finalizing,
                12 => Self::Finalized,
                13 => Self::Error,
                14 => Self::Expired,
                17 => Self::FinalizedExpired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "READY" => Self::Ready,
                "FIRST_SYNC" => Self::FirstSync,
                "ACTIVE" => Self::Active,
                "CUTTING_OVER" => Self::CuttingOver,
                "CUTOVER" => Self::Cutover,
                "FINAL_SYNC" => Self::FinalSync,
                "PAUSED" => Self::Paused,
                "FINALIZING" => Self::Finalizing,
                "FINALIZED" => Self::Finalized,
                "ERROR" => Self::Error,
                "EXPIRED" => Self::Expired,
                "FINALIZED_EXPIRED" => Self::FinalizedExpired,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::FirstSync => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::CuttingOver => serializer.serialize_i32(7),
                Self::Cutover => serializer.serialize_i32(8),
                Self::FinalSync => serializer.serialize_i32(9),
                Self::Paused => serializer.serialize_i32(10),
                Self::Finalizing => serializer.serialize_i32(11),
                Self::Finalized => serializer.serialize_i32(12),
                Self::Error => serializer.serialize_i32(13),
                Self::Expired => serializer.serialize_i32(14),
                Self::FinalizedExpired => serializer.serialize_i32(17),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.MigratingVm.State",
            ))
        }
    }

    /// The default configuration of the target VM that will be created in Google
    /// Cloud as a result of the migration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDefaults {
        /// Details of the target VM in Compute Engine.
        ComputeEngineTargetDefaults(std::boxed::Box<crate::model::ComputeEngineTargetDefaults>),
        /// Details of the target Persistent Disks in Compute Engine.
        ComputeEngineDisksTargetDefaults(
            std::boxed::Box<crate::model::ComputeEngineDisksTargetDefaults>,
        ),
    }

    /// Details about the source VM.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceVmDetails {
        /// Output only. Details of the VM from a Vmware source.
        VmwareSourceVmDetails(std::boxed::Box<crate::model::VmwareSourceVmDetails>),
        /// Output only. Details of the VM from an AWS source.
        AwsSourceVmDetails(std::boxed::Box<crate::model::AwsSourceVmDetails>),
        /// Output only. Details of the VM from an Azure source.
        AzureSourceVmDetails(std::boxed::Box<crate::model::AzureSourceVmDetails>),
    }
}

/// CutoverForecast holds information about future CutoverJobs of a MigratingVm.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CutoverForecast {
    /// Output only. Estimation of the CutoverJob duration.
    pub estimated_cutover_job_duration: std::option::Option<wkt::Duration>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverForecast {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [estimated_cutover_job_duration][crate::model::CutoverForecast::estimated_cutover_job_duration].
    pub fn set_estimated_cutover_job_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.estimated_cutover_job_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [estimated_cutover_job_duration][crate::model::CutoverForecast::estimated_cutover_job_duration].
    pub fn set_or_clear_estimated_cutover_job_duration<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.estimated_cutover_job_duration = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CutoverForecast {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverForecast"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CutoverForecast {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __estimated_cutover_job_duration,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CutoverForecast")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "estimatedCutoverJobDuration" => {
                                Ok(__FieldTag::__estimated_cutover_job_duration)
                            }
                            "estimated_cutover_job_duration" => {
                                Ok(__FieldTag::__estimated_cutover_job_duration)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CutoverForecast;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CutoverForecast")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__estimated_cutover_job_duration => {
                            if !fields.insert(__FieldTag::__estimated_cutover_job_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for estimated_cutover_job_duration",
                                ));
                            }
                            result.estimated_cutover_job_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CutoverForecast {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.estimated_cutover_job_duration.is_some() {
            state.serialize_entry(
                "estimatedCutoverJobDuration",
                &self.estimated_cutover_job_duration,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CutoverForecast {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CutoverForecast");
        debug_struct.field(
            "estimated_cutover_job_duration",
            &self.estimated_cutover_job_duration,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CloneJob describes the process of creating a clone of a
/// [MigratingVM][google.cloud.vmmigration.v1.MigratingVm] to the
/// requested target based on the latest successful uploaded snapshots.
/// While the migration cycles of a MigratingVm take place, it is possible to
/// verify the uploaded VM can be started in the cloud, by creating a clone. The
/// clone can be created without any downtime, and it is created using the latest
/// snapshots which are already in the cloud. The cloneJob is only responsible
/// for its work, not its products, which means once it is finished, it will
/// never touch the instance it created. It will only delete it in case of the
/// CloneJob being cancelled or upon failure to clone.
///
/// [google.cloud.vmmigration.v1.MigratingVm]: crate::model::MigratingVm
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneJob {
    /// Output only. The time the clone job was created (as an API call, not when
    /// it was actually created in the target).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the clone job was ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the clone.
    pub name: std::string::String,

    /// Output only. State of the clone job.
    pub state: crate::model::clone_job::State,

    /// Output only. The time the state was last updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details for the errors that led to the Clone Job's
    /// state.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The clone steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CloneStep>,

    /// Details of the VM to create as the target of this clone job.
    pub target_vm_details: std::option::Option<crate::model::clone_job::TargetVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CloneJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CloneJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CloneJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::clone_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CloneJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::CloneJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CloneJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [steps][crate::model::CloneJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::clone_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }

    /// The value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// if it holds a `ComputeEngineDisksTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_disks_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::clone_job::TargetVmDetails::ComputeEngineDisksTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CloneJob::target_vm_details]
    /// to hold a `ComputeEngineDisksTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_disks_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::clone_job::TargetVmDetails::ComputeEngineDisksTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_details,
            __compute_engine_disks_target_details,
            __create_time,
            __end_time,
            __name,
            __state,
            __state_time,
            __error,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "compute_engine_target_details" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "computeEngineDisksTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_disks_target_details)
                            }
                            "compute_engine_disks_target_details" => {
                                Ok(__FieldTag::__compute_engine_disks_target_details)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CloneJob.compute_engine_target_details, latest field was computeEngineTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::clone_job::TargetVmDetails::ComputeEngineTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__compute_engine_disks_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_disks_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_disks_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CloneJob.compute_engine_disks_target_details, latest field was computeEngineDisksTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::clone_job::TargetVmDetails::ComputeEngineDisksTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::clone_job::State>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_details() {
            state.serialize_entry("computeEngineTargetDetails", value)?;
        }
        if let Some(value) = self.compute_engine_disks_target_details() {
            state.serialize_entry("computeEngineDisksTargetDetails", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloneJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneJob");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("target_vm_details", &self.target_vm_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloneJob].
pub mod clone_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the clone job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The clone job has not yet started.
        Pending,
        /// The clone job is active and running.
        Active,
        /// The clone job finished with errors.
        Failed,
        /// The clone job finished successfully.
        Succeeded,
        /// The clone job was cancelled.
        Cancelled,
        /// The clone job is being cancelled.
        Cancelling,
        /// OS adaptation is running as part of the clone job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Active => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Cancelling => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Active,
                3 => Self::Failed,
                4 => Self::Succeeded,
                5 => Self::Cancelled,
                6 => Self::Cancelling,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "ACTIVE" => Self::Active,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Active => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Cancelling => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CloneJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this clone job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
        /// Output only. Details of the target Persistent Disks in Compute Engine.
        ComputeEngineDisksTargetDetails(
            std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>,
        ),
    }
}

/// CloneStep holds information about the clone step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CloneStep {
    /// The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::clone_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CloneStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CloneStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CloneStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CloneStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<T: std::convert::Into<std::option::Option<crate::model::clone_step::Step>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `AdaptingOs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn adapting_os(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdaptingOSStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::AdaptingOs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `AdaptingOs`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_adapting_os<T: std::convert::Into<std::boxed::Box<crate::model::AdaptingOSStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(crate::model::clone_step::Step::AdaptingOs(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::clone_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CloneStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::clone_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CloneStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::clone_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CloneStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CloneStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CloneStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __adapting_os,
            __preparing_vm_disks,
            __instantiating_migrated_vm,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CloneStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "adaptingOs" => Ok(__FieldTag::__adapting_os),
                            "adapting_os" => Ok(__FieldTag::__adapting_os),
                            "preparingVmDisks" => Ok(__FieldTag::__preparing_vm_disks),
                            "preparing_vm_disks" => Ok(__FieldTag::__preparing_vm_disks),
                            "instantiatingMigratedVm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "instantiating_migrated_vm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CloneStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CloneStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__adapting_os => {
                            if !fields.insert(__FieldTag::__adapting_os) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adapting_os",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.adapting_os, latest field was adaptingOs",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::AdaptingOs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdaptingOSStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__preparing_vm_disks => {
                            if !fields.insert(__FieldTag::__preparing_vm_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preparing_vm_disks",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.preparing_vm_disks, latest field was preparingVmDisks",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::PreparingVmDisks(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PreparingVMDisksStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__instantiating_migrated_vm => {
                            if !fields.insert(__FieldTag::__instantiating_migrated_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instantiating_migrated_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CloneStep.instantiating_migrated_vm, latest field was instantiatingMigratedVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::clone_step::Step::InstantiatingMigratedVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstantiatingMigratedVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CloneStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.adapting_os() {
            state.serialize_entry("adaptingOs", value)?;
        }
        if let Some(value) = self.preparing_vm_disks() {
            state.serialize_entry("preparingVmDisks", value)?;
        }
        if let Some(value) = self.instantiating_migrated_vm() {
            state.serialize_entry("instantiatingMigratedVm", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CloneStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CloneStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CloneStep].
pub mod clone_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Adapting OS step.
        AdaptingOs(std::boxed::Box<crate::model::AdaptingOSStep>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// AdaptingOSStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AdaptingOSStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AdaptingOSStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AdaptingOSStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AdaptingOSStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AdaptingOSStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AdaptingOSStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AdaptingOSStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AdaptingOSStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AdaptingOSStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AdaptingOSStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AdaptingOSStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// PreparingVMDisksStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PreparingVMDisksStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PreparingVMDisksStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PreparingVMDisksStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PreparingVMDisksStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PreparingVMDisksStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PreparingVMDisksStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PreparingVMDisksStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PreparingVMDisksStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PreparingVMDisksStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PreparingVMDisksStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PreparingVMDisksStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// InstantiatingMigratedVMStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InstantiatingMigratedVMStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstantiatingMigratedVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InstantiatingMigratedVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InstantiatingMigratedVMStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstantiatingMigratedVMStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstantiatingMigratedVMStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstantiatingMigratedVMStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstantiatingMigratedVMStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstantiatingMigratedVMStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InstantiatingMigratedVMStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstantiatingMigratedVMStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CutoverJob message describes a cutover of a migrating VM. The CutoverJob is
/// the operation of shutting down the VM, creating a snapshot and
/// cloning the VM using the replicated snapshot.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CutoverJob {
    /// Output only. The time the cutover job was created (as an API call, not when
    /// it was actually created in the target).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the cutover job had finished.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The name of the cutover job.
    pub name: std::string::String,

    /// Output only. State of the cutover job.
    pub state: crate::model::cutover_job::State,

    /// Output only. The time the state was last updated.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current progress in percentage of the cutover job.
    pub progress_percent: i32,

    /// Output only. Provides details for the errors that led to the Cutover Job's
    /// state.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. A message providing possible extra details about the current
    /// state.
    pub state_message: std::string::String,

    /// Output only. The cutover steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::CutoverStep>,

    /// Details of the VM to create as the target of this cutover job.
    pub target_vm_details: std::option::Option<crate::model::cutover_job::TargetVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CutoverJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::CutoverJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::CutoverJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::cutover_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::CutoverJob::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [progress_percent][crate::model::CutoverJob::progress_percent].
    pub fn set_progress_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.progress_percent = v.into();
        self
    }

    /// Sets the value of [error][crate::model::CutoverJob::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::CutoverJob::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state_message][crate::model::CutoverJob::state_message].
    pub fn set_state_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.state_message = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::CutoverJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details].
    ///
    /// Note that all the setters affecting `target_vm_details` are mutually
    /// exclusive.
    pub fn set_target_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::cutover_job::TargetVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = v.into();
        self
    }

    /// The value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// if it holds a `ComputeEngineTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// to hold a `ComputeEngineTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(v.into()),
        );
        self
    }

    /// The value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// if it holds a `ComputeEngineDisksTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compute_engine_disks_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_vm_details.as_ref().and_then(|v| match v {
            crate::model::cutover_job::TargetVmDetails::ComputeEngineDisksTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_vm_details][crate::model::CutoverJob::target_vm_details]
    /// to hold a `ComputeEngineDisksTargetDetails`.
    ///
    /// Note that all the setters affecting `target_vm_details` are
    /// mutually exclusive.
    pub fn set_compute_engine_disks_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_vm_details = std::option::Option::Some(
            crate::model::cutover_job::TargetVmDetails::ComputeEngineDisksTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CutoverJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compute_engine_target_details,
            __compute_engine_disks_target_details,
            __create_time,
            __end_time,
            __name,
            __state,
            __state_time,
            __progress_percent,
            __error,
            __state_message,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CutoverJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "computeEngineTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "compute_engine_target_details" => {
                                Ok(__FieldTag::__compute_engine_target_details)
                            }
                            "computeEngineDisksTargetDetails" => {
                                Ok(__FieldTag::__compute_engine_disks_target_details)
                            }
                            "compute_engine_disks_target_details" => {
                                Ok(__FieldTag::__compute_engine_disks_target_details)
                            }
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "name" => Ok(__FieldTag::__name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "progressPercent" => Ok(__FieldTag::__progress_percent),
                            "progress_percent" => Ok(__FieldTag::__progress_percent),
                            "error" => Ok(__FieldTag::__error),
                            "stateMessage" => Ok(__FieldTag::__state_message),
                            "state_message" => Ok(__FieldTag::__state_message),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CutoverJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CutoverJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compute_engine_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverJob.compute_engine_target_details, latest field was computeEngineTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::cutover_job::TargetVmDetails::ComputeEngineTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__compute_engine_disks_target_details => {
                            if !fields.insert(__FieldTag::__compute_engine_disks_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_engine_disks_target_details",
                                ));
                            }
                            if result.target_vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverJob.compute_engine_disks_target_details, latest field was computeEngineDisksTargetDetails",
                                ));
                            }
                            result.target_vm_details = std::option::Option::Some(
                                crate::model::cutover_job::TargetVmDetails::ComputeEngineDisksTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::cutover_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__progress_percent => {
                            if !fields.insert(__FieldTag::__progress_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for progress_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.progress_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__state_message => {
                            if !fields.insert(__FieldTag::__state_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_message",
                                ));
                            }
                            result.state_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverStep>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CutoverJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compute_engine_target_details() {
            state.serialize_entry("computeEngineTargetDetails", value)?;
        }
        if let Some(value) = self.compute_engine_disks_target_details() {
            state.serialize_entry("computeEngineDisksTargetDetails", value)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if !wkt::internal::is_default(&self.progress_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("progressPercent", &__With(&self.progress_percent))?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.state_message.is_empty() {
            state.serialize_entry("stateMessage", &self.state_message)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CutoverJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CutoverJob");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("progress_percent", &self.progress_percent);
        debug_struct.field("error", &self.error);
        debug_struct.field("state_message", &self.state_message);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("target_vm_details", &self.target_vm_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CutoverJob].
pub mod cutover_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the cutover job.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The cutover job has not yet started.
        Pending,
        /// The cutover job finished with errors.
        Failed,
        /// The cutover job finished successfully.
        Succeeded,
        /// The cutover job was cancelled.
        Cancelled,
        /// The cutover job is being cancelled.
        Cancelling,
        /// The cutover job is active and running.
        Active,
        /// OS adaptation is running as part of the cutover job to generate license.
        AdaptingOs,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Cancelled => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::AdaptingOs => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::AdaptingOs => std::option::Option::Some("ADAPTING_OS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Succeeded,
                4 => Self::Cancelled,
                5 => Self::Cancelling,
                6 => Self::Active,
                7 => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "CANCELLING" => Self::Cancelling,
                "ACTIVE" => Self::Active,
                "ADAPTING_OS" => Self::AdaptingOs,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Cancelled => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::AdaptingOs => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.CutoverJob.State",
            ))
        }
    }

    /// Details of the VM to create as the target of this cutover job.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetVmDetails {
        /// Output only. Details of the target VM in Compute Engine.
        ComputeEngineTargetDetails(std::boxed::Box<crate::model::ComputeEngineTargetDetails>),
        /// Output only. Details of the target Persistent Disks in Compute Engine.
        ComputeEngineDisksTargetDetails(
            std::boxed::Box<crate::model::ComputeEngineDisksTargetDetails>,
        ),
    }
}

/// CutoverStep holds information about the cutover step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CutoverStep {
    /// The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::cutover_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CutoverStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::CutoverStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::CutoverStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::CutoverStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<
        T: std::convert::Into<std::option::Option<crate::model::cutover_step::Step>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreviousReplicationCycle`, `None` if the field is not set or
    /// holds a different branch.
    pub fn previous_replication_cycle(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreviousReplicationCycle(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreviousReplicationCycle`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_previous_replication_cycle<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::PreviousReplicationCycle(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `ShuttingDownSourceVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn shutting_down_source_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ShuttingDownSourceVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `ShuttingDownSourceVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_shutting_down_source_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::ShuttingDownSourceVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::ShuttingDownSourceVm(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `FinalSync`, `None` if the field is not set or
    /// holds a different branch.
    pub fn final_sync(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ReplicationCycle>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::FinalSync(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `FinalSync`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_final_sync<
        T: std::convert::Into<std::boxed::Box<crate::model::ReplicationCycle>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::FinalSync(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `PreparingVmDisks`, `None` if the field is not set or
    /// holds a different branch.
    pub fn preparing_vm_disks(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::PreparingVMDisksStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::PreparingVmDisks(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `PreparingVmDisks`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_preparing_vm_disks<
        T: std::convert::Into<std::boxed::Box<crate::model::PreparingVMDisksStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::cutover_step::Step::PreparingVmDisks(v.into()));
        self
    }

    /// The value of [step][crate::model::CutoverStep::step]
    /// if it holds a `InstantiatingMigratedVm`, `None` if the field is not set or
    /// holds a different branch.
    pub fn instantiating_migrated_vm(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InstantiatingMigratedVMStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::CutoverStep::step]
    /// to hold a `InstantiatingMigratedVm`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_instantiating_migrated_vm<
        T: std::convert::Into<std::boxed::Box<crate::model::InstantiatingMigratedVMStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::cutover_step::Step::InstantiatingMigratedVm(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CutoverStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CutoverStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CutoverStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __previous_replication_cycle,
            __shutting_down_source_vm,
            __final_sync,
            __preparing_vm_disks,
            __instantiating_migrated_vm,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CutoverStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "previousReplicationCycle" => {
                                Ok(__FieldTag::__previous_replication_cycle)
                            }
                            "previous_replication_cycle" => {
                                Ok(__FieldTag::__previous_replication_cycle)
                            }
                            "shuttingDownSourceVm" => Ok(__FieldTag::__shutting_down_source_vm),
                            "shutting_down_source_vm" => Ok(__FieldTag::__shutting_down_source_vm),
                            "finalSync" => Ok(__FieldTag::__final_sync),
                            "final_sync" => Ok(__FieldTag::__final_sync),
                            "preparingVmDisks" => Ok(__FieldTag::__preparing_vm_disks),
                            "preparing_vm_disks" => Ok(__FieldTag::__preparing_vm_disks),
                            "instantiatingMigratedVm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "instantiating_migrated_vm" => {
                                Ok(__FieldTag::__instantiating_migrated_vm)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CutoverStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CutoverStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__previous_replication_cycle => {
                            if !fields.insert(__FieldTag::__previous_replication_cycle) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_replication_cycle",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.previous_replication_cycle, latest field was previousReplicationCycle",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::PreviousReplicationCycle(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicationCycle>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__shutting_down_source_vm => {
                            if !fields.insert(__FieldTag::__shutting_down_source_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shutting_down_source_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.shutting_down_source_vm, latest field was shuttingDownSourceVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::ShuttingDownSourceVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ShuttingDownSourceVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__final_sync => {
                            if !fields.insert(__FieldTag::__final_sync) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for final_sync",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.final_sync, latest field was finalSync",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::FinalSync(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ReplicationCycle>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__preparing_vm_disks => {
                            if !fields.insert(__FieldTag::__preparing_vm_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for preparing_vm_disks",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.preparing_vm_disks, latest field was preparingVmDisks",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::PreparingVmDisks(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::PreparingVMDisksStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__instantiating_migrated_vm => {
                            if !fields.insert(__FieldTag::__instantiating_migrated_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instantiating_migrated_vm",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.CutoverStep.instantiating_migrated_vm, latest field was instantiatingMigratedVm",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::cutover_step::Step::InstantiatingMigratedVm(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InstantiatingMigratedVMStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CutoverStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.previous_replication_cycle() {
            state.serialize_entry("previousReplicationCycle", value)?;
        }
        if let Some(value) = self.shutting_down_source_vm() {
            state.serialize_entry("shuttingDownSourceVm", value)?;
        }
        if let Some(value) = self.final_sync() {
            state.serialize_entry("finalSync", value)?;
        }
        if let Some(value) = self.preparing_vm_disks() {
            state.serialize_entry("preparingVmDisks", value)?;
        }
        if let Some(value) = self.instantiating_migrated_vm() {
            state.serialize_entry("instantiatingMigratedVm", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CutoverStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CutoverStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CutoverStep].
pub mod cutover_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// A replication cycle prior cutover step.
        PreviousReplicationCycle(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Shutting down VM step.
        ShuttingDownSourceVm(std::boxed::Box<crate::model::ShuttingDownSourceVMStep>),
        /// Final sync step.
        FinalSync(std::boxed::Box<crate::model::ReplicationCycle>),
        /// Preparing VM disks step.
        PreparingVmDisks(std::boxed::Box<crate::model::PreparingVMDisksStep>),
        /// Instantiating migrated VM step.
        InstantiatingMigratedVm(std::boxed::Box<crate::model::InstantiatingMigratedVMStep>),
    }
}

/// ShuttingDownSourceVMStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShuttingDownSourceVMStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShuttingDownSourceVMStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ShuttingDownSourceVMStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ShuttingDownSourceVMStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShuttingDownSourceVMStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShuttingDownSourceVMStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShuttingDownSourceVMStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShuttingDownSourceVMStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShuttingDownSourceVMStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ShuttingDownSourceVMStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShuttingDownSourceVMStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCloneJobRequest {
    /// Required. The Clone's parent.
    pub parent: std::string::String,

    /// Required. The clone job identifier.
    pub clone_job_id: std::string::String,

    /// Required. The clone request body.
    pub clone_job: std::option::Option<crate::model::CloneJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCloneJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [clone_job_id][crate::model::CreateCloneJobRequest::clone_job_id].
    pub fn set_clone_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_job_id = v.into();
        self
    }

    /// Sets the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_clone_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [clone_job][crate::model::CreateCloneJobRequest::clone_job].
    pub fn set_or_clear_clone_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CloneJob>,
    {
        self.clone_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCloneJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __clone_job_id,
            __clone_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cloneJobId" => Ok(__FieldTag::__clone_job_id),
                            "clone_job_id" => Ok(__FieldTag::__clone_job_id),
                            "cloneJob" => Ok(__FieldTag::__clone_job),
                            "clone_job" => Ok(__FieldTag::__clone_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_job_id => {
                            if !fields.insert(__FieldTag::__clone_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_job_id",
                                ));
                            }
                            result.clone_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__clone_job => {
                            if !fields.insert(__FieldTag::__clone_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_job",
                                ));
                            }
                            result.clone_job =
                                map.next_value::<std::option::Option<crate::model::CloneJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.clone_job_id.is_empty() {
            state.serialize_entry("cloneJobId", &self.clone_job_id)?;
        }
        if self.clone_job.is_some() {
            state.serialize_entry("cloneJob", &self.clone_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCloneJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("clone_job_id", &self.clone_job_id);
        debug_struct.field("clone_job", &self.clone_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCloneJobRequest {
    /// Required. The clone job id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCloneJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCloneJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCloneJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCloneJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCloneJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCloneJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCloneJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCloneJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCloneJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCloneJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCloneJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCloneJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListCloneJobsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloneJobsRequest {
    /// Required. The parent, which owns this collection of source VMs.
    pub parent: std::string::String,

    /// Optional. The maximum number of clone jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 clone jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCloneJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCloneJobs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCloneJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCloneJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCloneJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCloneJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCloneJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCloneJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloneJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloneJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloneJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloneJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloneJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloneJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloneJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListCloneJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCloneJobsResponse {
    /// Output only. The list of clone jobs response.
    pub clone_jobs: std::vec::Vec<crate::model::CloneJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCloneJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_jobs][crate::model::ListCloneJobsResponse::clone_jobs].
    pub fn set_clone_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CloneJob>,
    {
        use std::iter::Iterator;
        self.clone_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCloneJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCloneJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCloneJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCloneJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCloneJobsResponse {
    type PageItem = crate::model::CloneJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.clone_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCloneJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __clone_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCloneJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloneJobs" => Ok(__FieldTag::__clone_jobs),
                            "clone_jobs" => Ok(__FieldTag::__clone_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCloneJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCloneJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__clone_jobs => {
                            if !fields.insert(__FieldTag::__clone_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clone_jobs",
                                ));
                            }
                            result.clone_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CloneJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCloneJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.clone_jobs.is_empty() {
            state.serialize_entry("cloneJobs", &self.clone_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCloneJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCloneJobsResponse");
        debug_struct.field("clone_jobs", &self.clone_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetCloneJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCloneJobRequest {
    /// Required. The name of the CloneJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCloneJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCloneJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCloneJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCloneJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCloneJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCloneJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCloneJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCloneJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCloneJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCloneJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCloneJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Source message describes a specific vm migration Source resource. It contains
/// the source environment information.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Source {
    /// Output only. The Source name.
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// The labels of the source.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// User-provided description of the source.
    pub description: std::string::String,

    /// Optional. Immutable. The encryption details of the source data stored by
    /// the service.
    pub encryption: std::option::Option<crate::model::Encryption>,

    pub source_details: std::option::Option<crate::model::source::SourceDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Source {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Source::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Source::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Source::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Source::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Source::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Source::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [description][crate::model::Source::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::Source::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::Source::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_details][crate::model::Source::source_details].
    ///
    /// Note that all the setters affecting `source_details` are mutually
    /// exclusive.
    pub fn set_source_details<
        T: std::convert::Into<std::option::Option<crate::model::source::SourceDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_details = v.into();
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Vmware`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Vmware(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Vmware`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_vmware<T: std::convert::Into<std::boxed::Box<crate::model::VmwareSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Vmware(v.into()));
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Aws`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Aws(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Aws`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_aws<T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Aws(v.into()));
        self
    }

    /// The value of [source_details][crate::model::Source::source_details]
    /// if it holds a `Azure`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure(&self) -> std::option::Option<&std::boxed::Box<crate::model::AzureSourceDetails>> {
        #[allow(unreachable_patterns)]
        self.source_details.as_ref().and_then(|v| match v {
            crate::model::source::SourceDetails::Azure(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_details][crate::model::Source::source_details]
    /// to hold a `Azure`.
    ///
    /// Note that all the setters affecting `source_details` are
    /// mutually exclusive.
    pub fn set_azure<T: std::convert::Into<std::boxed::Box<crate::model::AzureSourceDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_details =
            std::option::Option::Some(crate::model::source::SourceDetails::Azure(v.into()));
        self
    }
}

impl wkt::message::Message for Source {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Source"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Source {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware,
            __aws,
            __azure,
            __name,
            __create_time,
            __update_time,
            __labels,
            __description,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Source")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmware" => Ok(__FieldTag::__vmware),
                            "aws" => Ok(__FieldTag::__aws),
                            "azure" => Ok(__FieldTag::__azure),
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "labels" => Ok(__FieldTag::__labels),
                            "description" => Ok(__FieldTag::__description),
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Source;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Source")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware => {
                            if !fields.insert(__FieldTag::__vmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware",
                                ));
                            }
                            if result.source_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_details`, a oneof with full ID .google.cloud.vmmigration.v1.Source.vmware, latest field was vmware",
                                ));
                            }
                            result.source_details = std::option::Option::Some(
                                crate::model::source::SourceDetails::Vmware(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws => {
                            if !fields.insert(__FieldTag::__aws) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws",
                                ));
                            }
                            if result.source_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_details`, a oneof with full ID .google.cloud.vmmigration.v1.Source.aws, latest field was aws",
                                ));
                            }
                            result.source_details = std::option::Option::Some(
                                crate::model::source::SourceDetails::Aws(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure => {
                            if !fields.insert(__FieldTag::__azure) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure",
                                ));
                            }
                            if result.source_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_details`, a oneof with full ID .google.cloud.vmmigration.v1.Source.azure, latest field was azure",
                                ));
                            }
                            result.source_details = std::option::Option::Some(
                                crate::model::source::SourceDetails::Azure(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureSourceDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Source {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware() {
            state.serialize_entry("vmware", value)?;
        }
        if let Some(value) = self.aws() {
            state.serialize_entry("aws", value)?;
        }
        if let Some(value) = self.azure() {
            state.serialize_entry("azure", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Source {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Source");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("description", &self.description);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("source_details", &self.source_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Source].
pub mod source {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceDetails {
        /// Vmware type source details.
        Vmware(std::boxed::Box<crate::model::VmwareSourceDetails>),
        /// AWS type source details.
        Aws(std::boxed::Box<crate::model::AwsSourceDetails>),
        /// Azure type source details.
        Azure(std::boxed::Box<crate::model::AzureSourceDetails>),
    }
}

/// Encryption message describes the details of the applied encryption.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Encryption {
    /// Required. The name of the encryption key that is stored in Google Cloud
    /// KMS.
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Encryption {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key][crate::model::Encryption::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for Encryption {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Encryption"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Encryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Encryption")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Encryption;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Encryption")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Encryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Encryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Encryption");
        debug_struct.field("kms_key", &self.kms_key);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VmwareSourceDetails message describes a specific source details for the
/// vmware source type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareSourceDetails {
    /// The credentials username.
    pub username: std::string::String,

    /// Input only. The credentials password. This is write only and can not be
    /// read in a GET operation.
    pub password: std::string::String,

    /// The ip address of the vcenter this Source represents.
    pub vcenter_ip: std::string::String,

    /// The thumbprint representing the certificate for the vcenter.
    pub thumbprint: std::string::String,

    /// The hostname of the vcenter.
    pub resolved_vcenter_host: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [username][crate::model::VmwareSourceDetails::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }

    /// Sets the value of [password][crate::model::VmwareSourceDetails::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }

    /// Sets the value of [vcenter_ip][crate::model::VmwareSourceDetails::vcenter_ip].
    pub fn set_vcenter_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vcenter_ip = v.into();
        self
    }

    /// Sets the value of [thumbprint][crate::model::VmwareSourceDetails::thumbprint].
    pub fn set_thumbprint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.thumbprint = v.into();
        self
    }

    /// Sets the value of [resolved_vcenter_host][crate::model::VmwareSourceDetails::resolved_vcenter_host].
    pub fn set_resolved_vcenter_host<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_vcenter_host = v.into();
        self
    }
}

impl wkt::message::Message for VmwareSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __username,
            __password,
            __vcenter_ip,
            __thumbprint,
            __resolved_vcenter_host,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "username" => Ok(__FieldTag::__username),
                            "password" => Ok(__FieldTag::__password),
                            "vcenterIp" => Ok(__FieldTag::__vcenter_ip),
                            "vcenter_ip" => Ok(__FieldTag::__vcenter_ip),
                            "thumbprint" => Ok(__FieldTag::__thumbprint),
                            "resolvedVcenterHost" => Ok(__FieldTag::__resolved_vcenter_host),
                            "resolved_vcenter_host" => Ok(__FieldTag::__resolved_vcenter_host),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__username => {
                            if !fields.insert(__FieldTag::__username) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for username",
                                ));
                            }
                            result.username = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcenter_ip => {
                            if !fields.insert(__FieldTag::__vcenter_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcenter_ip",
                                ));
                            }
                            result.vcenter_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__thumbprint => {
                            if !fields.insert(__FieldTag::__thumbprint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for thumbprint",
                                ));
                            }
                            result.thumbprint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resolved_vcenter_host => {
                            if !fields.insert(__FieldTag::__resolved_vcenter_host) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_vcenter_host",
                                ));
                            }
                            result.resolved_vcenter_host = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.username.is_empty() {
            state.serialize_entry("username", &self.username)?;
        }
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self.vcenter_ip.is_empty() {
            state.serialize_entry("vcenterIp", &self.vcenter_ip)?;
        }
        if !self.thumbprint.is_empty() {
            state.serialize_entry("thumbprint", &self.thumbprint)?;
        }
        if !self.resolved_vcenter_host.is_empty() {
            state.serialize_entry("resolvedVcenterHost", &self.resolved_vcenter_host)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareSourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareSourceDetails");
        debug_struct.field("username", &self.username);
        debug_struct.field("password", &self.password);
        debug_struct.field("vcenter_ip", &self.vcenter_ip);
        debug_struct.field("thumbprint", &self.thumbprint);
        debug_struct.field("resolved_vcenter_host", &self.resolved_vcenter_host);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AwsSourceDetails message describes a specific source details for the
/// AWS source type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSourceDetails {
    /// Immutable. The AWS region that the source VMs will be migrated from.
    pub aws_region: std::string::String,

    /// Output only. State of the source as determined by the health check.
    pub state: crate::model::aws_source_details::State,

    /// Output only. Provides details on the state of the Source in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// AWS resource tags to limit the scope of the source inventory.
    pub inventory_tag_list: std::vec::Vec<crate::model::aws_source_details::Tag>,

    /// AWS security group names to limit the scope of the source
    /// inventory.
    pub inventory_security_group_names: std::vec::Vec<std::string::String>,

    /// User specified tags to add to every M2VM generated resource in AWS.
    /// These tags will be set in addition to the default tags that are set as part
    /// of the migration process. The tags must not begin with the reserved prefix
    /// `m2vm`.
    pub migration_resources_user_tags:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The source's public IP. All communication initiated by this
    /// source will originate from this IP.
    pub public_ip: std::string::String,

    pub credentials_type: std::option::Option<crate::model::aws_source_details::CredentialsType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [aws_region][crate::model::AwsSourceDetails::aws_region].
    pub fn set_aws_region<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.aws_region = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AwsSourceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::aws_source_details::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AwsSourceDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [inventory_tag_list][crate::model::AwsSourceDetails::inventory_tag_list].
    pub fn set_inventory_tag_list<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::aws_source_details::Tag>,
    {
        use std::iter::Iterator;
        self.inventory_tag_list = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [inventory_security_group_names][crate::model::AwsSourceDetails::inventory_security_group_names].
    pub fn set_inventory_security_group_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.inventory_security_group_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [migration_resources_user_tags][crate::model::AwsSourceDetails::migration_resources_user_tags].
    pub fn set_migration_resources_user_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.migration_resources_user_tags =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [public_ip][crate::model::AwsSourceDetails::public_ip].
    pub fn set_public_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.public_ip = v.into();
        self
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type].
    ///
    /// Note that all the setters affecting `credentials_type` are mutually
    /// exclusive.
    pub fn set_credentials_type<
        T: std::convert::Into<std::option::Option<crate::model::aws_source_details::CredentialsType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = v.into();
        self
    }

    /// The value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// if it holds a `AccessKeyCreds`, `None` if the field is not set or
    /// holds a different branch.
    pub fn access_key_creds(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>
    {
        #[allow(unreachable_patterns)]
        self.credentials_type.as_ref().and_then(|v| match v {
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials_type][crate::model::AwsSourceDetails::credentials_type]
    /// to hold a `AccessKeyCreds`.
    ///
    /// Note that all the setters affecting `credentials_type` are
    /// mutually exclusive.
    pub fn set_access_key_creds<
        T: std::convert::Into<std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = std::option::Option::Some(
            crate::model::aws_source_details::CredentialsType::AccessKeyCreds(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AwsSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __access_key_creds,
            __aws_region,
            __state,
            __error,
            __inventory_tag_list,
            __inventory_security_group_names,
            __migration_resources_user_tags,
            __public_ip,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "accessKeyCreds" => Ok(__FieldTag::__access_key_creds),
                            "access_key_creds" => Ok(__FieldTag::__access_key_creds),
                            "awsRegion" => Ok(__FieldTag::__aws_region),
                            "aws_region" => Ok(__FieldTag::__aws_region),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "inventoryTagList" => Ok(__FieldTag::__inventory_tag_list),
                            "inventory_tag_list" => Ok(__FieldTag::__inventory_tag_list),
                            "inventorySecurityGroupNames" => {
                                Ok(__FieldTag::__inventory_security_group_names)
                            }
                            "inventory_security_group_names" => {
                                Ok(__FieldTag::__inventory_security_group_names)
                            }
                            "migrationResourcesUserTags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "migration_resources_user_tags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "publicIp" => Ok(__FieldTag::__public_ip),
                            "public_ip" => Ok(__FieldTag::__public_ip),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__access_key_creds => {
                            if !fields.insert(__FieldTag::__access_key_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for access_key_creds",
                                ));
                            }
                            if result.credentials_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credentials_type`, a oneof with full ID .google.cloud.vmmigration.v1.AwsSourceDetails.access_key_creds, latest field was accessKeyCreds",
                                ));
                            }
                            result.credentials_type = std::option::Option::Some(
                                crate::model::aws_source_details::CredentialsType::AccessKeyCreds(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::aws_source_details::AccessKeyCredentials,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_region => {
                            if !fields.insert(__FieldTag::__aws_region) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_region",
                                ));
                            }
                            result.aws_region = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::aws_source_details::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__inventory_tag_list => {
                            if !fields.insert(__FieldTag::__inventory_tag_list) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory_tag_list",
                                ));
                            }
                            result.inventory_tag_list = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::aws_source_details::Tag>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__inventory_security_group_names => {
                            if !fields.insert(__FieldTag::__inventory_security_group_names) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for inventory_security_group_names",
                                ));
                            }
                            result.inventory_security_group_names = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__migration_resources_user_tags => {
                            if !fields.insert(__FieldTag::__migration_resources_user_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_resources_user_tags",
                                ));
                            }
                            result.migration_resources_user_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__public_ip => {
                            if !fields.insert(__FieldTag::__public_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for public_ip",
                                ));
                            }
                            result.public_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.access_key_creds() {
            state.serialize_entry("accessKeyCreds", value)?;
        }
        if !self.aws_region.is_empty() {
            state.serialize_entry("awsRegion", &self.aws_region)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.inventory_tag_list.is_empty() {
            state.serialize_entry("inventoryTagList", &self.inventory_tag_list)?;
        }
        if !self.inventory_security_group_names.is_empty() {
            state.serialize_entry(
                "inventorySecurityGroupNames",
                &self.inventory_security_group_names,
            )?;
        }
        if !self.migration_resources_user_tags.is_empty() {
            state.serialize_entry(
                "migrationResourcesUserTags",
                &self.migration_resources_user_tags,
            )?;
        }
        if !self.public_ip.is_empty() {
            state.serialize_entry("publicIp", &self.public_ip)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSourceDetails");
        debug_struct.field("aws_region", &self.aws_region);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("inventory_tag_list", &self.inventory_tag_list);
        debug_struct.field(
            "inventory_security_group_names",
            &self.inventory_security_group_names,
        );
        debug_struct.field(
            "migration_resources_user_tags",
            &self.migration_resources_user_tags,
        );
        debug_struct.field("public_ip", &self.public_ip);
        debug_struct.field("credentials_type", &self.credentials_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsSourceDetails].
pub mod aws_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing AWS Credentials using access key id and secret.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AccessKeyCredentials {
        /// AWS access key ID.
        pub access_key_id: std::string::String,

        /// Input only. AWS secret access key.
        pub secret_access_key: std::string::String,

        /// Input only. AWS session token.
        /// Used only when AWS security token service (STS) is responsible for
        /// creating the temporary credentials.
        pub session_token: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AccessKeyCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_key_id][crate::model::aws_source_details::AccessKeyCredentials::access_key_id].
        pub fn set_access_key_id<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_key_id = v.into();
            self
        }

        /// Sets the value of [secret_access_key][crate::model::aws_source_details::AccessKeyCredentials::secret_access_key].
        pub fn set_secret_access_key<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.secret_access_key = v.into();
            self
        }

        /// Sets the value of [session_token][crate::model::aws_source_details::AccessKeyCredentials::session_token].
        pub fn set_session_token<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.session_token = v.into();
            self
        }
    }

    impl wkt::message::Message for AccessKeyCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.AccessKeyCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AccessKeyCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __access_key_id,
                __secret_access_key,
                __session_token,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AccessKeyCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accessKeyId" => Ok(__FieldTag::__access_key_id),
                                "access_key_id" => Ok(__FieldTag::__access_key_id),
                                "secretAccessKey" => Ok(__FieldTag::__secret_access_key),
                                "secret_access_key" => Ok(__FieldTag::__secret_access_key),
                                "sessionToken" => Ok(__FieldTag::__session_token),
                                "session_token" => Ok(__FieldTag::__session_token),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AccessKeyCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AccessKeyCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__access_key_id => {
                                if !fields.insert(__FieldTag::__access_key_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_key_id",
                                    ));
                                }
                                result.access_key_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__secret_access_key => {
                                if !fields.insert(__FieldTag::__secret_access_key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for secret_access_key",
                                    ));
                                }
                                result.secret_access_key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__session_token => {
                                if !fields.insert(__FieldTag::__session_token) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for session_token",
                                    ));
                                }
                                result.session_token = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AccessKeyCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.access_key_id.is_empty() {
                state.serialize_entry("accessKeyId", &self.access_key_id)?;
            }
            if !self.secret_access_key.is_empty() {
                state.serialize_entry("secretAccessKey", &self.secret_access_key)?;
            }
            if !self.session_token.is_empty() {
                state.serialize_entry("sessionToken", &self.session_token)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AccessKeyCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AccessKeyCredentials");
            debug_struct.field("access_key_id", &self.access_key_id);
            debug_struct.field("secret_access_key", &self.secret_access_key);
            debug_struct.field("session_token", &self.session_token);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Tag is an AWS tag representation.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Tag {
        /// Required. Key of tag.
        pub key: std::string::String,

        /// Required. Value of tag.
        pub value: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Tag {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [key][crate::model::aws_source_details::Tag::key].
        pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.key = v.into();
            self
        }

        /// Sets the value of [value][crate::model::aws_source_details::Tag::value].
        pub fn set_value<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.value = v.into();
            self
        }
    }

    impl wkt::message::Message for Tag {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDetails.Tag"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Tag {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __key,
                __value,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Tag")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "key" => Ok(__FieldTag::__key),
                                "value" => Ok(__FieldTag::__value),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Tag;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Tag")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__key => {
                                if !fields.insert(__FieldTag::__key) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for key",
                                    ));
                                }
                                result.key = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__value => {
                                if !fields.insert(__FieldTag::__value) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for value",
                                    ));
                                }
                                result.value = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Tag {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.key.is_empty() {
                state.serialize_entry("key", &self.key)?;
            }
            if !self.value.is_empty() {
                state.serialize_entry("value", &self.value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Tag {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Tag");
            debug_struct.field("key", &self.key);
            debug_struct.field("value", &self.value);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source is available but might not be usable yet due to invalid
        /// credentials or another reason.
        /// The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.AwsSourceDetails.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CredentialsType {
        /// AWS Credentials using access key id and secret.
        AccessKeyCreds(std::boxed::Box<crate::model::aws_source_details::AccessKeyCredentials>),
    }
}

/// AzureSourceDetails message describes a specific source details for the
/// Azure source type.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureSourceDetails {
    /// Immutable. Azure subscription ID.
    pub subscription_id: std::string::String,

    /// Immutable. The Azure location (region) that the source VMs will be migrated
    /// from.
    pub azure_location: std::string::String,

    /// Output only. State of the source as determined by the health check.
    pub state: crate::model::azure_source_details::State,

    /// Output only. Provides details on the state of the Source in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// User specified tags to add to every M2VM generated resource in Azure.
    /// These tags will be set in addition to the default tags that are set as part
    /// of the migration process. The tags must not begin with the reserved prefix
    /// `m4ce` or `m2vm`.
    pub migration_resources_user_tags:
        std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. The ID of the Azure resource group that contains all resources
    /// related to the migration process of this source.
    pub resource_group_id: std::string::String,

    pub credentials_type: std::option::Option<crate::model::azure_source_details::CredentialsType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureSourceDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [subscription_id][crate::model::AzureSourceDetails::subscription_id].
    pub fn set_subscription_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subscription_id = v.into();
        self
    }

    /// Sets the value of [azure_location][crate::model::AzureSourceDetails::azure_location].
    pub fn set_azure_location<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.azure_location = v.into();
        self
    }

    /// Sets the value of [state][crate::model::AzureSourceDetails::state].
    pub fn set_state<T: std::convert::Into<crate::model::azure_source_details::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::AzureSourceDetails::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::AzureSourceDetails::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migration_resources_user_tags][crate::model::AzureSourceDetails::migration_resources_user_tags].
    pub fn set_migration_resources_user_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.migration_resources_user_tags =
            v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [resource_group_id][crate::model::AzureSourceDetails::resource_group_id].
    pub fn set_resource_group_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resource_group_id = v.into();
        self
    }

    /// Sets the value of [credentials_type][crate::model::AzureSourceDetails::credentials_type].
    ///
    /// Note that all the setters affecting `credentials_type` are mutually
    /// exclusive.
    pub fn set_credentials_type<
        T: std::convert::Into<
                std::option::Option<crate::model::azure_source_details::CredentialsType>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = v.into();
        self
    }

    /// The value of [credentials_type][crate::model::AzureSourceDetails::credentials_type]
    /// if it holds a `ClientSecretCreds`, `None` if the field is not set or
    /// holds a different branch.
    pub fn client_secret_creds(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::azure_source_details::ClientSecretCredentials>,
    > {
        #[allow(unreachable_patterns)]
        self.credentials_type.as_ref().and_then(|v| match v {
            crate::model::azure_source_details::CredentialsType::ClientSecretCreds(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [credentials_type][crate::model::AzureSourceDetails::credentials_type]
    /// to hold a `ClientSecretCreds`.
    ///
    /// Note that all the setters affecting `credentials_type` are
    /// mutually exclusive.
    pub fn set_client_secret_creds<
        T: std::convert::Into<
                std::boxed::Box<crate::model::azure_source_details::ClientSecretCredentials>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.credentials_type = std::option::Option::Some(
            crate::model::azure_source_details::CredentialsType::ClientSecretCreds(v.into()),
        );
        self
    }
}

impl wkt::message::Message for AzureSourceDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AzureSourceDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureSourceDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __client_secret_creds,
            __subscription_id,
            __azure_location,
            __state,
            __error,
            __migration_resources_user_tags,
            __resource_group_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureSourceDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "clientSecretCreds" => Ok(__FieldTag::__client_secret_creds),
                            "client_secret_creds" => Ok(__FieldTag::__client_secret_creds),
                            "subscriptionId" => Ok(__FieldTag::__subscription_id),
                            "subscription_id" => Ok(__FieldTag::__subscription_id),
                            "azureLocation" => Ok(__FieldTag::__azure_location),
                            "azure_location" => Ok(__FieldTag::__azure_location),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "migrationResourcesUserTags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "migration_resources_user_tags" => {
                                Ok(__FieldTag::__migration_resources_user_tags)
                            }
                            "resourceGroupId" => Ok(__FieldTag::__resource_group_id),
                            "resource_group_id" => Ok(__FieldTag::__resource_group_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureSourceDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureSourceDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__client_secret_creds => {
                            if !fields.insert(__FieldTag::__client_secret_creds) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for client_secret_creds",
                                ));
                            }
                            if result.credentials_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `credentials_type`, a oneof with full ID .google.cloud.vmmigration.v1.AzureSourceDetails.client_secret_creds, latest field was clientSecretCreds",
                                ));
                            }
                            result.credentials_type = std::option::Option::Some(
                                crate::model::azure_source_details::CredentialsType::ClientSecretCreds(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::azure_source_details::ClientSecretCredentials>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__subscription_id => {
                            if !fields.insert(__FieldTag::__subscription_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subscription_id",
                                ));
                            }
                            result.subscription_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__azure_location => {
                            if !fields.insert(__FieldTag::__azure_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_location",
                                ));
                            }
                            result.azure_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::azure_source_details::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__migration_resources_user_tags => {
                            if !fields.insert(__FieldTag::__migration_resources_user_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_resources_user_tags",
                                ));
                            }
                            result.migration_resources_user_tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__resource_group_id => {
                            if !fields.insert(__FieldTag::__resource_group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resource_group_id",
                                ));
                            }
                            result.resource_group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureSourceDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.client_secret_creds() {
            state.serialize_entry("clientSecretCreds", value)?;
        }
        if !self.subscription_id.is_empty() {
            state.serialize_entry("subscriptionId", &self.subscription_id)?;
        }
        if !self.azure_location.is_empty() {
            state.serialize_entry("azureLocation", &self.azure_location)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.migration_resources_user_tags.is_empty() {
            state.serialize_entry(
                "migrationResourcesUserTags",
                &self.migration_resources_user_tags,
            )?;
        }
        if !self.resource_group_id.is_empty() {
            state.serialize_entry("resourceGroupId", &self.resource_group_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureSourceDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureSourceDetails");
        debug_struct.field("subscription_id", &self.subscription_id);
        debug_struct.field("azure_location", &self.azure_location);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field(
            "migration_resources_user_tags",
            &self.migration_resources_user_tags,
        );
        debug_struct.field("resource_group_id", &self.resource_group_id);
        debug_struct.field("credentials_type", &self.credentials_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AzureSourceDetails].
pub mod azure_source_details {
    #[allow(unused_imports)]
    use super::*;

    /// Message describing Azure Credentials using tenant ID, client ID and secret.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ClientSecretCredentials {
        /// Azure tenant ID.
        pub tenant_id: std::string::String,

        /// Azure client ID.
        pub client_id: std::string::String,

        /// Input only. Azure client secret.
        pub client_secret: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ClientSecretCredentials {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [tenant_id][crate::model::azure_source_details::ClientSecretCredentials::tenant_id].
        pub fn set_tenant_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.tenant_id = v.into();
            self
        }

        /// Sets the value of [client_id][crate::model::azure_source_details::ClientSecretCredentials::client_id].
        pub fn set_client_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.client_id = v.into();
            self
        }

        /// Sets the value of [client_secret][crate::model::azure_source_details::ClientSecretCredentials::client_secret].
        pub fn set_client_secret<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.client_secret = v.into();
            self
        }
    }

    impl wkt::message::Message for ClientSecretCredentials {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AzureSourceDetails.ClientSecretCredentials"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ClientSecretCredentials {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __tenant_id,
                __client_id,
                __client_secret,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ClientSecretCredentials")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "tenantId" => Ok(__FieldTag::__tenant_id),
                                "tenant_id" => Ok(__FieldTag::__tenant_id),
                                "clientId" => Ok(__FieldTag::__client_id),
                                "client_id" => Ok(__FieldTag::__client_id),
                                "clientSecret" => Ok(__FieldTag::__client_secret),
                                "client_secret" => Ok(__FieldTag::__client_secret),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ClientSecretCredentials;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ClientSecretCredentials")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__tenant_id => {
                                if !fields.insert(__FieldTag::__tenant_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tenant_id",
                                    ));
                                }
                                result.tenant_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_id => {
                                if !fields.insert(__FieldTag::__client_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_id",
                                    ));
                                }
                                result.client_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__client_secret => {
                                if !fields.insert(__FieldTag::__client_secret) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for client_secret",
                                    ));
                                }
                                result.client_secret = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ClientSecretCredentials {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.tenant_id.is_empty() {
                state.serialize_entry("tenantId", &self.tenant_id)?;
            }
            if !self.client_id.is_empty() {
                state.serialize_entry("clientId", &self.client_id)?;
            }
            if !self.client_secret.is_empty() {
                state.serialize_entry("clientSecret", &self.client_secret)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for ClientSecretCredentials {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("ClientSecretCredentials");
            debug_struct.field("tenant_id", &self.tenant_id);
            debug_struct.field("client_id", &self.client_id);
            debug_struct.field("client_secret", &self.client_secret);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source is available but might not be usable yet due to invalid
        /// credentials or another reason.
        /// The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Active => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Failed,
                3 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Active => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.AzureSourceDetails.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CredentialsType {
        /// Azure Credentials using tenant ID, client ID and secret.
        ClientSecretCreds(
            std::boxed::Box<crate::model::azure_source_details::ClientSecretCredentials>,
        ),
    }
}

/// DatacenterConnector message describes a connector between the Source and
/// Google Cloud, which is installed on a vmware datacenter (an OVA vm installed
/// by the user) to connect the Datacenter to Google Cloud and support vm
/// migration data transfer.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DatacenterConnector {
    /// Output only. The time the connector was created (as an API call, not when
    /// it was actually installed).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the connector was updated with an API call.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The connector's name.
    pub name: std::string::String,

    /// Immutable. A unique key for this connector. This key is internal to the OVA
    /// connector and is supplied with its creation during the registration process
    /// and can not be modified.
    pub registration_id: std::string::String,

    /// The service account to use in the connector when communicating with the
    /// cloud.
    pub service_account: std::string::String,

    /// The version running in the DatacenterConnector. This is supplied by the OVA
    /// connector during the registration process and can not be modified.
    pub version: std::string::String,

    /// Output only. The communication channel between the datacenter connector and
    /// Google Cloud.
    pub bucket: std::string::String,

    /// Output only. State of the DatacenterConnector, as determined by the health
    /// checks.
    pub state: crate::model::datacenter_connector::State,

    /// Output only. The time the state was last set.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the Datacenter Connector in
    /// case of an error.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. Appliance OVA version.
    /// This is the OVA which is manually installed by the user and contains the
    /// infrastructure for the automatically updatable components on the appliance.
    pub appliance_infrastructure_version: std::string::String,

    /// Output only. Appliance last installed update bundle version.
    /// This is the version of the automatically updatable components on the
    /// appliance.
    pub appliance_software_version: std::string::String,

    /// Output only. The available versions for updating this appliance.
    pub available_versions: std::option::Option<crate::model::AvailableUpdates>,

    /// Output only. The status of the current / last upgradeAppliance operation.
    pub upgrade_status: std::option::Option<crate::model::UpgradeStatus>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DatacenterConnector {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DatacenterConnector::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DatacenterConnector::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [name][crate::model::DatacenterConnector::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [registration_id][crate::model::DatacenterConnector::registration_id].
    pub fn set_registration_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.registration_id = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::DatacenterConnector::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [version][crate::model::DatacenterConnector::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [bucket][crate::model::DatacenterConnector::bucket].
    pub fn set_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.bucket = v.into();
        self
    }

    /// Sets the value of [state][crate::model::DatacenterConnector::state].
    pub fn set_state<T: std::convert::Into<crate::model::datacenter_connector::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::DatacenterConnector::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::DatacenterConnector::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [appliance_infrastructure_version][crate::model::DatacenterConnector::appliance_infrastructure_version].
    pub fn set_appliance_infrastructure_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_infrastructure_version = v.into();
        self
    }

    /// Sets the value of [appliance_software_version][crate::model::DatacenterConnector::appliance_software_version].
    pub fn set_appliance_software_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.appliance_software_version = v.into();
        self
    }

    /// Sets the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_available_versions<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [available_versions][crate::model::DatacenterConnector::available_versions].
    pub fn set_or_clear_available_versions<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AvailableUpdates>,
    {
        self.available_versions = v.map(|x| x.into());
        self
    }

    /// Sets the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_upgrade_status<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [upgrade_status][crate::model::DatacenterConnector::upgrade_status].
    pub fn set_or_clear_upgrade_status<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UpgradeStatus>,
    {
        self.upgrade_status = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DatacenterConnector {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DatacenterConnector"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DatacenterConnector {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __update_time,
            __name,
            __registration_id,
            __service_account,
            __version,
            __bucket,
            __state,
            __state_time,
            __error,
            __appliance_infrastructure_version,
            __appliance_software_version,
            __available_versions,
            __upgrade_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DatacenterConnector")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "name" => Ok(__FieldTag::__name),
                            "registrationId" => Ok(__FieldTag::__registration_id),
                            "registration_id" => Ok(__FieldTag::__registration_id),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "version" => Ok(__FieldTag::__version),
                            "bucket" => Ok(__FieldTag::__bucket),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "applianceInfrastructureVersion" => {
                                Ok(__FieldTag::__appliance_infrastructure_version)
                            }
                            "appliance_infrastructure_version" => {
                                Ok(__FieldTag::__appliance_infrastructure_version)
                            }
                            "applianceSoftwareVersion" => {
                                Ok(__FieldTag::__appliance_software_version)
                            }
                            "appliance_software_version" => {
                                Ok(__FieldTag::__appliance_software_version)
                            }
                            "availableVersions" => Ok(__FieldTag::__available_versions),
                            "available_versions" => Ok(__FieldTag::__available_versions),
                            "upgradeStatus" => Ok(__FieldTag::__upgrade_status),
                            "upgrade_status" => Ok(__FieldTag::__upgrade_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DatacenterConnector;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DatacenterConnector")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__registration_id => {
                            if !fields.insert(__FieldTag::__registration_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for registration_id",
                                ));
                            }
                            result.registration_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bucket => {
                            if !fields.insert(__FieldTag::__bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bucket",
                                ));
                            }
                            result.bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::datacenter_connector::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__appliance_infrastructure_version => {
                            if !fields.insert(__FieldTag::__appliance_infrastructure_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance_infrastructure_version",
                                ));
                            }
                            result.appliance_infrastructure_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__appliance_software_version => {
                            if !fields.insert(__FieldTag::__appliance_software_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for appliance_software_version",
                                ));
                            }
                            result.appliance_software_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__available_versions => {
                            if !fields.insert(__FieldTag::__available_versions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for available_versions",
                                ));
                            }
                            result.available_versions = map
                                .next_value::<std::option::Option<crate::model::AvailableUpdates>>(
                                )?;
                        }
                        __FieldTag::__upgrade_status => {
                            if !fields.insert(__FieldTag::__upgrade_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_status",
                                ));
                            }
                            result.upgrade_status = map
                                .next_value::<std::option::Option<crate::model::UpgradeStatus>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DatacenterConnector {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.registration_id.is_empty() {
            state.serialize_entry("registrationId", &self.registration_id)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.bucket.is_empty() {
            state.serialize_entry("bucket", &self.bucket)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if !self.appliance_infrastructure_version.is_empty() {
            state.serialize_entry(
                "applianceInfrastructureVersion",
                &self.appliance_infrastructure_version,
            )?;
        }
        if !self.appliance_software_version.is_empty() {
            state.serialize_entry("applianceSoftwareVersion", &self.appliance_software_version)?;
        }
        if self.available_versions.is_some() {
            state.serialize_entry("availableVersions", &self.available_versions)?;
        }
        if self.upgrade_status.is_some() {
            state.serialize_entry("upgradeStatus", &self.upgrade_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DatacenterConnector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DatacenterConnector");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("name", &self.name);
        debug_struct.field("registration_id", &self.registration_id);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("version", &self.version);
        debug_struct.field("bucket", &self.bucket);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field(
            "appliance_infrastructure_version",
            &self.appliance_infrastructure_version,
        );
        debug_struct.field(
            "appliance_software_version",
            &self.appliance_software_version,
        );
        debug_struct.field("available_versions", &self.available_versions);
        debug_struct.field("upgrade_status", &self.upgrade_status);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DatacenterConnector].
pub mod datacenter_connector {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This is used for API compatibility only and is not
        /// used by the system.
        Unspecified,
        /// The state was not sampled by the health checks yet.
        Pending,
        /// The source was sampled by health checks and is not available.
        Offline,
        /// The source is available but might not be usable yet due to unvalidated
        /// credentials or another reason. The credentials referred to are the ones
        /// to the Source. The error message will contain further details.
        Failed,
        /// The source exists and its credentials were verified.
        Active,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Offline => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::Active => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Offline => std::option::Option::Some("OFFLINE"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Offline,
                3 => Self::Failed,
                4 => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "OFFLINE" => Self::Offline,
                "FAILED" => Self::Failed,
                "ACTIVE" => Self::Active,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Offline => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::Active => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.DatacenterConnector.State",
            ))
        }
    }
}

/// UpgradeStatus contains information about upgradeAppliance operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeStatus {
    /// The version to upgrade to.
    pub version: std::string::String,

    /// The state of the upgradeAppliance operation.
    pub state: crate::model::upgrade_status::State,

    /// Output only. Provides details on the state of the upgrade operation in case
    /// of an error.
    pub error: std::option::Option<rpc::model::Status>,

    /// The time the operation was started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// The version from which we upgraded.
    pub previous_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeStatus {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::UpgradeStatus::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeStatus::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_status::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UpgradeStatus::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::UpgradeStatus::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [previous_version][crate::model::UpgradeStatus::previous_version].
    pub fn set_previous_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.previous_version = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeStatus {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeStatus"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeStatus {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __state,
            __error,
            __start_time,
            __previous_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeStatus")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "state" => Ok(__FieldTag::__state),
                            "error" => Ok(__FieldTag::__error),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "previousVersion" => Ok(__FieldTag::__previous_version),
                            "previous_version" => Ok(__FieldTag::__previous_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeStatus;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeStatus")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_status::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__previous_version => {
                            if !fields.insert(__FieldTag::__previous_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for previous_version",
                                ));
                            }
                            result.previous_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeStatus {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if !self.previous_version.is_empty() {
            state.serialize_entry("previousVersion", &self.previous_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeStatus {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeStatus");
        debug_struct.field("version", &self.version);
        debug_struct.field("state", &self.state);
        debug_struct.field("error", &self.error);
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("previous_version", &self.previous_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UpgradeStatus].
pub mod upgrade_status {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state was not sampled by the health checks yet.
        Unspecified,
        /// The upgrade has started.
        Running,
        /// The upgrade failed.
        Failed,
        /// The upgrade finished successfully.
        Succeeded,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Failed => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Failed,
                3 => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "FAILED" => Self::Failed,
                "SUCCEEDED" => Self::Succeeded,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Failed => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UpgradeStatus.State",
            ))
        }
    }
}

/// Holds information about the available versions for upgrade.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AvailableUpdates {
    /// The newest deployable version of the appliance.
    /// The current appliance can't be updated into this version, and the owner
    /// must manually deploy this OVA to a new appliance.
    pub new_deployable_appliance: std::option::Option<crate::model::ApplianceVersion>,

    /// The latest version for in place update.
    /// The current appliance can be updated to this version using the API or m4c
    /// CLI.
    pub in_place_update: std::option::Option<crate::model::ApplianceVersion>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AvailableUpdates {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_new_deployable_appliance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [new_deployable_appliance][crate::model::AvailableUpdates::new_deployable_appliance].
    pub fn set_or_clear_new_deployable_appliance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.new_deployable_appliance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_in_place_update<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [in_place_update][crate::model::AvailableUpdates::in_place_update].
    pub fn set_or_clear_in_place_update<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApplianceVersion>,
    {
        self.in_place_update = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AvailableUpdates {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AvailableUpdates"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AvailableUpdates {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __new_deployable_appliance,
            __in_place_update,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AvailableUpdates")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "newDeployableAppliance" => Ok(__FieldTag::__new_deployable_appliance),
                            "new_deployable_appliance" => {
                                Ok(__FieldTag::__new_deployable_appliance)
                            }
                            "inPlaceUpdate" => Ok(__FieldTag::__in_place_update),
                            "in_place_update" => Ok(__FieldTag::__in_place_update),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AvailableUpdates;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AvailableUpdates")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__new_deployable_appliance => {
                            if !fields.insert(__FieldTag::__new_deployable_appliance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_deployable_appliance",
                                ));
                            }
                            result.new_deployable_appliance = map
                                .next_value::<std::option::Option<crate::model::ApplianceVersion>>(
                                )?;
                        }
                        __FieldTag::__in_place_update => {
                            if !fields.insert(__FieldTag::__in_place_update) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for in_place_update",
                                ));
                            }
                            result.in_place_update = map
                                .next_value::<std::option::Option<crate::model::ApplianceVersion>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AvailableUpdates {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.new_deployable_appliance.is_some() {
            state.serialize_entry("newDeployableAppliance", &self.new_deployable_appliance)?;
        }
        if self.in_place_update.is_some() {
            state.serialize_entry("inPlaceUpdate", &self.in_place_update)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AvailableUpdates {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AvailableUpdates");
        debug_struct.field("new_deployable_appliance", &self.new_deployable_appliance);
        debug_struct.field("in_place_update", &self.in_place_update);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes an appliance version.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApplianceVersion {
    /// The appliance version.
    pub version: std::string::String,

    /// A link for downloading the version.
    pub uri: std::string::String,

    /// Determine whether it's critical to upgrade the appliance to this version.
    pub critical: bool,

    /// Link to a page that contains the version release notes.
    pub release_notes_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApplianceVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [version][crate::model::ApplianceVersion::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [uri][crate::model::ApplianceVersion::uri].
    pub fn set_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uri = v.into();
        self
    }

    /// Sets the value of [critical][crate::model::ApplianceVersion::critical].
    pub fn set_critical<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.critical = v.into();
        self
    }

    /// Sets the value of [release_notes_uri][crate::model::ApplianceVersion::release_notes_uri].
    pub fn set_release_notes_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_notes_uri = v.into();
        self
    }
}

impl wkt::message::Message for ApplianceVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ApplianceVersion"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApplianceVersion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __version,
            __uri,
            __critical,
            __release_notes_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApplianceVersion")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "version" => Ok(__FieldTag::__version),
                            "uri" => Ok(__FieldTag::__uri),
                            "critical" => Ok(__FieldTag::__critical),
                            "releaseNotesUri" => Ok(__FieldTag::__release_notes_uri),
                            "release_notes_uri" => Ok(__FieldTag::__release_notes_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApplianceVersion;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApplianceVersion")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uri => {
                            if !fields.insert(__FieldTag::__uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uri",
                                ));
                            }
                            result.uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__critical => {
                            if !fields.insert(__FieldTag::__critical) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for critical",
                                ));
                            }
                            result.critical = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_notes_uri => {
                            if !fields.insert(__FieldTag::__release_notes_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_notes_uri",
                                ));
                            }
                            result.release_notes_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApplianceVersion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !self.uri.is_empty() {
            state.serialize_entry("uri", &self.uri)?;
        }
        if !wkt::internal::is_default(&self.critical) {
            state.serialize_entry("critical", &self.critical)?;
        }
        if !self.release_notes_uri.is_empty() {
            state.serialize_entry("releaseNotesUri", &self.release_notes_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApplianceVersion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApplianceVersion");
        debug_struct.field("version", &self.version);
        debug_struct.field("uri", &self.uri);
        debug_struct.field("critical", &self.critical);
        debug_struct.field("release_notes_uri", &self.release_notes_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesRequest {
    /// Required. The parent, which owns this collection of sources.
    pub parent: std::string::String,

    /// Optional. The maximum number of sources to return. The service may return
    /// fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListSources` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListSources` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListSourcesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListSourcesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListSourcesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListSourcesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListSourcesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListSourcesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListSourcesResponse {
    /// Output only. The list of sources response.
    pub sources: std::vec::Vec<crate::model::Source>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListSourcesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [sources][crate::model::ListSourcesResponse::sources].
    pub fn set_sources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Source>,
    {
        use std::iter::Iterator;
        self.sources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListSourcesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListSourcesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListSourcesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListSourcesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListSourcesResponse {
    type PageItem = crate::model::Source;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.sources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListSourcesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __sources,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListSourcesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sources" => Ok(__FieldTag::__sources),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListSourcesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListSourcesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__sources => {
                            if !fields.insert(__FieldTag::__sources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for sources",
                                ));
                            }
                            result.sources = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Source>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListSourcesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.sources.is_empty() {
            state.serialize_entry("sources", &self.sources)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListSourcesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListSourcesResponse");
        debug_struct.field("sources", &self.sources);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetSourceRequest {
    /// Required. The Source name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetSourceRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateSourceRequest {
    /// Required. The Source's parent.
    pub parent: std::string::String,

    /// Required. The source identifier.
    pub source_id: std::string::String,

    /// Required. The create request body.
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateSourceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::CreateSourceRequest::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::CreateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __source_id,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateSourceRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateSources' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateSourceRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Source resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub source: std::option::Option<crate::model::Source>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateSourceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_source<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [source][crate::model::UpdateSourceRequest::source].
    pub fn set_or_clear_source<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Source>,
    {
        self.source = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __source,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "source" => Ok(__FieldTag::__source),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source =
                                map.next_value::<std::option::Option<crate::model::Source>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.source.is_some() {
            state.serialize_entry("source", &self.source)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateSourceRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("source", &self.source);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteSource' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteSourceRequest {
    /// Required. The Source name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteSourceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteSourceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteSourceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteSourceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteSourceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteSourceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteSourceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteSourceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteSourceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteSourceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteSourceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSourceRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchInventoryRequest {
    /// Required. The name of the Source.
    pub source: std::string::String,

    /// If this flag is set to true, the source will be queried instead of using
    /// cached results. Using this flag will make the call slower.
    pub force_refresh: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::FetchInventoryRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [force_refresh][crate::model::FetchInventoryRequest::force_refresh].
    pub fn set_force_refresh<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_refresh = v.into();
        self
    }
}

impl wkt::message::Message for FetchInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __force_refresh,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "forceRefresh" => Ok(__FieldTag::__force_refresh),
                            "force_refresh" => Ok(__FieldTag::__force_refresh),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force_refresh => {
                            if !fields.insert(__FieldTag::__force_refresh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force_refresh",
                                ));
                            }
                            result.force_refresh = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchInventoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.force_refresh) {
            state.serialize_entry("forceRefresh", &self.force_refresh)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchInventoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchInventoryRequest");
        debug_struct.field("source", &self.source);
        debug_struct.field("force_refresh", &self.force_refresh);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// VmwareVmDetails describes a VM in vCenter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareVmDetails {
    /// The VM's id in the source (note that this is not the MigratingVm's id).
    /// This is the moref id of the VM.
    pub vm_id: std::string::String,

    /// The id of the vCenter's datacenter this VM is contained in.
    pub datacenter_id: std::string::String,

    /// The descriptive name of the vCenter's datacenter this VM is contained in.
    pub datacenter_description: std::string::String,

    /// The unique identifier of the VM in vCenter.
    pub uuid: std::string::String,

    /// The display name of the VM. Note that this is not necessarily unique.
    pub display_name: std::string::String,

    /// The power state of the VM at the moment list was taken.
    pub power_state: crate::model::vmware_vm_details::PowerState,

    /// The number of cpus in the VM.
    pub cpu_count: i32,

    /// The size of the memory of the VM in MB.
    pub memory_mb: i32,

    /// The number of disks the VM has.
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    pub committed_storage_mb: i64,

    /// The VM's OS. See for example
    /// <https://vdc-repo.vmware.com/vmwb-repository/dcr-public/da47f910-60ac-438b-8b9b-6122f4d14524/16b7274a-bf8b-4b4c-a05e-746f2aa93c8c/doc/vim.vm.GuestOsDescriptor.GuestOsIdentifier.html>
    /// for types of strings this might hold.
    pub guest_description: std::string::String,

    /// Output only. The VM Boot Option.
    pub boot_option: crate::model::vmware_vm_details::BootOption,

    /// Output only. The CPU architecture.
    pub architecture: crate::model::vmware_vm_details::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmwareVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [datacenter_id][crate::model::VmwareVmDetails::datacenter_id].
    pub fn set_datacenter_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.datacenter_id = v.into();
        self
    }

    /// Sets the value of [datacenter_description][crate::model::VmwareVmDetails::datacenter_description].
    pub fn set_datacenter_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_description = v.into();
        self
    }

    /// Sets the value of [uuid][crate::model::VmwareVmDetails::uuid].
    pub fn set_uuid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uuid = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::VmwareVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::VmwareVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::vmware_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::VmwareVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::VmwareVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::VmwareVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::VmwareVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [guest_description][crate::model::VmwareVmDetails::guest_description].
    pub fn set_guest_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.guest_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::VmwareVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::vmware_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::VmwareVmDetails::architecture].
    pub fn set_architecture<
        T: std::convert::Into<crate::model::vmware_vm_details::VmArchitecture>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for VmwareVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_id,
            __datacenter_id,
            __datacenter_description,
            __uuid,
            __display_name,
            __power_state,
            __cpu_count,
            __memory_mb,
            __disk_count,
            __committed_storage_mb,
            __guest_description,
            __boot_option,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "datacenterId" => Ok(__FieldTag::__datacenter_id),
                            "datacenter_id" => Ok(__FieldTag::__datacenter_id),
                            "datacenterDescription" => Ok(__FieldTag::__datacenter_description),
                            "datacenter_description" => Ok(__FieldTag::__datacenter_description),
                            "uuid" => Ok(__FieldTag::__uuid),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "diskCount" => Ok(__FieldTag::__disk_count),
                            "disk_count" => Ok(__FieldTag::__disk_count),
                            "committedStorageMb" => Ok(__FieldTag::__committed_storage_mb),
                            "committed_storage_mb" => Ok(__FieldTag::__committed_storage_mb),
                            "guestDescription" => Ok(__FieldTag::__guest_description),
                            "guest_description" => Ok(__FieldTag::__guest_description),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_id => {
                            if !fields.insert(__FieldTag::__datacenter_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_id",
                                ));
                            }
                            result.datacenter_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_description => {
                            if !fields.insert(__FieldTag::__datacenter_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_description",
                                ));
                            }
                            result.datacenter_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__uuid => {
                            if !fields.insert(__FieldTag::__uuid) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uuid",
                                ));
                            }
                            result.uuid = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state =
                                map.next_value::<std::option::Option<
                                    crate::model::vmware_vm_details::PowerState,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_count => {
                            if !fields.insert(__FieldTag::__disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_mb => {
                            if !fields.insert(__FieldTag::__committed_storage_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_mb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__guest_description => {
                            if !fields.insert(__FieldTag::__guest_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for guest_description",
                                ));
                            }
                            result.guest_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option =
                                map.next_value::<std::option::Option<
                                    crate::model::vmware_vm_details::BootOption,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<
                                    crate::model::vmware_vm_details::VmArchitecture,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if !self.datacenter_id.is_empty() {
            state.serialize_entry("datacenterId", &self.datacenter_id)?;
        }
        if !self.datacenter_description.is_empty() {
            state.serialize_entry("datacenterDescription", &self.datacenter_description)?;
        }
        if !self.uuid.is_empty() {
            state.serialize_entry("uuid", &self.uuid)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.disk_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if !wkt::internal::is_default(&self.committed_storage_mb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("committedStorageMb", &__With(&self.committed_storage_mb))?;
        }
        if !self.guest_description.is_empty() {
            state.serialize_entry("guestDescription", &self.guest_description)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareVmDetails");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("datacenter_id", &self.datacenter_id);
        debug_struct.field("datacenter_description", &self.datacenter_description);
        debug_struct.field("uuid", &self.uuid);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("disk_count", &self.disk_count);
        debug_struct.field("committed_storage_mb", &self.committed_storage_mb);
        debug_struct.field("guest_description", &self.guest_description);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("architecture", &self.architecture);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmwareVmDetails].
pub mod vmware_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned ON.
        On,
        /// The VM is turned OFF.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep mode.
        Suspended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.PowerState",
            ))
        }
    }

    /// Possible values for vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is EFI.
        Efi,
        /// The boot option is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.BootOption",
            ))
        }
    }

    /// Possible values for the VM architecture.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmArchitecture {
        /// The architecture is unknown.
        Unspecified,
        /// The architecture is one of the x86 architectures.
        X86Family,
        /// The architecture is ARM64.
        Arm64,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmArchitecture::value] or
        /// [VmArchitecture::name].
        UnknownValue(vm_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::X86Family => std::option::Option::Some(1),
                Self::Arm64 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
                Self::X86Family => std::option::Option::Some("VM_ARCHITECTURE_X86_FAMILY"),
                Self::Arm64 => std::option::Option::Some("VM_ARCHITECTURE_ARM64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::X86Family,
                2 => Self::Arm64,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "VM_ARCHITECTURE_X86_FAMILY" => Self::X86Family,
                "VM_ARCHITECTURE_ARM64" => Self::Arm64,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::X86Family => serializer.serialize_i32(1),
                Self::Arm64 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
                ".google.cloud.vmmigration.v1.VmwareVmDetails.VmArchitecture",
            ))
        }
    }
}

/// AwsVmDetails describes a VM in AWS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsVmDetails {
    /// The VM ID in AWS.
    pub vm_id: std::string::String,

    /// The display name of the VM. Note that this value is not necessarily unique.
    pub display_name: std::string::String,

    /// The id of the AWS's source this VM is connected to.
    pub source_id: std::string::String,

    /// The descriptive name of the AWS's source this VM is connected to.
    pub source_description: std::string::String,

    /// Output only. The power state of the VM at the moment list was taken.
    pub power_state: crate::model::aws_vm_details::PowerState,

    /// The number of CPU cores the VM has.
    pub cpu_count: i32,

    /// The memory size of the VM in MB.
    pub memory_mb: i32,

    /// The number of disks the VM has.
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    pub committed_storage_mb: i64,

    /// The VM's OS.
    pub os_description: std::string::String,

    /// The VM Boot Option.
    pub boot_option: crate::model::aws_vm_details::BootOption,

    /// The instance type of the VM.
    pub instance_type: std::string::String,

    /// The VPC ID the VM belongs to.
    pub vpc_id: std::string::String,

    /// The security groups the VM belongs to.
    pub security_groups: std::vec::Vec<crate::model::AwsSecurityGroup>,

    /// The tags of the VM.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The AWS zone of the VM.
    pub zone: std::string::String,

    /// The virtualization type.
    pub virtualization_type: crate::model::aws_vm_details::VmVirtualizationType,

    /// The CPU architecture.
    pub architecture: crate::model::aws_vm_details::VmArchitecture,

    /// The number of vCPUs the VM has. It is calculated as the
    /// number of CPU cores * threads per CPU the VM has.
    pub vcpu_count: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::AwsVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::AwsVmDetails::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [source_id][crate::model::AwsVmDetails::source_id].
    pub fn set_source_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source_id = v.into();
        self
    }

    /// Sets the value of [source_description][crate::model::AwsVmDetails::source_description].
    pub fn set_source_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_description = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::AwsVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::aws_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::AwsVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::AwsVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::AwsVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::AwsVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [os_description][crate::model::AwsVmDetails::os_description].
    pub fn set_os_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_description = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::AwsVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::aws_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [instance_type][crate::model::AwsVmDetails::instance_type].
    pub fn set_instance_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_type = v.into();
        self
    }

    /// Sets the value of [vpc_id][crate::model::AwsVmDetails::vpc_id].
    pub fn set_vpc_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vpc_id = v.into();
        self
    }

    /// Sets the value of [security_groups][crate::model::AwsVmDetails::security_groups].
    pub fn set_security_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsSecurityGroup>,
    {
        use std::iter::Iterator;
        self.security_groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::AwsVmDetails::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [zone][crate::model::AwsVmDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [virtualization_type][crate::model::AwsVmDetails::virtualization_type].
    pub fn set_virtualization_type<
        T: std::convert::Into<crate::model::aws_vm_details::VmVirtualizationType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.virtualization_type = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AwsVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::aws_vm_details::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }

    /// Sets the value of [vcpu_count][crate::model::AwsVmDetails::vcpu_count].
    pub fn set_vcpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vcpu_count = v.into();
        self
    }
}

impl wkt::message::Message for AwsVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_id,
            __display_name,
            __source_id,
            __source_description,
            __power_state,
            __cpu_count,
            __memory_mb,
            __disk_count,
            __committed_storage_mb,
            __os_description,
            __boot_option,
            __instance_type,
            __vpc_id,
            __security_groups,
            __tags,
            __zone,
            __virtualization_type,
            __architecture,
            __vcpu_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "sourceId" => Ok(__FieldTag::__source_id),
                            "source_id" => Ok(__FieldTag::__source_id),
                            "sourceDescription" => Ok(__FieldTag::__source_description),
                            "source_description" => Ok(__FieldTag::__source_description),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "diskCount" => Ok(__FieldTag::__disk_count),
                            "disk_count" => Ok(__FieldTag::__disk_count),
                            "committedStorageMb" => Ok(__FieldTag::__committed_storage_mb),
                            "committed_storage_mb" => Ok(__FieldTag::__committed_storage_mb),
                            "osDescription" => Ok(__FieldTag::__os_description),
                            "os_description" => Ok(__FieldTag::__os_description),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "instanceType" => Ok(__FieldTag::__instance_type),
                            "instance_type" => Ok(__FieldTag::__instance_type),
                            "vpcId" => Ok(__FieldTag::__vpc_id),
                            "vpc_id" => Ok(__FieldTag::__vpc_id),
                            "securityGroups" => Ok(__FieldTag::__security_groups),
                            "security_groups" => Ok(__FieldTag::__security_groups),
                            "tags" => Ok(__FieldTag::__tags),
                            "zone" => Ok(__FieldTag::__zone),
                            "virtualizationType" => Ok(__FieldTag::__virtualization_type),
                            "virtualization_type" => Ok(__FieldTag::__virtualization_type),
                            "architecture" => Ok(__FieldTag::__architecture),
                            "vcpuCount" => Ok(__FieldTag::__vcpu_count),
                            "vcpu_count" => Ok(__FieldTag::__vcpu_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_id => {
                            if !fields.insert(__FieldTag::__source_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_id",
                                ));
                            }
                            result.source_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__source_description => {
                            if !fields.insert(__FieldTag::__source_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_description",
                                ));
                            }
                            result.source_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state = map.next_value::<std::option::Option<crate::model::aws_vm_details::PowerState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_count => {
                            if !fields.insert(__FieldTag::__disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_mb => {
                            if !fields.insert(__FieldTag::__committed_storage_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_mb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__os_description => {
                            if !fields.insert(__FieldTag::__os_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_description",
                                ));
                            }
                            result.os_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::aws_vm_details::BootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__instance_type => {
                            if !fields.insert(__FieldTag::__instance_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_type",
                                ));
                            }
                            result.instance_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vpc_id => {
                            if !fields.insert(__FieldTag::__vpc_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vpc_id",
                                ));
                            }
                            result.vpc_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__security_groups => {
                            if !fields.insert(__FieldTag::__security_groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for security_groups",
                                ));
                            }
                            result.security_groups =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AwsSecurityGroup>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__virtualization_type => {
                            if !fields.insert(__FieldTag::__virtualization_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for virtualization_type",
                                ));
                            }
                            result.virtualization_type = map
                                .next_value::<std::option::Option<
                                    crate::model::aws_vm_details::VmVirtualizationType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_vm_details::VmArchitecture,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vcpu_count => {
                            if !fields.insert(__FieldTag::__vcpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vcpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vcpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !self.source_id.is_empty() {
            state.serialize_entry("sourceId", &self.source_id)?;
        }
        if !self.source_description.is_empty() {
            state.serialize_entry("sourceDescription", &self.source_description)?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.disk_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if !wkt::internal::is_default(&self.committed_storage_mb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("committedStorageMb", &__With(&self.committed_storage_mb))?;
        }
        if !self.os_description.is_empty() {
            state.serialize_entry("osDescription", &self.os_description)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.instance_type.is_empty() {
            state.serialize_entry("instanceType", &self.instance_type)?;
        }
        if !self.vpc_id.is_empty() {
            state.serialize_entry("vpcId", &self.vpc_id)?;
        }
        if !self.security_groups.is_empty() {
            state.serialize_entry("securityGroups", &self.security_groups)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !wkt::internal::is_default(&self.virtualization_type) {
            state.serialize_entry("virtualizationType", &self.virtualization_type)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !wkt::internal::is_default(&self.vcpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vcpuCount", &__With(&self.vcpu_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsVmDetails");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("source_id", &self.source_id);
        debug_struct.field("source_description", &self.source_description);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("disk_count", &self.disk_count);
        debug_struct.field("committed_storage_mb", &self.committed_storage_mb);
        debug_struct.field("os_description", &self.os_description);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("instance_type", &self.instance_type);
        debug_struct.field("vpc_id", &self.vpc_id);
        debug_struct.field("security_groups", &self.security_groups);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("virtualization_type", &self.virtualization_type);
        debug_struct.field("architecture", &self.architecture);
        debug_struct.field("vcpu_count", &self.vcpu_count);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsVmDetails].
pub mod aws_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is turned on.
        On,
        /// The VM is turned off.
        Off,
        /// The VM is suspended. This is similar to hibernation or sleep
        /// mode.
        Suspended,
        /// The VM is starting.
        Pending,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::On => std::option::Option::Some(1),
                Self::Off => std::option::Option::Some(2),
                Self::Suspended => std::option::Option::Some(3),
                Self::Pending => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::On => std::option::Option::Some("ON"),
                Self::Off => std::option::Option::Some("OFF"),
                Self::Suspended => std::option::Option::Some("SUSPENDED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::On,
                2 => Self::Off,
                3 => Self::Suspended,
                4 => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "ON" => Self::On,
                "OFF" => Self::Off,
                "SUSPENDED" => Self::Suspended,
                "PENDING" => Self::Pending,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::On => serializer.serialize_i32(1),
                Self::Off => serializer.serialize_i32(2),
                Self::Suspended => serializer.serialize_i32(3),
                Self::Pending => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.PowerState",
            ))
        }
    }

    /// The possible values for the vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is UEFI.
        Efi,
        /// The boot option is LEGACY-BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.BootOption",
            ))
        }
    }

    /// Possible values for the virtualization types of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmVirtualizationType {
        /// The virtualization type is unknown.
        Unspecified,
        /// The virtualziation type is HVM.
        Hvm,
        /// The virtualziation type is PARAVIRTUAL.
        Paravirtual,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmVirtualizationType::value] or
        /// [VmVirtualizationType::name].
        UnknownValue(vm_virtualization_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_virtualization_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmVirtualizationType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Hvm => std::option::Option::Some(1),
                Self::Paravirtual => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("VM_VIRTUALIZATION_TYPE_UNSPECIFIED")
                }
                Self::Hvm => std::option::Option::Some("HVM"),
                Self::Paravirtual => std::option::Option::Some("PARAVIRTUAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmVirtualizationType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmVirtualizationType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmVirtualizationType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Hvm,
                2 => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmVirtualizationType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_VIRTUALIZATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HVM" => Self::Hvm,
                "PARAVIRTUAL" => Self::Paravirtual,
                _ => Self::UnknownValue(vm_virtualization_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmVirtualizationType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Hvm => serializer.serialize_i32(1),
                Self::Paravirtual => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmVirtualizationType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmVirtualizationType>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmVirtualizationType",
            ))
        }
    }

    /// Possible values for the architectures of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmArchitecture {
        /// The architecture is unknown.
        Unspecified,
        /// The architecture is I386.
        I386,
        /// The architecture is X86_64.
        X8664,
        /// The architecture is ARM64.
        Arm64,
        /// The architecture is X86_64_MAC.
        X8664Mac,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmArchitecture::value] or
        /// [VmArchitecture::name].
        UnknownValue(vm_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::I386 => std::option::Option::Some(1),
                Self::X8664 => std::option::Option::Some(2),
                Self::Arm64 => std::option::Option::Some(3),
                Self::X8664Mac => std::option::Option::Some(4),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
                Self::I386 => std::option::Option::Some("I386"),
                Self::X8664 => std::option::Option::Some("X86_64"),
                Self::Arm64 => std::option::Option::Some("ARM64"),
                Self::X8664Mac => std::option::Option::Some("X86_64_MAC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::I386,
                2 => Self::X8664,
                3 => Self::Arm64,
                4 => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "I386" => Self::I386,
                "X86_64" => Self::X8664,
                "ARM64" => Self::Arm64,
                "X86_64_MAC" => Self::X8664Mac,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::I386 => serializer.serialize_i32(1),
                Self::X8664 => serializer.serialize_i32(2),
                Self::Arm64 => serializer.serialize_i32(3),
                Self::X8664Mac => serializer.serialize_i32(4),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
                ".google.cloud.vmmigration.v1.AwsVmDetails.VmArchitecture",
            ))
        }
    }
}

/// AwsSecurityGroup describes a security group of an AWS VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSecurityGroup {
    /// The AWS security group id.
    pub id: std::string::String,

    /// The AWS security group name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSecurityGroup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [id][crate::model::AwsSecurityGroup::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [name][crate::model::AwsSecurityGroup::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for AwsSecurityGroup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSecurityGroup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSecurityGroup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __id,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSecurityGroup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "id" => Ok(__FieldTag::__id),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSecurityGroup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSecurityGroup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSecurityGroup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSecurityGroup {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSecurityGroup");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AzureVmDetails describes a VM in Azure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureVmDetails {
    /// The VM full path in Azure.
    pub vm_id: std::string::String,

    /// The power state of the VM at the moment list was taken.
    pub power_state: crate::model::azure_vm_details::PowerState,

    /// VM size as configured in Azure. Determines the VM's hardware spec.
    pub vm_size: std::string::String,

    /// The number of cpus the VM has.
    pub cpu_count: i32,

    /// The memory size of the VM in MB.
    pub memory_mb: i32,

    /// The number of disks the VM has, including OS disk.
    pub disk_count: i32,

    /// The total size of the storage allocated to the VM in MB.
    pub committed_storage_mb: i64,

    /// Description of the OS disk.
    pub os_disk: std::option::Option<crate::model::azure_vm_details::OSDisk>,

    /// Description of the data disks.
    pub disks: std::vec::Vec<crate::model::azure_vm_details::Disk>,

    /// Description of the OS.
    pub os_description: std::option::Option<crate::model::azure_vm_details::OSDescription>,

    /// The VM Boot Option.
    pub boot_option: crate::model::azure_vm_details::BootOption,

    /// The tags of the VM.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    /// The VM's ComputerName.
    pub computer_name: std::string::String,

    /// The CPU architecture.
    pub architecture: crate::model::azure_vm_details::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::AzureVmDetails::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [power_state][crate::model::AzureVmDetails::power_state].
    pub fn set_power_state<T: std::convert::Into<crate::model::azure_vm_details::PowerState>>(
        mut self,
        v: T,
    ) -> Self {
        self.power_state = v.into();
        self
    }

    /// Sets the value of [vm_size][crate::model::AzureVmDetails::vm_size].
    pub fn set_vm_size<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_size = v.into();
        self
    }

    /// Sets the value of [cpu_count][crate::model::AzureVmDetails::cpu_count].
    pub fn set_cpu_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_count = v.into();
        self
    }

    /// Sets the value of [memory_mb][crate::model::AzureVmDetails::memory_mb].
    pub fn set_memory_mb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_mb = v.into();
        self
    }

    /// Sets the value of [disk_count][crate::model::AzureVmDetails::disk_count].
    pub fn set_disk_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.disk_count = v.into();
        self
    }

    /// Sets the value of [committed_storage_mb][crate::model::AzureVmDetails::committed_storage_mb].
    pub fn set_committed_storage_mb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_mb = v.into();
        self
    }

    /// Sets the value of [os_disk][crate::model::AzureVmDetails::os_disk].
    pub fn set_os_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_vm_details::OSDisk>,
    {
        self.os_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_disk][crate::model::AzureVmDetails::os_disk].
    pub fn set_or_clear_os_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_vm_details::OSDisk>,
    {
        self.os_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disks][crate::model::AzureVmDetails::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::azure_vm_details::Disk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [os_description][crate::model::AzureVmDetails::os_description].
    pub fn set_os_description<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::azure_vm_details::OSDescription>,
    {
        self.os_description = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [os_description][crate::model::AzureVmDetails::os_description].
    pub fn set_or_clear_os_description<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::azure_vm_details::OSDescription>,
    {
        self.os_description = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_option][crate::model::AzureVmDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::azure_vm_details::BootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::AzureVmDetails::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [computer_name][crate::model::AzureVmDetails::computer_name].
    pub fn set_computer_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.computer_name = v.into();
        self
    }

    /// Sets the value of [architecture][crate::model::AzureVmDetails::architecture].
    pub fn set_architecture<
        T: std::convert::Into<crate::model::azure_vm_details::VmArchitecture>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for AzureVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AzureVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_id,
            __power_state,
            __vm_size,
            __cpu_count,
            __memory_mb,
            __disk_count,
            __committed_storage_mb,
            __os_disk,
            __disks,
            __os_description,
            __boot_option,
            __tags,
            __computer_name,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "powerState" => Ok(__FieldTag::__power_state),
                            "power_state" => Ok(__FieldTag::__power_state),
                            "vmSize" => Ok(__FieldTag::__vm_size),
                            "vm_size" => Ok(__FieldTag::__vm_size),
                            "cpuCount" => Ok(__FieldTag::__cpu_count),
                            "cpu_count" => Ok(__FieldTag::__cpu_count),
                            "memoryMb" => Ok(__FieldTag::__memory_mb),
                            "memory_mb" => Ok(__FieldTag::__memory_mb),
                            "diskCount" => Ok(__FieldTag::__disk_count),
                            "disk_count" => Ok(__FieldTag::__disk_count),
                            "committedStorageMb" => Ok(__FieldTag::__committed_storage_mb),
                            "committed_storage_mb" => Ok(__FieldTag::__committed_storage_mb),
                            "osDisk" => Ok(__FieldTag::__os_disk),
                            "os_disk" => Ok(__FieldTag::__os_disk),
                            "disks" => Ok(__FieldTag::__disks),
                            "osDescription" => Ok(__FieldTag::__os_description),
                            "os_description" => Ok(__FieldTag::__os_description),
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "tags" => Ok(__FieldTag::__tags),
                            "computerName" => Ok(__FieldTag::__computer_name),
                            "computer_name" => Ok(__FieldTag::__computer_name),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__power_state => {
                            if !fields.insert(__FieldTag::__power_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for power_state",
                                ));
                            }
                            result.power_state = map.next_value::<std::option::Option<crate::model::azure_vm_details::PowerState>>()?.unwrap_or_default();
                        }
                        __FieldTag::__vm_size => {
                            if !fields.insert(__FieldTag::__vm_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_size",
                                ));
                            }
                            result.vm_size = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cpu_count => {
                            if !fields.insert(__FieldTag::__cpu_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_mb => {
                            if !fields.insert(__FieldTag::__memory_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_mb",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_mb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_count => {
                            if !fields.insert(__FieldTag::__disk_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_mb => {
                            if !fields.insert(__FieldTag::__committed_storage_mb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_mb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_mb =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__os_disk => {
                            if !fields.insert(__FieldTag::__os_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_disk",
                                ));
                            }
                            result.os_disk = map.next_value::<std::option::Option<crate::model::azure_vm_details::OSDisk>>()?
                                ;
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::azure_vm_details::Disk>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__os_description => {
                            if !fields.insert(__FieldTag::__os_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_description",
                                ));
                            }
                            result.os_description = map.next_value::<std::option::Option<
                                crate::model::azure_vm_details::OSDescription,
                            >>()?;
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::azure_vm_details::BootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__computer_name => {
                            if !fields.insert(__FieldTag::__computer_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for computer_name",
                                ));
                            }
                            result.computer_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture =
                                map.next_value::<std::option::Option<
                                    crate::model::azure_vm_details::VmArchitecture,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if !wkt::internal::is_default(&self.power_state) {
            state.serialize_entry("powerState", &self.power_state)?;
        }
        if !self.vm_size.is_empty() {
            state.serialize_entry("vmSize", &self.vm_size)?;
        }
        if !wkt::internal::is_default(&self.cpu_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuCount", &__With(&self.cpu_count))?;
        }
        if !wkt::internal::is_default(&self.memory_mb) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMb", &__With(&self.memory_mb))?;
        }
        if !wkt::internal::is_default(&self.disk_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskCount", &__With(&self.disk_count))?;
        }
        if !wkt::internal::is_default(&self.committed_storage_mb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("committedStorageMb", &__With(&self.committed_storage_mb))?;
        }
        if self.os_disk.is_some() {
            state.serialize_entry("osDisk", &self.os_disk)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.os_description.is_some() {
            state.serialize_entry("osDescription", &self.os_description)?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.computer_name.is_empty() {
            state.serialize_entry("computerName", &self.computer_name)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureVmDetails");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("power_state", &self.power_state);
        debug_struct.field("vm_size", &self.vm_size);
        debug_struct.field("cpu_count", &self.cpu_count);
        debug_struct.field("memory_mb", &self.memory_mb);
        debug_struct.field("disk_count", &self.disk_count);
        debug_struct.field("committed_storage_mb", &self.committed_storage_mb);
        debug_struct.field("os_disk", &self.os_disk);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("os_description", &self.os_description);
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("computer_name", &self.computer_name);
        debug_struct.field("architecture", &self.architecture);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AzureVmDetails].
pub mod azure_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// A message describing the OS disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OSDisk {
        /// The disk's type.
        pub r#type: std::string::String,

        /// The disk's full name.
        pub name: std::string::String,

        /// The disk's size in GB.
        pub size_gb: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OSDisk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::azure_vm_details::OSDisk::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [name][crate::model::azure_vm_details::OSDisk::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::azure_vm_details::OSDisk::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for OSDisk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AzureVmDetails.OSDisk"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OSDisk {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __name,
                __size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OSDisk")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "name" => Ok(__FieldTag::__name),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OSDisk;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OSDisk")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OSDisk {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OSDisk {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OSDisk");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("name", &self.name);
            debug_struct.field("size_gb", &self.size_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A message describing a data disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Disk {
        /// The disk name.
        pub name: std::string::String,

        /// The disk size in GB.
        pub size_gb: i32,

        /// The disk's Logical Unit Number (LUN).
        pub lun: i32,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Disk {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [name][crate::model::azure_vm_details::Disk::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::azure_vm_details::Disk::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }

        /// Sets the value of [lun][crate::model::azure_vm_details::Disk::lun].
        pub fn set_lun<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.lun = v.into();
            self
        }
    }

    impl wkt::message::Message for Disk {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AzureVmDetails.Disk"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Disk {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __name,
                __size_gb,
                __lun,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Disk")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "name" => Ok(__FieldTag::__name),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                "lun" => Ok(__FieldTag::__lun),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Disk;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Disk")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__name => {
                                if !fields.insert(__FieldTag::__name) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for name",
                                    ));
                                }
                                result.name = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__lun => {
                                if !fields.insert(__FieldTag::__lun) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for lun",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.lun = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Disk {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.name.is_empty() {
                state.serialize_entry("name", &self.name)?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !wkt::internal::is_default(&self.lun) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("lun", &__With(&self.lun))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Disk {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Disk");
            debug_struct.field("name", &self.name);
            debug_struct.field("size_gb", &self.size_gb);
            debug_struct.field("lun", &self.lun);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// A message describing the VM's OS. Including OS, Publisher, Offer and Plan
    /// if applicable.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct OSDescription {
        /// OS type.
        pub r#type: std::string::String,

        /// OS publisher.
        pub publisher: std::string::String,

        /// OS offer.
        pub offer: std::string::String,

        /// OS plan.
        pub plan: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl OSDescription {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [r#type][crate::model::azure_vm_details::OSDescription::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }

        /// Sets the value of [publisher][crate::model::azure_vm_details::OSDescription::publisher].
        pub fn set_publisher<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.publisher = v.into();
            self
        }

        /// Sets the value of [offer][crate::model::azure_vm_details::OSDescription::offer].
        pub fn set_offer<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.offer = v.into();
            self
        }

        /// Sets the value of [plan][crate::model::azure_vm_details::OSDescription::plan].
        pub fn set_plan<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.plan = v.into();
            self
        }
    }

    impl wkt::message::Message for OSDescription {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AzureVmDetails.OSDescription"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for OSDescription {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __type,
                __publisher,
                __offer,
                __plan,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for OSDescription")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "type" => Ok(__FieldTag::__type),
                                "publisher" => Ok(__FieldTag::__publisher),
                                "offer" => Ok(__FieldTag::__offer),
                                "plan" => Ok(__FieldTag::__plan),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = OSDescription;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct OSDescription")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__type => {
                                if !fields.insert(__FieldTag::__type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for type",
                                    ));
                                }
                                result.r#type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__publisher => {
                                if !fields.insert(__FieldTag::__publisher) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for publisher",
                                    ));
                                }
                                result.publisher = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__offer => {
                                if !fields.insert(__FieldTag::__offer) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for offer",
                                    ));
                                }
                                result.offer = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__plan => {
                                if !fields.insert(__FieldTag::__plan) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for plan",
                                    ));
                                }
                                result.plan = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for OSDescription {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.r#type.is_empty() {
                state.serialize_entry("type", &self.r#type)?;
            }
            if !self.publisher.is_empty() {
                state.serialize_entry("publisher", &self.publisher)?;
            }
            if !self.offer.is_empty() {
                state.serialize_entry("offer", &self.offer)?;
            }
            if !self.plan.is_empty() {
                state.serialize_entry("plan", &self.plan)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for OSDescription {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("OSDescription");
            debug_struct.field("r#type", &self.r#type);
            debug_struct.field("publisher", &self.publisher);
            debug_struct.field("offer", &self.offer);
            debug_struct.field("plan", &self.plan);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible values for the power state of the VM.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum PowerState {
        /// Power state is not specified.
        Unspecified,
        /// The VM is starting.
        Starting,
        /// The VM is running.
        Running,
        /// The VM is stopping.
        Stopping,
        /// The VM is stopped.
        Stopped,
        /// The VM is deallocating.
        Deallocating,
        /// The VM is deallocated.
        Deallocated,
        /// The VM's power state is unknown.
        Unknown,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [PowerState::value] or
        /// [PowerState::name].
        UnknownValue(power_state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod power_state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl PowerState {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Starting => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Stopping => std::option::Option::Some(3),
                Self::Stopped => std::option::Option::Some(4),
                Self::Deallocating => std::option::Option::Some(5),
                Self::Deallocated => std::option::Option::Some(6),
                Self::Unknown => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("POWER_STATE_UNSPECIFIED"),
                Self::Starting => std::option::Option::Some("STARTING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Stopping => std::option::Option::Some("STOPPING"),
                Self::Stopped => std::option::Option::Some("STOPPED"),
                Self::Deallocating => std::option::Option::Some("DEALLOCATING"),
                Self::Deallocated => std::option::Option::Some("DEALLOCATED"),
                Self::Unknown => std::option::Option::Some("UNKNOWN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for PowerState {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for PowerState {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for PowerState {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Starting,
                2 => Self::Running,
                3 => Self::Stopping,
                4 => Self::Stopped,
                5 => Self::Deallocating,
                6 => Self::Deallocated,
                7 => Self::Unknown,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for PowerState {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "POWER_STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTING" => Self::Starting,
                "RUNNING" => Self::Running,
                "STOPPING" => Self::Stopping,
                "STOPPED" => Self::Stopped,
                "DEALLOCATING" => Self::Deallocating,
                "DEALLOCATED" => Self::Deallocated,
                "UNKNOWN" => Self::Unknown,
                _ => Self::UnknownValue(power_state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for PowerState {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Starting => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Stopping => serializer.serialize_i32(3),
                Self::Stopped => serializer.serialize_i32(4),
                Self::Deallocating => serializer.serialize_i32(5),
                Self::Deallocated => serializer.serialize_i32(6),
                Self::Unknown => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for PowerState {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<PowerState>::new(
                ".google.cloud.vmmigration.v1.AzureVmDetails.PowerState",
            ))
        }
    }

    /// The possible values for the vm boot option.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum BootOption {
        /// The boot option is unknown.
        Unspecified,
        /// The boot option is UEFI.
        Efi,
        /// The boot option is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [BootOption::value] or
        /// [BootOption::name].
        UnknownValue(boot_option::UnknownValue),
    }

    #[doc(hidden)]
    pub mod boot_option {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl BootOption {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("BOOT_OPTION_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for BootOption {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for BootOption {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for BootOption {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for BootOption {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(boot_option::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for BootOption {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for BootOption {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootOption>::new(
                ".google.cloud.vmmigration.v1.AzureVmDetails.BootOption",
            ))
        }
    }

    /// Possible values for the VM architecture.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmArchitecture {
        /// The architecture is unknown.
        Unspecified,
        /// The architecture is one of the x86 architectures.
        X86Family,
        /// The architecture is ARM64.
        Arm64,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [VmArchitecture::value] or
        /// [VmArchitecture::name].
        UnknownValue(vm_architecture::UnknownValue),
    }

    #[doc(hidden)]
    pub mod vm_architecture {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl VmArchitecture {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::X86Family => std::option::Option::Some(1),
                Self::Arm64 => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
                Self::X86Family => std::option::Option::Some("VM_ARCHITECTURE_X86_FAMILY"),
                Self::Arm64 => std::option::Option::Some("VM_ARCHITECTURE_ARM64"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for VmArchitecture {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for VmArchitecture {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for VmArchitecture {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::X86Family,
                2 => Self::Arm64,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for VmArchitecture {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
                "VM_ARCHITECTURE_X86_FAMILY" => Self::X86Family,
                "VM_ARCHITECTURE_ARM64" => Self::Arm64,
                _ => Self::UnknownValue(vm_architecture::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for VmArchitecture {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::X86Family => serializer.serialize_i32(1),
                Self::Arm64 => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
                ".google.cloud.vmmigration.v1.AzureVmDetails.VmArchitecture",
            ))
        }
    }
}

/// VmwareVmsDetails describes VMs in vCenter.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareVmsDetails {
    /// The details of the vmware VMs.
    pub details: std::vec::Vec<crate::model::VmwareVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::VmwareVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmwareVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for VmwareVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareVmsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareVmsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareVmsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareVmsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareVmsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VmwareVmDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareVmsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareVmsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareVmsDetails");
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AWSVmsDetails describes VMs in AWS.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsVmsDetails {
    /// The details of the AWS VMs.
    pub details: std::vec::Vec<crate::model::AwsVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::AwsVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AwsVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AwsVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsVmsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsVmsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsVmsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsVmsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsVmsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map.next_value::<std::option::Option<std::vec::Vec<crate::model::AwsVmDetails>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsVmsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsVmsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsVmsDetails");
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AzureVmsDetails describes VMs in Azure.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureVmsDetails {
    /// The details of the Azure VMs.
    pub details: std::vec::Vec<crate::model::AzureVmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureVmsDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [details][crate::model::AzureVmsDetails::details].
    pub fn set_details<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AzureVmDetails>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AzureVmsDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AzureVmsDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureVmsDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureVmsDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureVmsDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureVmsDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AzureVmDetails>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureVmsDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureVmsDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureVmsDetails");
        debug_struct.field("details", &self.details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for
/// [fetchInventory][google.cloud.vmmigration.v1.VmMigration.FetchInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchInventory]: crate::client::VmMigration::fetch_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchInventoryResponse {
    /// Output only. The timestamp when the source was last queried (if the result
    /// is from the cache).
    pub update_time: std::option::Option<wkt::Timestamp>,

    pub source_vms: std::option::Option<crate::model::fetch_inventory_response::SourceVms>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchInventoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FetchInventoryResponse::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms].
    ///
    /// Note that all the setters affecting `source_vms` are mutually
    /// exclusive.
    pub fn set_source_vms<
        T: std::convert::Into<std::option::Option<crate::model::fetch_inventory_response::SourceVms>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = v.into();
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `VmwareVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `VmwareVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_vmware_vms<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmsDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::VmwareVms(v.into()),
        );
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `AwsVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_vms(&self) -> std::option::Option<&std::boxed::Box<crate::model::AwsVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `AwsVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_aws_vms<T: std::convert::Into<std::boxed::Box<crate::model::AwsVmsDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::AwsVms(v.into()),
        );
        self
    }

    /// The value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// if it holds a `AzureVms`, `None` if the field is not set or
    /// holds a different branch.
    pub fn azure_vms(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AzureVmsDetails>> {
        #[allow(unreachable_patterns)]
        self.source_vms.as_ref().and_then(|v| match v {
            crate::model::fetch_inventory_response::SourceVms::AzureVms(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_vms][crate::model::FetchInventoryResponse::source_vms]
    /// to hold a `AzureVms`.
    ///
    /// Note that all the setters affecting `source_vms` are
    /// mutually exclusive.
    pub fn set_azure_vms<T: std::convert::Into<std::boxed::Box<crate::model::AzureVmsDetails>>>(
        mut self,
        v: T,
    ) -> Self {
        self.source_vms = std::option::Option::Some(
            crate::model::fetch_inventory_response::SourceVms::AzureVms(v.into()),
        );
        self
    }
}

impl wkt::message::Message for FetchInventoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchInventoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchInventoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware_vms,
            __aws_vms,
            __azure_vms,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchInventoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmwareVms" => Ok(__FieldTag::__vmware_vms),
                            "vmware_vms" => Ok(__FieldTag::__vmware_vms),
                            "awsVms" => Ok(__FieldTag::__aws_vms),
                            "aws_vms" => Ok(__FieldTag::__aws_vms),
                            "azureVms" => Ok(__FieldTag::__azure_vms),
                            "azure_vms" => Ok(__FieldTag::__azure_vms),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchInventoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchInventoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware_vms => {
                            if !fields.insert(__FieldTag::__vmware_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_vms",
                                ));
                            }
                            if result.source_vms.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vms`, a oneof with full ID .google.cloud.vmmigration.v1.FetchInventoryResponse.vmware_vms, latest field was vmwareVms",
                                ));
                            }
                            result.source_vms = std::option::Option::Some(
                                crate::model::fetch_inventory_response::SourceVms::VmwareVms(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareVmsDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__aws_vms => {
                            if !fields.insert(__FieldTag::__aws_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_vms",
                                ));
                            }
                            if result.source_vms.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vms`, a oneof with full ID .google.cloud.vmmigration.v1.FetchInventoryResponse.aws_vms, latest field was awsVms",
                                ));
                            }
                            result.source_vms = std::option::Option::Some(
                                crate::model::fetch_inventory_response::SourceVms::AwsVms(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AwsVmsDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__azure_vms => {
                            if !fields.insert(__FieldTag::__azure_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for azure_vms",
                                ));
                            }
                            if result.source_vms.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_vms`, a oneof with full ID .google.cloud.vmmigration.v1.FetchInventoryResponse.azure_vms, latest field was azureVms",
                                ));
                            }
                            result.source_vms = std::option::Option::Some(
                                crate::model::fetch_inventory_response::SourceVms::AzureVms(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AzureVmsDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchInventoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware_vms() {
            state.serialize_entry("vmwareVms", value)?;
        }
        if let Some(value) = self.aws_vms() {
            state.serialize_entry("awsVms", value)?;
        }
        if let Some(value) = self.azure_vms() {
            state.serialize_entry("azureVms", value)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchInventoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchInventoryResponse");
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("source_vms", &self.source_vms);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FetchInventoryResponse].
pub mod fetch_inventory_response {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceVms {
        /// The description of the VMs in a Source of type Vmware.
        VmwareVms(std::boxed::Box<crate::model::VmwareVmsDetails>),
        /// The description of the VMs in a Source of type AWS.
        AwsVms(std::boxed::Box<crate::model::AwsVmsDetails>),
        /// The description of the VMs in a Source of type Azure.
        AzureVms(std::boxed::Box<crate::model::AzureVmsDetails>),
    }
}

/// Request message for
/// [fetchStorageInventory][google.cloud.vmmigration.v1.VmMigration.FetchStorageInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchStorageInventory]: crate::client::VmMigration::fetch_storage_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStorageInventoryRequest {
    /// Required. The name of the Source.
    pub source: std::string::String,

    /// Required. The type of the storage inventory to fetch.
    pub r#type: crate::model::fetch_storage_inventory_request::StorageType,

    /// Optional. If this flag is set to true, the source will be queried instead
    /// of using cached results. Using this flag will make the call slower.
    pub force_refresh: bool,

    /// Optional. The maximum number of VMs to return. The service may return
    /// fewer than this value.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `FetchStorageInventory`
    /// call. Provide this to retrieve the subsequent page. When paginating, all
    /// other parameters provided to `FetchStorageInventory` must match the call
    /// that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStorageInventoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source][crate::model::FetchStorageInventoryRequest::source].
    pub fn set_source<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::FetchStorageInventoryRequest::type].
    pub fn set_type<
        T: std::convert::Into<crate::model::fetch_storage_inventory_request::StorageType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [force_refresh][crate::model::FetchStorageInventoryRequest::force_refresh].
    pub fn set_force_refresh<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force_refresh = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchStorageInventoryRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchStorageInventoryRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStorageInventoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchStorageInventoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStorageInventoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source,
            __type,
            __force_refresh,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStorageInventoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "source" => Ok(__FieldTag::__source),
                            "type" => Ok(__FieldTag::__type),
                            "forceRefresh" => Ok(__FieldTag::__force_refresh),
                            "force_refresh" => Ok(__FieldTag::__force_refresh),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStorageInventoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStorageInventoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source => {
                            if !fields.insert(__FieldTag::__source) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source",
                                ));
                            }
                            result.source = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::fetch_storage_inventory_request::StorageType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force_refresh => {
                            if !fields.insert(__FieldTag::__force_refresh) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force_refresh",
                                ));
                            }
                            result.force_refresh = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStorageInventoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.source.is_empty() {
            state.serialize_entry("source", &self.source)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.force_refresh) {
            state.serialize_entry("forceRefresh", &self.force_refresh)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStorageInventoryRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStorageInventoryRequest");
        debug_struct.field("source", &self.source);
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("force_refresh", &self.force_refresh);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [FetchStorageInventoryRequest].
pub mod fetch_storage_inventory_request {
    #[allow(unused_imports)]
    use super::*;

    /// The type of the storage inventory to fetch.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageType {
        /// The type is unspecified.
        Unspecified,
        /// The type is disks.
        Disks,
        /// The type is snapshots.
        Snapshots,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [StorageType::value] or
        /// [StorageType::name].
        UnknownValue(storage_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod storage_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl StorageType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Disks => std::option::Option::Some(1),
                Self::Snapshots => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STORAGE_TYPE_UNSPECIFIED"),
                Self::Disks => std::option::Option::Some("DISKS"),
                Self::Snapshots => std::option::Option::Some("SNAPSHOTS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for StorageType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for StorageType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for StorageType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Disks,
                2 => Self::Snapshots,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for StorageType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STORAGE_TYPE_UNSPECIFIED" => Self::Unspecified,
                "DISKS" => Self::Disks,
                "SNAPSHOTS" => Self::Snapshots,
                _ => Self::UnknownValue(storage_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for StorageType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Disks => serializer.serialize_i32(1),
                Self::Snapshots => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for StorageType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<StorageType>::new(
                ".google.cloud.vmmigration.v1.FetchStorageInventoryRequest.StorageType",
            ))
        }
    }
}

/// Response message for
/// [fetchStorageInventory][google.cloud.vmmigration.v1.VmMigration.FetchStorageInventory].
///
/// [google.cloud.vmmigration.v1.VmMigration.FetchStorageInventory]: crate::client::VmMigration::fetch_storage_inventory
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchStorageInventoryResponse {
    /// The list of storage resources in the source.
    pub resources: std::vec::Vec<crate::model::SourceStorageResource>,

    /// Output only. The timestamp when the source was last queried (if the result
    /// is from the cache).
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchStorageInventoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [resources][crate::model::FetchStorageInventoryResponse::resources].
    pub fn set_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SourceStorageResource>,
    {
        use std::iter::Iterator;
        self.resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [update_time][crate::model::FetchStorageInventoryResponse::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::FetchStorageInventoryResponse::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchStorageInventoryResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchStorageInventoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FetchStorageInventoryResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchStorageInventoryResponse {
    type PageItem = crate::model::SourceStorageResource;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.resources
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchStorageInventoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __resources,
            __update_time,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchStorageInventoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "resources" => Ok(__FieldTag::__resources),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchStorageInventoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchStorageInventoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__resources => {
                            if !fields.insert(__FieldTag::__resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resources",
                                ));
                            }
                            result.resources = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SourceStorageResource>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchStorageInventoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.resources.is_empty() {
            state.serialize_entry("resources", &self.resources)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FetchStorageInventoryResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchStorageInventoryResponse");
        debug_struct.field("resources", &self.resources);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// SourceStorageResource describes a storage resource in the source.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SourceStorageResource {
    /// Source storage resource details.
    pub storage_resource:
        std::option::Option<crate::model::source_storage_resource::StorageResource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SourceStorageResource {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [storage_resource][crate::model::SourceStorageResource::storage_resource].
    ///
    /// Note that all the setters affecting `storage_resource` are mutually
    /// exclusive.
    pub fn set_storage_resource<
        T: std::convert::Into<
                std::option::Option<crate::model::source_storage_resource::StorageResource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_resource = v.into();
        self
    }

    /// The value of [storage_resource][crate::model::SourceStorageResource::storage_resource]
    /// if it holds a `AwsDiskDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_disk_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceDiskDetails>> {
        #[allow(unreachable_patterns)]
        self.storage_resource.as_ref().and_then(|v| match v {
            crate::model::source_storage_resource::StorageResource::AwsDiskDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [storage_resource][crate::model::SourceStorageResource::storage_resource]
    /// to hold a `AwsDiskDetails`.
    ///
    /// Note that all the setters affecting `storage_resource` are
    /// mutually exclusive.
    pub fn set_aws_disk_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceDiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.storage_resource = std::option::Option::Some(
            crate::model::source_storage_resource::StorageResource::AwsDiskDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for SourceStorageResource {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SourceStorageResource"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SourceStorageResource {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_disk_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SourceStorageResource")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsDiskDetails" => Ok(__FieldTag::__aws_disk_details),
                            "aws_disk_details" => Ok(__FieldTag::__aws_disk_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SourceStorageResource;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SourceStorageResource")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_disk_details => {
                            if !fields.insert(__FieldTag::__aws_disk_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_disk_details",
                                ));
                            }
                            if result.storage_resource.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `storage_resource`, a oneof with full ID .google.cloud.vmmigration.v1.SourceStorageResource.aws_disk_details, latest field was awsDiskDetails",
                                ));
                            }
                            result.storage_resource = std::option::Option::Some(
                                crate::model::source_storage_resource::StorageResource::AwsDiskDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsSourceDiskDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SourceStorageResource {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.aws_disk_details() {
            state.serialize_entry("awsDiskDetails", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SourceStorageResource {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SourceStorageResource");
        debug_struct.field("storage_resource", &self.storage_resource);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SourceStorageResource].
pub mod source_storage_resource {
    #[allow(unused_imports)]
    use super::*;

    /// Source storage resource details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum StorageResource {
        /// Source AWS volume details.
        AwsDiskDetails(std::boxed::Box<crate::model::AwsSourceDiskDetails>),
    }
}

/// Utilization report details the utilization (CPU, memory, etc.) of selected
/// source VMs.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UtilizationReport {
    /// Output only. The report unique name.
    pub name: std::string::String,

    /// The report display name, as assigned by the user.
    pub display_name: std::string::String,

    /// Output only. Current state of the report.
    pub state: crate::model::utilization_report::State,

    /// Output only. The time the state was last set.
    pub state_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the state of the report in case of an
    /// error.
    pub error: std::option::Option<rpc::model::Status>,

    /// Output only. The time the report was created (this refers to the time of
    /// the request, not the time the report creation completed).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Time frame of the report.
    pub time_frame: crate::model::utilization_report::TimeFrame,

    /// Output only. The point in time when the time frame ends. Notice that the
    /// time frame is counted backwards. For instance if the "frame_end_time" value
    /// is 2021/01/20 and the time frame is WEEK then the report covers the week
    /// between 2021/01/20 and 2021/01/14.
    pub frame_end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Total number of VMs included in the report.
    pub vm_count: i32,

    /// List of utilization information per VM.
    /// When sent as part of the request, the "vm_id" field is used in order to
    /// specify which VMs to include in the report. In that case all other fields
    /// are ignored.
    pub vms: std::vec::Vec<crate::model::VmUtilizationInfo>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UtilizationReport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UtilizationReport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::UtilizationReport::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UtilizationReport::state].
    pub fn set_state<T: std::convert::Into<crate::model::utilization_report::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_state_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [state_time][crate::model::UtilizationReport::state_time].
    pub fn set_or_clear_state_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.state_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [error][crate::model::UtilizationReport::error].
    pub fn set_error<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error][crate::model::UtilizationReport::error].
    pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::Status>,
    {
        self.error = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UtilizationReport::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [time_frame][crate::model::UtilizationReport::time_frame].
    pub fn set_time_frame<T: std::convert::Into<crate::model::utilization_report::TimeFrame>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_frame = v.into();
        self
    }

    /// Sets the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_frame_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [frame_end_time][crate::model::UtilizationReport::frame_end_time].
    pub fn set_or_clear_frame_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.frame_end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_count][crate::model::UtilizationReport::vm_count].
    pub fn set_vm_count<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.vm_count = v.into();
        self
    }

    /// Sets the value of [vms][crate::model::UtilizationReport::vms].
    pub fn set_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::VmUtilizationInfo>,
    {
        use std::iter::Iterator;
        self.vms = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for UtilizationReport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UtilizationReport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UtilizationReport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __display_name,
            __state,
            __state_time,
            __error,
            __create_time,
            __time_frame,
            __frame_end_time,
            __vm_count,
            __vms,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UtilizationReport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "state" => Ok(__FieldTag::__state),
                            "stateTime" => Ok(__FieldTag::__state_time),
                            "state_time" => Ok(__FieldTag::__state_time),
                            "error" => Ok(__FieldTag::__error),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "timeFrame" => Ok(__FieldTag::__time_frame),
                            "time_frame" => Ok(__FieldTag::__time_frame),
                            "frameEndTime" => Ok(__FieldTag::__frame_end_time),
                            "frame_end_time" => Ok(__FieldTag::__frame_end_time),
                            "vmCount" => Ok(__FieldTag::__vm_count),
                            "vm_count" => Ok(__FieldTag::__vm_count),
                            "vms" => Ok(__FieldTag::__vms),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UtilizationReport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UtilizationReport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::utilization_report::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state_time => {
                            if !fields.insert(__FieldTag::__state_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_time",
                                ));
                            }
                            result.state_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__error => {
                            if !fields.insert(__FieldTag::__error) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error",
                                ));
                            }
                            result.error =
                                map.next_value::<std::option::Option<rpc::model::Status>>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__time_frame => {
                            if !fields.insert(__FieldTag::__time_frame) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_frame",
                                ));
                            }
                            result.time_frame =
                                map.next_value::<std::option::Option<
                                    crate::model::utilization_report::TimeFrame,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__frame_end_time => {
                            if !fields.insert(__FieldTag::__frame_end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for frame_end_time",
                                ));
                            }
                            result.frame_end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__vm_count => {
                            if !fields.insert(__FieldTag::__vm_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_count",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.vm_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__vms => {
                            if !fields.insert(__FieldTag::__vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vms",
                                ));
                            }
                            result.vms =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::VmUtilizationInfo>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UtilizationReport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.state_time.is_some() {
            state.serialize_entry("stateTime", &self.state_time)?;
        }
        if self.error.is_some() {
            state.serialize_entry("error", &self.error)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.time_frame) {
            state.serialize_entry("timeFrame", &self.time_frame)?;
        }
        if self.frame_end_time.is_some() {
            state.serialize_entry("frameEndTime", &self.frame_end_time)?;
        }
        if !wkt::internal::is_default(&self.vm_count) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("vmCount", &__With(&self.vm_count))?;
        }
        if !self.vms.is_empty() {
            state.serialize_entry("vms", &self.vms)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UtilizationReport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UtilizationReport");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("state", &self.state);
        debug_struct.field("state_time", &self.state_time);
        debug_struct.field("error", &self.error);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("time_frame", &self.time_frame);
        debug_struct.field("frame_end_time", &self.frame_end_time);
        debug_struct.field("vm_count", &self.vm_count);
        debug_struct.field("vms", &self.vms);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [UtilizationReport].
pub mod utilization_report {
    #[allow(unused_imports)]
    use super::*;

    /// Utilization report state.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown. This value is not in use.
        Unspecified,
        /// The report is in the making.
        Creating,
        /// Report creation completed successfully.
        Succeeded,
        /// Report creation failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.State",
            ))
        }
    }

    /// Report time frame options.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TimeFrame {
        /// The time frame was not specified and will default to WEEK.
        Unspecified,
        /// One week.
        Week,
        /// One month.
        Month,
        /// One year.
        Year,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TimeFrame::value] or
        /// [TimeFrame::name].
        UnknownValue(time_frame::UnknownValue),
    }

    #[doc(hidden)]
    pub mod time_frame {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TimeFrame {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Week => std::option::Option::Some(1),
                Self::Month => std::option::Option::Some(2),
                Self::Year => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TIME_FRAME_UNSPECIFIED"),
                Self::Week => std::option::Option::Some("WEEK"),
                Self::Month => std::option::Option::Some("MONTH"),
                Self::Year => std::option::Option::Some("YEAR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TimeFrame {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TimeFrame {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TimeFrame {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Week,
                2 => Self::Month,
                3 => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TimeFrame {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TIME_FRAME_UNSPECIFIED" => Self::Unspecified,
                "WEEK" => Self::Week,
                "MONTH" => Self::Month,
                "YEAR" => Self::Year,
                _ => Self::UnknownValue(time_frame::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TimeFrame {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Week => serializer.serialize_i32(1),
                Self::Month => serializer.serialize_i32(2),
                Self::Year => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TimeFrame {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TimeFrame>::new(
                ".google.cloud.vmmigration.v1.UtilizationReport.TimeFrame",
            ))
        }
    }
}

/// Utilization information of a single VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmUtilizationInfo {
    /// The VM's ID in the source.
    pub vm_id: std::string::String,

    /// Utilization metrics for this VM.
    pub utilization: std::option::Option<crate::model::VmUtilizationMetrics>,

    pub vm_details: std::option::Option<crate::model::vm_utilization_info::VmDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationInfo {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_id][crate::model::VmUtilizationInfo::vm_id].
    pub fn set_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_id = v.into();
        self
    }

    /// Sets the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_utilization<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization][crate::model::VmUtilizationInfo::utilization].
    pub fn set_or_clear_utilization<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmUtilizationMetrics>,
    {
        self.utilization = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details].
    ///
    /// Note that all the setters affecting `vm_details` are mutually
    /// exclusive.
    pub fn set_vm_details<
        T: std::convert::Into<std::option::Option<crate::model::vm_utilization_info::VmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = v.into();
        self
    }

    /// The value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// if it holds a `VmwareVmDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vmware_vm_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::VmwareVmDetails>> {
        #[allow(unreachable_patterns)]
        self.vm_details.as_ref().and_then(|v| match v {
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_details][crate::model::VmUtilizationInfo::vm_details]
    /// to hold a `VmwareVmDetails`.
    ///
    /// Note that all the setters affecting `vm_details` are
    /// mutually exclusive.
    pub fn set_vmware_vm_details<
        T: std::convert::Into<std::boxed::Box<crate::model::VmwareVmDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_details = std::option::Option::Some(
            crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for VmUtilizationInfo {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationInfo"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmUtilizationInfo {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vmware_vm_details,
            __vm_id,
            __utilization,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmUtilizationInfo")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmwareVmDetails" => Ok(__FieldTag::__vmware_vm_details),
                            "vmware_vm_details" => Ok(__FieldTag::__vmware_vm_details),
                            "vmId" => Ok(__FieldTag::__vm_id),
                            "vm_id" => Ok(__FieldTag::__vm_id),
                            "utilization" => Ok(__FieldTag::__utilization),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmUtilizationInfo;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmUtilizationInfo")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vmware_vm_details => {
                            if !fields.insert(__FieldTag::__vmware_vm_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vmware_vm_details",
                                ));
                            }
                            if result.vm_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_details`, a oneof with full ID .google.cloud.vmmigration.v1.VmUtilizationInfo.vmware_vm_details, latest field was vmwareVmDetails",
                                ));
                            }
                            result.vm_details = std::option::Option::Some(
                                crate::model::vm_utilization_info::VmDetails::VmwareVmDetails(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::VmwareVmDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__vm_id => {
                            if !fields.insert(__FieldTag::__vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_id",
                                ));
                            }
                            result.vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization => {
                            if !fields.insert(__FieldTag::__utilization) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization",
                                ));
                            }
                            result.utilization = map.next_value::<std::option::Option<crate::model::VmUtilizationMetrics>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmUtilizationInfo {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.vmware_vm_details() {
            state.serialize_entry("vmwareVmDetails", value)?;
        }
        if !self.vm_id.is_empty() {
            state.serialize_entry("vmId", &self.vm_id)?;
        }
        if self.utilization.is_some() {
            state.serialize_entry("utilization", &self.utilization)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmUtilizationInfo {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmUtilizationInfo");
        debug_struct.field("vm_id", &self.vm_id);
        debug_struct.field("utilization", &self.utilization);
        debug_struct.field("vm_details", &self.vm_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmUtilizationInfo].
pub mod vm_utilization_info {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmDetails {
        /// The description of the VM in a Source of type Vmware.
        VmwareVmDetails(std::boxed::Box<crate::model::VmwareVmDetails>),
    }
}

/// Utilization metrics values for a single VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmUtilizationMetrics {
    /// Max CPU usage, percent.
    pub cpu_max_percent: i32,

    /// Average CPU usage, percent.
    pub cpu_average_percent: i32,

    /// Max memory usage, percent.
    pub memory_max_percent: i32,

    /// Average memory usage, percent.
    pub memory_average_percent: i32,

    /// Max disk IO rate, in kilobytes per second.
    pub disk_io_rate_max_kbps: i64,

    /// Average disk IO rate, in kilobytes per second.
    pub disk_io_rate_average_kbps: i64,

    /// Max network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    pub network_throughput_max_kbps: i64,

    /// Average network throughput (combined transmit-rates and receive-rates), in
    /// kilobytes per second.
    pub network_throughput_average_kbps: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmUtilizationMetrics {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cpu_max_percent][crate::model::VmUtilizationMetrics::cpu_max_percent].
    pub fn set_cpu_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_max_percent = v.into();
        self
    }

    /// Sets the value of [cpu_average_percent][crate::model::VmUtilizationMetrics::cpu_average_percent].
    pub fn set_cpu_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.cpu_average_percent = v.into();
        self
    }

    /// Sets the value of [memory_max_percent][crate::model::VmUtilizationMetrics::memory_max_percent].
    pub fn set_memory_max_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_max_percent = v.into();
        self
    }

    /// Sets the value of [memory_average_percent][crate::model::VmUtilizationMetrics::memory_average_percent].
    pub fn set_memory_average_percent<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.memory_average_percent = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_max_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_max_kbps].
    pub fn set_disk_io_rate_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_max_kbps = v.into();
        self
    }

    /// Sets the value of [disk_io_rate_average_kbps][crate::model::VmUtilizationMetrics::disk_io_rate_average_kbps].
    pub fn set_disk_io_rate_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_io_rate_average_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_max_kbps][crate::model::VmUtilizationMetrics::network_throughput_max_kbps].
    pub fn set_network_throughput_max_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_max_kbps = v.into();
        self
    }

    /// Sets the value of [network_throughput_average_kbps][crate::model::VmUtilizationMetrics::network_throughput_average_kbps].
    pub fn set_network_throughput_average_kbps<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.network_throughput_average_kbps = v.into();
        self
    }
}

impl wkt::message::Message for VmUtilizationMetrics {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmUtilizationMetrics"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmUtilizationMetrics {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cpu_max_percent,
            __cpu_average_percent,
            __memory_max_percent,
            __memory_average_percent,
            __disk_io_rate_max_kbps,
            __disk_io_rate_average_kbps,
            __network_throughput_max_kbps,
            __network_throughput_average_kbps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmUtilizationMetrics")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cpuMaxPercent" => Ok(__FieldTag::__cpu_max_percent),
                            "cpu_max_percent" => Ok(__FieldTag::__cpu_max_percent),
                            "cpuAveragePercent" => Ok(__FieldTag::__cpu_average_percent),
                            "cpu_average_percent" => Ok(__FieldTag::__cpu_average_percent),
                            "memoryMaxPercent" => Ok(__FieldTag::__memory_max_percent),
                            "memory_max_percent" => Ok(__FieldTag::__memory_max_percent),
                            "memoryAveragePercent" => Ok(__FieldTag::__memory_average_percent),
                            "memory_average_percent" => Ok(__FieldTag::__memory_average_percent),
                            "diskIoRateMaxKbps" => Ok(__FieldTag::__disk_io_rate_max_kbps),
                            "disk_io_rate_max_kbps" => Ok(__FieldTag::__disk_io_rate_max_kbps),
                            "diskIoRateAverageKbps" => Ok(__FieldTag::__disk_io_rate_average_kbps),
                            "disk_io_rate_average_kbps" => {
                                Ok(__FieldTag::__disk_io_rate_average_kbps)
                            }
                            "networkThroughputMaxKbps" => {
                                Ok(__FieldTag::__network_throughput_max_kbps)
                            }
                            "network_throughput_max_kbps" => {
                                Ok(__FieldTag::__network_throughput_max_kbps)
                            }
                            "networkThroughputAverageKbps" => {
                                Ok(__FieldTag::__network_throughput_average_kbps)
                            }
                            "network_throughput_average_kbps" => {
                                Ok(__FieldTag::__network_throughput_average_kbps)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmUtilizationMetrics;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmUtilizationMetrics")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cpu_max_percent => {
                            if !fields.insert(__FieldTag::__cpu_max_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_max_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_max_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__cpu_average_percent => {
                            if !fields.insert(__FieldTag::__cpu_average_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cpu_average_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.cpu_average_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_max_percent => {
                            if !fields.insert(__FieldTag::__memory_max_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_max_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_max_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__memory_average_percent => {
                            if !fields.insert(__FieldTag::__memory_average_percent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for memory_average_percent",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.memory_average_percent =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_io_rate_max_kbps => {
                            if !fields.insert(__FieldTag::__disk_io_rate_max_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_io_rate_max_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_io_rate_max_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_io_rate_average_kbps => {
                            if !fields.insert(__FieldTag::__disk_io_rate_average_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_io_rate_average_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_io_rate_average_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_throughput_max_kbps => {
                            if !fields.insert(__FieldTag::__network_throughput_max_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_throughput_max_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.network_throughput_max_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__network_throughput_average_kbps => {
                            if !fields.insert(__FieldTag::__network_throughput_average_kbps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_throughput_average_kbps",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.network_throughput_average_kbps =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmUtilizationMetrics {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.cpu_max_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuMaxPercent", &__With(&self.cpu_max_percent))?;
        }
        if !wkt::internal::is_default(&self.cpu_average_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("cpuAveragePercent", &__With(&self.cpu_average_percent))?;
        }
        if !wkt::internal::is_default(&self.memory_max_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("memoryMaxPercent", &__With(&self.memory_max_percent))?;
        }
        if !wkt::internal::is_default(&self.memory_average_percent) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "memoryAveragePercent",
                &__With(&self.memory_average_percent),
            )?;
        }
        if !wkt::internal::is_default(&self.disk_io_rate_max_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskIoRateMaxKbps", &__With(&self.disk_io_rate_max_kbps))?;
        }
        if !wkt::internal::is_default(&self.disk_io_rate_average_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "diskIoRateAverageKbps",
                &__With(&self.disk_io_rate_average_kbps),
            )?;
        }
        if !wkt::internal::is_default(&self.network_throughput_max_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "networkThroughputMaxKbps",
                &__With(&self.network_throughput_max_kbps),
            )?;
        }
        if !wkt::internal::is_default(&self.network_throughput_average_kbps) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "networkThroughputAverageKbps",
                &__With(&self.network_throughput_average_kbps),
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmUtilizationMetrics {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmUtilizationMetrics");
        debug_struct.field("cpu_max_percent", &self.cpu_max_percent);
        debug_struct.field("cpu_average_percent", &self.cpu_average_percent);
        debug_struct.field("memory_max_percent", &self.memory_max_percent);
        debug_struct.field("memory_average_percent", &self.memory_average_percent);
        debug_struct.field("disk_io_rate_max_kbps", &self.disk_io_rate_max_kbps);
        debug_struct.field("disk_io_rate_average_kbps", &self.disk_io_rate_average_kbps);
        debug_struct.field(
            "network_throughput_max_kbps",
            &self.network_throughput_max_kbps,
        );
        debug_struct.field(
            "network_throughput_average_kbps",
            &self.network_throughput_average_kbps,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListUtilizationReports' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUtilizationReportsRequest {
    /// Required. The Utilization Reports parent.
    pub parent: std::string::String,

    /// Optional. The level of details of each report.
    /// Defaults to BASIC.
    pub view: crate::model::UtilizationReportView,

    /// Optional. The maximum number of reports to return. The service may return
    /// fewer than this value. If unspecified, at most 500 reports will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListUtilizationReports`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListUtilizationReports`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListUtilizationReportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListUtilizationReportsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListUtilizationReportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListUtilizationReportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListUtilizationReportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListUtilizationReportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUtilizationReportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __view,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUtilizationReportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "view" => Ok(__FieldTag::__view),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUtilizationReportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUtilizationReportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::UtilizationReportView>>()?.unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUtilizationReportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUtilizationReportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUtilizationReportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("view", &self.view);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListUtilizationReports' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListUtilizationReportsResponse {
    /// Output only. The list of reports.
    pub utilization_reports: std::vec::Vec<crate::model::UtilizationReport>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListUtilizationReportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [utilization_reports][crate::model::ListUtilizationReportsResponse::utilization_reports].
    pub fn set_utilization_reports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UtilizationReport>,
    {
        use std::iter::Iterator;
        self.utilization_reports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListUtilizationReportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListUtilizationReportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListUtilizationReportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListUtilizationReportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListUtilizationReportsResponse {
    type PageItem = crate::model::UtilizationReport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.utilization_reports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListUtilizationReportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __utilization_reports,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListUtilizationReportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "utilizationReports" => Ok(__FieldTag::__utilization_reports),
                            "utilization_reports" => Ok(__FieldTag::__utilization_reports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListUtilizationReportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListUtilizationReportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__utilization_reports => {
                            if !fields.insert(__FieldTag::__utilization_reports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_reports",
                                ));
                            }
                            result.utilization_reports =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UtilizationReport>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListUtilizationReportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.utilization_reports.is_empty() {
            state.serialize_entry("utilizationReports", &self.utilization_reports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListUtilizationReportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUtilizationReportsResponse");
        debug_struct.field("utilization_reports", &self.utilization_reports);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetUtilizationReportRequest {
    /// Required. The Utilization Report name.
    pub name: std::string::String,

    /// Optional. The level of details of the report.
    /// Defaults to FULL
    pub view: crate::model::UtilizationReportView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetUtilizationReportRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::UtilizationReportView>>(
        mut self,
        v: T,
    ) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map.next_value::<std::option::Option<crate::model::UtilizationReportView>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetUtilizationReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateUtilizationReportRequest {
    /// Required. The Utilization Report's parent.
    pub parent: std::string::String,

    /// Required. The report to create.
    pub utilization_report: std::option::Option<crate::model::UtilizationReport>,

    /// Required. The ID to use for the report, which will become the final
    /// component of the reports's resource name.
    ///
    /// This value maximum length is 63 characters, and valid characters
    /// are /[a-z][0-9]-/. It must start with an english letter and must not
    /// end with a hyphen.
    pub utilization_report_id: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateUtilizationReportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_utilization_report<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [utilization_report][crate::model::CreateUtilizationReportRequest::utilization_report].
    pub fn set_or_clear_utilization_report<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UtilizationReport>,
    {
        self.utilization_report = v.map(|x| x.into());
        self
    }

    /// Sets the value of [utilization_report_id][crate::model::CreateUtilizationReportRequest::utilization_report_id].
    pub fn set_utilization_report_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.utilization_report_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __utilization_report,
            __utilization_report_id,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "utilizationReport" => Ok(__FieldTag::__utilization_report),
                            "utilization_report" => Ok(__FieldTag::__utilization_report),
                            "utilizationReportId" => Ok(__FieldTag::__utilization_report_id),
                            "utilization_report_id" => Ok(__FieldTag::__utilization_report_id),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__utilization_report => {
                            if !fields.insert(__FieldTag::__utilization_report) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_report",
                                ));
                            }
                            result.utilization_report = map
                                .next_value::<std::option::Option<crate::model::UtilizationReport>>(
                                )?;
                        }
                        __FieldTag::__utilization_report_id => {
                            if !fields.insert(__FieldTag::__utilization_report_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for utilization_report_id",
                                ));
                            }
                            result.utilization_report_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.utilization_report.is_some() {
            state.serialize_entry("utilizationReport", &self.utilization_report)?;
        }
        if !self.utilization_report_id.is_empty() {
            state.serialize_entry("utilizationReportId", &self.utilization_report_id)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateUtilizationReportRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("utilization_report", &self.utilization_report);
        debug_struct.field("utilization_report_id", &self.utilization_report_id);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteUtilizationReport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteUtilizationReportRequest {
    /// Required. The Utilization Report name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteUtilizationReportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteUtilizationReportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteUtilizationReportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteUtilizationReportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteUtilizationReportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteUtilizationReportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteUtilizationReportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteUtilizationReportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteUtilizationReportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteUtilizationReportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteUtilizationReportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUtilizationReportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListDatacenterConnectors' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatacenterConnectorsResponse {
    /// Output only. The list of sources response.
    pub datacenter_connectors: std::vec::Vec<crate::model::DatacenterConnector>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connectors][crate::model::ListDatacenterConnectorsResponse::datacenter_connectors].
    pub fn set_datacenter_connectors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DatacenterConnector>,
    {
        use std::iter::Iterator;
        self.datacenter_connectors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDatacenterConnectorsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatacenterConnectorsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDatacenterConnectorsResponse {
    type PageItem = crate::model::DatacenterConnector;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datacenter_connectors
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatacenterConnectorsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datacenter_connectors,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatacenterConnectorsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datacenterConnectors" => Ok(__FieldTag::__datacenter_connectors),
                            "datacenter_connectors" => Ok(__FieldTag::__datacenter_connectors),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatacenterConnectorsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatacenterConnectorsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datacenter_connectors => {
                            if !fields.insert(__FieldTag::__datacenter_connectors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connectors",
                                ));
                            }
                            result.datacenter_connectors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DatacenterConnector>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatacenterConnectorsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datacenter_connectors.is_empty() {
            state.serialize_entry("datacenterConnectors", &self.datacenter_connectors)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDatacenterConnectorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDatacenterConnectorsResponse");
        debug_struct.field("datacenter_connectors", &self.datacenter_connectors);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDatacenterConnectorRequest {
    /// Required. The name of the DatacenterConnector.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDatacenterConnectorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDatacenterConnectorRequest {
    /// Required. The DatacenterConnector's parent.
    /// Required. The Source in where the new DatacenterConnector will be created.
    /// For example:
    /// `projects/my-project/locations/us-central1/sources/my-source`
    pub parent: std::string::String,

    /// Required. The datacenterConnector identifier.
    pub datacenter_connector_id: std::string::String,

    /// Required. The create request body.
    pub datacenter_connector: std::option::Option<crate::model::DatacenterConnector>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatacenterConnectorRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [datacenter_connector_id][crate::model::CreateDatacenterConnectorRequest::datacenter_connector_id].
    pub fn set_datacenter_connector_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector_id = v.into();
        self
    }

    /// Sets the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_datacenter_connector<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [datacenter_connector][crate::model::CreateDatacenterConnectorRequest::datacenter_connector].
    pub fn set_or_clear_datacenter_connector<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DatacenterConnector>,
    {
        self.datacenter_connector = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __datacenter_connector_id,
            __datacenter_connector,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "datacenterConnectorId" => Ok(__FieldTag::__datacenter_connector_id),
                            "datacenter_connector_id" => Ok(__FieldTag::__datacenter_connector_id),
                            "datacenterConnector" => Ok(__FieldTag::__datacenter_connector),
                            "datacenter_connector" => Ok(__FieldTag::__datacenter_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_connector_id => {
                            if !fields.insert(__FieldTag::__datacenter_connector_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector_id",
                                ));
                            }
                            result.datacenter_connector_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__datacenter_connector => {
                            if !fields.insert(__FieldTag::__datacenter_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector",
                                ));
                            }
                            result.datacenter_connector = map.next_value::<std::option::Option<crate::model::DatacenterConnector>>()?
                                ;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.datacenter_connector_id.is_empty() {
            state.serialize_entry("datacenterConnectorId", &self.datacenter_connector_id)?;
        }
        if self.datacenter_connector.is_some() {
            state.serialize_entry("datacenterConnector", &self.datacenter_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDatacenterConnectorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("datacenter_connector_id", &self.datacenter_connector_id);
        debug_struct.field("datacenter_connector", &self.datacenter_connector);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteDatacenterConnector' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDatacenterConnectorRequest {
    /// Required. The DatacenterConnector name.
    pub name: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDatacenterConnectorRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatacenterConnectorRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDatacenterConnectorRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatacenterConnectorRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteDatacenterConnectorRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDatacenterConnectorRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDatacenterConnectorRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDatacenterConnectorRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDatacenterConnectorRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDatacenterConnectorRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDatacenterConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDatacenterConnectorRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpgradeAppliance' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeApplianceRequest {
    /// Required. The DatacenterConnector name.
    pub datacenter_connector: std::string::String,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [datacenter_connector][crate::model::UpgradeApplianceRequest::datacenter_connector].
    pub fn set_datacenter_connector<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.datacenter_connector = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpgradeApplianceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeApplianceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeApplianceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __datacenter_connector,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeApplianceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "datacenterConnector" => Ok(__FieldTag::__datacenter_connector),
                            "datacenter_connector" => Ok(__FieldTag::__datacenter_connector),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeApplianceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeApplianceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__datacenter_connector => {
                            if !fields.insert(__FieldTag::__datacenter_connector) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for datacenter_connector",
                                ));
                            }
                            result.datacenter_connector = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeApplianceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.datacenter_connector.is_empty() {
            state.serialize_entry("datacenterConnector", &self.datacenter_connector)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeApplianceRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeApplianceRequest");
        debug_struct.field("datacenter_connector", &self.datacenter_connector);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'UpgradeAppliance' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeApplianceResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeApplianceResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for UpgradeApplianceResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpgradeApplianceResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeApplianceResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeApplianceResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeApplianceResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeApplianceResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeApplianceResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpgradeApplianceResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpgradeApplianceResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListDatacenterConnectors' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDatacenterConnectorsRequest {
    /// Required. The parent, which owns this collection of connectors.
    pub parent: std::string::String,

    /// Optional. The maximum number of connectors to return. The service may
    /// return fewer than this value. If unspecified, at most 500 sources will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListDatacenterConnectors`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListDatacenterConnectors` must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDatacenterConnectorsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatacenterConnectorsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatacenterConnectorsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatacenterConnectorsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatacenterConnectorsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatacenterConnectorsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatacenterConnectorsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDatacenterConnectorsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDatacenterConnectorsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDatacenterConnectorsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDatacenterConnectorsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDatacenterConnectorsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDatacenterConnectorsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDatacenterConnectorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDatacenterConnectorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ComputeEngineTargetDefaults is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineTargetDefaults {
    /// The name of the VM to create.
    pub vm_name: std::string::String,

    /// The full path of the resource of type TargetProject which represents the
    /// Compute Engine project in which to create this VM.
    pub target_project: std::string::String,

    /// The zone in which to create the VM.
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    pub machine_type: std::string::String,

    /// A list of network tags to associate with the VM.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. The service account to associate the VM with.
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// Output only. The OS license returned from the adaptation module report.
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the VM boot option is EFI.
    pub secure_boot: bool,

    /// Optional. Defines whether the instance has vTPM enabled.
    /// This can be set to true only if the VM boot option is EFI.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the instance has integrity monitoring enabled.
    /// This can be set to true only if the VM boot option is EFI, and vTPM is
    /// enabled.
    pub enable_integrity_monitoring: bool,

    /// Output only. The VM Boot Option, as set in the source VM.
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    pub hostname: std::string::String,

    /// Optional. Immutable. The encryption to apply to the VM disks.
    pub encryption: std::option::Option<crate::model::Encryption>,

    /// Optional. By default the virtual machine will keep its existing boot
    /// option. Setting this property will trigger an internal process which will
    /// convert the virtual machine from using the existing boot option to another.
    pub boot_conversion: crate::model::BootConversion,

    /// Optional. Additional replica zones of the target regional disks.
    /// If this list is not empty a regional disk will be created. The first
    /// supported zone would be the one stated in the
    /// [zone][google.cloud.vmmigration.v1.ComputeEngineTargetDefaults.zone] field.
    /// The rest are taken from this list. Please refer to the [regional disk
    /// creation
    /// API](https://cloud.google.com/compute/docs/regions-zones/global-regional-zonal-resources)
    /// for further details about regional vs zonal disks. If not specified, a
    /// zonal disk will be created in the same zone the VM is created.
    ///
    /// [google.cloud.vmmigration.v1.ComputeEngineTargetDefaults.zone]: crate::model::ComputeEngineTargetDefaults::zone
    pub disk_replica_zones: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDefaults::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::ComputeEngineTargetDefaults::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDefaults::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDefaults::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDefaults::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDefaults::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDefaults::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDefaults::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDefaults::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDefaults::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDefaults::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDefaults::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ComputeEngineTargetDefaults::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ComputeEngineTargetDefaults::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDefaults::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDefaults::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDefaults::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDefaults::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::ComputeEngineTargetDefaults::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::ComputeEngineTargetDefaults::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_conversion][crate::model::ComputeEngineTargetDefaults::boot_conversion].
    pub fn set_boot_conversion<T: std::convert::Into<crate::model::BootConversion>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_conversion = v.into();
        self
    }

    /// Sets the value of [disk_replica_zones][crate::model::ComputeEngineTargetDefaults::disk_replica_zones].
    pub fn set_disk_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.disk_replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineTargetDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_name,
            __target_project,
            __zone,
            __machine_type_series,
            __machine_type,
            __network_tags,
            __network_interfaces,
            __service_account,
            __disk_type,
            __labels,
            __license_type,
            __applied_license,
            __compute_scheduling,
            __secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            __boot_option,
            __metadata,
            __additional_licenses,
            __hostname,
            __encryption,
            __boot_conversion,
            __disk_replica_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineTargetDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "zone" => Ok(__FieldTag::__zone),
                            "machineTypeSeries" => Ok(__FieldTag::__machine_type_series),
                            "machine_type_series" => Ok(__FieldTag::__machine_type_series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "appliedLicense" => Ok(__FieldTag::__applied_license),
                            "applied_license" => Ok(__FieldTag::__applied_license),
                            "computeScheduling" => Ok(__FieldTag::__compute_scheduling),
                            "compute_scheduling" => Ok(__FieldTag::__compute_scheduling),
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "bootConversion" => Ok(__FieldTag::__boot_conversion),
                            "boot_conversion" => Ok(__FieldTag::__boot_conversion),
                            "diskReplicaZones" => Ok(__FieldTag::__disk_replica_zones),
                            "disk_replica_zones" => Ok(__FieldTag::__disk_replica_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineTargetDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineTargetDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_series => {
                            if !fields.insert(__FieldTag::__machine_type_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_series",
                                ));
                            }
                            result.machine_type_series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map.next_value::<std::option::Option<crate::model::ComputeEngineLicenseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__applied_license => {
                            if !fields.insert(__FieldTag::__applied_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_license",
                                ));
                            }
                            result.applied_license = map
                                .next_value::<std::option::Option<crate::model::AppliedLicense>>(
                                )?;
                        }
                        __FieldTag::__compute_scheduling => {
                            if !fields.insert(__FieldTag::__compute_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_scheduling",
                                ));
                            }
                            result.compute_scheduling = map
                                .next_value::<std::option::Option<crate::model::ComputeScheduling>>(
                                )?;
                        }
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::ComputeEngineBootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::__boot_conversion => {
                            if !fields.insert(__FieldTag::__boot_conversion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_conversion",
                                ));
                            }
                            result.boot_conversion = map
                                .next_value::<std::option::Option<crate::model::BootConversion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_replica_zones => {
                            if !fields.insert(__FieldTag::__disk_replica_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_replica_zones",
                                ));
                            }
                            result.disk_replica_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineTargetDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.machine_type_series.is_empty() {
            state.serialize_entry("machineTypeSeries", &self.machine_type_series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if self.applied_license.is_some() {
            state.serialize_entry("appliedLicense", &self.applied_license)?;
        }
        if self.compute_scheduling.is_some() {
            state.serialize_entry("computeScheduling", &self.compute_scheduling)?;
        }
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_vtpm) {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !wkt::internal::is_default(&self.boot_conversion) {
            state.serialize_entry("bootConversion", &self.boot_conversion)?;
        }
        if !self.disk_replica_zones.is_empty() {
            state.serialize_entry("diskReplicaZones", &self.disk_replica_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineTargetDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineTargetDefaults");
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("machine_type_series", &self.machine_type_series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("applied_license", &self.applied_license);
        debug_struct.field("compute_scheduling", &self.compute_scheduling);
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("enable_vtpm", &self.enable_vtpm);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("boot_conversion", &self.boot_conversion);
        debug_struct.field("disk_replica_zones", &self.disk_replica_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ComputeEngineTargetDetails is a collection of details for creating a VM in a
/// target Compute Engine project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineTargetDetails {
    /// The name of the VM to create.
    pub vm_name: std::string::String,

    /// The Google Cloud target project ID or project name.
    pub project: std::string::String,

    /// The zone in which to create the VM.
    pub zone: std::string::String,

    /// The machine type series to create the VM with.
    pub machine_type_series: std::string::String,

    /// The machine type to create the VM with.
    pub machine_type: std::string::String,

    /// A list of network tags to associate with the VM.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// List of NICs connected to this VM.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// The service account to associate the VM with.
    pub service_account: std::string::String,

    /// The disk type to use in the VM.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// The license type to use in OS adaptation.
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// The OS license returned from the adaptation module report.
    pub applied_license: std::option::Option<crate::model::AppliedLicense>,

    /// Compute instance scheduling information (if empty default is used).
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the VM boot option is EFI.
    pub secure_boot: bool,

    /// Optional. Defines whether the instance has vTPM enabled.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the instance has integrity monitoring enabled.
    pub enable_integrity_monitoring: bool,

    /// The VM Boot Option, as set in the source VM.
    pub boot_option: crate::model::ComputeEngineBootOption,

    /// The metadata key/value pairs to assign to the VM.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Additional licenses to assign to the VM.
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// The hostname to assign to the VM.
    pub hostname: std::string::String,

    /// Optional. The encryption to apply to the VM disks.
    pub encryption: std::option::Option<crate::model::Encryption>,

    /// Optional. By default the virtual machine will keep its existing boot
    /// option. Setting this property will trigger an internal process which will
    /// convert the virtual machine from using the existing boot option to another.
    pub boot_conversion: crate::model::BootConversion,

    /// Optional. Additional replica zones of the target regional disks.
    /// If this list is not empty a regional disk will be created. The first
    /// supported zone would be the one stated in the
    /// [zone][google.cloud.vmmigration.v1.ComputeEngineTargetDetails.zone] field.
    /// The rest are taken from this list. Please refer to the [regional disk
    /// creation
    /// API](https://cloud.google.com/compute/docs/regions-zones/global-regional-zonal-resources)
    /// for further details about regional vs zonal disks. If not specified, a
    /// zonal disk will be created in the same zone the VM is created.
    ///
    /// [google.cloud.vmmigration.v1.ComputeEngineTargetDetails.zone]: crate::model::ComputeEngineTargetDetails::zone
    pub disk_replica_zones: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::ComputeEngineTargetDetails::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::ComputeEngineTargetDetails::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineTargetDetails::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::ComputeEngineTargetDetails::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::ComputeEngineTargetDetails::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::ComputeEngineTargetDetails::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::ComputeEngineTargetDetails::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::ComputeEngineTargetDetails::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineTargetDetails::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::ComputeEngineTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [license_type][crate::model::ComputeEngineTargetDetails::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_applied_license<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [applied_license][crate::model::ComputeEngineTargetDetails::applied_license].
    pub fn set_or_clear_applied_license<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::AppliedLicense>,
    {
        self.applied_license = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::ComputeEngineTargetDetails::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::ComputeEngineTargetDetails::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ComputeEngineTargetDetails::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ComputeEngineTargetDetails::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }

    /// Sets the value of [boot_option][crate::model::ComputeEngineTargetDetails::boot_option].
    pub fn set_boot_option<T: std::convert::Into<crate::model::ComputeEngineBootOption>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_option = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::ComputeEngineTargetDetails::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::ComputeEngineTargetDetails::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::ComputeEngineTargetDetails::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::ComputeEngineTargetDetails::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::ComputeEngineTargetDetails::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [boot_conversion][crate::model::ComputeEngineTargetDetails::boot_conversion].
    pub fn set_boot_conversion<T: std::convert::Into<crate::model::BootConversion>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_conversion = v.into();
        self
    }

    /// Sets the value of [disk_replica_zones][crate::model::ComputeEngineTargetDetails::disk_replica_zones].
    pub fn set_disk_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.disk_replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ComputeEngineTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_name,
            __project,
            __zone,
            __machine_type_series,
            __machine_type,
            __network_tags,
            __network_interfaces,
            __service_account,
            __disk_type,
            __labels,
            __license_type,
            __applied_license,
            __compute_scheduling,
            __secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            __boot_option,
            __metadata,
            __additional_licenses,
            __hostname,
            __encryption,
            __boot_conversion,
            __disk_replica_zones,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "project" => Ok(__FieldTag::__project),
                            "zone" => Ok(__FieldTag::__zone),
                            "machineTypeSeries" => Ok(__FieldTag::__machine_type_series),
                            "machine_type_series" => Ok(__FieldTag::__machine_type_series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "labels" => Ok(__FieldTag::__labels),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "appliedLicense" => Ok(__FieldTag::__applied_license),
                            "applied_license" => Ok(__FieldTag::__applied_license),
                            "computeScheduling" => Ok(__FieldTag::__compute_scheduling),
                            "compute_scheduling" => Ok(__FieldTag::__compute_scheduling),
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "bootOption" => Ok(__FieldTag::__boot_option),
                            "boot_option" => Ok(__FieldTag::__boot_option),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "bootConversion" => Ok(__FieldTag::__boot_conversion),
                            "boot_conversion" => Ok(__FieldTag::__boot_conversion),
                            "diskReplicaZones" => Ok(__FieldTag::__disk_replica_zones),
                            "disk_replica_zones" => Ok(__FieldTag::__disk_replica_zones),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_series => {
                            if !fields.insert(__FieldTag::__machine_type_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_series",
                                ));
                            }
                            result.machine_type_series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map.next_value::<std::option::Option<crate::model::ComputeEngineLicenseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__applied_license => {
                            if !fields.insert(__FieldTag::__applied_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for applied_license",
                                ));
                            }
                            result.applied_license = map
                                .next_value::<std::option::Option<crate::model::AppliedLicense>>(
                                )?;
                        }
                        __FieldTag::__compute_scheduling => {
                            if !fields.insert(__FieldTag::__compute_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_scheduling",
                                ));
                            }
                            result.compute_scheduling = map
                                .next_value::<std::option::Option<crate::model::ComputeScheduling>>(
                                )?;
                        }
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_option => {
                            if !fields.insert(__FieldTag::__boot_option) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_option",
                                ));
                            }
                            result.boot_option = map.next_value::<std::option::Option<crate::model::ComputeEngineBootOption>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::__boot_conversion => {
                            if !fields.insert(__FieldTag::__boot_conversion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_conversion",
                                ));
                            }
                            result.boot_conversion = map
                                .next_value::<std::option::Option<crate::model::BootConversion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_replica_zones => {
                            if !fields.insert(__FieldTag::__disk_replica_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_replica_zones",
                                ));
                            }
                            result.disk_replica_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.machine_type_series.is_empty() {
            state.serialize_entry("machineTypeSeries", &self.machine_type_series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if self.applied_license.is_some() {
            state.serialize_entry("appliedLicense", &self.applied_license)?;
        }
        if self.compute_scheduling.is_some() {
            state.serialize_entry("computeScheduling", &self.compute_scheduling)?;
        }
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_vtpm) {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !wkt::internal::is_default(&self.boot_option) {
            state.serialize_entry("bootOption", &self.boot_option)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !wkt::internal::is_default(&self.boot_conversion) {
            state.serialize_entry("bootConversion", &self.boot_conversion)?;
        }
        if !self.disk_replica_zones.is_empty() {
            state.serialize_entry("diskReplicaZones", &self.disk_replica_zones)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineTargetDetails");
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("project", &self.project);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("machine_type_series", &self.machine_type_series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("applied_license", &self.applied_license);
        debug_struct.field("compute_scheduling", &self.compute_scheduling);
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("enable_vtpm", &self.enable_vtpm);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        debug_struct.field("boot_option", &self.boot_option);
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("boot_conversion", &self.boot_conversion);
        debug_struct.field("disk_replica_zones", &self.disk_replica_zones);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// NetworkInterface represents a NIC of a VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// Optional. The network to connect the NIC to.
    pub network: std::string::String,

    /// Optional. The subnetwork to connect the NIC to.
    pub subnetwork: std::string::String,

    /// Optional. The internal IP to define in the NIC.
    /// The formats accepted are: `ephemeral` \ ipv4 address \ a named address
    /// resource full path.
    pub internal_ip: std::string::String,

    /// Optional. The external IP to define in the NIC.
    pub external_ip: std::string::String,

    /// Optional. The networking tier used for optimizing connectivity between
    /// instances and systems on the internet. Applies only for external ephemeral
    /// IP addresses. If left empty, will default to PREMIUM.
    pub network_tier: crate::model::ComputeEngineNetworkTier,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnetwork][crate::model::NetworkInterface::subnetwork].
    pub fn set_subnetwork<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnetwork = v.into();
        self
    }

    /// Sets the value of [internal_ip][crate::model::NetworkInterface::internal_ip].
    pub fn set_internal_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.internal_ip = v.into();
        self
    }

    /// Sets the value of [external_ip][crate::model::NetworkInterface::external_ip].
    pub fn set_external_ip<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.external_ip = v.into();
        self
    }

    /// Sets the value of [network_tier][crate::model::NetworkInterface::network_tier].
    pub fn set_network_tier<T: std::convert::Into<crate::model::ComputeEngineNetworkTier>>(
        mut self,
        v: T,
    ) -> Self {
        self.network_tier = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.NetworkInterface"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkInterface {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnetwork,
            __internal_ip,
            __external_ip,
            __network_tier,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInterface")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnetwork" => Ok(__FieldTag::__subnetwork),
                            "internalIp" => Ok(__FieldTag::__internal_ip),
                            "internal_ip" => Ok(__FieldTag::__internal_ip),
                            "externalIp" => Ok(__FieldTag::__external_ip),
                            "external_ip" => Ok(__FieldTag::__external_ip),
                            "networkTier" => Ok(__FieldTag::__network_tier),
                            "network_tier" => Ok(__FieldTag::__network_tier),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterface;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInterface")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnetwork => {
                            if !fields.insert(__FieldTag::__subnetwork) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnetwork",
                                ));
                            }
                            result.subnetwork = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_ip => {
                            if !fields.insert(__FieldTag::__internal_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_ip",
                                ));
                            }
                            result.internal_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__external_ip => {
                            if !fields.insert(__FieldTag::__external_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for external_ip",
                                ));
                            }
                            result.external_ip = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tier => {
                            if !fields.insert(__FieldTag::__network_tier) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tier",
                                ));
                            }
                            result.network_tier = map.next_value::<std::option::Option<crate::model::ComputeEngineNetworkTier>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnetwork.is_empty() {
            state.serialize_entry("subnetwork", &self.subnetwork)?;
        }
        if !self.internal_ip.is_empty() {
            state.serialize_entry("internalIp", &self.internal_ip)?;
        }
        if !self.external_ip.is_empty() {
            state.serialize_entry("externalIp", &self.external_ip)?;
        }
        if !wkt::internal::is_default(&self.network_tier) {
            state.serialize_entry("networkTier", &self.network_tier)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for NetworkInterface {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("NetworkInterface");
        debug_struct.field("network", &self.network);
        debug_struct.field("subnetwork", &self.subnetwork);
        debug_struct.field("internal_ip", &self.internal_ip);
        debug_struct.field("external_ip", &self.external_ip);
        debug_struct.field("network_tier", &self.network_tier);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// AppliedLicense holds the license data returned by adaptation module report.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AppliedLicense {
    /// The license type that was used in OS adaptation.
    pub r#type: crate::model::applied_license::Type,

    /// The OS license returned from the adaptation module's report.
    pub os_license: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AppliedLicense {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AppliedLicense::type].
    pub fn set_type<T: std::convert::Into<crate::model::applied_license::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [os_license][crate::model::AppliedLicense::os_license].
    pub fn set_os_license<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.os_license = v.into();
        self
    }
}

impl wkt::message::Message for AppliedLicense {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AppliedLicense"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AppliedLicense {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __os_license,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AppliedLicense")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "osLicense" => Ok(__FieldTag::__os_license),
                            "os_license" => Ok(__FieldTag::__os_license),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AppliedLicense;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AppliedLicense")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map.next_value::<std::option::Option<crate::model::applied_license::Type>>()?.unwrap_or_default();
                        }
                        __FieldTag::__os_license => {
                            if !fields.insert(__FieldTag::__os_license) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_license",
                                ));
                            }
                            result.os_license = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AppliedLicense {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.os_license.is_empty() {
            state.serialize_entry("osLicense", &self.os_license)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AppliedLicense {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppliedLicense");
        debug_struct.field("r#type", &self.r#type);
        debug_struct.field("os_license", &self.os_license);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AppliedLicense].
pub mod applied_license {
    #[allow(unused_imports)]
    use super::*;

    /// License types used in OS adaptation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified license for the OS.
        Unspecified,
        /// No license available for the OS.
        None,
        /// The license type is Pay As You Go license type.
        Payg,
        /// The license type is Bring Your Own License type.
        Byol,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::None => std::option::Option::Some(1),
                Self::Payg => std::option::Option::Some(2),
                Self::Byol => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::None => std::option::Option::Some("NONE"),
                Self::Payg => std::option::Option::Some("PAYG"),
                Self::Byol => std::option::Option::Some("BYOL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::None,
                2 => Self::Payg,
                3 => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "NONE" => Self::None,
                "PAYG" => Self::Payg,
                "BYOL" => Self::Byol,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::None => serializer.serialize_i32(1),
                Self::Payg => serializer.serialize_i32(2),
                Self::Byol => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmmigration.v1.AppliedLicense.Type",
            ))
        }
    }
}

/// Node Affinity: the configuration of desired nodes onto which this Instance
/// could be scheduled. Based on
/// <https://cloud.google.com/compute/docs/reference/rest/v1/instances/setScheduling>
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulingNodeAffinity {
    /// The label key of Node resource to reference.
    pub key: std::string::String,

    /// The operator to use for the node resources specified in the `values`
    /// parameter.
    pub operator: crate::model::scheduling_node_affinity::Operator,

    /// Corresponds to the label values of Node resource.
    pub values: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulingNodeAffinity {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key][crate::model::SchedulingNodeAffinity::key].
    pub fn set_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key = v.into();
        self
    }

    /// Sets the value of [operator][crate::model::SchedulingNodeAffinity::operator].
    pub fn set_operator<T: std::convert::Into<crate::model::scheduling_node_affinity::Operator>>(
        mut self,
        v: T,
    ) -> Self {
        self.operator = v.into();
        self
    }

    /// Sets the value of [values][crate::model::SchedulingNodeAffinity::values].
    pub fn set_values<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.values = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SchedulingNodeAffinity {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulingNodeAffinity"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchedulingNodeAffinity {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __key,
            __operator,
            __values,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchedulingNodeAffinity")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "key" => Ok(__FieldTag::__key),
                            "operator" => Ok(__FieldTag::__operator),
                            "values" => Ok(__FieldTag::__values),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchedulingNodeAffinity;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchedulingNodeAffinity")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__key => {
                            if !fields.insert(__FieldTag::__key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for key",
                                ));
                            }
                            result.key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__operator => {
                            if !fields.insert(__FieldTag::__operator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operator",
                                ));
                            }
                            result.operator = map
                                .next_value::<std::option::Option<
                                    crate::model::scheduling_node_affinity::Operator,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__values => {
                            if !fields.insert(__FieldTag::__values) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for values",
                                ));
                            }
                            result.values = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchedulingNodeAffinity {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.key.is_empty() {
            state.serialize_entry("key", &self.key)?;
        }
        if !wkt::internal::is_default(&self.operator) {
            state.serialize_entry("operator", &self.operator)?;
        }
        if !self.values.is_empty() {
            state.serialize_entry("values", &self.values)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchedulingNodeAffinity {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulingNodeAffinity");
        debug_struct.field("key", &self.key);
        debug_struct.field("operator", &self.operator);
        debug_struct.field("values", &self.values);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SchedulingNodeAffinity].
pub mod scheduling_node_affinity {
    #[allow(unused_imports)]
    use super::*;

    /// Possible types of node selection operators. Valid operators are IN for
    /// affinity and NOT_IN for anti-affinity.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Operator {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// The node resource group should be in these resources affinity.
        In,
        /// The node resource group should not be in these resources affinity.
        NotIn,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Operator::value] or
        /// [Operator::name].
        UnknownValue(operator::UnknownValue),
    }

    #[doc(hidden)]
    pub mod operator {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Operator {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::In => std::option::Option::Some(1),
                Self::NotIn => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("OPERATOR_UNSPECIFIED"),
                Self::In => std::option::Option::Some("IN"),
                Self::NotIn => std::option::Option::Some("NOT_IN"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Operator {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Operator {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Operator {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::In,
                2 => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Operator {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "OPERATOR_UNSPECIFIED" => Self::Unspecified,
                "IN" => Self::In,
                "NOT_IN" => Self::NotIn,
                _ => Self::UnknownValue(operator::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Operator {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::In => serializer.serialize_i32(1),
                Self::NotIn => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Operator {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Operator>::new(
                ".google.cloud.vmmigration.v1.SchedulingNodeAffinity.Operator",
            ))
        }
    }
}

/// Scheduling information for VM on maintenance/restart behaviour and
/// node allocation in sole tenant nodes.
/// Options for instance behavior when the host machine undergoes
/// maintenance that may temporarily impact instance performance.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeScheduling {
    /// How the instance should behave when the host machine undergoes
    /// maintenance that may temporarily impact instance performance.
    pub on_host_maintenance: crate::model::compute_scheduling::OnHostMaintenance,

    /// Whether the Instance should be automatically restarted whenever it is
    /// terminated by Compute Engine (not terminated by user).
    /// This configuration is identical to `automaticRestart` field in Compute
    /// Engine create instance under scheduling.
    /// It was changed to an enum (instead of a boolean) to match the default
    /// value in Compute Engine which is automatic restart.
    pub restart_type: crate::model::compute_scheduling::RestartType,

    /// A set of node affinity and anti-affinity configurations for sole tenant
    /// nodes.
    pub node_affinities: std::vec::Vec<crate::model::SchedulingNodeAffinity>,

    /// The minimum number of virtual CPUs this instance will consume when
    /// running on a sole-tenant node. Ignored if no node_affinites are
    /// configured.
    pub min_node_cpus: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeScheduling {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [on_host_maintenance][crate::model::ComputeScheduling::on_host_maintenance].
    pub fn set_on_host_maintenance<
        T: std::convert::Into<crate::model::compute_scheduling::OnHostMaintenance>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.on_host_maintenance = v.into();
        self
    }

    /// Sets the value of [restart_type][crate::model::ComputeScheduling::restart_type].
    pub fn set_restart_type<
        T: std::convert::Into<crate::model::compute_scheduling::RestartType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.restart_type = v.into();
        self
    }

    /// Sets the value of [node_affinities][crate::model::ComputeScheduling::node_affinities].
    pub fn set_node_affinities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SchedulingNodeAffinity>,
    {
        use std::iter::Iterator;
        self.node_affinities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [min_node_cpus][crate::model::ComputeScheduling::min_node_cpus].
    pub fn set_min_node_cpus<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.min_node_cpus = v.into();
        self
    }
}

impl wkt::message::Message for ComputeScheduling {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeScheduling"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeScheduling {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __on_host_maintenance,
            __restart_type,
            __node_affinities,
            __min_node_cpus,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeScheduling")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "onHostMaintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "on_host_maintenance" => Ok(__FieldTag::__on_host_maintenance),
                            "restartType" => Ok(__FieldTag::__restart_type),
                            "restart_type" => Ok(__FieldTag::__restart_type),
                            "nodeAffinities" => Ok(__FieldTag::__node_affinities),
                            "node_affinities" => Ok(__FieldTag::__node_affinities),
                            "minNodeCpus" => Ok(__FieldTag::__min_node_cpus),
                            "min_node_cpus" => Ok(__FieldTag::__min_node_cpus),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeScheduling;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeScheduling")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__on_host_maintenance => {
                            if !fields.insert(__FieldTag::__on_host_maintenance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for on_host_maintenance",
                                ));
                            }
                            result.on_host_maintenance = map
                                .next_value::<std::option::Option<
                                    crate::model::compute_scheduling::OnHostMaintenance,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__restart_type => {
                            if !fields.insert(__FieldTag::__restart_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for restart_type",
                                ));
                            }
                            result.restart_type =
                                map.next_value::<std::option::Option<
                                    crate::model::compute_scheduling::RestartType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__node_affinities => {
                            if !fields.insert(__FieldTag::__node_affinities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for node_affinities",
                                ));
                            }
                            result.node_affinities = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::SchedulingNodeAffinity>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__min_node_cpus => {
                            if !fields.insert(__FieldTag::__min_node_cpus) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for min_node_cpus",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.min_node_cpus =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeScheduling {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.on_host_maintenance) {
            state.serialize_entry("onHostMaintenance", &self.on_host_maintenance)?;
        }
        if !wkt::internal::is_default(&self.restart_type) {
            state.serialize_entry("restartType", &self.restart_type)?;
        }
        if !self.node_affinities.is_empty() {
            state.serialize_entry("nodeAffinities", &self.node_affinities)?;
        }
        if !wkt::internal::is_default(&self.min_node_cpus) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("minNodeCpus", &__With(&self.min_node_cpus))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeScheduling {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeScheduling");
        debug_struct.field("on_host_maintenance", &self.on_host_maintenance);
        debug_struct.field("restart_type", &self.restart_type);
        debug_struct.field("node_affinities", &self.node_affinities);
        debug_struct.field("min_node_cpus", &self.min_node_cpus);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ComputeScheduling].
pub mod compute_scheduling {
    #[allow(unused_imports)]
    use super::*;

    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OnHostMaintenance {
        /// An unknown, unexpected behavior.
        Unspecified,
        /// Terminate the instance when the host machine undergoes maintenance.
        Terminate,
        /// Migrate the instance when the host machine undergoes maintenance.
        Migrate,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [OnHostMaintenance::value] or
        /// [OnHostMaintenance::name].
        UnknownValue(on_host_maintenance::UnknownValue),
    }

    #[doc(hidden)]
    pub mod on_host_maintenance {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl OnHostMaintenance {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Terminate => std::option::Option::Some(1),
                Self::Migrate => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ON_HOST_MAINTENANCE_UNSPECIFIED"),
                Self::Terminate => std::option::Option::Some("TERMINATE"),
                Self::Migrate => std::option::Option::Some("MIGRATE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for OnHostMaintenance {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for OnHostMaintenance {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for OnHostMaintenance {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Terminate,
                2 => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for OnHostMaintenance {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ON_HOST_MAINTENANCE_UNSPECIFIED" => Self::Unspecified,
                "TERMINATE" => Self::Terminate,
                "MIGRATE" => Self::Migrate,
                _ => Self::UnknownValue(on_host_maintenance::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for OnHostMaintenance {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Terminate => serializer.serialize_i32(1),
                Self::Migrate => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for OnHostMaintenance {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<OnHostMaintenance>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.OnHostMaintenance",
            ))
        }
    }

    /// Defines whether the Instance should be automatically restarted whenever
    /// it is terminated by Compute Engine (not terminated by user).
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RestartType {
        /// Unspecified behavior. This will use the default.
        Unspecified,
        /// The Instance should be automatically restarted whenever it is
        /// terminated by Compute Engine.
        AutomaticRestart,
        /// The Instance isn't automatically restarted whenever it is
        /// terminated by Compute Engine.
        NoAutomaticRestart,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RestartType::value] or
        /// [RestartType::name].
        UnknownValue(restart_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod restart_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RestartType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AutomaticRestart => std::option::Option::Some(1),
                Self::NoAutomaticRestart => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("RESTART_TYPE_UNSPECIFIED"),
                Self::AutomaticRestart => std::option::Option::Some("AUTOMATIC_RESTART"),
                Self::NoAutomaticRestart => std::option::Option::Some("NO_AUTOMATIC_RESTART"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RestartType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RestartType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RestartType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AutomaticRestart,
                2 => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RestartType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "RESTART_TYPE_UNSPECIFIED" => Self::Unspecified,
                "AUTOMATIC_RESTART" => Self::AutomaticRestart,
                "NO_AUTOMATIC_RESTART" => Self::NoAutomaticRestart,
                _ => Self::UnknownValue(restart_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RestartType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AutomaticRestart => serializer.serialize_i32(1),
                Self::NoAutomaticRestart => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RestartType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RestartType>::new(
                ".google.cloud.vmmigration.v1.ComputeScheduling.RestartType",
            ))
        }
    }
}

/// ComputeEngineDisksTargetDefaults is a collection of details for creating
/// Persistent Disks in a target Compute Engine project.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineDisksTargetDefaults {
    /// The full path of the resource of type TargetProject which represents the
    /// Compute Engine project in which to create the Persistent Disks.
    pub target_project: std::string::String,

    /// The details of each Persistent Disk to create.
    pub disks: std::vec::Vec<crate::model::PersistentDiskDefaults>,

    pub location: std::option::Option<crate::model::compute_engine_disks_target_defaults::Location>,

    /// Details of the VM to attach the disks to as the target of this migration.
    pub vm_target:
        std::option::Option<crate::model::compute_engine_disks_target_defaults::VmTarget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineDisksTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_project][crate::model::ComputeEngineDisksTargetDefaults::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::ComputeEngineDisksTargetDefaults::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PersistentDiskDefaults>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [location][crate::model::ComputeEngineDisksTargetDefaults::location].
    ///
    /// Note that all the setters affecting `location` are mutually
    /// exclusive.
    pub fn set_location<
        T: std::convert::Into<
                std::option::Option<crate::model::compute_engine_disks_target_defaults::Location>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.location = v.into();
        self
    }

    /// The value of [location][crate::model::ComputeEngineDisksTargetDefaults::location]
    /// if it holds a `Zone`, `None` if the field is not set or
    /// holds a different branch.
    pub fn zone(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.location.as_ref().and_then(|v| match v {
            crate::model::compute_engine_disks_target_defaults::Location::Zone(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [location][crate::model::ComputeEngineDisksTargetDefaults::location]
    /// to hold a `Zone`.
    ///
    /// Note that all the setters affecting `location` are
    /// mutually exclusive.
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.location = std::option::Option::Some(
            crate::model::compute_engine_disks_target_defaults::Location::Zone(v.into()),
        );
        self
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDefaults::vm_target].
    ///
    /// Note that all the setters affecting `vm_target` are mutually
    /// exclusive.
    pub fn set_vm_target<
        T: std::convert::Into<
                std::option::Option<crate::model::compute_engine_disks_target_defaults::VmTarget>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = v.into();
        self
    }

    /// The value of [vm_target][crate::model::ComputeEngineDisksTargetDefaults::vm_target]
    /// if it holds a `DisksTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disks_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DisksMigrationDisksTargetDefaults>>
    {
        #[allow(unreachable_patterns)]
        self.vm_target.as_ref().and_then(|v| match v {
            crate::model::compute_engine_disks_target_defaults::VmTarget::DisksTargetDefaults(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDefaults::vm_target]
    /// to hold a `DisksTargetDefaults`.
    ///
    /// Note that all the setters affecting `vm_target` are
    /// mutually exclusive.
    pub fn set_disks_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::DisksMigrationDisksTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = std::option::Option::Some(
            crate::model::compute_engine_disks_target_defaults::VmTarget::DisksTargetDefaults(
                v.into(),
            ),
        );
        self
    }

    /// The value of [vm_target][crate::model::ComputeEngineDisksTargetDefaults::vm_target]
    /// if it holds a `VmTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DisksMigrationVmTargetDefaults>> {
        #[allow(unreachable_patterns)]
        self.vm_target.as_ref().and_then(|v| match v {
            crate::model::compute_engine_disks_target_defaults::VmTarget::VmTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDefaults::vm_target]
    /// to hold a `VmTargetDefaults`.
    ///
    /// Note that all the setters affecting `vm_target` are
    /// mutually exclusive.
    pub fn set_vm_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::DisksMigrationVmTargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = std::option::Option::Some(
            crate::model::compute_engine_disks_target_defaults::VmTarget::VmTargetDefaults(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for ComputeEngineDisksTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineDisksTargetDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineDisksTargetDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __zone,
            __disks_target_defaults,
            __vm_target_defaults,
            __target_project,
            __disks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineDisksTargetDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "zone" => Ok(__FieldTag::__zone),
                            "disksTargetDefaults" => Ok(__FieldTag::__disks_target_defaults),
                            "disks_target_defaults" => Ok(__FieldTag::__disks_target_defaults),
                            "vmTargetDefaults" => Ok(__FieldTag::__vm_target_defaults),
                            "vm_target_defaults" => Ok(__FieldTag::__vm_target_defaults),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "disks" => Ok(__FieldTag::__disks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineDisksTargetDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineDisksTargetDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            if result.location.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `location`, a oneof with full ID .google.cloud.vmmigration.v1.ComputeEngineDisksTargetDefaults.zone, latest field was zone",
                                ));
                            }
                            result.location = std::option::Option::Some(
                                crate::model::compute_engine_disks_target_defaults::Location::Zone(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__disks_target_defaults => {
                            if !fields.insert(__FieldTag::__disks_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks_target_defaults",
                                ));
                            }
                            if result.vm_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_target`, a oneof with full ID .google.cloud.vmmigration.v1.ComputeEngineDisksTargetDefaults.disks_target_defaults, latest field was disksTargetDefaults",
                                ));
                            }
                            result.vm_target = std::option::Option::Some(
                                crate::model::compute_engine_disks_target_defaults::VmTarget::DisksTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DisksMigrationDisksTargetDefaults>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vm_target_defaults => {
                            if !fields.insert(__FieldTag::__vm_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_target_defaults",
                                ));
                            }
                            if result.vm_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_target`, a oneof with full ID .google.cloud.vmmigration.v1.ComputeEngineDisksTargetDefaults.vm_target_defaults, latest field was vmTargetDefaults",
                                ));
                            }
                            result.vm_target = std::option::Option::Some(
                                crate::model::compute_engine_disks_target_defaults::VmTarget::VmTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DisksMigrationVmTargetDefaults>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PersistentDiskDefaults>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineDisksTargetDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.zone() {
            state.serialize_entry("zone", value)?;
        }
        if let Some(value) = self.disks_target_defaults() {
            state.serialize_entry("disksTargetDefaults", value)?;
        }
        if let Some(value) = self.vm_target_defaults() {
            state.serialize_entry("vmTargetDefaults", value)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineDisksTargetDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineDisksTargetDefaults");
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("location", &self.location);
        debug_struct.field("vm_target", &self.vm_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ComputeEngineDisksTargetDefaults].
pub mod compute_engine_disks_target_defaults {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Location {
        /// The zone in which to create the Persistent Disks.
        Zone(std::string::String),
    }

    /// Details of the VM to attach the disks to as the target of this migration.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmTarget {
        /// Details of the disk only migration target.
        DisksTargetDefaults(std::boxed::Box<crate::model::DisksMigrationDisksTargetDefaults>),
        /// Details of the VM migration target.
        VmTargetDefaults(std::boxed::Box<crate::model::DisksMigrationVmTargetDefaults>),
    }
}

/// Details for creation of a Persistent Disk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PersistentDiskDefaults {
    /// Required. The ordinal number of the source VM disk.
    pub source_disk_number: i32,

    /// Optional. The name of the Persistent Disk to create.
    pub disk_name: std::string::String,

    /// The disk type to use.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// A map of labels to associate with the Persistent Disk.
    pub additional_labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The encryption to apply to the disk.
    pub encryption: std::option::Option<crate::model::Encryption>,

    /// Optional. Details for attachment of the disk to a VM.
    /// Used when the disk is set to be attached to a target VM.
    pub vm_attachment_details: std::option::Option<crate::model::VmAttachmentDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PersistentDiskDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_disk_number][crate::model::PersistentDiskDefaults::source_disk_number].
    pub fn set_source_disk_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_disk_number = v.into();
        self
    }

    /// Sets the value of [disk_name][crate::model::PersistentDiskDefaults::disk_name].
    pub fn set_disk_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_name = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::PersistentDiskDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [additional_labels][crate::model::PersistentDiskDefaults::additional_labels].
    pub fn set_additional_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [encryption][crate::model::PersistentDiskDefaults::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::PersistentDiskDefaults::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [vm_attachment_details][crate::model::PersistentDiskDefaults::vm_attachment_details].
    pub fn set_vm_attachment_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmAttachmentDetails>,
    {
        self.vm_attachment_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_attachment_details][crate::model::PersistentDiskDefaults::vm_attachment_details].
    pub fn set_or_clear_vm_attachment_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmAttachmentDetails>,
    {
        self.vm_attachment_details = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PersistentDiskDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PersistentDiskDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PersistentDiskDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_disk_number,
            __disk_name,
            __disk_type,
            __additional_labels,
            __encryption,
            __vm_attachment_details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PersistentDiskDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceDiskNumber" => Ok(__FieldTag::__source_disk_number),
                            "source_disk_number" => Ok(__FieldTag::__source_disk_number),
                            "diskName" => Ok(__FieldTag::__disk_name),
                            "disk_name" => Ok(__FieldTag::__disk_name),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "additionalLabels" => Ok(__FieldTag::__additional_labels),
                            "additional_labels" => Ok(__FieldTag::__additional_labels),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "vmAttachmentDetails" => Ok(__FieldTag::__vm_attachment_details),
                            "vm_attachment_details" => Ok(__FieldTag::__vm_attachment_details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PersistentDiskDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PersistentDiskDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_disk_number => {
                            if !fields.insert(__FieldTag::__source_disk_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_disk_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_disk_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_name => {
                            if !fields.insert(__FieldTag::__disk_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_name",
                                ));
                            }
                            result.disk_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__additional_labels => {
                            if !fields.insert(__FieldTag::__additional_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_labels",
                                ));
                            }
                            result.additional_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::__vm_attachment_details => {
                            if !fields.insert(__FieldTag::__vm_attachment_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_attachment_details",
                                ));
                            }
                            result.vm_attachment_details = map.next_value::<std::option::Option<crate::model::VmAttachmentDetails>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PersistentDiskDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_disk_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceDiskNumber", &__With(&self.source_disk_number))?;
        }
        if !self.disk_name.is_empty() {
            state.serialize_entry("diskName", &self.disk_name)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.additional_labels.is_empty() {
            state.serialize_entry("additionalLabels", &self.additional_labels)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if self.vm_attachment_details.is_some() {
            state.serialize_entry("vmAttachmentDetails", &self.vm_attachment_details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PersistentDiskDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PersistentDiskDefaults");
        debug_struct.field("source_disk_number", &self.source_disk_number);
        debug_struct.field("disk_name", &self.disk_name);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("additional_labels", &self.additional_labels);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("vm_attachment_details", &self.vm_attachment_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details for attachment of the disk to a VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmAttachmentDetails {
    /// Optional. Specifies a unique device name of your choice that is reflected
    /// into the /dev/disk/by-id/google-* tree of a Linux operating system running
    /// within the instance. If not specified, the server chooses a default device
    /// name to apply to this disk, in the form persistent-disk-x, where x is a
    /// number assigned by Google Compute Engine. This field is only applicable for
    /// persistent disks.
    pub device_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmAttachmentDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [device_name][crate::model::VmAttachmentDetails::device_name].
    pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.device_name = v.into();
        self
    }
}

impl wkt::message::Message for VmAttachmentDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmAttachmentDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmAttachmentDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __device_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmAttachmentDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "deviceName" => Ok(__FieldTag::__device_name),
                            "device_name" => Ok(__FieldTag::__device_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmAttachmentDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmAttachmentDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__device_name => {
                            if !fields.insert(__FieldTag::__device_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_name",
                                ));
                            }
                            result.device_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmAttachmentDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.device_name.is_empty() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmAttachmentDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmAttachmentDetails");
        debug_struct.field("device_name", &self.device_name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details for a disk only migration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisksMigrationDisksTargetDefaults {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisksMigrationDisksTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisksMigrationDisksTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DisksMigrationDisksTargetDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisksMigrationDisksTargetDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisksMigrationDisksTargetDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisksMigrationDisksTargetDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisksMigrationDisksTargetDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisksMigrationDisksTargetDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisksMigrationDisksTargetDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisksMigrationDisksTargetDefaults");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details for creation of a VM that migrated data disks will be attached to.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisksMigrationVmTargetDefaults {
    /// Required. The name of the VM to create.
    pub vm_name: std::string::String,

    /// Optional. The machine type series to create the VM with.
    /// For presentation only.
    pub machine_type_series: std::string::String,

    /// Required. The machine type to create the VM with.
    pub machine_type: std::string::String,

    /// Optional. A list of network tags to associate with the VM.
    pub network_tags: std::vec::Vec<std::string::String>,

    /// Optional. NICs to attach to the VM.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. The service account to associate the VM with.
    pub service_account: std::string::String,

    /// Optional. Compute instance scheduling information (if empty default is
    /// used).
    pub compute_scheduling: std::option::Option<crate::model::ComputeScheduling>,

    /// Optional. Defines whether the instance has Secure Boot enabled.
    /// This can be set to true only if the VM boot option is EFI.
    pub secure_boot: bool,

    /// Optional. Defines whether the instance has vTPM enabled.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the instance has integrity monitoring enabled.
    pub enable_integrity_monitoring: bool,

    /// Optional. The metadata key/value pairs to assign to the VM.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Additional licenses to assign to the VM.
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// Optional. The hostname to assign to the VM.
    pub hostname: std::string::String,

    /// Optional. A map of labels to associate with the VM.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Details of the boot disk of the VM.
    pub boot_disk_defaults: std::option::Option<crate::model::BootDiskDefaults>,

    /// Optional. The encryption to apply to the VM.
    pub encryption: std::option::Option<crate::model::Encryption>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisksMigrationVmTargetDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_name][crate::model::DisksMigrationVmTargetDefaults::vm_name].
    pub fn set_vm_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_name = v.into();
        self
    }

    /// Sets the value of [machine_type_series][crate::model::DisksMigrationVmTargetDefaults::machine_type_series].
    pub fn set_machine_type_series<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_type_series = v.into();
        self
    }

    /// Sets the value of [machine_type][crate::model::DisksMigrationVmTargetDefaults::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [network_tags][crate::model::DisksMigrationVmTargetDefaults::network_tags].
    pub fn set_network_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.network_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::DisksMigrationVmTargetDefaults::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_account][crate::model::DisksMigrationVmTargetDefaults::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [compute_scheduling][crate::model::DisksMigrationVmTargetDefaults::compute_scheduling].
    pub fn set_compute_scheduling<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compute_scheduling][crate::model::DisksMigrationVmTargetDefaults::compute_scheduling].
    pub fn set_or_clear_compute_scheduling<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ComputeScheduling>,
    {
        self.compute_scheduling = v.map(|x| x.into());
        self
    }

    /// Sets the value of [secure_boot][crate::model::DisksMigrationVmTargetDefaults::secure_boot].
    pub fn set_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::DisksMigrationVmTargetDefaults::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::DisksMigrationVmTargetDefaults::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }

    /// Sets the value of [metadata][crate::model::DisksMigrationVmTargetDefaults::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::DisksMigrationVmTargetDefaults::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [hostname][crate::model::DisksMigrationVmTargetDefaults::hostname].
    pub fn set_hostname<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.hostname = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DisksMigrationVmTargetDefaults::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [boot_disk_defaults][crate::model::DisksMigrationVmTargetDefaults::boot_disk_defaults].
    pub fn set_boot_disk_defaults<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BootDiskDefaults>,
    {
        self.boot_disk_defaults = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk_defaults][crate::model::DisksMigrationVmTargetDefaults::boot_disk_defaults].
    pub fn set_or_clear_boot_disk_defaults<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BootDiskDefaults>,
    {
        self.boot_disk_defaults = v.map(|x| x.into());
        self
    }

    /// Sets the value of [encryption][crate::model::DisksMigrationVmTargetDefaults::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::DisksMigrationVmTargetDefaults::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DisksMigrationVmTargetDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DisksMigrationVmTargetDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisksMigrationVmTargetDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_name,
            __machine_type_series,
            __machine_type,
            __network_tags,
            __network_interfaces,
            __service_account,
            __compute_scheduling,
            __secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            __metadata,
            __additional_licenses,
            __hostname,
            __labels,
            __boot_disk_defaults,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisksMigrationVmTargetDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmName" => Ok(__FieldTag::__vm_name),
                            "vm_name" => Ok(__FieldTag::__vm_name),
                            "machineTypeSeries" => Ok(__FieldTag::__machine_type_series),
                            "machine_type_series" => Ok(__FieldTag::__machine_type_series),
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "networkTags" => Ok(__FieldTag::__network_tags),
                            "network_tags" => Ok(__FieldTag::__network_tags),
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "computeScheduling" => Ok(__FieldTag::__compute_scheduling),
                            "compute_scheduling" => Ok(__FieldTag::__compute_scheduling),
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "metadata" => Ok(__FieldTag::__metadata),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "hostname" => Ok(__FieldTag::__hostname),
                            "labels" => Ok(__FieldTag::__labels),
                            "bootDiskDefaults" => Ok(__FieldTag::__boot_disk_defaults),
                            "boot_disk_defaults" => Ok(__FieldTag::__boot_disk_defaults),
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisksMigrationVmTargetDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisksMigrationVmTargetDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_name => {
                            if !fields.insert(__FieldTag::__vm_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_name",
                                ));
                            }
                            result.vm_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type_series => {
                            if !fields.insert(__FieldTag::__machine_type_series) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type_series",
                                ));
                            }
                            result.machine_type_series = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__network_tags => {
                            if !fields.insert(__FieldTag::__network_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_tags",
                                ));
                            }
                            result.network_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compute_scheduling => {
                            if !fields.insert(__FieldTag::__compute_scheduling) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compute_scheduling",
                                ));
                            }
                            result.compute_scheduling = map
                                .next_value::<std::option::Option<crate::model::ComputeScheduling>>(
                                )?;
                        }
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__hostname => {
                            if !fields.insert(__FieldTag::__hostname) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for hostname",
                                ));
                            }
                            result.hostname = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__boot_disk_defaults => {
                            if !fields.insert(__FieldTag::__boot_disk_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk_defaults",
                                ));
                            }
                            result.boot_disk_defaults = map
                                .next_value::<std::option::Option<crate::model::BootDiskDefaults>>(
                                )?;
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisksMigrationVmTargetDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_name.is_empty() {
            state.serialize_entry("vmName", &self.vm_name)?;
        }
        if !self.machine_type_series.is_empty() {
            state.serialize_entry("machineTypeSeries", &self.machine_type_series)?;
        }
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.network_tags.is_empty() {
            state.serialize_entry("networkTags", &self.network_tags)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if self.compute_scheduling.is_some() {
            state.serialize_entry("computeScheduling", &self.compute_scheduling)?;
        }
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_vtpm) {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.hostname.is_empty() {
            state.serialize_entry("hostname", &self.hostname)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.boot_disk_defaults.is_some() {
            state.serialize_entry("bootDiskDefaults", &self.boot_disk_defaults)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisksMigrationVmTargetDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisksMigrationVmTargetDefaults");
        debug_struct.field("vm_name", &self.vm_name);
        debug_struct.field("machine_type_series", &self.machine_type_series);
        debug_struct.field("machine_type", &self.machine_type);
        debug_struct.field("network_tags", &self.network_tags);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("compute_scheduling", &self.compute_scheduling);
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("enable_vtpm", &self.enable_vtpm);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        debug_struct.field("metadata", &self.metadata);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("hostname", &self.hostname);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("boot_disk_defaults", &self.boot_disk_defaults);
        debug_struct.field("encryption", &self.encryption);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// BootDiskDefaults hold information about the boot disk of a VM.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct BootDiskDefaults {
    /// Optional. The name of the disk.
    pub disk_name: std::string::String,

    /// Optional. The type of disk provisioning to use for the VM.
    pub disk_type: crate::model::ComputeEngineDiskType,

    /// Optional. Specifies a unique device name of your choice that is reflected
    /// into the /dev/disk/by-id/google-* tree of a Linux operating system running
    /// within the instance. If not specified, the server chooses a default device
    /// name to apply to this disk, in the form persistent-disk-x, where x is a
    /// number assigned by Google Compute Engine. This field is only applicable for
    /// persistent disks.
    pub device_name: std::string::String,

    /// Optional. The encryption to apply to the boot disk.
    pub encryption: std::option::Option<crate::model::Encryption>,

    pub source: std::option::Option<crate::model::boot_disk_defaults::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BootDiskDefaults {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_name][crate::model::BootDiskDefaults::disk_name].
    pub fn set_disk_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_name = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::BootDiskDefaults::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [device_name][crate::model::BootDiskDefaults::device_name].
    pub fn set_device_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.device_name = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::BootDiskDefaults::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::BootDiskDefaults::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::BootDiskDefaults::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::boot_disk_defaults::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::BootDiskDefaults::source]
    /// if it holds a `Image`, `None` if the field is not set or
    /// holds a different branch.
    pub fn image(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::boot_disk_defaults::DiskImageDefaults>>
    {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::boot_disk_defaults::Source::Image(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::BootDiskDefaults::source]
    /// to hold a `Image`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_image<
        T: std::convert::Into<std::boxed::Box<crate::model::boot_disk_defaults::DiskImageDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source =
            std::option::Option::Some(crate::model::boot_disk_defaults::Source::Image(v.into()));
        self
    }
}

impl wkt::message::Message for BootDiskDefaults {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.BootDiskDefaults"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BootDiskDefaults {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image,
            __disk_name,
            __disk_type,
            __device_name,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BootDiskDefaults")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "image" => Ok(__FieldTag::__image),
                            "diskName" => Ok(__FieldTag::__disk_name),
                            "disk_name" => Ok(__FieldTag::__disk_name),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "deviceName" => Ok(__FieldTag::__device_name),
                            "device_name" => Ok(__FieldTag::__device_name),
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BootDiskDefaults;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BootDiskDefaults")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image => {
                            if !fields.insert(__FieldTag::__image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.vmmigration.v1.BootDiskDefaults.image, latest field was image",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::boot_disk_defaults::Source::Image(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::boot_disk_defaults::DiskImageDefaults,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__disk_name => {
                            if !fields.insert(__FieldTag::__disk_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_name",
                                ));
                            }
                            result.disk_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__device_name => {
                            if !fields.insert(__FieldTag::__device_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for device_name",
                                ));
                            }
                            result.device_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BootDiskDefaults {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.image() {
            state.serialize_entry("image", value)?;
        }
        if !self.disk_name.is_empty() {
            state.serialize_entry("diskName", &self.disk_name)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.device_name.is_empty() {
            state.serialize_entry("deviceName", &self.device_name)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for BootDiskDefaults {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BootDiskDefaults");
        debug_struct.field("disk_name", &self.disk_name);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("device_name", &self.device_name);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("source", &self.source);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [BootDiskDefaults].
pub mod boot_disk_defaults {
    #[allow(unused_imports)]
    use super::*;

    /// Contains details about the image source used to create the disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DiskImageDefaults {
        /// Required. The Image resource used when creating the disk.
        pub source_image: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DiskImageDefaults {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_image][crate::model::boot_disk_defaults::DiskImageDefaults::source_image].
        pub fn set_source_image<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_image = v.into();
            self
        }
    }

    impl wkt::message::Message for DiskImageDefaults {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.BootDiskDefaults.DiskImageDefaults"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DiskImageDefaults {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __source_image,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DiskImageDefaults")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sourceImage" => Ok(__FieldTag::__source_image),
                                "source_image" => Ok(__FieldTag::__source_image),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DiskImageDefaults;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DiskImageDefaults")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__source_image => {
                                if !fields.insert(__FieldTag::__source_image) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for source_image",
                                    ));
                                }
                                result.source_image = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DiskImageDefaults {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.source_image.is_empty() {
                state.serialize_entry("sourceImage", &self.source_image)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for DiskImageDefaults {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("DiskImageDefaults");
            debug_struct.field("source_image", &self.source_image);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// The image to use when creating the disk.
        Image(std::boxed::Box<crate::model::boot_disk_defaults::DiskImageDefaults>),
    }
}

/// ComputeEngineDisksTargetDetails is a collection of created Persistent Disks
/// details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineDisksTargetDetails {
    /// The details of each created Persistent Disk.
    pub disks: std::vec::Vec<crate::model::PersistentDisk>,

    /// Details of the VM the disks are attached to.
    pub vm_target: std::option::Option<crate::model::compute_engine_disks_target_details::VmTarget>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineDisksTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disks][crate::model::ComputeEngineDisksTargetDetails::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PersistentDisk>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDetails::vm_target].
    ///
    /// Note that all the setters affecting `vm_target` are mutually
    /// exclusive.
    pub fn set_vm_target<
        T: std::convert::Into<
                std::option::Option<crate::model::compute_engine_disks_target_details::VmTarget>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = v.into();
        self
    }

    /// The value of [vm_target][crate::model::ComputeEngineDisksTargetDetails::vm_target]
    /// if it holds a `DisksTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disks_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DisksMigrationDisksTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.vm_target.as_ref().and_then(|v| match v {
            crate::model::compute_engine_disks_target_details::VmTarget::DisksTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDetails::vm_target]
    /// to hold a `DisksTargetDetails`.
    ///
    /// Note that all the setters affecting `vm_target` are
    /// mutually exclusive.
    pub fn set_disks_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DisksMigrationDisksTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = std::option::Option::Some(
            crate::model::compute_engine_disks_target_details::VmTarget::DisksTargetDetails(
                v.into(),
            ),
        );
        self
    }

    /// The value of [vm_target][crate::model::ComputeEngineDisksTargetDetails::vm_target]
    /// if it holds a `VmTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DisksMigrationVmTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.vm_target.as_ref().and_then(|v| match v {
            crate::model::compute_engine_disks_target_details::VmTarget::VmTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [vm_target][crate::model::ComputeEngineDisksTargetDetails::vm_target]
    /// to hold a `VmTargetDetails`.
    ///
    /// Note that all the setters affecting `vm_target` are
    /// mutually exclusive.
    pub fn set_vm_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DisksMigrationVmTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.vm_target = std::option::Option::Some(
            crate::model::compute_engine_disks_target_details::VmTarget::VmTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ComputeEngineDisksTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineDisksTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineDisksTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disks_target_details,
            __vm_target_details,
            __disks,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineDisksTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "disksTargetDetails" => Ok(__FieldTag::__disks_target_details),
                            "disks_target_details" => Ok(__FieldTag::__disks_target_details),
                            "vmTargetDetails" => Ok(__FieldTag::__vm_target_details),
                            "vm_target_details" => Ok(__FieldTag::__vm_target_details),
                            "disks" => Ok(__FieldTag::__disks),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineDisksTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineDisksTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disks_target_details => {
                            if !fields.insert(__FieldTag::__disks_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks_target_details",
                                ));
                            }
                            if result.vm_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_target`, a oneof with full ID .google.cloud.vmmigration.v1.ComputeEngineDisksTargetDetails.disks_target_details, latest field was disksTargetDetails",
                                ));
                            }
                            result.vm_target = std::option::Option::Some(
                                crate::model::compute_engine_disks_target_details::VmTarget::DisksTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DisksMigrationDisksTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__vm_target_details => {
                            if !fields.insert(__FieldTag::__vm_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_target_details",
                                ));
                            }
                            if result.vm_target.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `vm_target`, a oneof with full ID .google.cloud.vmmigration.v1.ComputeEngineDisksTargetDetails.vm_target_details, latest field was vmTargetDetails",
                                ));
                            }
                            result.vm_target = std::option::Option::Some(
                                crate::model::compute_engine_disks_target_details::VmTarget::VmTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DisksMigrationVmTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::PersistentDisk>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineDisksTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.disks_target_details() {
            state.serialize_entry("disksTargetDetails", value)?;
        }
        if let Some(value) = self.vm_target_details() {
            state.serialize_entry("vmTargetDetails", value)?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineDisksTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineDisksTargetDetails");
        debug_struct.field("disks", &self.disks);
        debug_struct.field("vm_target", &self.vm_target);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ComputeEngineDisksTargetDetails].
pub mod compute_engine_disks_target_details {
    #[allow(unused_imports)]
    use super::*;

    /// Details of the VM the disks are attached to.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum VmTarget {
        /// Details of the disks-only migration target.
        DisksTargetDetails(std::boxed::Box<crate::model::DisksMigrationDisksTargetDetails>),
        /// Details for the VM the migrated data disks are attached to.
        VmTargetDetails(std::boxed::Box<crate::model::DisksMigrationVmTargetDetails>),
    }
}

/// Details of a created Persistent Disk.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PersistentDisk {
    /// The ordinal number of the source VM disk.
    pub source_disk_number: i32,

    /// The URI of the Persistent Disk.
    pub disk_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PersistentDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [source_disk_number][crate::model::PersistentDisk::source_disk_number].
    pub fn set_source_disk_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.source_disk_number = v.into();
        self
    }

    /// Sets the value of [disk_uri][crate::model::PersistentDisk::disk_uri].
    pub fn set_disk_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_uri = v.into();
        self
    }
}

impl wkt::message::Message for PersistentDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PersistentDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PersistentDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __source_disk_number,
            __disk_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PersistentDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "sourceDiskNumber" => Ok(__FieldTag::__source_disk_number),
                            "source_disk_number" => Ok(__FieldTag::__source_disk_number),
                            "diskUri" => Ok(__FieldTag::__disk_uri),
                            "disk_uri" => Ok(__FieldTag::__disk_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PersistentDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PersistentDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__source_disk_number => {
                            if !fields.insert(__FieldTag::__source_disk_number) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for source_disk_number",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.source_disk_number =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_uri => {
                            if !fields.insert(__FieldTag::__disk_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_uri",
                                ));
                            }
                            result.disk_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PersistentDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.source_disk_number) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sourceDiskNumber", &__With(&self.source_disk_number))?;
        }
        if !self.disk_uri.is_empty() {
            state.serialize_entry("diskUri", &self.disk_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PersistentDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PersistentDisk");
        debug_struct.field("source_disk_number", &self.source_disk_number);
        debug_struct.field("disk_uri", &self.disk_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details for a disks-only migration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisksMigrationDisksTargetDetails {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisksMigrationDisksTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DisksMigrationDisksTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DisksMigrationDisksTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisksMigrationDisksTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisksMigrationDisksTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisksMigrationDisksTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisksMigrationDisksTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisksMigrationDisksTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisksMigrationDisksTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisksMigrationDisksTargetDetails");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Details for the VM created VM as part of disks migration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DisksMigrationVmTargetDetails {
    /// Output only. The URI of the Compute Engine VM.
    pub vm_uri: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DisksMigrationVmTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [vm_uri][crate::model::DisksMigrationVmTargetDetails::vm_uri].
    pub fn set_vm_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_uri = v.into();
        self
    }
}

impl wkt::message::Message for DisksMigrationVmTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DisksMigrationVmTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DisksMigrationVmTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __vm_uri,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DisksMigrationVmTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "vmUri" => Ok(__FieldTag::__vm_uri),
                            "vm_uri" => Ok(__FieldTag::__vm_uri),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DisksMigrationVmTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DisksMigrationVmTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__vm_uri => {
                            if !fields.insert(__FieldTag::__vm_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_uri",
                                ));
                            }
                            result.vm_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DisksMigrationVmTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.vm_uri.is_empty() {
            state.serialize_entry("vmUri", &self.vm_uri)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DisksMigrationVmTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DisksMigrationVmTargetDetails");
        debug_struct.field("vm_uri", &self.vm_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A policy for scheduling replications.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SchedulePolicy {
    /// The idle duration between replication stages.
    pub idle_duration: std::option::Option<wkt::Duration>,

    /// A flag to indicate whether to skip OS adaptation during the replication
    /// sync. OS adaptation is a process where the VM's operating system undergoes
    /// changes and adaptations to fully function on Compute Engine.
    pub skip_os_adaptation: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SchedulePolicy {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_idle_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [idle_duration][crate::model::SchedulePolicy::idle_duration].
    pub fn set_or_clear_idle_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.idle_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [skip_os_adaptation][crate::model::SchedulePolicy::skip_os_adaptation].
    pub fn set_skip_os_adaptation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.skip_os_adaptation = v.into();
        self
    }
}

impl wkt::message::Message for SchedulePolicy {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SchedulePolicy"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SchedulePolicy {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __idle_duration,
            __skip_os_adaptation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SchedulePolicy")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "idleDuration" => Ok(__FieldTag::__idle_duration),
                            "idle_duration" => Ok(__FieldTag::__idle_duration),
                            "skipOsAdaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            "skip_os_adaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SchedulePolicy;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SchedulePolicy")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__idle_duration => {
                            if !fields.insert(__FieldTag::__idle_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for idle_duration",
                                ));
                            }
                            result.idle_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__skip_os_adaptation => {
                            if !fields.insert(__FieldTag::__skip_os_adaptation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_os_adaptation",
                                ));
                            }
                            result.skip_os_adaptation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SchedulePolicy {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.idle_duration.is_some() {
            state.serialize_entry("idleDuration", &self.idle_duration)?;
        }
        if !wkt::internal::is_default(&self.skip_os_adaptation) {
            state.serialize_entry("skipOsAdaptation", &self.skip_os_adaptation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SchedulePolicy {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SchedulePolicy");
        debug_struct.field("idle_duration", &self.idle_duration);
        debug_struct.field("skip_os_adaptation", &self.skip_os_adaptation);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMigratingVmRequest {
    /// Required. The MigratingVm's parent.
    pub parent: std::string::String,

    /// Required. The migratingVm identifier.
    pub migrating_vm_id: std::string::String,

    /// Required. The create request body.
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMigratingVmRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [migrating_vm_id][crate::model::CreateMigratingVmRequest::migrating_vm_id].
    pub fn set_migrating_vm_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm_id = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::CreateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __migrating_vm_id,
            __migrating_vm,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "migratingVmId" => Ok(__FieldTag::__migrating_vm_id),
                            "migrating_vm_id" => Ok(__FieldTag::__migrating_vm_id),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm_id => {
                            if !fields.insert(__FieldTag::__migrating_vm_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm_id",
                                ));
                            }
                            result.migrating_vm_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm =
                                map.next_value::<std::option::Option<crate::model::MigratingVm>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.migrating_vm_id.is_empty() {
            state.serialize_entry("migratingVmId", &self.migrating_vm_id)?;
        }
        if self.migrating_vm.is_some() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateMigratingVmRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("migrating_vm_id", &self.migrating_vm_id);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'LisMigratingVmsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigratingVmsRequest {
    /// Required. The parent, which owns this collection of MigratingVms.
    pub parent: std::string::String,

    /// Optional. The maximum number of migrating VMs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 migrating VMs
    /// will be returned. The maximum value is 1000; values above 1000 will be
    /// coerced to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListMigratingVms` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListMigratingVms`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    /// Optional. The level of details of each migrating VM.
    pub view: crate::model::MigratingVmView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListMigratingVmsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListMigratingVmsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListMigratingVmsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListMigratingVmsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListMigratingVmsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [view][crate::model::ListMigratingVmsRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigratingVmsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigratingVmsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigratingVmsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigratingVmsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::MigratingVmView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigratingVmsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigratingVmsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigratingVmsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListMigratingVms' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListMigratingVmsResponse {
    /// Output only. The list of Migrating VMs response.
    pub migrating_vms: std::vec::Vec<crate::model::MigratingVm>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListMigratingVmsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vms][crate::model::ListMigratingVmsResponse::migrating_vms].
    pub fn set_migrating_vms<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigratingVm>,
    {
        use std::iter::Iterator;
        self.migrating_vms = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListMigratingVmsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListMigratingVmsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListMigratingVmsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListMigratingVmsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListMigratingVmsResponse {
    type PageItem = crate::model::MigratingVm;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.migrating_vms
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListMigratingVmsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vms,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListMigratingVmsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVms" => Ok(__FieldTag::__migrating_vms),
                            "migrating_vms" => Ok(__FieldTag::__migrating_vms),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListMigratingVmsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListMigratingVmsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vms => {
                            if !fields.insert(__FieldTag::__migrating_vms) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vms",
                                ));
                            }
                            result.migrating_vms = map.next_value::<std::option::Option<std::vec::Vec<crate::model::MigratingVm>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListMigratingVmsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vms.is_empty() {
            state.serialize_entry("migratingVms", &self.migrating_vms)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListMigratingVmsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListMigratingVmsResponse");
        debug_struct.field("migrating_vms", &self.migrating_vms);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    pub name: std::string::String,

    /// Optional. The level of details of the migrating VM.
    pub view: crate::model::MigratingVmView,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [view][crate::model::GetMigratingVmRequest::view].
    pub fn set_view<T: std::convert::Into<crate::model::MigratingVmView>>(mut self, v: T) -> Self {
        self.view = v.into();
        self
    }
}

impl wkt::message::Message for GetMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __view,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "view" => Ok(__FieldTag::__view),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__view => {
                            if !fields.insert(__FieldTag::__view) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for view",
                                ));
                            }
                            result.view = map
                                .next_value::<std::option::Option<crate::model::MigratingVmView>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.view) {
            state.serialize_entry("view", &self.view)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetMigratingVmRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("view", &self.view);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateMigratingVmRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// MigratingVm resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub migrating_vm: std::option::Option<crate::model::MigratingVm>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateMigratingVmRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_migrating_vm<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [migrating_vm][crate::model::UpdateMigratingVmRequest::migrating_vm].
    pub fn set_or_clear_migrating_vm<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::MigratingVm>,
    {
        self.migrating_vm = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateMigratingVmRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __migrating_vm,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm =
                                map.next_value::<std::option::Option<crate::model::MigratingVm>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.migrating_vm.is_some() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateMigratingVmRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteMigratingVm' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteMigratingVmRequest {
    /// Required. The name of the MigratingVm.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteMigratingVmRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteMigratingVmRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteMigratingVmRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteMigratingVmRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteMigratingVmRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteMigratingVmRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteMigratingVmRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteMigratingVmRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteMigratingVmRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteMigratingVmRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteMigratingVmRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'StartMigrationRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::StartMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for StartMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'StartMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct StartMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for StartMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.StartMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for StartMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("StartMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'PauseMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::PauseMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for PauseMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'PauseMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PauseMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PauseMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PauseMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.PauseMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PauseMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PauseMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PauseMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PauseMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PauseMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PauseMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PauseMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ResumeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::ResumeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for ResumeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ResumeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ResumeMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResumeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResumeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ResumeMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResumeMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResumeMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResumeMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResumeMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResumeMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ResumeMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ResumeMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'FinalizeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FinalizeMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::FinalizeMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for FinalizeMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FinalizeMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FinalizeMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FinalizeMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FinalizeMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FinalizeMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FinalizeMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FinalizeMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ExtendMigrationRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExtendMigrationRequest {
    /// Required. The name of the MigratingVm.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtendMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [migrating_vm][crate::model::ExtendMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for ExtendMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ExtendMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExtendMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtendMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExtendMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtendMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExtendMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExtendMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtendMigrationRequest");
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ExtendMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ExtendMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ExtendMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExtendMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ExtendMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ExtendMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ExtendMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ExtendMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ExtendMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ExtendMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ExtendMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExtendMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'FinalizeMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct FinalizeMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FinalizeMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for FinalizeMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.FinalizeMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FinalizeMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FinalizeMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FinalizeMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FinalizeMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FinalizeMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for FinalizeMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FinalizeMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// TargetProject message represents a target Compute Engine project for a
/// migration or a clone.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct TargetProject {
    /// Output only. The name of the target project.
    pub name: std::string::String,

    /// Required. The target project ID (number) or project name.
    pub project: std::string::String,

    /// The target project's description.
    pub description: std::string::String,

    /// Output only. The time this target project resource was created (not related
    /// to when the Compute Engine project it points to was created).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the target project resource was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl TargetProject {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::TargetProject::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [project][crate::model::TargetProject::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [description][crate::model::TargetProject::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::TargetProject::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::TargetProject::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for TargetProject {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.TargetProject"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for TargetProject {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __project,
            __description,
            __create_time,
            __update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for TargetProject")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "project" => Ok(__FieldTag::__project),
                            "description" => Ok(__FieldTag::__description),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = TargetProject;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct TargetProject")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for TargetProject {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for TargetProject {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("TargetProject");
        debug_struct.field("name", &self.name);
        debug_struct.field("project", &self.project);
        debug_struct.field("description", &self.description);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetTargetProject' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetTargetProjectRequest {
    /// Required. The TargetProject name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetTargetProjectRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListTargetProjects' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetProjectsRequest {
    /// Required. The parent, which owns this collection of targets.
    pub parent: std::string::String,

    /// Optional. The maximum number of targets to return. The service may return
    /// fewer than this value. If unspecified, at most 500 targets will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListTargets` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListTargets` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListTargetProjectsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListTargetProjectsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListTargetProjectsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListTargetProjectsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListTargetProjectsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetProjectsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetProjectsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetProjectsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetProjectsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetProjectsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetProjectsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetProjectsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListTargetProjects' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListTargetProjectsResponse {
    /// Output only. The list of target response.
    pub target_projects: std::vec::Vec<crate::model::TargetProject>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListTargetProjectsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_projects][crate::model::ListTargetProjectsResponse::target_projects].
    pub fn set_target_projects<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::TargetProject>,
    {
        use std::iter::Iterator;
        self.target_projects = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListTargetProjectsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListTargetProjectsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListTargetProjectsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListTargetProjectsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListTargetProjectsResponse {
    type PageItem = crate::model::TargetProject;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.target_projects
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListTargetProjectsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_projects,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListTargetProjectsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetProjects" => Ok(__FieldTag::__target_projects),
                            "target_projects" => Ok(__FieldTag::__target_projects),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListTargetProjectsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListTargetProjectsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_projects => {
                            if !fields.insert(__FieldTag::__target_projects) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_projects",
                                ));
                            }
                            result.target_projects = map.next_value::<std::option::Option<std::vec::Vec<crate::model::TargetProject>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListTargetProjectsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_projects.is_empty() {
            state.serialize_entry("targetProjects", &self.target_projects)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListTargetProjectsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListTargetProjectsResponse");
        debug_struct.field("target_projects", &self.target_projects);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateTargetProjectRequest {
    /// Required. The TargetProject's parent.
    pub parent: std::string::String,

    /// Required. The target_project identifier.
    pub target_project_id: std::string::String,

    /// Required. The create request body.
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateTargetProjectRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [target_project_id][crate::model::CreateTargetProjectRequest::target_project_id].
    pub fn set_target_project_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_project_id = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::CreateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __target_project_id,
            __target_project,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "targetProjectId" => Ok(__FieldTag::__target_project_id),
                            "target_project_id" => Ok(__FieldTag::__target_project_id),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project_id => {
                            if !fields.insert(__FieldTag::__target_project_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project_id",
                                ));
                            }
                            result.target_project_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<crate::model::TargetProject>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.target_project_id.is_empty() {
            state.serialize_entry("targetProjectId", &self.target_project_id)?;
        }
        if self.target_project.is_some() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateTargetProjectRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("target_project_id", &self.target_project_id);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateTargetProjectRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// TargetProject resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub target_project: std::option::Option<crate::model::TargetProject>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateTargetProjectRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_target_project<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_project][crate::model::UpdateTargetProjectRequest::target_project].
    pub fn set_or_clear_target_project<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::TargetProject>,
    {
        self.target_project = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __target_project,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<crate::model::TargetProject>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.target_project.is_some() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateTargetProjectRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteTargetProject' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteTargetProjectRequest {
    /// Required. The TargetProject name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteTargetProjectRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteTargetProjectRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteTargetProjectRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteTargetProjectRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteTargetProjectRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteTargetProjectRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteTargetProjectRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteTargetProjectRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteTargetProjectRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteTargetProjectRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteTargetProjectRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteTargetProjectRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes message for 'Group' resource. The Group is a collections of several
/// MigratingVms.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Group {
    /// Output only. The Group name.
    pub name: std::string::String,

    /// Output only. The create time timestamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The update time timestamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// User-provided description of the group.
    pub description: std::string::String,

    /// Display name is a user defined name for this group which can be updated.
    pub display_name: std::string::String,

    /// Immutable. The target type of this group.
    pub migration_target_type: crate::model::group::MigrationTargetType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Group {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Group::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Group::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Group::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Group::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Group::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [description][crate::model::Group::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [display_name][crate::model::Group::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [migration_target_type][crate::model::Group::migration_target_type].
    pub fn set_migration_target_type<
        T: std::convert::Into<crate::model::group::MigrationTargetType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.migration_target_type = v.into();
        self
    }
}

impl wkt::message::Message for Group {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.Group"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Group {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __description,
            __display_name,
            __migration_target_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Group")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "description" => Ok(__FieldTag::__description),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "migrationTargetType" => Ok(__FieldTag::__migration_target_type),
                            "migration_target_type" => Ok(__FieldTag::__migration_target_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Group;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Group")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migration_target_type => {
                            if !fields.insert(__FieldTag::__migration_target_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migration_target_type",
                                ));
                            }
                            result.migration_target_type = map.next_value::<std::option::Option<crate::model::group::MigrationTargetType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Group {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if !wkt::internal::is_default(&self.migration_target_type) {
            state.serialize_entry("migrationTargetType", &self.migration_target_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Group {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Group");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("description", &self.description);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("migration_target_type", &self.migration_target_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Group].
pub mod group {
    #[allow(unused_imports)]
    use super::*;

    /// The possible types of the group.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum MigrationTargetType {
        /// Group type is not specified. This defaults to Compute Engine targets.
        Unspecified,
        /// All MigratingVMs in the group must have Compute Engine targets.
        Gce,
        /// All MigratingVMs in the group must have Compute Engine Disks targets.
        Disks,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [MigrationTargetType::value] or
        /// [MigrationTargetType::name].
        UnknownValue(migration_target_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod migration_target_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl MigrationTargetType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gce => std::option::Option::Some(1),
                Self::Disks => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("MIGRATION_TARGET_TYPE_UNSPECIFIED"),
                Self::Gce => std::option::Option::Some("MIGRATION_TARGET_TYPE_GCE"),
                Self::Disks => std::option::Option::Some("MIGRATION_TARGET_TYPE_DISKS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for MigrationTargetType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for MigrationTargetType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for MigrationTargetType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gce,
                2 => Self::Disks,
                _ => Self::UnknownValue(migration_target_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for MigrationTargetType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "MIGRATION_TARGET_TYPE_UNSPECIFIED" => Self::Unspecified,
                "MIGRATION_TARGET_TYPE_GCE" => Self::Gce,
                "MIGRATION_TARGET_TYPE_DISKS" => Self::Disks,
                _ => Self::UnknownValue(migration_target_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for MigrationTargetType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gce => serializer.serialize_i32(1),
                Self::Disks => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for MigrationTargetType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigrationTargetType>::new(
                ".google.cloud.vmmigration.v1.Group.MigrationTargetType",
            ))
        }
    }
}

/// Request message for 'ListGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsRequest {
    /// Required. The parent, which owns this collection of groups.
    pub parent: std::string::String,

    /// Optional. The maximum number of groups to return. The service may return
    /// fewer than this value. If unspecified, at most 500 groups will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListGroups` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListGroups` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGroupsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGroupsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGroupsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGroupsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGroupsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGroupsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGroupsResponse {
    /// Output only. The list of groups response.
    pub groups: std::vec::Vec<crate::model::Group>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGroupsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [groups][crate::model::ListGroupsResponse::groups].
    pub fn set_groups<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Group>,
    {
        use std::iter::Iterator;
        self.groups = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGroupsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGroupsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGroupsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListGroupsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGroupsResponse {
    type PageItem = crate::model::Group;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.groups
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGroupsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __groups,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGroupsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "groups" => Ok(__FieldTag::__groups),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGroupsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGroupsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__groups => {
                            if !fields.insert(__FieldTag::__groups) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for groups",
                                ));
                            }
                            result.groups = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Group>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGroupsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.groups.is_empty() {
            state.serialize_entry("groups", &self.groups)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGroupsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGroupsResponse");
        debug_struct.field("groups", &self.groups);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGroupRequest {
    /// Required. The group name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGroupRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGroupRequest {
    /// Required. The Group's parent.
    pub parent: std::string::String,

    /// Required. The group identifier.
    pub group_id: std::string::String,

    /// Required. The create request body.
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGroupRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [group_id][crate::model::CreateGroupRequest::group_id].
    pub fn set_group_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group_id = v.into();
        self
    }

    /// Sets the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::CreateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __group_id,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "groupId" => Ok(__FieldTag::__group_id),
                            "group_id" => Ok(__FieldTag::__group_id),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group_id => {
                            if !fields.insert(__FieldTag::__group_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group_id",
                                ));
                            }
                            result.group_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.group_id.is_empty() {
            state.serialize_entry("groupId", &self.group_id)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGroupRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("group_id", &self.group_id);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Update message for 'UpdateGroups' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateGroupRequest {
    /// Field mask is used to specify the fields to be overwritten in the
    /// Group resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub group: std::option::Option<crate::model::Group>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateGroupRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_group<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [group][crate::model::UpdateGroupRequest::group].
    pub fn set_or_clear_group<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Group>,
    {
        self.group = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __group,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "group" => Ok(__FieldTag::__group),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group =
                                map.next_value::<std::option::Option<crate::model::Group>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.group.is_some() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateGroupRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("group", &self.group);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteGroup' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteGroupRequest {
    /// Required. The Group name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGroupRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGroupRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGroupRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGroupRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteGroupRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteGroupRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteGroupRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteGroupRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteGroupRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteGroupRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteGroupRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteGroupRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'AddGroupMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddGroupMigrationRequest {
    /// Required. The full path name of the Group to add to.
    pub group: std::string::String,

    /// The full path name of the MigratingVm to add.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::AddGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::AddGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for AddGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddGroupMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddGroupMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddGroupMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddGroupMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddGroupMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddGroupMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddGroupMigrationRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'AddGroupMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AddGroupMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AddGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for AddGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AddGroupMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AddGroupMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AddGroupMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AddGroupMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AddGroupMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AddGroupMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AddGroupMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AddGroupMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'RemoveMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveGroupMigrationRequest {
    /// Required. The name of the Group.
    pub group: std::string::String,

    /// The MigratingVm to remove.
    pub migrating_vm: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [group][crate::model::RemoveGroupMigrationRequest::group].
    pub fn set_group<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.group = v.into();
        self
    }

    /// Sets the value of [migrating_vm][crate::model::RemoveGroupMigrationRequest::migrating_vm].
    pub fn set_migrating_vm<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.migrating_vm = v.into();
        self
    }
}

impl wkt::message::Message for RemoveGroupMigrationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveGroupMigrationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __group,
            __migrating_vm,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveGroupMigrationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "group" => Ok(__FieldTag::__group),
                            "migratingVm" => Ok(__FieldTag::__migrating_vm),
                            "migrating_vm" => Ok(__FieldTag::__migrating_vm),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveGroupMigrationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveGroupMigrationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__group => {
                            if !fields.insert(__FieldTag::__group) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for group",
                                ));
                            }
                            result.group = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__migrating_vm => {
                            if !fields.insert(__FieldTag::__migrating_vm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for migrating_vm",
                                ));
                            }
                            result.migrating_vm = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveGroupMigrationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.group.is_empty() {
            state.serialize_entry("group", &self.group)?;
        }
        if !self.migrating_vm.is_empty() {
            state.serialize_entry("migratingVm", &self.migrating_vm)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveGroupMigrationRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveGroupMigrationRequest");
        debug_struct.field("group", &self.group);
        debug_struct.field("migrating_vm", &self.migrating_vm);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'RemoveMigration' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveGroupMigrationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveGroupMigrationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveGroupMigrationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RemoveGroupMigrationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveGroupMigrationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveGroupMigrationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveGroupMigrationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveGroupMigrationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveGroupMigrationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RemoveGroupMigrationResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RemoveGroupMigrationResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCutoverJobRequest {
    /// Required. The Cutover's parent.
    pub parent: std::string::String,

    /// Required. The cutover job identifier.
    pub cutover_job_id: std::string::String,

    /// Required. The cutover request body.
    pub cutover_job: std::option::Option<crate::model::CutoverJob>,

    /// A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCutoverJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [cutover_job_id][crate::model::CreateCutoverJobRequest::cutover_job_id].
    pub fn set_cutover_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cutover_job_id = v.into();
        self
    }

    /// Sets the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_cutover_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [cutover_job][crate::model::CreateCutoverJobRequest::cutover_job].
    pub fn set_or_clear_cutover_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CutoverJob>,
    {
        self.cutover_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateCutoverJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __cutover_job_id,
            __cutover_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "cutoverJobId" => Ok(__FieldTag::__cutover_job_id),
                            "cutover_job_id" => Ok(__FieldTag::__cutover_job_id),
                            "cutoverJob" => Ok(__FieldTag::__cutover_job),
                            "cutover_job" => Ok(__FieldTag::__cutover_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cutover_job_id => {
                            if !fields.insert(__FieldTag::__cutover_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_job_id",
                                ));
                            }
                            result.cutover_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__cutover_job => {
                            if !fields.insert(__FieldTag::__cutover_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_job",
                                ));
                            }
                            result.cutover_job =
                                map.next_value::<std::option::Option<crate::model::CutoverJob>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.cutover_job_id.is_empty() {
            state.serialize_entry("cutoverJobId", &self.cutover_job_id)?;
        }
        if self.cutover_job.is_some() {
            state.serialize_entry("cutoverJob", &self.cutover_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateCutoverJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("cutover_job_id", &self.cutover_job_id);
        debug_struct.field("cutover_job", &self.cutover_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCutoverJobRequest {
    /// Required. The cutover job id
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCutoverJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelCutoverJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelCutoverJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelCutoverJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelCutoverJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelCutoverJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelCutoverJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelCutoverJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelCutoverJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelCutoverJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelCutoverJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelCutoverJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListCutoverJobsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCutoverJobsRequest {
    /// Required. The parent, which owns this collection of migrating VMs.
    pub parent: std::string::String,

    /// Optional. The maximum number of cutover jobs to return. The service may
    /// return fewer than this value. If unspecified, at most 500 cutover jobs will
    /// be returned. The maximum value is 1000; values above 1000 will be coerced
    /// to 1000.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListCutoverJobs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCutoverJobs` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCutoverJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCutoverJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCutoverJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCutoverJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCutoverJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCutoverJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCutoverJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCutoverJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCutoverJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCutoverJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCutoverJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCutoverJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListCutoverJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCutoverJobsResponse {
    /// Output only. The list of cutover jobs response.
    pub cutover_jobs: std::vec::Vec<crate::model::CutoverJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCutoverJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [cutover_jobs][crate::model::ListCutoverJobsResponse::cutover_jobs].
    pub fn set_cutover_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CutoverJob>,
    {
        use std::iter::Iterator;
        self.cutover_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCutoverJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCutoverJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCutoverJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListCutoverJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCutoverJobsResponse {
    type PageItem = crate::model::CutoverJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.cutover_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCutoverJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cutover_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCutoverJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cutoverJobs" => Ok(__FieldTag::__cutover_jobs),
                            "cutover_jobs" => Ok(__FieldTag::__cutover_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCutoverJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCutoverJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cutover_jobs => {
                            if !fields.insert(__FieldTag::__cutover_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cutover_jobs",
                                ));
                            }
                            result.cutover_jobs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::CutoverJob>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCutoverJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.cutover_jobs.is_empty() {
            state.serialize_entry("cutoverJobs", &self.cutover_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListCutoverJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListCutoverJobsResponse");
        debug_struct.field("cutover_jobs", &self.cutover_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetCutoverJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCutoverJobRequest {
    /// Required. The name of the CutoverJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCutoverJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCutoverJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCutoverJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetCutoverJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCutoverJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCutoverJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCutoverJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCutoverJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCutoverJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetCutoverJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetCutoverJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents migration resource error information that can be used with
/// google.rpc.Status message. MigrationError is used to present the user with
/// error information in migration operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationError {
    /// Output only. The error code.
    pub code: crate::model::migration_error::ErrorCode,

    /// Output only. The localized error message.
    pub error_message: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. Suggested action for solving the error.
    pub action_item: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. URL(s) pointing to additional information on handling the
    /// current error.
    pub help_links: std::vec::Vec<rpc::model::help::Link>,

    /// Output only. The time the error occurred.
    pub error_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationError {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MigrationError::code].
    pub fn set_code<T: std::convert::Into<crate::model::migration_error::ErrorCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_error_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_message][crate::model::MigrationError::error_message].
    pub fn set_or_clear_error_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.error_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_action_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action_item][crate::model::MigrationError::action_item].
    pub fn set_or_clear_action_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [help_links][crate::model::MigrationError::help_links].
    pub fn set_help_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::help::Link>,
    {
        use std::iter::Iterator;
        self.help_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_error_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [error_time][crate::model::MigrationError::error_time].
    pub fn set_or_clear_error_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.error_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationError {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigrationError"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationError {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __error_message,
            __action_item,
            __help_links,
            __error_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationError")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "errorMessage" => Ok(__FieldTag::__error_message),
                            "error_message" => Ok(__FieldTag::__error_message),
                            "actionItem" => Ok(__FieldTag::__action_item),
                            "action_item" => Ok(__FieldTag::__action_item),
                            "helpLinks" => Ok(__FieldTag::__help_links),
                            "help_links" => Ok(__FieldTag::__help_links),
                            "errorTime" => Ok(__FieldTag::__error_time),
                            "error_time" => Ok(__FieldTag::__error_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationError;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationError")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code = map.next_value::<std::option::Option<crate::model::migration_error::ErrorCode>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_message => {
                            if !fields.insert(__FieldTag::__error_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_message",
                                ));
                            }
                            result.error_message = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__action_item => {
                            if !fields.insert(__FieldTag::__action_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_item",
                                ));
                            }
                            result.action_item = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__help_links => {
                            if !fields.insert(__FieldTag::__help_links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for help_links",
                                ));
                            }
                            result.help_links = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::help::Link>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__error_time => {
                            if !fields.insert(__FieldTag::__error_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for error_time",
                                ));
                            }
                            result.error_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationError {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if self.error_message.is_some() {
            state.serialize_entry("errorMessage", &self.error_message)?;
        }
        if self.action_item.is_some() {
            state.serialize_entry("actionItem", &self.action_item)?;
        }
        if !self.help_links.is_empty() {
            state.serialize_entry("helpLinks", &self.help_links)?;
        }
        if self.error_time.is_some() {
            state.serialize_entry("errorTime", &self.error_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationError");
        debug_struct.field("code", &self.code);
        debug_struct.field("error_message", &self.error_message);
        debug_struct.field("action_item", &self.action_item);
        debug_struct.field("help_links", &self.help_links);
        debug_struct.field("error_time", &self.error_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationError].
pub mod migration_error {
    #[allow(unused_imports)]
    use super::*;

    /// Represents resource error codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ErrorCode {
        /// Default value. This value is not used.
        Unspecified,
        /// Migrate to Virtual Machines encountered an unknown error.
        UnknownError,
        /// Migrate to Virtual Machines encountered an error while validating
        /// replication source health.
        SourceValidationError,
        /// Migrate to Virtual Machines encountered an error during source data
        /// operation.
        SourceReplicationError,
        /// Migrate to Virtual Machines encountered an error during target data
        /// operation.
        TargetReplicationError,
        /// Migrate to Virtual Machines encountered an error during OS adaptation.
        OsAdaptationError,
        /// Migrate to Virtual Machines encountered an error in clone operation.
        CloneError,
        /// Migrate to Virtual Machines encountered an error in cutover operation.
        CutoverError,
        /// Migrate to Virtual Machines encountered an error during utilization
        /// report creation.
        UtilizationReportError,
        /// Migrate to Virtual Machines encountered an error during appliance
        /// upgrade.
        ApplianceUpgradeError,
        /// Migrate to Virtual Machines encountered an error in image import
        /// operation.
        ImageImportError,
        /// Migrate to Virtual Machines encountered an error in disk migration
        /// operation.
        DiskMigrationError,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [ErrorCode::value] or
        /// [ErrorCode::name].
        UnknownValue(error_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod error_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl ErrorCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::UnknownError => std::option::Option::Some(1),
                Self::SourceValidationError => std::option::Option::Some(2),
                Self::SourceReplicationError => std::option::Option::Some(3),
                Self::TargetReplicationError => std::option::Option::Some(4),
                Self::OsAdaptationError => std::option::Option::Some(5),
                Self::CloneError => std::option::Option::Some(6),
                Self::CutoverError => std::option::Option::Some(7),
                Self::UtilizationReportError => std::option::Option::Some(8),
                Self::ApplianceUpgradeError => std::option::Option::Some(9),
                Self::ImageImportError => std::option::Option::Some(10),
                Self::DiskMigrationError => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ERROR_CODE_UNSPECIFIED"),
                Self::UnknownError => std::option::Option::Some("UNKNOWN_ERROR"),
                Self::SourceValidationError => std::option::Option::Some("SOURCE_VALIDATION_ERROR"),
                Self::SourceReplicationError => {
                    std::option::Option::Some("SOURCE_REPLICATION_ERROR")
                }
                Self::TargetReplicationError => {
                    std::option::Option::Some("TARGET_REPLICATION_ERROR")
                }
                Self::OsAdaptationError => std::option::Option::Some("OS_ADAPTATION_ERROR"),
                Self::CloneError => std::option::Option::Some("CLONE_ERROR"),
                Self::CutoverError => std::option::Option::Some("CUTOVER_ERROR"),
                Self::UtilizationReportError => {
                    std::option::Option::Some("UTILIZATION_REPORT_ERROR")
                }
                Self::ApplianceUpgradeError => std::option::Option::Some("APPLIANCE_UPGRADE_ERROR"),
                Self::ImageImportError => std::option::Option::Some("IMAGE_IMPORT_ERROR"),
                Self::DiskMigrationError => std::option::Option::Some("DISK_MIGRATION_ERROR"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for ErrorCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for ErrorCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for ErrorCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::UnknownError,
                2 => Self::SourceValidationError,
                3 => Self::SourceReplicationError,
                4 => Self::TargetReplicationError,
                5 => Self::OsAdaptationError,
                6 => Self::CloneError,
                7 => Self::CutoverError,
                8 => Self::UtilizationReportError,
                9 => Self::ApplianceUpgradeError,
                10 => Self::ImageImportError,
                11 => Self::DiskMigrationError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for ErrorCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ERROR_CODE_UNSPECIFIED" => Self::Unspecified,
                "UNKNOWN_ERROR" => Self::UnknownError,
                "SOURCE_VALIDATION_ERROR" => Self::SourceValidationError,
                "SOURCE_REPLICATION_ERROR" => Self::SourceReplicationError,
                "TARGET_REPLICATION_ERROR" => Self::TargetReplicationError,
                "OS_ADAPTATION_ERROR" => Self::OsAdaptationError,
                "CLONE_ERROR" => Self::CloneError,
                "CUTOVER_ERROR" => Self::CutoverError,
                "UTILIZATION_REPORT_ERROR" => Self::UtilizationReportError,
                "APPLIANCE_UPGRADE_ERROR" => Self::ApplianceUpgradeError,
                "IMAGE_IMPORT_ERROR" => Self::ImageImportError,
                "DISK_MIGRATION_ERROR" => Self::DiskMigrationError,
                _ => Self::UnknownValue(error_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for ErrorCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::UnknownError => serializer.serialize_i32(1),
                Self::SourceValidationError => serializer.serialize_i32(2),
                Self::SourceReplicationError => serializer.serialize_i32(3),
                Self::TargetReplicationError => serializer.serialize_i32(4),
                Self::OsAdaptationError => serializer.serialize_i32(5),
                Self::CloneError => serializer.serialize_i32(6),
                Self::CutoverError => serializer.serialize_i32(7),
                Self::UtilizationReportError => serializer.serialize_i32(8),
                Self::ApplianceUpgradeError => serializer.serialize_i32(9),
                Self::ImageImportError => serializer.serialize_i32(10),
                Self::DiskMigrationError => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for ErrorCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<ErrorCode>::new(
                ".google.cloud.vmmigration.v1.MigrationError.ErrorCode",
            ))
        }
    }
}

/// Represents migration resource warning information that can be used with
/// google.rpc.Status message. MigrationWarning is used to present the user with
/// warning information in migration operations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MigrationWarning {
    /// The warning code.
    pub code: crate::model::migration_warning::WarningCode,

    /// Output only. The localized warning message.
    pub warning_message: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. Suggested action for solving the warning.
    pub action_item: std::option::Option<rpc::model::LocalizedMessage>,

    /// Output only. URL(s) pointing to additional information on handling the
    /// current warning.
    pub help_links: std::vec::Vec<rpc::model::help::Link>,

    /// The time the warning occurred.
    pub warning_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MigrationWarning {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [code][crate::model::MigrationWarning::code].
    pub fn set_code<T: std::convert::Into<crate::model::migration_warning::WarningCode>>(
        mut self,
        v: T,
    ) -> Self {
        self.code = v.into();
        self
    }

    /// Sets the value of [warning_message][crate::model::MigrationWarning::warning_message].
    pub fn set_warning_message<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.warning_message = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning_message][crate::model::MigrationWarning::warning_message].
    pub fn set_or_clear_warning_message<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.warning_message = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action_item][crate::model::MigrationWarning::action_item].
    pub fn set_action_item<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [action_item][crate::model::MigrationWarning::action_item].
    pub fn set_or_clear_action_item<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<rpc::model::LocalizedMessage>,
    {
        self.action_item = v.map(|x| x.into());
        self
    }

    /// Sets the value of [help_links][crate::model::MigrationWarning::help_links].
    pub fn set_help_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::help::Link>,
    {
        use std::iter::Iterator;
        self.help_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warning_time][crate::model::MigrationWarning::warning_time].
    pub fn set_warning_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.warning_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [warning_time][crate::model::MigrationWarning::warning_time].
    pub fn set_or_clear_warning_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.warning_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for MigrationWarning {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MigrationWarning"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MigrationWarning {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __code,
            __warning_message,
            __action_item,
            __help_links,
            __warning_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MigrationWarning")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "code" => Ok(__FieldTag::__code),
                            "warningMessage" => Ok(__FieldTag::__warning_message),
                            "warning_message" => Ok(__FieldTag::__warning_message),
                            "actionItem" => Ok(__FieldTag::__action_item),
                            "action_item" => Ok(__FieldTag::__action_item),
                            "helpLinks" => Ok(__FieldTag::__help_links),
                            "help_links" => Ok(__FieldTag::__help_links),
                            "warningTime" => Ok(__FieldTag::__warning_time),
                            "warning_time" => Ok(__FieldTag::__warning_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MigrationWarning;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MigrationWarning")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__code => {
                            if !fields.insert(__FieldTag::__code) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code",
                                ));
                            }
                            result.code =
                                map.next_value::<std::option::Option<
                                    crate::model::migration_warning::WarningCode,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__warning_message => {
                            if !fields.insert(__FieldTag::__warning_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warning_message",
                                ));
                            }
                            result.warning_message = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__action_item => {
                            if !fields.insert(__FieldTag::__action_item) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action_item",
                                ));
                            }
                            result.action_item = map
                                .next_value::<std::option::Option<rpc::model::LocalizedMessage>>(
                                )?;
                        }
                        __FieldTag::__help_links => {
                            if !fields.insert(__FieldTag::__help_links) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for help_links",
                                ));
                            }
                            result.help_links = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::help::Link>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__warning_time => {
                            if !fields.insert(__FieldTag::__warning_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warning_time",
                                ));
                            }
                            result.warning_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MigrationWarning {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.code) {
            state.serialize_entry("code", &self.code)?;
        }
        if self.warning_message.is_some() {
            state.serialize_entry("warningMessage", &self.warning_message)?;
        }
        if self.action_item.is_some() {
            state.serialize_entry("actionItem", &self.action_item)?;
        }
        if !self.help_links.is_empty() {
            state.serialize_entry("helpLinks", &self.help_links)?;
        }
        if self.warning_time.is_some() {
            state.serialize_entry("warningTime", &self.warning_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MigrationWarning {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MigrationWarning");
        debug_struct.field("code", &self.code);
        debug_struct.field("warning_message", &self.warning_message);
        debug_struct.field("action_item", &self.action_item);
        debug_struct.field("help_links", &self.help_links);
        debug_struct.field("warning_time", &self.warning_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MigrationWarning].
pub mod migration_warning {
    #[allow(unused_imports)]
    use super::*;

    /// Represents possible warning codes.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum WarningCode {
        /// Default value. This value is not used.
        Unspecified,
        /// A warning originated from OS Adaptation.
        AdaptationWarning,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [WarningCode::value] or
        /// [WarningCode::name].
        UnknownValue(warning_code::UnknownValue),
    }

    #[doc(hidden)]
    pub mod warning_code {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl WarningCode {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::AdaptationWarning => std::option::Option::Some(1),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("WARNING_CODE_UNSPECIFIED"),
                Self::AdaptationWarning => std::option::Option::Some("ADAPTATION_WARNING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for WarningCode {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for WarningCode {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for WarningCode {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::AdaptationWarning,
                _ => Self::UnknownValue(warning_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for WarningCode {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "WARNING_CODE_UNSPECIFIED" => Self::Unspecified,
                "ADAPTATION_WARNING" => Self::AdaptationWarning,
                _ => Self::UnknownValue(warning_code::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for WarningCode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::AdaptationWarning => serializer.serialize_i32(1),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for WarningCode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<WarningCode>::new(
                ".google.cloud.vmmigration.v1.MigrationWarning.WarningCode",
            ))
        }
    }
}

/// Represent the source Vmware VM details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmwareSourceVmDetails {
    /// Output only. The firmware type of the source VM.
    pub firmware: crate::model::vmware_source_vm_details::Firmware,

    /// Output only. The total size of the disks being migrated in bytes.
    pub committed_storage_bytes: i64,

    /// Output only. The disks attached to the source VM.
    pub disks: std::vec::Vec<crate::model::vmware_source_vm_details::VmwareDiskDetails>,

    /// Output only. Information about VM capabilities needed for some Compute
    /// Engine features.
    pub vm_capabilities_info: std::option::Option<crate::model::VmCapabilities>,

    /// Output only. The VM architecture.
    pub architecture: crate::model::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmwareSourceVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firmware][crate::model::VmwareSourceVmDetails::firmware].
    pub fn set_firmware<T: std::convert::Into<crate::model::vmware_source_vm_details::Firmware>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware = v.into();
        self
    }

    /// Sets the value of [committed_storage_bytes][crate::model::VmwareSourceVmDetails::committed_storage_bytes].
    pub fn set_committed_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_bytes = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::VmwareSourceVmDetails::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::vmware_source_vm_details::VmwareDiskDetails>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vm_capabilities_info][crate::model::VmwareSourceVmDetails::vm_capabilities_info].
    pub fn set_vm_capabilities_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_capabilities_info][crate::model::VmwareSourceVmDetails::vm_capabilities_info].
    pub fn set_or_clear_vm_capabilities_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [architecture][crate::model::VmwareSourceVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for VmwareSourceVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmwareSourceVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmwareSourceVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firmware,
            __committed_storage_bytes,
            __disks,
            __vm_capabilities_info,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmwareSourceVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firmware" => Ok(__FieldTag::__firmware),
                            "committedStorageBytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "committed_storage_bytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "disks" => Ok(__FieldTag::__disks),
                            "vmCapabilitiesInfo" => Ok(__FieldTag::__vm_capabilities_info),
                            "vm_capabilities_info" => Ok(__FieldTag::__vm_capabilities_info),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmwareSourceVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmwareSourceVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firmware => {
                            if !fields.insert(__FieldTag::__firmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware",
                                ));
                            }
                            result.firmware = map
                                .next_value::<std::option::Option<
                                    crate::model::vmware_source_vm_details::Firmware,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_bytes => {
                            if !fields.insert(__FieldTag::__committed_storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::vmware_source_vm_details::VmwareDiskDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_capabilities_info => {
                            if !fields.insert(__FieldTag::__vm_capabilities_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_capabilities_info",
                                ));
                            }
                            result.vm_capabilities_info = map
                                .next_value::<std::option::Option<crate::model::VmCapabilities>>(
                                )?;
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::VmArchitecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmwareSourceVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.firmware) {
            state.serialize_entry("firmware", &self.firmware)?;
        }
        if !wkt::internal::is_default(&self.committed_storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "committedStorageBytes",
                &__With(&self.committed_storage_bytes),
            )?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.vm_capabilities_info.is_some() {
            state.serialize_entry("vmCapabilitiesInfo", &self.vm_capabilities_info)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmwareSourceVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmwareSourceVmDetails");
        debug_struct.field("firmware", &self.firmware);
        debug_struct.field("committed_storage_bytes", &self.committed_storage_bytes);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("vm_capabilities_info", &self.vm_capabilities_info);
        debug_struct.field("architecture", &self.architecture);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [VmwareSourceVmDetails].
pub mod vmware_source_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// The details of a Vmware VM disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct VmwareDiskDetails {
        /// Output only. The ordinal number of the disk.
        pub disk_number: i32,

        /// Output only. Size in GB.
        pub size_gb: i64,

        /// Output only. The disk label.
        pub label: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl VmwareDiskDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_number][crate::model::vmware_source_vm_details::VmwareDiskDetails::disk_number].
        pub fn set_disk_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.disk_number = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::vmware_source_vm_details::VmwareDiskDetails::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }

        /// Sets the value of [label][crate::model::vmware_source_vm_details::VmwareDiskDetails::label].
        pub fn set_label<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.label = v.into();
            self
        }
    }

    impl wkt::message::Message for VmwareDiskDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.VmwareSourceVmDetails.VmwareDiskDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for VmwareDiskDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disk_number,
                __size_gb,
                __label,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for VmwareDiskDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "diskNumber" => Ok(__FieldTag::__disk_number),
                                "disk_number" => Ok(__FieldTag::__disk_number),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                "label" => Ok(__FieldTag::__label),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = VmwareDiskDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct VmwareDiskDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disk_number => {
                                if !fields.insert(__FieldTag::__disk_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.disk_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__label => {
                                if !fields.insert(__FieldTag::__label) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for label",
                                    ));
                                }
                                result.label = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for VmwareDiskDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.disk_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("diskNumber", &__With(&self.disk_number))?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !self.label.is_empty() {
                state.serialize_entry("label", &self.label)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for VmwareDiskDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("VmwareDiskDetails");
            debug_struct.field("disk_number", &self.disk_number);
            debug_struct.field("size_gb", &self.size_gb);
            debug_struct.field("label", &self.label);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible values for Vmware VM firmware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified,
        /// The firmware is EFI.
        Efi,
        /// The firmware is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Firmware::value] or
        /// [Firmware::name].
        UnknownValue(firmware::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Firmware {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Firmware {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Firmware {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Firmware {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Firmware {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Firmware {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Firmware {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Firmware>::new(
                ".google.cloud.vmmigration.v1.VmwareSourceVmDetails.Firmware",
            ))
        }
    }
}

/// Represent the source AWS VM details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSourceVmDetails {
    /// Output only. The firmware type of the source VM.
    pub firmware: crate::model::aws_source_vm_details::Firmware,

    /// Output only. The total size of the disks being migrated in bytes.
    pub committed_storage_bytes: i64,

    /// Output only. The disks attached to the source VM.
    pub disks: std::vec::Vec<crate::model::aws_source_vm_details::AwsDiskDetails>,

    /// Output only. Information about VM capabilities needed for some Compute
    /// Engine features.
    pub vm_capabilities_info: std::option::Option<crate::model::VmCapabilities>,

    /// Output only. The VM architecture.
    pub architecture: crate::model::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firmware][crate::model::AwsSourceVmDetails::firmware].
    pub fn set_firmware<T: std::convert::Into<crate::model::aws_source_vm_details::Firmware>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware = v.into();
        self
    }

    /// Sets the value of [committed_storage_bytes][crate::model::AwsSourceVmDetails::committed_storage_bytes].
    pub fn set_committed_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_bytes = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::AwsSourceVmDetails::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::aws_source_vm_details::AwsDiskDetails>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vm_capabilities_info][crate::model::AwsSourceVmDetails::vm_capabilities_info].
    pub fn set_vm_capabilities_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_capabilities_info][crate::model::AwsSourceVmDetails::vm_capabilities_info].
    pub fn set_or_clear_vm_capabilities_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [architecture][crate::model::AwsSourceVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for AwsSourceVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSourceVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firmware,
            __committed_storage_bytes,
            __disks,
            __vm_capabilities_info,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSourceVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firmware" => Ok(__FieldTag::__firmware),
                            "committedStorageBytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "committed_storage_bytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "disks" => Ok(__FieldTag::__disks),
                            "vmCapabilitiesInfo" => Ok(__FieldTag::__vm_capabilities_info),
                            "vm_capabilities_info" => Ok(__FieldTag::__vm_capabilities_info),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSourceVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSourceVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firmware => {
                            if !fields.insert(__FieldTag::__firmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware",
                                ));
                            }
                            result.firmware =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_source_vm_details::Firmware,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_bytes => {
                            if !fields.insert(__FieldTag::__committed_storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::aws_source_vm_details::AwsDiskDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_capabilities_info => {
                            if !fields.insert(__FieldTag::__vm_capabilities_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_capabilities_info",
                                ));
                            }
                            result.vm_capabilities_info = map
                                .next_value::<std::option::Option<crate::model::VmCapabilities>>(
                                )?;
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::VmArchitecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSourceVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.firmware) {
            state.serialize_entry("firmware", &self.firmware)?;
        }
        if !wkt::internal::is_default(&self.committed_storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "committedStorageBytes",
                &__With(&self.committed_storage_bytes),
            )?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.vm_capabilities_info.is_some() {
            state.serialize_entry("vmCapabilitiesInfo", &self.vm_capabilities_info)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSourceVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSourceVmDetails");
        debug_struct.field("firmware", &self.firmware);
        debug_struct.field("committed_storage_bytes", &self.committed_storage_bytes);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("vm_capabilities_info", &self.vm_capabilities_info);
        debug_struct.field("architecture", &self.architecture);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsSourceVmDetails].
pub mod aws_source_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// The details of an AWS instance disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AwsDiskDetails {
        /// Output only. The ordinal number of the disk.
        pub disk_number: i32,

        /// Output only. AWS volume ID.
        pub volume_id: std::string::String,

        /// Output only. Size in GB.
        pub size_gb: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AwsDiskDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_number][crate::model::aws_source_vm_details::AwsDiskDetails::disk_number].
        pub fn set_disk_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.disk_number = v.into();
            self
        }

        /// Sets the value of [volume_id][crate::model::aws_source_vm_details::AwsDiskDetails::volume_id].
        pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.volume_id = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::aws_source_vm_details::AwsDiskDetails::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for AwsDiskDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceVmDetails.AwsDiskDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AwsDiskDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disk_number,
                __volume_id,
                __size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AwsDiskDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "diskNumber" => Ok(__FieldTag::__disk_number),
                                "disk_number" => Ok(__FieldTag::__disk_number),
                                "volumeId" => Ok(__FieldTag::__volume_id),
                                "volume_id" => Ok(__FieldTag::__volume_id),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AwsDiskDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AwsDiskDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disk_number => {
                                if !fields.insert(__FieldTag::__disk_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.disk_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__volume_id => {
                                if !fields.insert(__FieldTag::__volume_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for volume_id",
                                    ));
                                }
                                result.volume_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AwsDiskDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.disk_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("diskNumber", &__With(&self.disk_number))?;
            }
            if !self.volume_id.is_empty() {
                state.serialize_entry("volumeId", &self.volume_id)?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AwsDiskDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AwsDiskDetails");
            debug_struct.field("disk_number", &self.disk_number);
            debug_struct.field("volume_id", &self.volume_id);
            debug_struct.field("size_gb", &self.size_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible values for AWS VM firmware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified,
        /// The firmware is EFI.
        Efi,
        /// The firmware is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Firmware::value] or
        /// [Firmware::name].
        UnknownValue(firmware::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Firmware {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Firmware {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Firmware {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Firmware {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Firmware {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Firmware {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Firmware {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Firmware>::new(
                ".google.cloud.vmmigration.v1.AwsSourceVmDetails.Firmware",
            ))
        }
    }
}

/// Represent the source Azure VM details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AzureSourceVmDetails {
    /// Output only. The firmware type of the source VM.
    pub firmware: crate::model::azure_source_vm_details::Firmware,

    /// Output only. The total size of the disks being migrated in bytes.
    pub committed_storage_bytes: i64,

    /// Output only. The disks attached to the source VM.
    pub disks: std::vec::Vec<crate::model::azure_source_vm_details::AzureDiskDetails>,

    /// Output only. Information about VM capabilities needed for some Compute
    /// Engine features.
    pub vm_capabilities_info: std::option::Option<crate::model::VmCapabilities>,

    /// Output only. The VM architecture.
    pub architecture: crate::model::VmArchitecture,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AzureSourceVmDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [firmware][crate::model::AzureSourceVmDetails::firmware].
    pub fn set_firmware<T: std::convert::Into<crate::model::azure_source_vm_details::Firmware>>(
        mut self,
        v: T,
    ) -> Self {
        self.firmware = v.into();
        self
    }

    /// Sets the value of [committed_storage_bytes][crate::model::AzureSourceVmDetails::committed_storage_bytes].
    pub fn set_committed_storage_bytes<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.committed_storage_bytes = v.into();
        self
    }

    /// Sets the value of [disks][crate::model::AzureSourceVmDetails::disks].
    pub fn set_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::azure_source_vm_details::AzureDiskDetails>,
    {
        use std::iter::Iterator;
        self.disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [vm_capabilities_info][crate::model::AzureSourceVmDetails::vm_capabilities_info].
    pub fn set_vm_capabilities_info<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [vm_capabilities_info][crate::model::AzureSourceVmDetails::vm_capabilities_info].
    pub fn set_or_clear_vm_capabilities_info<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::VmCapabilities>,
    {
        self.vm_capabilities_info = v.map(|x| x.into());
        self
    }

    /// Sets the value of [architecture][crate::model::AzureSourceVmDetails::architecture].
    pub fn set_architecture<T: std::convert::Into<crate::model::VmArchitecture>>(
        mut self,
        v: T,
    ) -> Self {
        self.architecture = v.into();
        self
    }
}

impl wkt::message::Message for AzureSourceVmDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AzureSourceVmDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AzureSourceVmDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __firmware,
            __committed_storage_bytes,
            __disks,
            __vm_capabilities_info,
            __architecture,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AzureSourceVmDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "firmware" => Ok(__FieldTag::__firmware),
                            "committedStorageBytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "committed_storage_bytes" => Ok(__FieldTag::__committed_storage_bytes),
                            "disks" => Ok(__FieldTag::__disks),
                            "vmCapabilitiesInfo" => Ok(__FieldTag::__vm_capabilities_info),
                            "vm_capabilities_info" => Ok(__FieldTag::__vm_capabilities_info),
                            "architecture" => Ok(__FieldTag::__architecture),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AzureSourceVmDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AzureSourceVmDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__firmware => {
                            if !fields.insert(__FieldTag::__firmware) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for firmware",
                                ));
                            }
                            result.firmware = map
                                .next_value::<std::option::Option<
                                    crate::model::azure_source_vm_details::Firmware,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__committed_storage_bytes => {
                            if !fields.insert(__FieldTag::__committed_storage_bytes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for committed_storage_bytes",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.committed_storage_bytes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disks => {
                            if !fields.insert(__FieldTag::__disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disks",
                                ));
                            }
                            result.disks = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::azure_source_vm_details::AzureDiskDetails,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_capabilities_info => {
                            if !fields.insert(__FieldTag::__vm_capabilities_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_capabilities_info",
                                ));
                            }
                            result.vm_capabilities_info = map
                                .next_value::<std::option::Option<crate::model::VmCapabilities>>(
                                )?;
                        }
                        __FieldTag::__architecture => {
                            if !fields.insert(__FieldTag::__architecture) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for architecture",
                                ));
                            }
                            result.architecture = map
                                .next_value::<std::option::Option<crate::model::VmArchitecture>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AzureSourceVmDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.firmware) {
            state.serialize_entry("firmware", &self.firmware)?;
        }
        if !wkt::internal::is_default(&self.committed_storage_bytes) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry(
                "committedStorageBytes",
                &__With(&self.committed_storage_bytes),
            )?;
        }
        if !self.disks.is_empty() {
            state.serialize_entry("disks", &self.disks)?;
        }
        if self.vm_capabilities_info.is_some() {
            state.serialize_entry("vmCapabilitiesInfo", &self.vm_capabilities_info)?;
        }
        if !wkt::internal::is_default(&self.architecture) {
            state.serialize_entry("architecture", &self.architecture)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AzureSourceVmDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AzureSourceVmDetails");
        debug_struct.field("firmware", &self.firmware);
        debug_struct.field("committed_storage_bytes", &self.committed_storage_bytes);
        debug_struct.field("disks", &self.disks);
        debug_struct.field("vm_capabilities_info", &self.vm_capabilities_info);
        debug_struct.field("architecture", &self.architecture);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AzureSourceVmDetails].
pub mod azure_source_vm_details {
    #[allow(unused_imports)]
    use super::*;

    /// The details of an Azure VM disk.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AzureDiskDetails {
        /// Output only. The ordinal number of the disk.
        pub disk_number: i32,

        /// Output only. Azure disk ID.
        pub disk_id: std::string::String,

        /// Output only. Size in GB.
        pub size_gb: i64,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AzureDiskDetails {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [disk_number][crate::model::azure_source_vm_details::AzureDiskDetails::disk_number].
        pub fn set_disk_number<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.disk_number = v.into();
            self
        }

        /// Sets the value of [disk_id][crate::model::azure_source_vm_details::AzureDiskDetails::disk_id].
        pub fn set_disk_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.disk_id = v.into();
            self
        }

        /// Sets the value of [size_gb][crate::model::azure_source_vm_details::AzureDiskDetails::size_gb].
        pub fn set_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.size_gb = v.into();
            self
        }
    }

    impl wkt::message::Message for AzureDiskDetails {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.vmmigration.v1.AzureSourceVmDetails.AzureDiskDetails"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AzureDiskDetails {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __disk_number,
                __disk_id,
                __size_gb,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AzureDiskDetails")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "diskNumber" => Ok(__FieldTag::__disk_number),
                                "disk_number" => Ok(__FieldTag::__disk_number),
                                "diskId" => Ok(__FieldTag::__disk_id),
                                "disk_id" => Ok(__FieldTag::__disk_id),
                                "sizeGb" => Ok(__FieldTag::__size_gb),
                                "size_gb" => Ok(__FieldTag::__size_gb),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AzureDiskDetails;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AzureDiskDetails")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__disk_number => {
                                if !fields.insert(__FieldTag::__disk_number) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_number",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.disk_number =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__disk_id => {
                                if !fields.insert(__FieldTag::__disk_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disk_id",
                                    ));
                                }
                                result.disk_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__size_gb => {
                                if !fields.insert(__FieldTag::__size_gb) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for size_gb",
                                    ));
                                }
                                struct __With(std::option::Option<i64>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AzureDiskDetails {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !wkt::internal::is_default(&self.disk_number) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("diskNumber", &__With(&self.disk_number))?;
            }
            if !self.disk_id.is_empty() {
                state.serialize_entry("diskId", &self.disk_id)?;
            }
            if !wkt::internal::is_default(&self.size_gb) {
                struct __With<'a>(&'a i64);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("sizeGb", &__With(&self.size_gb))?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AzureDiskDetails {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AzureDiskDetails");
            debug_struct.field("disk_number", &self.disk_number);
            debug_struct.field("disk_id", &self.disk_id);
            debug_struct.field("size_gb", &self.size_gb);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Possible values for Azure VM firmware.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Firmware {
        /// The firmware is unknown.
        Unspecified,
        /// The firmware is EFI.
        Efi,
        /// The firmware is BIOS.
        Bios,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Firmware::value] or
        /// [Firmware::name].
        UnknownValue(firmware::UnknownValue),
    }

    #[doc(hidden)]
    pub mod firmware {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Firmware {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Efi => std::option::Option::Some(1),
                Self::Bios => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("FIRMWARE_UNSPECIFIED"),
                Self::Efi => std::option::Option::Some("EFI"),
                Self::Bios => std::option::Option::Some("BIOS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Firmware {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Firmware {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Firmware {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Efi,
                2 => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Firmware {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "FIRMWARE_UNSPECIFIED" => Self::Unspecified,
                "EFI" => Self::Efi,
                "BIOS" => Self::Bios,
                _ => Self::UnknownValue(firmware::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Firmware {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Efi => serializer.serialize_i32(1),
                Self::Bios => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Firmware {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Firmware>::new(
                ".google.cloud.vmmigration.v1.AzureSourceVmDetails.Firmware",
            ))
        }
    }
}

/// Request message for 'LisReplicationCyclesRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationCyclesRequest {
    /// Required. The parent, which owns this collection of ReplicationCycles.
    pub parent: std::string::String,

    /// Optional. The maximum number of replication cycles to return. The service
    /// may return fewer than this value. If unspecified, at most 100 migrating VMs
    /// will be returned. The maximum value is 100; values above 100 will be
    /// coerced to 100.
    pub page_size: i32,

    /// Required. A page token, received from a previous `ListReplicationCycles`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReplicationCycles`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request.
    pub filter: std::string::String,

    /// Optional. the order by fields for the result.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReplicationCyclesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReplicationCyclesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReplicationCyclesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListReplicationCyclesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListReplicationCyclesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationCyclesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationCyclesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationCyclesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationCyclesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationCyclesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationCyclesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationCyclesRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListReplicationCycles' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReplicationCyclesResponse {
    /// Output only. The list of replication cycles response.
    pub replication_cycles: std::vec::Vec<crate::model::ReplicationCycle>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReplicationCyclesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [replication_cycles][crate::model::ListReplicationCyclesResponse::replication_cycles].
    pub fn set_replication_cycles<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReplicationCycle>,
    {
        use std::iter::Iterator;
        self.replication_cycles = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReplicationCyclesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReplicationCyclesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReplicationCyclesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListReplicationCyclesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReplicationCyclesResponse {
    type PageItem = crate::model::ReplicationCycle;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.replication_cycles
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReplicationCyclesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __replication_cycles,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReplicationCyclesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "replicationCycles" => Ok(__FieldTag::__replication_cycles),
                            "replication_cycles" => Ok(__FieldTag::__replication_cycles),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReplicationCyclesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReplicationCyclesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__replication_cycles => {
                            if !fields.insert(__FieldTag::__replication_cycles) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replication_cycles",
                                ));
                            }
                            result.replication_cycles =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ReplicationCycle>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReplicationCyclesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.replication_cycles.is_empty() {
            state.serialize_entry("replicationCycles", &self.replication_cycles)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListReplicationCyclesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListReplicationCyclesResponse");
        debug_struct.field("replication_cycles", &self.replication_cycles);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetReplicationCycle' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReplicationCycleRequest {
    /// Required. The name of the ReplicationCycle.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReplicationCycleRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReplicationCycleRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReplicationCycleRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetReplicationCycleRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReplicationCycleRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReplicationCycleRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReplicationCycleRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReplicationCycleRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReplicationCycleRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetReplicationCycleRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetReplicationCycleRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Migrating VM source information about the VM capabilities needed for some
/// Compute Engine features.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct VmCapabilities {
    /// Output only. Unordered list. List of certain VM OS capabilities needed for
    /// some Compute Engine features.
    pub os_capabilities: std::vec::Vec<crate::model::OsCapability>,

    /// Output only. The last time OS capabilities list was updated.
    pub last_os_capabilities_update_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmCapabilities {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [os_capabilities][crate::model::VmCapabilities::os_capabilities].
    pub fn set_os_capabilities<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::OsCapability>,
    {
        use std::iter::Iterator;
        self.os_capabilities = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [last_os_capabilities_update_time][crate::model::VmCapabilities::last_os_capabilities_update_time].
    pub fn set_last_os_capabilities_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_os_capabilities_update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_os_capabilities_update_time][crate::model::VmCapabilities::last_os_capabilities_update_time].
    pub fn set_or_clear_last_os_capabilities_update_time<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_os_capabilities_update_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for VmCapabilities {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.VmCapabilities"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmCapabilities {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_capabilities,
            __last_os_capabilities_update_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmCapabilities")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osCapabilities" => Ok(__FieldTag::__os_capabilities),
                            "os_capabilities" => Ok(__FieldTag::__os_capabilities),
                            "lastOsCapabilitiesUpdateTime" => {
                                Ok(__FieldTag::__last_os_capabilities_update_time)
                            }
                            "last_os_capabilities_update_time" => {
                                Ok(__FieldTag::__last_os_capabilities_update_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmCapabilities;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmCapabilities")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_capabilities => {
                            if !fields.insert(__FieldTag::__os_capabilities) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_capabilities",
                                ));
                            }
                            result.os_capabilities = map.next_value::<std::option::Option<std::vec::Vec<crate::model::OsCapability>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__last_os_capabilities_update_time => {
                            if !fields.insert(__FieldTag::__last_os_capabilities_update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_os_capabilities_update_time",
                                ));
                            }
                            result.last_os_capabilities_update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmCapabilities {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.os_capabilities.is_empty() {
            state.serialize_entry("osCapabilities", &self.os_capabilities)?;
        }
        if self.last_os_capabilities_update_time.is_some() {
            state.serialize_entry(
                "lastOsCapabilitiesUpdateTime",
                &self.last_os_capabilities_update_time,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for VmCapabilities {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("VmCapabilities");
        debug_struct.field("os_capabilities", &self.os_capabilities);
        debug_struct.field(
            "last_os_capabilities_update_time",
            &self.last_os_capabilities_update_time,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ImageImport describes the configuration of the image import to run.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageImport {
    /// Output only. The resource path of the ImageImport.
    pub name: std::string::String,

    /// Output only. The time the image import was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The result of the most recent runs for this ImageImport. All
    /// jobs for this ImageImport can be listed via ListImageImportJobs.
    pub recent_image_import_jobs: std::vec::Vec<crate::model::ImageImportJob>,

    /// Immutable. The encryption details used by the image import process during
    /// the image adaptation for Compute Engine.
    pub encryption: std::option::Option<crate::model::Encryption>,

    pub source: std::option::Option<crate::model::image_import::Source>,

    /// The configuration of the resources that will be created in GCP as a result
    /// of the ImageImport.
    pub target_defaults: std::option::Option<crate::model::image_import::TargetDefaults>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageImport {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImageImport::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImageImport::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImageImport::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [recent_image_import_jobs][crate::model::ImageImport::recent_image_import_jobs].
    pub fn set_recent_image_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageImportJob>,
    {
        use std::iter::Iterator;
        self.recent_image_import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [encryption][crate::model::ImageImport::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::ImageImport::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::ImageImport::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::image_import::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImageImport::source]
    /// if it holds a `CloudStorageUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::image_import::Source::CloudStorageUri(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImageImport::source]
    /// to hold a `CloudStorageUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::image_import::Source::CloudStorageUri(v.into()),
        );
        self
    }

    /// Sets the value of [target_defaults][crate::model::ImageImport::target_defaults].
    ///
    /// Note that all the setters affecting `target_defaults` are mutually
    /// exclusive.
    pub fn set_target_defaults<
        T: std::convert::Into<std::option::Option<crate::model::image_import::TargetDefaults>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_defaults = v.into();
        self
    }

    /// The value of [target_defaults][crate::model::ImageImport::target_defaults]
    /// if it holds a `DiskImageTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disk_image_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiskImageTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_defaults.as_ref().and_then(|v| match v {
            crate::model::image_import::TargetDefaults::DiskImageTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_defaults][crate::model::ImageImport::target_defaults]
    /// to hold a `DiskImageTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_defaults` are
    /// mutually exclusive.
    pub fn set_disk_image_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::DiskImageTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_defaults = std::option::Option::Some(
            crate::model::image_import::TargetDefaults::DiskImageTargetDefaults(v.into()),
        );
        self
    }

    /// The value of [target_defaults][crate::model::ImageImport::target_defaults]
    /// if it holds a `MachineImageTargetDefaults`, `None` if the field is not set or
    /// holds a different branch.
    pub fn machine_image_target_defaults(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineImageTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_defaults.as_ref().and_then(|v| match v {
            crate::model::image_import::TargetDefaults::MachineImageTargetDefaults(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_defaults][crate::model::ImageImport::target_defaults]
    /// to hold a `MachineImageTargetDefaults`.
    ///
    /// Note that all the setters affecting `target_defaults` are
    /// mutually exclusive.
    pub fn set_machine_image_target_defaults<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineImageTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_defaults = std::option::Option::Some(
            crate::model::image_import::TargetDefaults::MachineImageTargetDefaults(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImageImport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ImageImport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageImport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_storage_uri,
            __disk_image_target_defaults,
            __machine_image_target_defaults,
            __name,
            __create_time,
            __recent_image_import_jobs,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageImport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudStorageUri" => Ok(__FieldTag::__cloud_storage_uri),
                            "cloud_storage_uri" => Ok(__FieldTag::__cloud_storage_uri),
                            "diskImageTargetDefaults" => {
                                Ok(__FieldTag::__disk_image_target_defaults)
                            }
                            "disk_image_target_defaults" => {
                                Ok(__FieldTag::__disk_image_target_defaults)
                            }
                            "machineImageTargetDefaults" => {
                                Ok(__FieldTag::__machine_image_target_defaults)
                            }
                            "machine_image_target_defaults" => {
                                Ok(__FieldTag::__machine_image_target_defaults)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "recentImageImportJobs" => Ok(__FieldTag::__recent_image_import_jobs),
                            "recent_image_import_jobs" => {
                                Ok(__FieldTag::__recent_image_import_jobs)
                            }
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageImport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageImport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_storage_uri => {
                            if !fields.insert(__FieldTag::__cloud_storage_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImport.cloud_storage_uri, latest field was cloudStorageUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::image_import::Source::CloudStorageUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__disk_image_target_defaults => {
                            if !fields.insert(__FieldTag::__disk_image_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_image_target_defaults",
                                ));
                            }
                            if result.target_defaults.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_defaults`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImport.disk_image_target_defaults, latest field was diskImageTargetDefaults",
                                ));
                            }
                            result.target_defaults = std::option::Option::Some(
                                crate::model::image_import::TargetDefaults::DiskImageTargetDefaults(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DiskImageTargetDetails>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__machine_image_target_defaults => {
                            if !fields.insert(__FieldTag::__machine_image_target_defaults) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_image_target_defaults",
                                ));
                            }
                            if result.target_defaults.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_defaults`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImport.machine_image_target_defaults, latest field was machineImageTargetDefaults",
                                ));
                            }
                            result.target_defaults = std::option::Option::Some(
                                crate::model::image_import::TargetDefaults::MachineImageTargetDefaults(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MachineImageTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__recent_image_import_jobs => {
                            if !fields.insert(__FieldTag::__recent_image_import_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_image_import_jobs",
                                ));
                            }
                            result.recent_image_import_jobs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ImageImportJob>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageImport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_storage_uri() {
            state.serialize_entry("cloudStorageUri", value)?;
        }
        if let Some(value) = self.disk_image_target_defaults() {
            state.serialize_entry("diskImageTargetDefaults", value)?;
        }
        if let Some(value) = self.machine_image_target_defaults() {
            state.serialize_entry("machineImageTargetDefaults", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.recent_image_import_jobs.is_empty() {
            state.serialize_entry("recentImageImportJobs", &self.recent_image_import_jobs)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageImport");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("recent_image_import_jobs", &self.recent_image_import_jobs);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("source", &self.source);
        debug_struct.field("target_defaults", &self.target_defaults);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImageImport].
pub mod image_import {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Immutable. The path to the Cloud Storage file from which the image should
        /// be imported.
        CloudStorageUri(std::string::String),
    }

    /// The configuration of the resources that will be created in GCP as a result
    /// of the ImageImport.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetDefaults {
        /// Immutable. Target details for importing a disk image, will be used by
        /// ImageImportJob.
        DiskImageTargetDefaults(std::boxed::Box<crate::model::DiskImageTargetDetails>),
        /// Immutable. Target details for importing a machine image, will be used by
        /// ImageImportJob.
        MachineImageTargetDefaults(std::boxed::Box<crate::model::MachineImageTargetDetails>),
    }
}

/// ImageImportJob describes the progress and result of an image import.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageImportJob {
    /// Output only. The resource path of the ImageImportJob.
    pub name: std::string::String,

    /// Output only. The resource paths of the resources created by the image
    /// import job.
    pub created_resources: std::vec::Vec<std::string::String>,

    /// Output only. The state of the image import.
    pub state: crate::model::image_import_job::State,

    /// Output only. The time the image import was created (as an API call, not
    /// when it was actually created in the target).
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the image import was ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Provides details on the error that led to the image import
    /// state in case of an error.
    pub errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. Warnings that occurred during the image import.
    pub warnings: std::vec::Vec<crate::model::MigrationWarning>,

    /// Output only. The image import steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::ImageImportStep>,

    pub source: std::option::Option<crate::model::image_import_job::Source>,

    /// The configuration of the resources that were created in GCP as a result of
    /// the image import.
    pub target_details: std::option::Option<crate::model::image_import_job::TargetDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageImportJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImageImportJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [created_resources][crate::model::ImageImportJob::created_resources].
    pub fn set_created_resources<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.created_resources = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [state][crate::model::ImageImportJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::image_import_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::ImageImportJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::ImageImportJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ImageImportJob::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ImageImportJob::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [errors][crate::model::ImageImportJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [warnings][crate::model::ImageImportJob::warnings].
    pub fn set_warnings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::MigrationWarning>,
    {
        use std::iter::Iterator;
        self.warnings = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::ImageImportJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageImportStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source][crate::model::ImageImportJob::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::image_import_job::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::ImageImportJob::source]
    /// if it holds a `CloudStorageUri`, `None` if the field is not set or
    /// holds a different branch.
    pub fn cloud_storage_uri(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::image_import_job::Source::CloudStorageUri(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::ImageImportJob::source]
    /// to hold a `CloudStorageUri`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_cloud_storage_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.source = std::option::Option::Some(
            crate::model::image_import_job::Source::CloudStorageUri(v.into()),
        );
        self
    }

    /// Sets the value of [target_details][crate::model::ImageImportJob::target_details].
    ///
    /// Note that all the setters affecting `target_details` are mutually
    /// exclusive.
    pub fn set_target_details<
        T: std::convert::Into<std::option::Option<crate::model::image_import_job::TargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_details = v.into();
        self
    }

    /// The value of [target_details][crate::model::ImageImportJob::target_details]
    /// if it holds a `DiskImageTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn disk_image_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DiskImageTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_details.as_ref().and_then(|v| match v {
            crate::model::image_import_job::TargetDetails::DiskImageTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_details][crate::model::ImageImportJob::target_details]
    /// to hold a `DiskImageTargetDetails`.
    ///
    /// Note that all the setters affecting `target_details` are
    /// mutually exclusive.
    pub fn set_disk_image_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::DiskImageTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_details = std::option::Option::Some(
            crate::model::image_import_job::TargetDetails::DiskImageTargetDetails(v.into()),
        );
        self
    }

    /// The value of [target_details][crate::model::ImageImportJob::target_details]
    /// if it holds a `MachineImageTargetDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn machine_image_target_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::MachineImageTargetDetails>> {
        #[allow(unreachable_patterns)]
        self.target_details.as_ref().and_then(|v| match v {
            crate::model::image_import_job::TargetDetails::MachineImageTargetDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_details][crate::model::ImageImportJob::target_details]
    /// to hold a `MachineImageTargetDetails`.
    ///
    /// Note that all the setters affecting `target_details` are
    /// mutually exclusive.
    pub fn set_machine_image_target_details<
        T: std::convert::Into<std::boxed::Box<crate::model::MachineImageTargetDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_details = std::option::Option::Some(
            crate::model::image_import_job::TargetDetails::MachineImageTargetDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImageImportJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ImageImportJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageImportJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __cloud_storage_uri,
            __disk_image_target_details,
            __machine_image_target_details,
            __name,
            __created_resources,
            __state,
            __create_time,
            __end_time,
            __errors,
            __warnings,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageImportJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "cloudStorageUri" => Ok(__FieldTag::__cloud_storage_uri),
                            "cloud_storage_uri" => Ok(__FieldTag::__cloud_storage_uri),
                            "diskImageTargetDetails" => Ok(__FieldTag::__disk_image_target_details),
                            "disk_image_target_details" => {
                                Ok(__FieldTag::__disk_image_target_details)
                            }
                            "machineImageTargetDetails" => {
                                Ok(__FieldTag::__machine_image_target_details)
                            }
                            "machine_image_target_details" => {
                                Ok(__FieldTag::__machine_image_target_details)
                            }
                            "name" => Ok(__FieldTag::__name),
                            "createdResources" => Ok(__FieldTag::__created_resources),
                            "created_resources" => Ok(__FieldTag::__created_resources),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "errors" => Ok(__FieldTag::__errors),
                            "warnings" => Ok(__FieldTag::__warnings),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageImportJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageImportJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__cloud_storage_uri => {
                            if !fields.insert(__FieldTag::__cloud_storage_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cloud_storage_uri",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportJob.cloud_storage_uri, latest field was cloudStorageUri",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::image_import_job::Source::CloudStorageUri(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__disk_image_target_details => {
                            if !fields.insert(__FieldTag::__disk_image_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_image_target_details",
                                ));
                            }
                            if result.target_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_details`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportJob.disk_image_target_details, latest field was diskImageTargetDetails",
                                ));
                            }
                            result.target_details = std::option::Option::Some(
                                crate::model::image_import_job::TargetDetails::DiskImageTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DiskImageTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__machine_image_target_details => {
                            if !fields.insert(__FieldTag::__machine_image_target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_image_target_details",
                                ));
                            }
                            if result.target_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_details`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportJob.machine_image_target_details, latest field was machineImageTargetDetails",
                                ));
                            }
                            result.target_details = std::option::Option::Some(
                                crate::model::image_import_job::TargetDetails::MachineImageTargetDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::MachineImageTargetDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__created_resources => {
                            if !fields.insert(__FieldTag::__created_resources) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for created_resources",
                                ));
                            }
                            result.created_resources = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::image_import_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__warnings => {
                            if !fields.insert(__FieldTag::__warnings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for warnings",
                                ));
                            }
                            result.warnings =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::MigrationWarning>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ImageImportStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageImportJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.cloud_storage_uri() {
            state.serialize_entry("cloudStorageUri", value)?;
        }
        if let Some(value) = self.disk_image_target_details() {
            state.serialize_entry("diskImageTargetDetails", value)?;
        }
        if let Some(value) = self.machine_image_target_details() {
            state.serialize_entry("machineImageTargetDetails", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.created_resources.is_empty() {
            state.serialize_entry("createdResources", &self.created_resources)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.warnings.is_empty() {
            state.serialize_entry("warnings", &self.warnings)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageImportJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageImportJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("created_resources", &self.created_resources);
        debug_struct.field("state", &self.state);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("warnings", &self.warnings);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("source", &self.source);
        debug_struct.field("target_details", &self.target_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImageImportJob].
pub mod image_import_job {
    #[allow(unused_imports)]
    use super::*;

    /// Possible states of the image import.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unknown.
        Unspecified,
        /// The image import has not yet started.
        Pending,
        /// The image import is active and running.
        Running,
        /// The image import has finished successfully.
        Succeeded,
        /// The image import has finished with errors.
        Failed,
        /// The image import is being cancelled.
        Cancelling,
        /// The image import was cancelled.
        Cancelled,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Pending => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(2),
                Self::Succeeded => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Pending,
                2 => Self::Running,
                3 => Self::Succeeded,
                4 => Self::Failed,
                5 => Self::Cancelling,
                6 => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Pending => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(2),
                Self::Succeeded => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.ImageImportJob.State",
            ))
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Output only. The path to the Cloud Storage file from which the image
        /// should be imported.
        CloudStorageUri(std::string::String),
    }

    /// The configuration of the resources that were created in GCP as a result of
    /// the image import.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetDetails {
        /// Output only. Target details used to import a disk image.
        DiskImageTargetDetails(std::boxed::Box<crate::model::DiskImageTargetDetails>),
        /// Output only. Target details used to import a machine image.
        MachineImageTargetDetails(std::boxed::Box<crate::model::MachineImageTargetDetails>),
    }
}

/// ImageImportStep holds information about the image import step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageImportStep {
    /// Output only. The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    pub step: std::option::Option<crate::model::image_import_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageImportStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::ImageImportStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::ImageImportStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::ImageImportStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::ImageImportStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::ImageImportStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<
        T: std::convert::Into<std::option::Option<crate::model::image_import_step::Step>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::ImageImportStep::step]
    /// if it holds a `Initializing`, `None` if the field is not set or
    /// holds a different branch.
    pub fn initializing(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::InitializingImageImportStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::image_import_step::Step::Initializing(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::ImageImportStep::step]
    /// to hold a `Initializing`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_initializing<
        T: std::convert::Into<std::boxed::Box<crate::model::InitializingImageImportStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(crate::model::image_import_step::Step::Initializing(
            v.into(),
        ));
        self
    }

    /// The value of [step][crate::model::ImageImportStep::step]
    /// if it holds a `LoadingSourceFiles`, `None` if the field is not set or
    /// holds a different branch.
    pub fn loading_source_files(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::LoadingImageSourceFilesStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::image_import_step::Step::LoadingSourceFiles(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::ImageImportStep::step]
    /// to hold a `LoadingSourceFiles`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_loading_source_files<
        T: std::convert::Into<std::boxed::Box<crate::model::LoadingImageSourceFilesStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::image_import_step::Step::LoadingSourceFiles(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::ImageImportStep::step]
    /// if it holds a `AdaptingOs`, `None` if the field is not set or
    /// holds a different branch.
    pub fn adapting_os(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AdaptingOSStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::image_import_step::Step::AdaptingOs(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::ImageImportStep::step]
    /// to hold a `AdaptingOs`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_adapting_os<T: std::convert::Into<std::boxed::Box<crate::model::AdaptingOSStep>>>(
        mut self,
        v: T,
    ) -> Self {
        self.step =
            std::option::Option::Some(crate::model::image_import_step::Step::AdaptingOs(v.into()));
        self
    }

    /// The value of [step][crate::model::ImageImportStep::step]
    /// if it holds a `CreatingImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn creating_image(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatingImageStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::image_import_step::Step::CreatingImage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::ImageImportStep::step]
    /// to hold a `CreatingImage`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_creating_image<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatingImageStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::image_import_step::Step::CreatingImage(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ImageImportStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ImageImportStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageImportStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __initializing,
            __loading_source_files,
            __adapting_os,
            __creating_image,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageImportStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "initializing" => Ok(__FieldTag::__initializing),
                            "loadingSourceFiles" => Ok(__FieldTag::__loading_source_files),
                            "loading_source_files" => Ok(__FieldTag::__loading_source_files),
                            "adaptingOs" => Ok(__FieldTag::__adapting_os),
                            "adapting_os" => Ok(__FieldTag::__adapting_os),
                            "creatingImage" => Ok(__FieldTag::__creating_image),
                            "creating_image" => Ok(__FieldTag::__creating_image),
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageImportStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageImportStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__initializing => {
                            if !fields.insert(__FieldTag::__initializing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for initializing",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportStep.initializing, latest field was initializing",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::image_import_step::Step::Initializing(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::InitializingImageImportStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__loading_source_files => {
                            if !fields.insert(__FieldTag::__loading_source_files) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for loading_source_files",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportStep.loading_source_files, latest field was loadingSourceFiles",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::image_import_step::Step::LoadingSourceFiles(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::LoadingImageSourceFilesStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__adapting_os => {
                            if !fields.insert(__FieldTag::__adapting_os) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for adapting_os",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportStep.adapting_os, latest field was adaptingOs",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::image_import_step::Step::AdaptingOs(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::AdaptingOSStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__creating_image => {
                            if !fields.insert(__FieldTag::__creating_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creating_image",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.ImageImportStep.creating_image, latest field was creatingImage",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::image_import_step::Step::CreatingImage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::CreatingImageStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageImportStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.initializing() {
            state.serialize_entry("initializing", value)?;
        }
        if let Some(value) = self.loading_source_files() {
            state.serialize_entry("loadingSourceFiles", value)?;
        }
        if let Some(value) = self.adapting_os() {
            state.serialize_entry("adaptingOs", value)?;
        }
        if let Some(value) = self.creating_image() {
            state.serialize_entry("creatingImage", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageImportStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageImportStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ImageImportStep].
pub mod image_import_step {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Initializing step.
        Initializing(std::boxed::Box<crate::model::InitializingImageImportStep>),
        /// Loading source files step.
        LoadingSourceFiles(std::boxed::Box<crate::model::LoadingImageSourceFilesStep>),
        /// Adapting OS step.
        AdaptingOs(std::boxed::Box<crate::model::AdaptingOSStep>),
        /// Creating image step.
        CreatingImage(std::boxed::Box<crate::model::CreatingImageStep>),
    }
}

/// InitializingImageImportStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct InitializingImageImportStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InitializingImageImportStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InitializingImageImportStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.InitializingImageImportStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InitializingImageImportStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InitializingImageImportStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InitializingImageImportStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InitializingImageImportStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InitializingImageImportStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for InitializingImageImportStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InitializingImageImportStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// LoadingImageSourceFilesStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct LoadingImageSourceFilesStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LoadingImageSourceFilesStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for LoadingImageSourceFilesStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.LoadingImageSourceFilesStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for LoadingImageSourceFilesStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for LoadingImageSourceFilesStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = LoadingImageSourceFilesStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct LoadingImageSourceFilesStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for LoadingImageSourceFilesStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for LoadingImageSourceFilesStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LoadingImageSourceFilesStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CreatingImageStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatingImageStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatingImageStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreatingImageStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreatingImageStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatingImageStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatingImageStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatingImageStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatingImageStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatingImageStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatingImageStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatingImageStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// The target details of the image resource that will be created by the import
/// job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskImageTargetDetails {
    /// Required. The name of the image to be created.
    pub image_name: std::string::String,

    /// Required. Reference to the TargetProject resource that represents the
    /// target project in which the imported image will be created.
    pub target_project: std::string::String,

    /// Optional. An optional description of the image.
    pub description: std::string::String,

    /// Optional. The name of the image family to which the new image belongs.
    pub family_name: std::string::String,

    /// Optional. A map of labels to associate with the image.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Additional licenses to assign to the image.
    /// Format:
    /// <https://www.googleapis.com/compute/v1/projects/PROJECT_ID/global/licenses/LICENSE_NAME>
    /// Or
    /// <https://www.googleapis.com/compute/beta/projects/PROJECT_ID/global/licenses/LICENSE_NAME>
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// Optional. Set to true to set the image storageLocations to the single
    /// region of the import job. When false, the closest multi-region is selected.
    pub single_region_storage: bool,

    /// Immutable. The encryption to apply to the image.
    pub encryption: std::option::Option<crate::model::Encryption>,

    pub os_adaptation_config:
        std::option::Option<crate::model::disk_image_target_details::OsAdaptationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskImageTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_name][crate::model::DiskImageTargetDetails::image_name].
    pub fn set_image_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_name = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::DiskImageTargetDetails::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [description][crate::model::DiskImageTargetDetails::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [family_name][crate::model::DiskImageTargetDetails::family_name].
    pub fn set_family_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.family_name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DiskImageTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [additional_licenses][crate::model::DiskImageTargetDetails::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [single_region_storage][crate::model::DiskImageTargetDetails::single_region_storage].
    pub fn set_single_region_storage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_region_storage = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::DiskImageTargetDetails::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::DiskImageTargetDetails::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [os_adaptation_config][crate::model::DiskImageTargetDetails::os_adaptation_config].
    ///
    /// Note that all the setters affecting `os_adaptation_config` are mutually
    /// exclusive.
    pub fn set_os_adaptation_config<
        T: std::convert::Into<
                std::option::Option<crate::model::disk_image_target_details::OsAdaptationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = v.into();
        self
    }

    /// The value of [os_adaptation_config][crate::model::DiskImageTargetDetails::os_adaptation_config]
    /// if it holds a `OsAdaptationParameters`, `None` if the field is not set or
    /// holds a different branch.
    pub fn os_adaptation_parameters(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>
    {
        #[allow(unreachable_patterns)]
        self.os_adaptation_config.as_ref().and_then(|v| match v {
            crate::model::disk_image_target_details::OsAdaptationConfig::OsAdaptationParameters(
                v,
            ) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [os_adaptation_config][crate::model::DiskImageTargetDetails::os_adaptation_config]
    /// to hold a `OsAdaptationParameters`.
    ///
    /// Note that all the setters affecting `os_adaptation_config` are
    /// mutually exclusive.
    pub fn set_os_adaptation_parameters<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = std::option::Option::Some(
            crate::model::disk_image_target_details::OsAdaptationConfig::OsAdaptationParameters(
                v.into(),
            ),
        );
        self
    }

    /// The value of [os_adaptation_config][crate::model::DiskImageTargetDetails::os_adaptation_config]
    /// if it holds a `DataDiskImageImport`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_disk_image_import(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DataDiskImageImport>> {
        #[allow(unreachable_patterns)]
        self.os_adaptation_config.as_ref().and_then(|v| match v {
            crate::model::disk_image_target_details::OsAdaptationConfig::DataDiskImageImport(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [os_adaptation_config][crate::model::DiskImageTargetDetails::os_adaptation_config]
    /// to hold a `DataDiskImageImport`.
    ///
    /// Note that all the setters affecting `os_adaptation_config` are
    /// mutually exclusive.
    pub fn set_data_disk_image_import<
        T: std::convert::Into<std::boxed::Box<crate::model::DataDiskImageImport>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = std::option::Option::Some(
            crate::model::disk_image_target_details::OsAdaptationConfig::DataDiskImageImport(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for DiskImageTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DiskImageTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskImageTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_adaptation_parameters,
            __data_disk_image_import,
            __image_name,
            __target_project,
            __description,
            __family_name,
            __labels,
            __additional_licenses,
            __single_region_storage,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskImageTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osAdaptationParameters" => Ok(__FieldTag::__os_adaptation_parameters),
                            "os_adaptation_parameters" => {
                                Ok(__FieldTag::__os_adaptation_parameters)
                            }
                            "dataDiskImageImport" => Ok(__FieldTag::__data_disk_image_import),
                            "data_disk_image_import" => Ok(__FieldTag::__data_disk_image_import),
                            "imageName" => Ok(__FieldTag::__image_name),
                            "image_name" => Ok(__FieldTag::__image_name),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "description" => Ok(__FieldTag::__description),
                            "familyName" => Ok(__FieldTag::__family_name),
                            "family_name" => Ok(__FieldTag::__family_name),
                            "labels" => Ok(__FieldTag::__labels),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "singleRegionStorage" => Ok(__FieldTag::__single_region_storage),
                            "single_region_storage" => Ok(__FieldTag::__single_region_storage),
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskImageTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskImageTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_adaptation_parameters => {
                            if !fields.insert(__FieldTag::__os_adaptation_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_adaptation_parameters",
                                ));
                            }
                            if result.os_adaptation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `os_adaptation_config`, a oneof with full ID .google.cloud.vmmigration.v1.DiskImageTargetDetails.os_adaptation_parameters, latest field was osAdaptationParameters",
                                ));
                            }
                            result.os_adaptation_config = std::option::Option::Some(
                                crate::model::disk_image_target_details::OsAdaptationConfig::OsAdaptationParameters(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_disk_image_import => {
                            if !fields.insert(__FieldTag::__data_disk_image_import) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disk_image_import",
                                ));
                            }
                            if result.os_adaptation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `os_adaptation_config`, a oneof with full ID .google.cloud.vmmigration.v1.DiskImageTargetDetails.data_disk_image_import, latest field was dataDiskImageImport",
                                ));
                            }
                            result.os_adaptation_config = std::option::Option::Some(
                                crate::model::disk_image_target_details::OsAdaptationConfig::DataDiskImageImport(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::DataDiskImageImport>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__image_name => {
                            if !fields.insert(__FieldTag::__image_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_name",
                                ));
                            }
                            result.image_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__family_name => {
                            if !fields.insert(__FieldTag::__family_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family_name",
                                ));
                            }
                            result.family_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__single_region_storage => {
                            if !fields.insert(__FieldTag::__single_region_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_region_storage",
                                ));
                            }
                            result.single_region_storage = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskImageTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.os_adaptation_parameters() {
            state.serialize_entry("osAdaptationParameters", value)?;
        }
        if let Some(value) = self.data_disk_image_import() {
            state.serialize_entry("dataDiskImageImport", value)?;
        }
        if !self.image_name.is_empty() {
            state.serialize_entry("imageName", &self.image_name)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.family_name.is_empty() {
            state.serialize_entry("familyName", &self.family_name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !wkt::internal::is_default(&self.single_region_storage) {
            state.serialize_entry("singleRegionStorage", &self.single_region_storage)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskImageTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskImageTargetDetails");
        debug_struct.field("image_name", &self.image_name);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("description", &self.description);
        debug_struct.field("family_name", &self.family_name);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("single_region_storage", &self.single_region_storage);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("os_adaptation_config", &self.os_adaptation_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiskImageTargetDetails].
pub mod disk_image_target_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OsAdaptationConfig {
        /// Optional. Use to set the parameters relevant for the OS adaptation
        /// process.
        OsAdaptationParameters(std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>),
        /// Optional. Use to skip OS adaptation process.
        DataDiskImageImport(std::boxed::Box<crate::model::DataDiskImageImport>),
    }
}

/// The target details of the machine image resource that will be created by the
/// image import job.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineImageTargetDetails {
    /// Required. The name of the machine image to be created.
    pub machine_image_name: std::string::String,

    /// Required. Reference to the TargetProject resource that represents the
    /// target project in which the imported machine image will be created.
    pub target_project: std::string::String,

    /// Optional. An optional description of the machine image.
    pub description: std::string::String,

    /// Optional. Set to true to set the machine image storageLocations to the
    /// single region of the import job. When false, the closest multi-region is
    /// selected.
    pub single_region_storage: bool,

    /// Immutable. The encryption to apply to the machine image.
    /// If the Image Import resource has an encryption, this field must be set to
    /// the same encryption key.
    pub encryption: std::option::Option<crate::model::Encryption>,

    /// Optional. Parameters overriding decisions based on the source machine image
    /// configurations.
    pub machine_image_parameters_overrides:
        std::option::Option<crate::model::MachineImageParametersOverrides>,

    /// Optional. The service account to assign to the instance created by the
    /// machine image.
    pub service_account: std::option::Option<crate::model::ServiceAccount>,

    /// Optional. Additional licenses to assign to the instance created by the
    /// machine image. Format:
    /// <https://www.googleapis.com/compute/v1/projects/PROJECT_ID/global/licenses/LICENSE_NAME>
    /// Or
    /// <https://www.googleapis.com/compute/beta/projects/PROJECT_ID/global/licenses/LICENSE_NAME>
    pub additional_licenses: std::vec::Vec<std::string::String>,

    /// Optional. The labels to apply to the instance created by the machine image.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The tags to apply to the instance created by the machine image.
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. Shielded instance configuration.
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Optional. The network interfaces to create with the instance created by the
    /// machine image. Internal and external IP addresses, and network tiers are
    /// ignored for machine image import.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    pub os_adaptation_config:
        std::option::Option<crate::model::machine_image_target_details::OsAdaptationConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineImageTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_image_name][crate::model::MachineImageTargetDetails::machine_image_name].
    pub fn set_machine_image_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.machine_image_name = v.into();
        self
    }

    /// Sets the value of [target_project][crate::model::MachineImageTargetDetails::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [description][crate::model::MachineImageTargetDetails::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [single_region_storage][crate::model::MachineImageTargetDetails::single_region_storage].
    pub fn set_single_region_storage<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.single_region_storage = v.into();
        self
    }

    /// Sets the value of [encryption][crate::model::MachineImageTargetDetails::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::MachineImageTargetDetails::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [machine_image_parameters_overrides][crate::model::MachineImageTargetDetails::machine_image_parameters_overrides].
    pub fn set_machine_image_parameters_overrides<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::MachineImageParametersOverrides>,
    {
        self.machine_image_parameters_overrides = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [machine_image_parameters_overrides][crate::model::MachineImageTargetDetails::machine_image_parameters_overrides].
    pub fn set_or_clear_machine_image_parameters_overrides<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::MachineImageParametersOverrides>,
    {
        self.machine_image_parameters_overrides = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_account][crate::model::MachineImageTargetDetails::service_account].
    pub fn set_service_account<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceAccount>,
    {
        self.service_account = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_account][crate::model::MachineImageTargetDetails::service_account].
    pub fn set_or_clear_service_account<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceAccount>,
    {
        self.service_account = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_licenses][crate::model::MachineImageTargetDetails::additional_licenses].
    pub fn set_additional_licenses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_licenses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::MachineImageTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [tags][crate::model::MachineImageTargetDetails::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::MachineImageTargetDetails::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::MachineImageTargetDetails::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::MachineImageTargetDetails::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [os_adaptation_config][crate::model::MachineImageTargetDetails::os_adaptation_config].
    ///
    /// Note that all the setters affecting `os_adaptation_config` are mutually
    /// exclusive.
    pub fn set_os_adaptation_config<
        T: std::convert::Into<
                std::option::Option<crate::model::machine_image_target_details::OsAdaptationConfig>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = v.into();
        self
    }

    /// The value of [os_adaptation_config][crate::model::MachineImageTargetDetails::os_adaptation_config]
    /// if it holds a `OsAdaptationParameters`, `None` if the field is not set or
    /// holds a different branch.
    pub fn os_adaptation_parameters(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>
    {
        #[allow(unreachable_patterns)]
        self.os_adaptation_config.as_ref().and_then(|v| match v {
            crate::model::machine_image_target_details::OsAdaptationConfig::OsAdaptationParameters(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [os_adaptation_config][crate::model::MachineImageTargetDetails::os_adaptation_config]
    /// to hold a `OsAdaptationParameters`.
    ///
    /// Note that all the setters affecting `os_adaptation_config` are
    /// mutually exclusive.
    pub fn set_os_adaptation_parameters<
        T: std::convert::Into<std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = std::option::Option::Some(
            crate::model::machine_image_target_details::OsAdaptationConfig::OsAdaptationParameters(
                v.into(),
            ),
        );
        self
    }

    /// The value of [os_adaptation_config][crate::model::MachineImageTargetDetails::os_adaptation_config]
    /// if it holds a `SkipOsAdaptation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn skip_os_adaptation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::SkipOsAdaptation>> {
        #[allow(unreachable_patterns)]
        self.os_adaptation_config.as_ref().and_then(|v| match v {
            crate::model::machine_image_target_details::OsAdaptationConfig::SkipOsAdaptation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [os_adaptation_config][crate::model::MachineImageTargetDetails::os_adaptation_config]
    /// to hold a `SkipOsAdaptation`.
    ///
    /// Note that all the setters affecting `os_adaptation_config` are
    /// mutually exclusive.
    pub fn set_skip_os_adaptation<
        T: std::convert::Into<std::boxed::Box<crate::model::SkipOsAdaptation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.os_adaptation_config = std::option::Option::Some(
            crate::model::machine_image_target_details::OsAdaptationConfig::SkipOsAdaptation(
                v.into(),
            ),
        );
        self
    }
}

impl wkt::message::Message for MachineImageTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MachineImageTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineImageTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __os_adaptation_parameters,
            __skip_os_adaptation,
            __machine_image_name,
            __target_project,
            __description,
            __single_region_storage,
            __encryption,
            __machine_image_parameters_overrides,
            __service_account,
            __additional_licenses,
            __labels,
            __tags,
            __shielded_instance_config,
            __network_interfaces,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineImageTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "osAdaptationParameters" => Ok(__FieldTag::__os_adaptation_parameters),
                            "os_adaptation_parameters" => {
                                Ok(__FieldTag::__os_adaptation_parameters)
                            }
                            "skipOsAdaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            "skip_os_adaptation" => Ok(__FieldTag::__skip_os_adaptation),
                            "machineImageName" => Ok(__FieldTag::__machine_image_name),
                            "machine_image_name" => Ok(__FieldTag::__machine_image_name),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "description" => Ok(__FieldTag::__description),
                            "singleRegionStorage" => Ok(__FieldTag::__single_region_storage),
                            "single_region_storage" => Ok(__FieldTag::__single_region_storage),
                            "encryption" => Ok(__FieldTag::__encryption),
                            "machineImageParametersOverrides" => {
                                Ok(__FieldTag::__machine_image_parameters_overrides)
                            }
                            "machine_image_parameters_overrides" => {
                                Ok(__FieldTag::__machine_image_parameters_overrides)
                            }
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "additionalLicenses" => Ok(__FieldTag::__additional_licenses),
                            "additional_licenses" => Ok(__FieldTag::__additional_licenses),
                            "labels" => Ok(__FieldTag::__labels),
                            "tags" => Ok(__FieldTag::__tags),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineImageTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineImageTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__os_adaptation_parameters => {
                            if !fields.insert(__FieldTag::__os_adaptation_parameters) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for os_adaptation_parameters",
                                ));
                            }
                            if result.os_adaptation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `os_adaptation_config`, a oneof with full ID .google.cloud.vmmigration.v1.MachineImageTargetDetails.os_adaptation_parameters, latest field was osAdaptationParameters",
                                ));
                            }
                            result.os_adaptation_config = std::option::Option::Some(
                                crate::model::machine_image_target_details::OsAdaptationConfig::OsAdaptationParameters(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__skip_os_adaptation => {
                            if !fields.insert(__FieldTag::__skip_os_adaptation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for skip_os_adaptation",
                                ));
                            }
                            if result.os_adaptation_config.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `os_adaptation_config`, a oneof with full ID .google.cloud.vmmigration.v1.MachineImageTargetDetails.skip_os_adaptation, latest field was skipOsAdaptation",
                                ));
                            }
                            result.os_adaptation_config = std::option::Option::Some(
                                crate::model::machine_image_target_details::OsAdaptationConfig::SkipOsAdaptation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::SkipOsAdaptation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__machine_image_name => {
                            if !fields.insert(__FieldTag::__machine_image_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_image_name",
                                ));
                            }
                            result.machine_image_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__single_region_storage => {
                            if !fields.insert(__FieldTag::__single_region_storage) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for single_region_storage",
                                ));
                            }
                            result.single_region_storage = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::__machine_image_parameters_overrides => {
                            if !fields.insert(__FieldTag::__machine_image_parameters_overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_image_parameters_overrides",
                                ));
                            }
                            result.machine_image_parameters_overrides = map
                                .next_value::<std::option::Option<
                                    crate::model::MachineImageParametersOverrides,
                                >>()?;
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<crate::model::ServiceAccount>>(
                                )?;
                        }
                        __FieldTag::__additional_licenses => {
                            if !fields.insert(__FieldTag::__additional_licenses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_licenses",
                                ));
                            }
                            result.additional_licenses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineImageTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.os_adaptation_parameters() {
            state.serialize_entry("osAdaptationParameters", value)?;
        }
        if let Some(value) = self.skip_os_adaptation() {
            state.serialize_entry("skipOsAdaptation", value)?;
        }
        if !self.machine_image_name.is_empty() {
            state.serialize_entry("machineImageName", &self.machine_image_name)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !wkt::internal::is_default(&self.single_region_storage) {
            state.serialize_entry("singleRegionStorage", &self.single_region_storage)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if self.machine_image_parameters_overrides.is_some() {
            state.serialize_entry(
                "machineImageParametersOverrides",
                &self.machine_image_parameters_overrides,
            )?;
        }
        if self.service_account.is_some() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.additional_licenses.is_empty() {
            state.serialize_entry("additionalLicenses", &self.additional_licenses)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineImageTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineImageTargetDetails");
        debug_struct.field("machine_image_name", &self.machine_image_name);
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("description", &self.description);
        debug_struct.field("single_region_storage", &self.single_region_storage);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field(
            "machine_image_parameters_overrides",
            &self.machine_image_parameters_overrides,
        );
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("additional_licenses", &self.additional_licenses);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("tags", &self.tags);
        debug_struct.field("shielded_instance_config", &self.shielded_instance_config);
        debug_struct.field("network_interfaces", &self.network_interfaces);
        debug_struct.field("os_adaptation_config", &self.os_adaptation_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [MachineImageTargetDetails].
pub mod machine_image_target_details {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum OsAdaptationConfig {
        /// Optional. Use to set the parameters relevant for the OS adaptation
        /// process.
        OsAdaptationParameters(std::boxed::Box<crate::model::ImageImportOsAdaptationParameters>),
        /// Optional. Use to skip OS adaptation process.
        SkipOsAdaptation(std::boxed::Box<crate::model::SkipOsAdaptation>),
    }
}

/// Service account to assign to the instance created by the machine image.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Required. The email address of the service account.
    pub email: std::string::String,

    /// Optional. The list of scopes to be made available for this service account.
    pub scopes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ServiceAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            __scopes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            "scopes" => Ok(__FieldTag::__scopes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ServiceAccount {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceAccount");
        debug_struct.field("email", &self.email);
        debug_struct.field("scopes", &self.scopes);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Shielded instance configuration.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Optional. Defines whether the instance created by the machine image has
    /// Secure Boot enabled. This can be set to true only if the image boot option
    /// is EFI.
    pub secure_boot: crate::model::shielded_instance_config::SecureBoot,

    /// Optional. Defines whether the instance created by the machine image has
    /// vTPM enabled. This can be set to true only if the image boot option is EFI.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the instance created by the machine image has
    /// integrity monitoring enabled. This can be set to true only if the image
    /// boot option is EFI, and vTPM is enabled.
    pub enable_integrity_monitoring: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [secure_boot][crate::model::ShieldedInstanceConfig::secure_boot].
    pub fn set_secure_boot<
        T: std::convert::Into<crate::model::shielded_instance_config::SecureBoot>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ShieldedInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShieldedInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "secureBoot" => Ok(__FieldTag::__secure_boot),
                            "secure_boot" => Ok(__FieldTag::__secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShieldedInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__secure_boot => {
                            if !fields.insert(__FieldTag::__secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for secure_boot",
                                ));
                            }
                            result.secure_boot = map
                                .next_value::<std::option::Option<
                                    crate::model::shielded_instance_config::SecureBoot,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.secure_boot) {
            state.serialize_entry("secureBoot", &self.secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_vtpm) {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ShieldedInstanceConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ShieldedInstanceConfig");
        debug_struct.field("secure_boot", &self.secure_boot);
        debug_struct.field("enable_vtpm", &self.enable_vtpm);
        debug_struct.field(
            "enable_integrity_monitoring",
            &self.enable_integrity_monitoring,
        );
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ShieldedInstanceConfig].
pub mod shielded_instance_config {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for secure boot.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SecureBoot {
        /// No explicit value is selected. Will use the configuration of the source
        /// (if exists, otherwise the default will be false).
        Unspecified,
        /// Use secure boot. This can be set to true only if the image boot option is
        /// EFI.
        True,
        /// Do not use secure boot.
        False,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [SecureBoot::value] or
        /// [SecureBoot::name].
        UnknownValue(secure_boot::UnknownValue),
    }

    #[doc(hidden)]
    pub mod secure_boot {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl SecureBoot {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::True => std::option::Option::Some(1),
                Self::False => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("SECURE_BOOT_UNSPECIFIED"),
                Self::True => std::option::Option::Some("TRUE"),
                Self::False => std::option::Option::Some("FALSE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for SecureBoot {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for SecureBoot {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for SecureBoot {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::True,
                2 => Self::False,
                _ => Self::UnknownValue(secure_boot::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for SecureBoot {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "SECURE_BOOT_UNSPECIFIED" => Self::Unspecified,
                "TRUE" => Self::True,
                "FALSE" => Self::False,
                _ => Self::UnknownValue(secure_boot::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for SecureBoot {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::True => serializer.serialize_i32(1),
                Self::False => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for SecureBoot {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<SecureBoot>::new(
                ".google.cloud.vmmigration.v1.ShieldedInstanceConfig.SecureBoot",
            ))
        }
    }
}

/// Parameters overriding decisions based on the source machine image
/// configurations.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct MachineImageParametersOverrides {
    /// Optional. The machine type to create the MachineImage with.
    /// If empty, the service will choose a relevant machine type based on the
    /// information from the source image.
    /// For more information about machine types, please refer to
    /// <https://cloud.google.com/compute/docs/machine-resource>.
    pub machine_type: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MachineImageParametersOverrides {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::MachineImageParametersOverrides::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }
}

impl wkt::message::Message for MachineImageParametersOverrides {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.MachineImageParametersOverrides"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MachineImageParametersOverrides {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MachineImageParametersOverrides")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MachineImageParametersOverrides;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MachineImageParametersOverrides")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MachineImageParametersOverrides {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for MachineImageParametersOverrides {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("MachineImageParametersOverrides");
        debug_struct.field("machine_type", &self.machine_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Parameters affecting the OS adaptation process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ImageImportOsAdaptationParameters {
    /// Optional. Set to true in order to generalize the imported image.
    /// The generalization process enables co-existence of multiple VMs created
    /// from the same image.
    /// For Windows, generalizing the image removes computer-specific information
    /// such as installed drivers and the computer security identifier (SID).
    pub generalize: bool,

    /// Optional. Choose which type of license to apply to the imported image.
    pub license_type: crate::model::ComputeEngineLicenseType,

    /// Optional. By default the image will keep its existing boot option. Setting
    /// this property will trigger an internal process which will convert the
    /// image from using the existing boot option to another.
    /// The size of the boot disk might be increased to allow the conversion
    pub boot_conversion: crate::model::BootConversion,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ImageImportOsAdaptationParameters {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [generalize][crate::model::ImageImportOsAdaptationParameters::generalize].
    pub fn set_generalize<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.generalize = v.into();
        self
    }

    /// Sets the value of [license_type][crate::model::ImageImportOsAdaptationParameters::license_type].
    pub fn set_license_type<T: std::convert::Into<crate::model::ComputeEngineLicenseType>>(
        mut self,
        v: T,
    ) -> Self {
        self.license_type = v.into();
        self
    }

    /// Sets the value of [boot_conversion][crate::model::ImageImportOsAdaptationParameters::boot_conversion].
    pub fn set_boot_conversion<T: std::convert::Into<crate::model::BootConversion>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_conversion = v.into();
        self
    }
}

impl wkt::message::Message for ImageImportOsAdaptationParameters {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ImageImportOsAdaptationParameters"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ImageImportOsAdaptationParameters {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __generalize,
            __license_type,
            __boot_conversion,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ImageImportOsAdaptationParameters")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "generalize" => Ok(__FieldTag::__generalize),
                            "licenseType" => Ok(__FieldTag::__license_type),
                            "license_type" => Ok(__FieldTag::__license_type),
                            "bootConversion" => Ok(__FieldTag::__boot_conversion),
                            "boot_conversion" => Ok(__FieldTag::__boot_conversion),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ImageImportOsAdaptationParameters;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ImageImportOsAdaptationParameters")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__generalize => {
                            if !fields.insert(__FieldTag::__generalize) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for generalize",
                                ));
                            }
                            result.generalize = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__license_type => {
                            if !fields.insert(__FieldTag::__license_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for license_type",
                                ));
                            }
                            result.license_type = map.next_value::<std::option::Option<crate::model::ComputeEngineLicenseType>>()?.unwrap_or_default();
                        }
                        __FieldTag::__boot_conversion => {
                            if !fields.insert(__FieldTag::__boot_conversion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_conversion",
                                ));
                            }
                            result.boot_conversion = map
                                .next_value::<std::option::Option<crate::model::BootConversion>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ImageImportOsAdaptationParameters {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.generalize) {
            state.serialize_entry("generalize", &self.generalize)?;
        }
        if !wkt::internal::is_default(&self.license_type) {
            state.serialize_entry("licenseType", &self.license_type)?;
        }
        if !wkt::internal::is_default(&self.boot_conversion) {
            state.serialize_entry("bootConversion", &self.boot_conversion)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ImageImportOsAdaptationParameters {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ImageImportOsAdaptationParameters");
        debug_struct.field("generalize", &self.generalize);
        debug_struct.field("license_type", &self.license_type);
        debug_struct.field("boot_conversion", &self.boot_conversion);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Mentions that the image import is not using OS adaptation process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DataDiskImageImport {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDiskImageImport {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for DataDiskImageImport {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DataDiskImageImport"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataDiskImageImport {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataDiskImageImport")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataDiskImageImport;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataDiskImageImport")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataDiskImageImport {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DataDiskImageImport {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DataDiskImageImport");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Mentions that the machine image import is not using OS adaptation process.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SkipOsAdaptation {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SkipOsAdaptation {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for SkipOsAdaptation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.SkipOsAdaptation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SkipOsAdaptation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SkipOsAdaptation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SkipOsAdaptation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SkipOsAdaptation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SkipOsAdaptation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SkipOsAdaptation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SkipOsAdaptation");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetImageImport' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetImageImportRequest {
    /// Required. The ImageImport name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetImageImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImageImportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImageImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetImageImportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetImageImportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetImageImportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetImageImportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetImageImportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetImageImportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetImageImportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetImageImportRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListImageImports' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageImportsRequest {
    /// Required. The parent, which owns this collection of targets.
    pub parent: std::string::String,

    /// Optional. The maximum number of targets to return. The service may return
    /// fewer than this value. If unspecified, at most 500 targets will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListImageImports` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListImageImports` must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request (according to <a
    /// href="https://google.aip.dev/160" target="_blank">AIP-160</a>).
    pub filter: std::string::String,

    /// Optional. The order by fields for the result (according to <a
    /// href="https://google.aip.dev/132#ordering" target="_blank">AIP-132</a>).
    /// Currently ordering is only possible by "name" field.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageImportsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImageImportsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImageImportsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImageImportsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImageImportsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImageImportsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImageImportsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListImageImportsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageImportsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageImportsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageImportsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageImportsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageImportsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageImportsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageImportsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListImageImports' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageImportsResponse {
    /// Output only. The list of target response.
    pub image_imports: std::vec::Vec<crate::model::ImageImport>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageImportsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_imports][crate::model::ListImageImportsResponse::image_imports].
    pub fn set_image_imports<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageImport>,
    {
        use std::iter::Iterator;
        self.image_imports = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImageImportsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImageImportsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImageImportsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListImageImportsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImageImportsResponse {
    type PageItem = crate::model::ImageImport;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.image_imports
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageImportsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_imports,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageImportsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageImports" => Ok(__FieldTag::__image_imports),
                            "image_imports" => Ok(__FieldTag::__image_imports),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageImportsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageImportsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_imports => {
                            if !fields.insert(__FieldTag::__image_imports) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_imports",
                                ));
                            }
                            result.image_imports = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ImageImport>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageImportsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_imports.is_empty() {
            state.serialize_entry("imageImports", &self.image_imports)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageImportsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageImportsResponse");
        debug_struct.field("image_imports", &self.image_imports);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CreateImageImport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateImageImportRequest {
    /// Required. The ImageImport's parent.
    pub parent: std::string::String,

    /// Required. The image import identifier.
    /// This value maximum length is 63 characters, and valid characters are
    /// /[a-z][0-9]-/. It must start with an english letter and must not end with a
    /// hyphen.
    pub image_import_id: std::string::String,

    /// Required. The create request body.
    pub image_import: std::option::Option<crate::model::ImageImport>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateImageImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateImageImportRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [image_import_id][crate::model::CreateImageImportRequest::image_import_id].
    pub fn set_image_import_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image_import_id = v.into();
        self
    }

    /// Sets the value of [image_import][crate::model::CreateImageImportRequest::image_import].
    pub fn set_image_import<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ImageImport>,
    {
        self.image_import = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [image_import][crate::model::CreateImageImportRequest::image_import].
    pub fn set_or_clear_image_import<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ImageImport>,
    {
        self.image_import = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateImageImportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateImageImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateImageImportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateImageImportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __image_import_id,
            __image_import,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateImageImportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "imageImportId" => Ok(__FieldTag::__image_import_id),
                            "image_import_id" => Ok(__FieldTag::__image_import_id),
                            "imageImport" => Ok(__FieldTag::__image_import),
                            "image_import" => Ok(__FieldTag::__image_import),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateImageImportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateImageImportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_import_id => {
                            if !fields.insert(__FieldTag::__image_import_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_import_id",
                                ));
                            }
                            result.image_import_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__image_import => {
                            if !fields.insert(__FieldTag::__image_import) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_import",
                                ));
                            }
                            result.image_import =
                                map.next_value::<std::option::Option<crate::model::ImageImport>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateImageImportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.image_import_id.is_empty() {
            state.serialize_entry("imageImportId", &self.image_import_id)?;
        }
        if self.image_import.is_some() {
            state.serialize_entry("imageImport", &self.image_import)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateImageImportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateImageImportRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("image_import_id", &self.image_import_id);
        debug_struct.field("image_import", &self.image_import);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteImageImport' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteImageImportRequest {
    /// Required. The ImageImport name.
    pub name: std::string::String,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and t
    /// he request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteImageImportRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteImageImportRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteImageImportRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteImageImportRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteImageImportRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteImageImportRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteImageImportRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteImageImportRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteImageImportRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteImageImportRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteImageImportRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteImageImportRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetImageImportJob' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetImageImportJobRequest {
    /// Required. The ImageImportJob name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetImageImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetImageImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetImageImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetImageImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetImageImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetImageImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetImageImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetImageImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetImageImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetImageImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetImageImportJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListImageImportJobs' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageImportJobsRequest {
    /// Required. The parent, which owns this collection of targets.
    pub parent: std::string::String,

    /// Optional. The maximum number of targets to return. The service may return
    /// fewer than this value. If unspecified, at most 500 targets will be
    /// returned. The maximum value is 1000; values above 1000 will be coerced to
    /// 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListImageImportJobs`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListImageImportJobs`
    /// must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request (according to <a
    /// href="https://google.aip.dev/160" target="_blank">AIP-160</a>).
    pub filter: std::string::String,

    /// Optional. The order by fields for the result (according to <a
    /// href="https://google.aip.dev/132#ordering" target="_blank">AIP-132</a>).
    /// Currently ordering is only possible by "name" field.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageImportJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListImageImportJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListImageImportJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListImageImportJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListImageImportJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListImageImportJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListImageImportJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListImageImportJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageImportJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageImportJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageImportJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageImportJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageImportJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageImportJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageImportJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListImageImportJobs' call.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListImageImportJobsResponse {
    /// Output only. The list of target response.
    pub image_import_jobs: std::vec::Vec<crate::model::ImageImportJob>,

    /// Output only. A token, which can be sent as `page_token` to retrieve the
    /// next page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListImageImportJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [image_import_jobs][crate::model::ListImageImportJobsResponse::image_import_jobs].
    pub fn set_image_import_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ImageImportJob>,
    {
        use std::iter::Iterator;
        self.image_import_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListImageImportJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListImageImportJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListImageImportJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListImageImportJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListImageImportJobsResponse {
    type PageItem = crate::model::ImageImportJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.image_import_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListImageImportJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __image_import_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListImageImportJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "imageImportJobs" => Ok(__FieldTag::__image_import_jobs),
                            "image_import_jobs" => Ok(__FieldTag::__image_import_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListImageImportJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListImageImportJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__image_import_jobs => {
                            if !fields.insert(__FieldTag::__image_import_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for image_import_jobs",
                                ));
                            }
                            result.image_import_jobs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ImageImportJob>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListImageImportJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.image_import_jobs.is_empty() {
            state.serialize_entry("imageImportJobs", &self.image_import_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListImageImportJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListImageImportJobsResponse");
        debug_struct.field("image_import_jobs", &self.image_import_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelImageImportJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelImageImportJobRequest {
    /// Required. The image import job id.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelImageImportJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelImageImportJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelImageImportJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelImageImportJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelImageImportJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelImageImportJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelImageImportJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelImageImportJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelImageImportJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelImageImportJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelImageImportJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelImageImportJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelImageImportJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelImageImportJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelImageImportJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelImageImportJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelImageImportJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelImageImportJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelImageImportJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelImageImportJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelImageImportJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelImageImportJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelImageImportJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Describes the disk which will be migrated from the source environment.
/// The source disk has to be unattached.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskMigrationJob {
    /// Output only. Identifier. The identifier of the DiskMigrationJob.
    pub name: std::string::String,

    /// Required. Details of the target Disk in Compute Engine.
    pub target_details: std::option::Option<crate::model::DiskMigrationJobTargetDetails>,

    /// Output only. The time the DiskMigrationJob resource was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last time the DiskMigrationJob resource was updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the DiskMigrationJob.
    pub state: crate::model::disk_migration_job::State,

    /// Output only. Provides details on the errors that led to the disk migration
    /// job's state in case of an error.
    pub errors: std::vec::Vec<rpc::model::Status>,

    /// Output only. The disk migration steps list representing its progress.
    pub steps: std::vec::Vec<crate::model::DiskMigrationStep>,

    /// Unattached source disk details.
    pub source_disk_details:
        std::option::Option<crate::model::disk_migration_job::SourceDiskDetails>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskMigrationJob {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiskMigrationJob::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_details][crate::model::DiskMigrationJob::target_details].
    pub fn set_target_details<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJobTargetDetails>,
    {
        self.target_details = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target_details][crate::model::DiskMigrationJob::target_details].
    pub fn set_or_clear_target_details<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJobTargetDetails>,
    {
        self.target_details = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::DiskMigrationJob::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::DiskMigrationJob::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::DiskMigrationJob::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::DiskMigrationJob::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::DiskMigrationJob::state].
    pub fn set_state<T: std::convert::Into<crate::model::disk_migration_job::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [errors][crate::model::DiskMigrationJob::errors].
    pub fn set_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<rpc::model::Status>,
    {
        use std::iter::Iterator;
        self.errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [steps][crate::model::DiskMigrationJob::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskMigrationStep>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [source_disk_details][crate::model::DiskMigrationJob::source_disk_details].
    ///
    /// Note that all the setters affecting `source_disk_details` are mutually
    /// exclusive.
    pub fn set_source_disk_details<
        T: std::convert::Into<
                std::option::Option<crate::model::disk_migration_job::SourceDiskDetails>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_disk_details = v.into();
        self
    }

    /// The value of [source_disk_details][crate::model::DiskMigrationJob::source_disk_details]
    /// if it holds a `AwsSourceDiskDetails`, `None` if the field is not set or
    /// holds a different branch.
    pub fn aws_source_disk_details(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::AwsSourceDiskDetails>> {
        #[allow(unreachable_patterns)]
        self.source_disk_details.as_ref().and_then(|v| match v {
            crate::model::disk_migration_job::SourceDiskDetails::AwsSourceDiskDetails(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source_disk_details][crate::model::DiskMigrationJob::source_disk_details]
    /// to hold a `AwsSourceDiskDetails`.
    ///
    /// Note that all the setters affecting `source_disk_details` are
    /// mutually exclusive.
    pub fn set_aws_source_disk_details<
        T: std::convert::Into<std::boxed::Box<crate::model::AwsSourceDiskDetails>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source_disk_details = std::option::Option::Some(
            crate::model::disk_migration_job::SourceDiskDetails::AwsSourceDiskDetails(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiskMigrationJob {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DiskMigrationJob"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskMigrationJob {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __aws_source_disk_details,
            __name,
            __target_details,
            __create_time,
            __update_time,
            __state,
            __errors,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskMigrationJob")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "awsSourceDiskDetails" => Ok(__FieldTag::__aws_source_disk_details),
                            "aws_source_disk_details" => Ok(__FieldTag::__aws_source_disk_details),
                            "name" => Ok(__FieldTag::__name),
                            "targetDetails" => Ok(__FieldTag::__target_details),
                            "target_details" => Ok(__FieldTag::__target_details),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "errors" => Ok(__FieldTag::__errors),
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskMigrationJob;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskMigrationJob")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__aws_source_disk_details => {
                            if !fields.insert(__FieldTag::__aws_source_disk_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for aws_source_disk_details",
                                ));
                            }
                            if result.source_disk_details.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source_disk_details`, a oneof with full ID .google.cloud.vmmigration.v1.DiskMigrationJob.aws_source_disk_details, latest field was awsSourceDiskDetails",
                                ));
                            }
                            result.source_disk_details = std::option::Option::Some(
                                crate::model::disk_migration_job::SourceDiskDetails::AwsSourceDiskDetails(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::AwsSourceDiskDetails>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_details => {
                            if !fields.insert(__FieldTag::__target_details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_details",
                                ));
                            }
                            result.target_details =
                                map.next_value::<std::option::Option<
                                    crate::model::DiskMigrationJobTargetDetails,
                                >>()?;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::disk_migration_job::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__errors => {
                            if !fields.insert(__FieldTag::__errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for errors",
                                ));
                            }
                            result.errors = map.next_value::<std::option::Option<std::vec::Vec<rpc::model::Status>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiskMigrationStep>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskMigrationJob {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.aws_source_disk_details() {
            state.serialize_entry("awsSourceDiskDetails", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.target_details.is_some() {
            state.serialize_entry("targetDetails", &self.target_details)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.errors.is_empty() {
            state.serialize_entry("errors", &self.errors)?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskMigrationJob {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskMigrationJob");
        debug_struct.field("name", &self.name);
        debug_struct.field("target_details", &self.target_details);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("state", &self.state);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("steps", &self.steps);
        debug_struct.field("source_disk_details", &self.source_disk_details);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiskMigrationJob].
pub mod disk_migration_job {
    #[allow(unused_imports)]
    use super::*;

    /// The possible values of the state/health of DiskMigrationJob.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The state is unspecified. This is not in use.
        Unspecified,
        /// The initial state of the disk migration.
        /// In this state the customers can update the target details.
        Ready,
        /// The migration is active, and it's running or scheduled to run.
        Running,
        /// The migration completed successfully.
        Succeeded,
        /// Migration cancellation was initiated.
        Cancelling,
        /// The migration was cancelled.
        Cancelled,
        /// The migration process encountered an unrecoverable error and was aborted.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Ready => std::option::Option::Some(1),
                Self::Running => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Cancelling => std::option::Option::Some(5),
                Self::Cancelled => std::option::Option::Some(6),
                Self::Failed => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelling => std::option::Option::Some("CANCELLING"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Ready,
                3 => Self::Running,
                4 => Self::Succeeded,
                5 => Self::Cancelling,
                6 => Self::Cancelled,
                7 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "READY" => Self::Ready,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLING" => Self::Cancelling,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Ready => serializer.serialize_i32(1),
                Self::Running => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Cancelling => serializer.serialize_i32(5),
                Self::Cancelled => serializer.serialize_i32(6),
                Self::Failed => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.vmmigration.v1.DiskMigrationJob.State",
            ))
        }
    }

    /// Unattached source disk details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum SourceDiskDetails {
        /// Details of the unattached AWS source disk.
        AwsSourceDiskDetails(std::boxed::Box<crate::model::AwsSourceDiskDetails>),
    }
}

/// Details of the target disk in Compute Engine.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskMigrationJobTargetDetails {
    /// Required. The name of the resource of type TargetProject which represents
    /// the Compute Engine project in which to create the disk. Should be of the
    /// form: projects/{project}/locations/global/targetProjects/{target-project}
    pub target_project: std::string::String,

    /// Optional. A map of labels to associate with the disk.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The encryption to apply to the disk.
    /// If the DiskMigrationJob parent Source resource has an encryption, this
    /// field must be set to the same encryption key.
    pub encryption: std::option::Option<crate::model::Encryption>,

    /// The target storage.
    pub target_storage:
        std::option::Option<crate::model::disk_migration_job_target_details::TargetStorage>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskMigrationJobTargetDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_project][crate::model::DiskMigrationJobTargetDetails::target_project].
    pub fn set_target_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_project = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::DiskMigrationJobTargetDetails::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [encryption][crate::model::DiskMigrationJobTargetDetails::encryption].
    pub fn set_encryption<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [encryption][crate::model::DiskMigrationJobTargetDetails::encryption].
    pub fn set_or_clear_encryption<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Encryption>,
    {
        self.encryption = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target_storage][crate::model::DiskMigrationJobTargetDetails::target_storage].
    ///
    /// Note that all the setters affecting `target_storage` are mutually
    /// exclusive.
    pub fn set_target_storage<
        T: std::convert::Into<
                std::option::Option<crate::model::disk_migration_job_target_details::TargetStorage>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_storage = v.into();
        self
    }

    /// The value of [target_storage][crate::model::DiskMigrationJobTargetDetails::target_storage]
    /// if it holds a `TargetDisk`, `None` if the field is not set or
    /// holds a different branch.
    pub fn target_disk(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ComputeEngineDisk>> {
        #[allow(unreachable_patterns)]
        self.target_storage.as_ref().and_then(|v| match v {
            crate::model::disk_migration_job_target_details::TargetStorage::TargetDisk(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [target_storage][crate::model::DiskMigrationJobTargetDetails::target_storage]
    /// to hold a `TargetDisk`.
    ///
    /// Note that all the setters affecting `target_storage` are
    /// mutually exclusive.
    pub fn set_target_disk<
        T: std::convert::Into<std::boxed::Box<crate::model::ComputeEngineDisk>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.target_storage = std::option::Option::Some(
            crate::model::disk_migration_job_target_details::TargetStorage::TargetDisk(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiskMigrationJobTargetDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DiskMigrationJobTargetDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskMigrationJobTargetDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_disk,
            __target_project,
            __labels,
            __encryption,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskMigrationJobTargetDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetDisk" => Ok(__FieldTag::__target_disk),
                            "target_disk" => Ok(__FieldTag::__target_disk),
                            "targetProject" => Ok(__FieldTag::__target_project),
                            "target_project" => Ok(__FieldTag::__target_project),
                            "labels" => Ok(__FieldTag::__labels),
                            "encryption" => Ok(__FieldTag::__encryption),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskMigrationJobTargetDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskMigrationJobTargetDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_disk => {
                            if !fields.insert(__FieldTag::__target_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_disk",
                                ));
                            }
                            if result.target_storage.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `target_storage`, a oneof with full ID .google.cloud.vmmigration.v1.DiskMigrationJobTargetDetails.target_disk, latest field was targetDisk",
                                ));
                            }
                            result.target_storage = std::option::Option::Some(
                                crate::model::disk_migration_job_target_details::TargetStorage::TargetDisk(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::ComputeEngineDisk>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target_project => {
                            if !fields.insert(__FieldTag::__target_project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_project",
                                ));
                            }
                            result.target_project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__encryption => {
                            if !fields.insert(__FieldTag::__encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for encryption",
                                ));
                            }
                            result.encryption =
                                map.next_value::<std::option::Option<crate::model::Encryption>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskMigrationJobTargetDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.target_disk() {
            state.serialize_entry("targetDisk", value)?;
        }
        if !self.target_project.is_empty() {
            state.serialize_entry("targetProject", &self.target_project)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if self.encryption.is_some() {
            state.serialize_entry("encryption", &self.encryption)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskMigrationJobTargetDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskMigrationJobTargetDetails");
        debug_struct.field("target_project", &self.target_project);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("encryption", &self.encryption);
        debug_struct.field("target_storage", &self.target_storage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiskMigrationJobTargetDetails].
pub mod disk_migration_job_target_details {
    #[allow(unused_imports)]
    use super::*;

    /// The target storage.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TargetStorage {
        /// Required. The target disk.
        TargetDisk(std::boxed::Box<crate::model::ComputeEngineDisk>),
    }
}

/// DiskMigrationStep holds information about the disk migration step progress.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DiskMigrationStep {
    /// Output only. The time the step has started.
    pub start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the step has ended.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The step details.
    pub step: std::option::Option<crate::model::disk_migration_step::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiskMigrationStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [start_time][crate::model::DiskMigrationStep::start_time].
    pub fn set_start_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [start_time][crate::model::DiskMigrationStep::start_time].
    pub fn set_or_clear_start_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.start_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::DiskMigrationStep::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::DiskMigrationStep::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [step][crate::model::DiskMigrationStep::step].
    ///
    /// Note that all the setters affecting `step` are mutually
    /// exclusive.
    pub fn set_step<
        T: std::convert::Into<std::option::Option<crate::model::disk_migration_step::Step>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = v.into();
        self
    }

    /// The value of [step][crate::model::DiskMigrationStep::step]
    /// if it holds a `CreatingSourceDiskSnapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn creating_source_disk_snapshot(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CreatingSourceDiskSnapshotStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::disk_migration_step::Step::CreatingSourceDiskSnapshot(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::DiskMigrationStep::step]
    /// to hold a `CreatingSourceDiskSnapshot`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_creating_source_disk_snapshot<
        T: std::convert::Into<std::boxed::Box<crate::model::CreatingSourceDiskSnapshotStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::disk_migration_step::Step::CreatingSourceDiskSnapshot(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::DiskMigrationStep::step]
    /// if it holds a `CopyingSourceDiskSnapshot`, `None` if the field is not set or
    /// holds a different branch.
    pub fn copying_source_disk_snapshot(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::CopyingSourceDiskSnapshotStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::disk_migration_step::Step::CopyingSourceDiskSnapshot(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::DiskMigrationStep::step]
    /// to hold a `CopyingSourceDiskSnapshot`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_copying_source_disk_snapshot<
        T: std::convert::Into<std::boxed::Box<crate::model::CopyingSourceDiskSnapshotStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::disk_migration_step::Step::CopyingSourceDiskSnapshot(v.into()),
        );
        self
    }

    /// The value of [step][crate::model::DiskMigrationStep::step]
    /// if it holds a `ProvisioningTargetDisk`, `None` if the field is not set or
    /// holds a different branch.
    pub fn provisioning_target_disk(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ProvisioningTargetDiskStep>> {
        #[allow(unreachable_patterns)]
        self.step.as_ref().and_then(|v| match v {
            crate::model::disk_migration_step::Step::ProvisioningTargetDisk(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [step][crate::model::DiskMigrationStep::step]
    /// to hold a `ProvisioningTargetDisk`.
    ///
    /// Note that all the setters affecting `step` are
    /// mutually exclusive.
    pub fn set_provisioning_target_disk<
        T: std::convert::Into<std::boxed::Box<crate::model::ProvisioningTargetDiskStep>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.step = std::option::Option::Some(
            crate::model::disk_migration_step::Step::ProvisioningTargetDisk(v.into()),
        );
        self
    }
}

impl wkt::message::Message for DiskMigrationStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DiskMigrationStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiskMigrationStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __creating_source_disk_snapshot,
            __copying_source_disk_snapshot,
            __provisioning_target_disk,
            __start_time,
            __end_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiskMigrationStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "creatingSourceDiskSnapshot" => {
                                Ok(__FieldTag::__creating_source_disk_snapshot)
                            }
                            "creating_source_disk_snapshot" => {
                                Ok(__FieldTag::__creating_source_disk_snapshot)
                            }
                            "copyingSourceDiskSnapshot" => {
                                Ok(__FieldTag::__copying_source_disk_snapshot)
                            }
                            "copying_source_disk_snapshot" => {
                                Ok(__FieldTag::__copying_source_disk_snapshot)
                            }
                            "provisioningTargetDisk" => Ok(__FieldTag::__provisioning_target_disk),
                            "provisioning_target_disk" => {
                                Ok(__FieldTag::__provisioning_target_disk)
                            }
                            "startTime" => Ok(__FieldTag::__start_time),
                            "start_time" => Ok(__FieldTag::__start_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiskMigrationStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiskMigrationStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__creating_source_disk_snapshot => {
                            if !fields.insert(__FieldTag::__creating_source_disk_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creating_source_disk_snapshot",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.DiskMigrationStep.creating_source_disk_snapshot, latest field was creatingSourceDiskSnapshot",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::disk_migration_step::Step::CreatingSourceDiskSnapshot(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::CreatingSourceDiskSnapshotStep,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__copying_source_disk_snapshot => {
                            if !fields.insert(__FieldTag::__copying_source_disk_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for copying_source_disk_snapshot",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.DiskMigrationStep.copying_source_disk_snapshot, latest field was copyingSourceDiskSnapshot",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::disk_migration_step::Step::CopyingSourceDiskSnapshot(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::CopyingSourceDiskSnapshotStep,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__provisioning_target_disk => {
                            if !fields.insert(__FieldTag::__provisioning_target_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for provisioning_target_disk",
                                ));
                            }
                            if result.step.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `step`, a oneof with full ID .google.cloud.vmmigration.v1.DiskMigrationStep.provisioning_target_disk, latest field was provisioningTargetDisk",
                                ));
                            }
                            result.step = std::option::Option::Some(
                                crate::model::disk_migration_step::Step::ProvisioningTargetDisk(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ProvisioningTargetDiskStep>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__start_time => {
                            if !fields.insert(__FieldTag::__start_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for start_time",
                                ));
                            }
                            result.start_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiskMigrationStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.creating_source_disk_snapshot() {
            state.serialize_entry("creatingSourceDiskSnapshot", value)?;
        }
        if let Some(value) = self.copying_source_disk_snapshot() {
            state.serialize_entry("copyingSourceDiskSnapshot", value)?;
        }
        if let Some(value) = self.provisioning_target_disk() {
            state.serialize_entry("provisioningTargetDisk", value)?;
        }
        if self.start_time.is_some() {
            state.serialize_entry("startTime", &self.start_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DiskMigrationStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DiskMigrationStep");
        debug_struct.field("start_time", &self.start_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("step", &self.step);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [DiskMigrationStep].
pub mod disk_migration_step {
    #[allow(unused_imports)]
    use super::*;

    /// The step details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Step {
        /// Creating source disk snapshot step.
        CreatingSourceDiskSnapshot(std::boxed::Box<crate::model::CreatingSourceDiskSnapshotStep>),
        /// Copying source disk snapshot step.
        CopyingSourceDiskSnapshot(std::boxed::Box<crate::model::CopyingSourceDiskSnapshotStep>),
        /// Creating target disk step.
        ProvisioningTargetDisk(std::boxed::Box<crate::model::ProvisioningTargetDiskStep>),
    }
}

/// CreatingSourceDiskSnapshotStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreatingSourceDiskSnapshotStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreatingSourceDiskSnapshotStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CreatingSourceDiskSnapshotStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreatingSourceDiskSnapshotStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreatingSourceDiskSnapshotStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreatingSourceDiskSnapshotStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreatingSourceDiskSnapshotStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreatingSourceDiskSnapshotStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreatingSourceDiskSnapshotStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreatingSourceDiskSnapshotStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreatingSourceDiskSnapshotStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// CopyingSourceDiskSnapshotStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CopyingSourceDiskSnapshotStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CopyingSourceDiskSnapshotStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CopyingSourceDiskSnapshotStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CopyingSourceDiskSnapshotStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CopyingSourceDiskSnapshotStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CopyingSourceDiskSnapshotStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CopyingSourceDiskSnapshotStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CopyingSourceDiskSnapshotStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CopyingSourceDiskSnapshotStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CopyingSourceDiskSnapshotStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CopyingSourceDiskSnapshotStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// ProvisioningTargetDiskStep contains specific step details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ProvisioningTargetDiskStep {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ProvisioningTargetDiskStep {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ProvisioningTargetDiskStep {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ProvisioningTargetDiskStep"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ProvisioningTargetDiskStep {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ProvisioningTargetDiskStep")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ProvisioningTargetDiskStep;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ProvisioningTargetDiskStep")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ProvisioningTargetDiskStep {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ProvisioningTargetDiskStep {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProvisioningTargetDiskStep");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Compute Engine disk target details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeEngineDisk {
    /// Optional. Target Compute Engine Disk ID.
    /// This is the resource ID segment of the Compute Engine Disk to create.
    /// In the resource name compute/v1/projects/{project}/zones/{zone}/disks/disk1
    /// "disk1" is the resource ID for the disk.
    pub disk_id: std::string::String,

    /// Required. The Compute Engine zone in which to create the disk. Should be of
    /// the form: projects/{target-project}/locations/{zone}
    pub zone: std::string::String,

    /// Optional. Replication zones of the regional disk. Should be of the form:
    /// projects/{target-project}/locations/{replica-zone}
    /// Currently only one replica zone is supported.
    pub replica_zones: std::vec::Vec<std::string::String>,

    /// Required. The disk type to use.
    pub disk_type: crate::model::ComputeEngineDiskType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeEngineDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_id][crate::model::ComputeEngineDisk::disk_id].
    pub fn set_disk_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.disk_id = v.into();
        self
    }

    /// Sets the value of [zone][crate::model::ComputeEngineDisk::zone].
    pub fn set_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.zone = v.into();
        self
    }

    /// Sets the value of [replica_zones][crate::model::ComputeEngineDisk::replica_zones].
    pub fn set_replica_zones<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.replica_zones = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disk_type][crate::model::ComputeEngineDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::ComputeEngineDiskType>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }
}

impl wkt::message::Message for ComputeEngineDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ComputeEngineDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeEngineDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_id,
            __zone,
            __replica_zones,
            __disk_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ComputeEngineDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskId" => Ok(__FieldTag::__disk_id),
                            "disk_id" => Ok(__FieldTag::__disk_id),
                            "zone" => Ok(__FieldTag::__zone),
                            "replicaZones" => Ok(__FieldTag::__replica_zones),
                            "replica_zones" => Ok(__FieldTag::__replica_zones),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeEngineDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeEngineDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_id => {
                            if !fields.insert(__FieldTag::__disk_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_id",
                                ));
                            }
                            result.disk_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__zone => {
                            if !fields.insert(__FieldTag::__zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for zone",
                                ));
                            }
                            result.zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__replica_zones => {
                            if !fields.insert(__FieldTag::__replica_zones) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for replica_zones",
                                ));
                            }
                            result.replica_zones = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map.next_value::<std::option::Option<crate::model::ComputeEngineDiskType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeEngineDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_id.is_empty() {
            state.serialize_entry("diskId", &self.disk_id)?;
        }
        if !self.zone.is_empty() {
            state.serialize_entry("zone", &self.zone)?;
        }
        if !self.replica_zones.is_empty() {
            state.serialize_entry("replicaZones", &self.replica_zones)?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ComputeEngineDisk {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ComputeEngineDisk");
        debug_struct.field("disk_id", &self.disk_id);
        debug_struct.field("zone", &self.zone);
        debug_struct.field("replica_zones", &self.replica_zones);
        debug_struct.field("disk_type", &self.disk_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the source AWS Disk details.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AwsSourceDiskDetails {
    /// Required. AWS volume ID.
    pub volume_id: std::string::String,

    /// Output only. Size in GiB.
    pub size_gib: i64,

    /// Optional. Output only. Disk type.
    pub disk_type: crate::model::aws_source_disk_details::Type,

    /// Optional. Output only. A map of AWS volume tags.
    pub tags: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AwsSourceDiskDetails {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [volume_id][crate::model::AwsSourceDiskDetails::volume_id].
    pub fn set_volume_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.volume_id = v.into();
        self
    }

    /// Sets the value of [size_gib][crate::model::AwsSourceDiskDetails::size_gib].
    pub fn set_size_gib<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.size_gib = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::AwsSourceDiskDetails::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::aws_source_disk_details::Type>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::AwsSourceDiskDetails::tags].
    pub fn set_tags<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for AwsSourceDiskDetails {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.AwsSourceDiskDetails"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AwsSourceDiskDetails {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __volume_id,
            __size_gib,
            __disk_type,
            __tags,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AwsSourceDiskDetails")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "volumeId" => Ok(__FieldTag::__volume_id),
                            "volume_id" => Ok(__FieldTag::__volume_id),
                            "sizeGib" => Ok(__FieldTag::__size_gib),
                            "size_gib" => Ok(__FieldTag::__size_gib),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "tags" => Ok(__FieldTag::__tags),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AwsSourceDiskDetails;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AwsSourceDiskDetails")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__volume_id => {
                            if !fields.insert(__FieldTag::__volume_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for volume_id",
                                ));
                            }
                            result.volume_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__size_gib => {
                            if !fields.insert(__FieldTag::__size_gib) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for size_gib",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.size_gib = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type =
                                map.next_value::<std::option::Option<
                                    crate::model::aws_source_disk_details::Type,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AwsSourceDiskDetails {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.volume_id.is_empty() {
            state.serialize_entry("volumeId", &self.volume_id)?;
        }
        if !wkt::internal::is_default(&self.size_gib) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("sizeGib", &__With(&self.size_gib))?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AwsSourceDiskDetails {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AwsSourceDiskDetails");
        debug_struct.field("volume_id", &self.volume_id);
        debug_struct.field("size_gib", &self.size_gib);
        debug_struct.field("disk_type", &self.disk_type);
        debug_struct.field("tags", &self.tags);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [AwsSourceDiskDetails].
pub mod aws_source_disk_details {
    #[allow(unused_imports)]
    use super::*;

    /// Possible values for disk types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Type {
        /// Unspecified AWS disk type. Should not be used.
        Unspecified,
        /// GP2 disk type.
        Gp2,
        /// GP3 disk type.
        Gp3,
        /// IO1 disk type.
        Io1,
        /// IO2 disk type.
        Io2,
        /// ST1 disk type.
        St1,
        /// SC1 disk type.
        Sc1,
        /// Standard disk type.
        Standard,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Type::value] or
        /// [Type::name].
        UnknownValue(r#type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod r#type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Type {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Gp2 => std::option::Option::Some(1),
                Self::Gp3 => std::option::Option::Some(2),
                Self::Io1 => std::option::Option::Some(3),
                Self::Io2 => std::option::Option::Some(4),
                Self::St1 => std::option::Option::Some(5),
                Self::Sc1 => std::option::Option::Some(6),
                Self::Standard => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TYPE_UNSPECIFIED"),
                Self::Gp2 => std::option::Option::Some("GP2"),
                Self::Gp3 => std::option::Option::Some("GP3"),
                Self::Io1 => std::option::Option::Some("IO1"),
                Self::Io2 => std::option::Option::Some("IO2"),
                Self::St1 => std::option::Option::Some("ST1"),
                Self::Sc1 => std::option::Option::Some("SC1"),
                Self::Standard => std::option::Option::Some("STANDARD"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Type {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Type {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Type {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Gp2,
                2 => Self::Gp3,
                3 => Self::Io1,
                4 => Self::Io2,
                5 => Self::St1,
                6 => Self::Sc1,
                7 => Self::Standard,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Type {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TYPE_UNSPECIFIED" => Self::Unspecified,
                "GP2" => Self::Gp2,
                "GP3" => Self::Gp3,
                "IO1" => Self::Io1,
                "IO2" => Self::Io2,
                "ST1" => Self::St1,
                "SC1" => Self::Sc1,
                "STANDARD" => Self::Standard,
                _ => Self::UnknownValue(r#type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Type {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Gp2 => serializer.serialize_i32(1),
                Self::Gp3 => serializer.serialize_i32(2),
                Self::Io1 => serializer.serialize_i32(3),
                Self::Io2 => serializer.serialize_i32(4),
                Self::St1 => serializer.serialize_i32(5),
                Self::Sc1 => serializer.serialize_i32(6),
                Self::Standard => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Type {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Type>::new(
                ".google.cloud.vmmigration.v1.AwsSourceDiskDetails.Type",
            ))
        }
    }
}

/// Request message for 'CreateDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateDiskMigrationJobRequest {
    /// Required. The DiskMigrationJob's parent.
    pub parent: std::string::String,

    /// Required. The DiskMigrationJob identifier.
    /// The maximum length of this value is 63 characters.
    /// Valid characters are lower case Latin letters, digits and hyphen.
    /// It must start with a Latin letter and must not end with a hyphen.
    pub disk_migration_job_id: std::string::String,

    /// Required. The create request body.
    pub disk_migration_job: std::option::Option<crate::model::DiskMigrationJob>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request timed out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDiskMigrationJobRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [disk_migration_job_id][crate::model::CreateDiskMigrationJobRequest::disk_migration_job_id].
    pub fn set_disk_migration_job_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_migration_job_id = v.into();
        self
    }

    /// Sets the value of [disk_migration_job][crate::model::CreateDiskMigrationJobRequest::disk_migration_job].
    pub fn set_disk_migration_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJob>,
    {
        self.disk_migration_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_migration_job][crate::model::CreateDiskMigrationJobRequest::disk_migration_job].
    pub fn set_or_clear_disk_migration_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJob>,
    {
        self.disk_migration_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDiskMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CreateDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __disk_migration_job_id,
            __disk_migration_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "diskMigrationJobId" => Ok(__FieldTag::__disk_migration_job_id),
                            "disk_migration_job_id" => Ok(__FieldTag::__disk_migration_job_id),
                            "diskMigrationJob" => Ok(__FieldTag::__disk_migration_job),
                            "disk_migration_job" => Ok(__FieldTag::__disk_migration_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_migration_job_id => {
                            if !fields.insert(__FieldTag::__disk_migration_job_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_migration_job_id",
                                ));
                            }
                            result.disk_migration_job_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_migration_job => {
                            if !fields.insert(__FieldTag::__disk_migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_migration_job",
                                ));
                            }
                            result.disk_migration_job = map
                                .next_value::<std::option::Option<crate::model::DiskMigrationJob>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.disk_migration_job_id.is_empty() {
            state.serialize_entry("diskMigrationJobId", &self.disk_migration_job_id)?;
        }
        if self.disk_migration_job.is_some() {
            state.serialize_entry("diskMigrationJob", &self.disk_migration_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateDiskMigrationJobRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("disk_migration_job_id", &self.disk_migration_job_id);
        debug_struct.field("disk_migration_job", &self.disk_migration_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'ListDiskMigrationJobsRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiskMigrationJobsRequest {
    /// Required. The parent, which owns this collection of DiskMigrationJobs.
    pub parent: std::string::String,

    /// Optional. The maximum number of disk migration jobs to return. The service
    /// may return fewer than this value. If unspecified, at most 500
    /// disk migration jobs will be returned.
    /// The maximum value is 1000; values above 1000 will be coerced to 1000.
    pub page_size: i32,

    /// Optional. A page token, received from a previous `ListDiskMigrationJobs`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all parameters provided to `ListDiskMigrationJobs`
    /// except `page_size` must match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. The filter request (according to <a
    /// href="https://google.aip.dev/160" target="_blank">AIP-160</a>).
    pub filter: std::string::String,

    /// Optional. Ordering of the result list.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiskMigrationJobsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDiskMigrationJobsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDiskMigrationJobsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDiskMigrationJobsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDiskMigrationJobsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDiskMigrationJobsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDiskMigrationJobsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDiskMigrationJobsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiskMigrationJobsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiskMigrationJobsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiskMigrationJobsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiskMigrationJobsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiskMigrationJobsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiskMigrationJobsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiskMigrationJobsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'ListDiskMigrationJobs' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDiskMigrationJobsResponse {
    /// Output only. The list of the disk migration jobs.
    pub disk_migration_jobs: std::vec::Vec<crate::model::DiskMigrationJob>,

    /// Optional. Output only. A token, which can be sent as `page_token` to
    /// retrieve the next page. If this field is omitted, there are no subsequent
    /// pages.
    pub next_page_token: std::string::String,

    /// Output only. Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDiskMigrationJobsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_migration_jobs][crate::model::ListDiskMigrationJobsResponse::disk_migration_jobs].
    pub fn set_disk_migration_jobs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DiskMigrationJob>,
    {
        use std::iter::Iterator;
        self.disk_migration_jobs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDiskMigrationJobsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDiskMigrationJobsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDiskMigrationJobsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.ListDiskMigrationJobsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDiskMigrationJobsResponse {
    type PageItem = crate::model::DiskMigrationJob;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.disk_migration_jobs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDiskMigrationJobsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_migration_jobs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDiskMigrationJobsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskMigrationJobs" => Ok(__FieldTag::__disk_migration_jobs),
                            "disk_migration_jobs" => Ok(__FieldTag::__disk_migration_jobs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDiskMigrationJobsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDiskMigrationJobsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_migration_jobs => {
                            if !fields.insert(__FieldTag::__disk_migration_jobs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_migration_jobs",
                                ));
                            }
                            result.disk_migration_jobs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DiskMigrationJob>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDiskMigrationJobsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.disk_migration_jobs.is_empty() {
            state.serialize_entry("diskMigrationJobs", &self.disk_migration_jobs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListDiskMigrationJobsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListDiskMigrationJobsResponse");
        debug_struct.field("disk_migration_jobs", &self.disk_migration_jobs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'GetDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDiskMigrationJobRequest {
    /// Required. The name of the DiskMigrationJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDiskMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.GetDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetDiskMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'UpdateDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDiskMigrationJobRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// DiskMigrationJob resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask, then a mask equivalent to all fields that are
    /// populated (have a non-empty value), will be implied.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The update request body.
    pub disk_migration_job: std::option::Option<crate::model::DiskMigrationJob>,

    /// Optional. A request ID to identify requests. Specify a unique request ID
    /// so that if you must retry your request, the server will know to ignore
    /// the request if it has already been completed. The server will guarantee
    /// that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and
    /// the request timed out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDiskMigrationJobRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDiskMigrationJobRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disk_migration_job][crate::model::UpdateDiskMigrationJobRequest::disk_migration_job].
    pub fn set_disk_migration_job<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJob>,
    {
        self.disk_migration_job = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [disk_migration_job][crate::model::UpdateDiskMigrationJobRequest::disk_migration_job].
    pub fn set_or_clear_disk_migration_job<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiskMigrationJob>,
    {
        self.disk_migration_job = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDiskMigrationJobRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.UpdateDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __disk_migration_job,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "diskMigrationJob" => Ok(__FieldTag::__disk_migration_job),
                            "disk_migration_job" => Ok(__FieldTag::__disk_migration_job),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__disk_migration_job => {
                            if !fields.insert(__FieldTag::__disk_migration_job) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_migration_job",
                                ));
                            }
                            result.disk_migration_job = map
                                .next_value::<std::option::Option<crate::model::DiskMigrationJob>>(
                                )?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.disk_migration_job.is_some() {
            state.serialize_entry("diskMigrationJob", &self.disk_migration_job)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateDiskMigrationJobRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("disk_migration_job", &self.disk_migration_job);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'DeleteDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDiskMigrationJobRequest {
    /// Required. The name of the DiskMigrationJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDiskMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.DeleteDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteDiskMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'RunDiskMigrationJobRequest' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunDiskMigrationJobRequest {
    /// Required. The name of the DiskMigrationJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RunDiskMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for RunDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RunDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunDiskMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'RunDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RunDiskMigrationJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RunDiskMigrationJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RunDiskMigrationJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.RunDiskMigrationJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RunDiskMigrationJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RunDiskMigrationJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RunDiskMigrationJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RunDiskMigrationJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RunDiskMigrationJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RunDiskMigrationJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RunDiskMigrationJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for 'CancelDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelDiskMigrationJobRequest {
    /// Required. The name of the DiskMigrationJob.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelDiskMigrationJobRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelDiskMigrationJobRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelDiskMigrationJobRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelDiskMigrationJobRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelDiskMigrationJobRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelDiskMigrationJobRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelDiskMigrationJobRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelDiskMigrationJobRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelDiskMigrationJobRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelDiskMigrationJobRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelDiskMigrationJobRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for 'CancelDiskMigrationJob' request.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelDiskMigrationJobResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelDiskMigrationJobResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelDiskMigrationJobResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.vmmigration.v1.CancelDiskMigrationJobResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelDiskMigrationJobResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelDiskMigrationJobResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelDiskMigrationJobResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelDiskMigrationJobResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelDiskMigrationJobResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CancelDiskMigrationJobResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CancelDiskMigrationJobResponse");
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Types of disks supported for Compute Engine VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineDiskType {
    /// An unspecified disk type. Will be used as STANDARD.
    Unspecified,
    /// A Standard disk type.
    Standard,
    /// SSD hard disk type.
    Ssd,
    /// An alternative to SSD persistent disks that balance performance and
    /// cost.
    Balanced,
    /// Hyperdisk balanced disk type.
    HyperdiskBalanced,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineDiskType::value] or
    /// [ComputeEngineDiskType::name].
    UnknownValue(compute_engine_disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineDiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Standard => std::option::Option::Some(1),
            Self::Ssd => std::option::Option::Some(2),
            Self::Balanced => std::option::Option::Some(3),
            Self::HyperdiskBalanced => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED"),
            Self::Standard => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_STANDARD"),
            Self::Ssd => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_SSD"),
            Self::Balanced => std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_BALANCED"),
            Self::HyperdiskBalanced => {
                std::option::Option::Some("COMPUTE_ENGINE_DISK_TYPE_HYPERDISK_BALANCED")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineDiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineDiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineDiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Standard,
            2 => Self::Ssd,
            3 => Self::Balanced,
            4 => Self::HyperdiskBalanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineDiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_DISK_TYPE_STANDARD" => Self::Standard,
            "COMPUTE_ENGINE_DISK_TYPE_SSD" => Self::Ssd,
            "COMPUTE_ENGINE_DISK_TYPE_BALANCED" => Self::Balanced,
            "COMPUTE_ENGINE_DISK_TYPE_HYPERDISK_BALANCED" => Self::HyperdiskBalanced,
            _ => Self::UnknownValue(compute_engine_disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineDiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Standard => serializer.serialize_i32(1),
            Self::Ssd => serializer.serialize_i32(2),
            Self::Balanced => serializer.serialize_i32(3),
            Self::HyperdiskBalanced => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineDiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineDiskType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineDiskType",
        ))
    }
}

/// Types of licenses used in OS adaptation.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineLicenseType {
    /// The license type is the default for the OS.
    Default,
    /// The license type is Pay As You Go license type.
    Payg,
    /// The license type is Bring Your Own License type.
    Byol,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineLicenseType::value] or
    /// [ComputeEngineLicenseType::name].
    UnknownValue(compute_engine_license_type::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_license_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineLicenseType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Default => std::option::Option::Some(0),
            Self::Payg => std::option::Option::Some(1),
            Self::Byol => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Default => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT"),
            Self::Payg => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_PAYG"),
            Self::Byol => std::option::Option::Some("COMPUTE_ENGINE_LICENSE_TYPE_BYOL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineLicenseType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineLicenseType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineLicenseType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Default,
            1 => Self::Payg,
            2 => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineLicenseType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_LICENSE_TYPE_DEFAULT" => Self::Default,
            "COMPUTE_ENGINE_LICENSE_TYPE_PAYG" => Self::Payg,
            "COMPUTE_ENGINE_LICENSE_TYPE_BYOL" => Self::Byol,
            _ => Self::UnknownValue(compute_engine_license_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineLicenseType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Default => serializer.serialize_i32(0),
            Self::Payg => serializer.serialize_i32(1),
            Self::Byol => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineLicenseType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineLicenseType>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineLicenseType",
        ))
    }
}

/// Possible values for vm boot option.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineBootOption {
    /// The boot option is unknown.
    Unspecified,
    /// The boot option is EFI.
    Efi,
    /// The boot option is BIOS.
    Bios,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineBootOption::value] or
    /// [ComputeEngineBootOption::name].
    UnknownValue(compute_engine_boot_option::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_boot_option {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineBootOption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Efi => std::option::Option::Some(1),
            Self::Bios => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED")
            }
            Self::Efi => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_EFI"),
            Self::Bios => std::option::Option::Some("COMPUTE_ENGINE_BOOT_OPTION_BIOS"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineBootOption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineBootOption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineBootOption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Efi,
            2 => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineBootOption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_BOOT_OPTION_UNSPECIFIED" => Self::Unspecified,
            "COMPUTE_ENGINE_BOOT_OPTION_EFI" => Self::Efi,
            "COMPUTE_ENGINE_BOOT_OPTION_BIOS" => Self::Bios,
            _ => Self::UnknownValue(compute_engine_boot_option::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineBootOption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Efi => serializer.serialize_i32(1),
            Self::Bios => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineBootOption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineBootOption>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineBootOption",
        ))
    }
}

/// VM operating system (OS) capabilities needed for determining compatibility
/// with Compute Engine features supported by the migration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum OsCapability {
    /// This is for API compatibility only and is not in use.
    Unspecified,
    /// NVMe driver installed and the VM can use NVMe PD or local SSD.
    NvmeStorageAccess,
    /// gVNIC virtual NIC driver supported.
    GvnicNetworkInterface,
    /// IDPF virtual NIC driver supported.
    IdpfNetworkInterface,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [OsCapability::value] or
    /// [OsCapability::name].
    UnknownValue(os_capability::UnknownValue),
}

#[doc(hidden)]
pub mod os_capability {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl OsCapability {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NvmeStorageAccess => std::option::Option::Some(1),
            Self::GvnicNetworkInterface => std::option::Option::Some(2),
            Self::IdpfNetworkInterface => std::option::Option::Some(3),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("OS_CAPABILITY_UNSPECIFIED"),
            Self::NvmeStorageAccess => {
                std::option::Option::Some("OS_CAPABILITY_NVME_STORAGE_ACCESS")
            }
            Self::GvnicNetworkInterface => {
                std::option::Option::Some("OS_CAPABILITY_GVNIC_NETWORK_INTERFACE")
            }
            Self::IdpfNetworkInterface => {
                std::option::Option::Some("OS_CAPABILITY_IDPF_NETWORK_INTERFACE")
            }
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for OsCapability {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for OsCapability {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for OsCapability {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NvmeStorageAccess,
            2 => Self::GvnicNetworkInterface,
            3 => Self::IdpfNetworkInterface,
            _ => Self::UnknownValue(os_capability::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for OsCapability {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "OS_CAPABILITY_UNSPECIFIED" => Self::Unspecified,
            "OS_CAPABILITY_NVME_STORAGE_ACCESS" => Self::NvmeStorageAccess,
            "OS_CAPABILITY_GVNIC_NETWORK_INTERFACE" => Self::GvnicNetworkInterface,
            "OS_CAPABILITY_IDPF_NETWORK_INTERFACE" => Self::IdpfNetworkInterface,
            _ => Self::UnknownValue(os_capability::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for OsCapability {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NvmeStorageAccess => serializer.serialize_i32(1),
            Self::GvnicNetworkInterface => serializer.serialize_i32(2),
            Self::IdpfNetworkInterface => serializer.serialize_i32(3),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for OsCapability {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<OsCapability>::new(
            ".google.cloud.vmmigration.v1.OsCapability",
        ))
    }
}

/// Possible boot options conversions.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum BootConversion {
    /// Unspecified conversion type.
    Unspecified,
    /// No conversion.
    None,
    /// Convert from BIOS to EFI.
    BiosToEfi,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [BootConversion::value] or
    /// [BootConversion::name].
    UnknownValue(boot_conversion::UnknownValue),
}

#[doc(hidden)]
pub mod boot_conversion {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl BootConversion {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::None => std::option::Option::Some(1),
            Self::BiosToEfi => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("BOOT_CONVERSION_UNSPECIFIED"),
            Self::None => std::option::Option::Some("NONE"),
            Self::BiosToEfi => std::option::Option::Some("BIOS_TO_EFI"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for BootConversion {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for BootConversion {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for BootConversion {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::None,
            2 => Self::BiosToEfi,
            _ => Self::UnknownValue(boot_conversion::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for BootConversion {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "BOOT_CONVERSION_UNSPECIFIED" => Self::Unspecified,
            "NONE" => Self::None,
            "BIOS_TO_EFI" => Self::BiosToEfi,
            _ => Self::UnknownValue(boot_conversion::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for BootConversion {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::None => serializer.serialize_i32(1),
            Self::BiosToEfi => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for BootConversion {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<BootConversion>::new(
            ".google.cloud.vmmigration.v1.BootConversion",
        ))
    }
}

/// Controls the level of details of a Utilization Report.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum UtilizationReportView {
    /// The default / unset value.
    /// The API will default to FULL on single report request and BASIC for
    /// multiple reports request.
    Unspecified,
    /// Get the report metadata, without the list of VMs and their utilization
    /// info.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [UtilizationReportView::value] or
    /// [UtilizationReportView::name].
    UnknownValue(utilization_report_view::UnknownValue),
}

#[doc(hidden)]
pub mod utilization_report_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl UtilizationReportView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("UTILIZATION_REPORT_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("BASIC"),
            Self::Full => std::option::Option::Some("FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for UtilizationReportView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for UtilizationReportView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for UtilizationReportView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for UtilizationReportView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "UTILIZATION_REPORT_VIEW_UNSPECIFIED" => Self::Unspecified,
            "BASIC" => Self::Basic,
            "FULL" => Self::Full,
            _ => Self::UnknownValue(utilization_report_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for UtilizationReportView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for UtilizationReportView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<UtilizationReportView>::new(
            ".google.cloud.vmmigration.v1.UtilizationReportView",
        ))
    }
}

/// Controls the level of details of a Migrating VM.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum MigratingVmView {
    /// View is unspecified. The API will fallback to the default value.
    Unspecified,
    /// Get the migrating VM basic details.
    /// The basic details do not include the recent clone jobs and recent cutover
    /// jobs lists.
    Basic,
    /// Include everything.
    Full,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [MigratingVmView::value] or
    /// [MigratingVmView::name].
    UnknownValue(migrating_vm_view::UnknownValue),
}

#[doc(hidden)]
pub mod migrating_vm_view {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl MigratingVmView {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Basic => std::option::Option::Some(1),
            Self::Full => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("MIGRATING_VM_VIEW_UNSPECIFIED"),
            Self::Basic => std::option::Option::Some("MIGRATING_VM_VIEW_BASIC"),
            Self::Full => std::option::Option::Some("MIGRATING_VM_VIEW_FULL"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for MigratingVmView {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for MigratingVmView {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for MigratingVmView {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Basic,
            2 => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for MigratingVmView {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "MIGRATING_VM_VIEW_UNSPECIFIED" => Self::Unspecified,
            "MIGRATING_VM_VIEW_BASIC" => Self::Basic,
            "MIGRATING_VM_VIEW_FULL" => Self::Full,
            _ => Self::UnknownValue(migrating_vm_view::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for MigratingVmView {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Basic => serializer.serialize_i32(1),
            Self::Full => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for MigratingVmView {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<MigratingVmView>::new(
            ".google.cloud.vmmigration.v1.MigratingVmView",
        ))
    }
}

/// Possible values for the VM architecture.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum VmArchitecture {
    /// The architecture is unknown.
    Unspecified,
    /// The architecture is one of the x86 architectures.
    X86Family,
    /// The architecture is ARM64.
    Arm64,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [VmArchitecture::value] or
    /// [VmArchitecture::name].
    UnknownValue(vm_architecture::UnknownValue),
}

#[doc(hidden)]
pub mod vm_architecture {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl VmArchitecture {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::X86Family => std::option::Option::Some(1),
            Self::Arm64 => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("VM_ARCHITECTURE_UNSPECIFIED"),
            Self::X86Family => std::option::Option::Some("VM_ARCHITECTURE_X86_FAMILY"),
            Self::Arm64 => std::option::Option::Some("VM_ARCHITECTURE_ARM64"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for VmArchitecture {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for VmArchitecture {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for VmArchitecture {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::X86Family,
            2 => Self::Arm64,
            _ => Self::UnknownValue(vm_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for VmArchitecture {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "VM_ARCHITECTURE_UNSPECIFIED" => Self::Unspecified,
            "VM_ARCHITECTURE_X86_FAMILY" => Self::X86Family,
            "VM_ARCHITECTURE_ARM64" => Self::Arm64,
            _ => Self::UnknownValue(vm_architecture::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for VmArchitecture {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::X86Family => serializer.serialize_i32(1),
            Self::Arm64 => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for VmArchitecture {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<VmArchitecture>::new(
            ".google.cloud.vmmigration.v1.VmArchitecture",
        ))
    }
}

/// Describes the networking tier used for configuring network access
/// configuration.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum ComputeEngineNetworkTier {
    /// An unspecified network tier. Will be used as PREMIUM.
    Unspecified,
    /// A standard network tier.
    NetworkTierStandard,
    /// A premium network tier.
    NetworkTierPremium,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [ComputeEngineNetworkTier::value] or
    /// [ComputeEngineNetworkTier::name].
    UnknownValue(compute_engine_network_tier::UnknownValue),
}

#[doc(hidden)]
pub mod compute_engine_network_tier {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl ComputeEngineNetworkTier {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::NetworkTierStandard => std::option::Option::Some(1),
            Self::NetworkTierPremium => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => {
                std::option::Option::Some("COMPUTE_ENGINE_NETWORK_TIER_UNSPECIFIED")
            }
            Self::NetworkTierStandard => std::option::Option::Some("NETWORK_TIER_STANDARD"),
            Self::NetworkTierPremium => std::option::Option::Some("NETWORK_TIER_PREMIUM"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for ComputeEngineNetworkTier {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for ComputeEngineNetworkTier {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for ComputeEngineNetworkTier {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::NetworkTierStandard,
            2 => Self::NetworkTierPremium,
            _ => Self::UnknownValue(compute_engine_network_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for ComputeEngineNetworkTier {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "COMPUTE_ENGINE_NETWORK_TIER_UNSPECIFIED" => Self::Unspecified,
            "NETWORK_TIER_STANDARD" => Self::NetworkTierStandard,
            "NETWORK_TIER_PREMIUM" => Self::NetworkTierPremium,
            _ => Self::UnknownValue(compute_engine_network_tier::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for ComputeEngineNetworkTier {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::NetworkTierStandard => serializer.serialize_i32(1),
            Self::NetworkTierPremium => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for ComputeEngineNetworkTier {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<ComputeEngineNetworkTier>::new(
            ".google.cloud.vmmigration.v1.ComputeEngineNetworkTier",
        ))
    }
}
