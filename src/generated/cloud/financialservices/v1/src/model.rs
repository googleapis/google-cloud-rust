// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gclient;
extern crate gtype;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// BacktestResult is created to test the performance of a model on a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BacktestResult {
    /// Output only. The resource name of the BacktestResult.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/backtestResults/{backtest_result}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp of creation of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the most recent update of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the BacktestResult (creating, active, deleting, etc.)
    pub state: crate::model::backtest_result::State,

    /// Required. The resource name of the Dataset to backtest on
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. The resource name of the Model to use or to backtest.
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Required. End_time specifies the latest time from which labels are used and
    /// from which data is used to generate features for backtesting.  End_time
    /// should be no later than the end of the date_range of the primary dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The number of consecutive months to conduct backtesting for, ending with
    /// the last full month prior to the end_time according to the dataset's
    /// timezone.
    pub backtest_periods: i32,

    /// Required. PerformanceTarget gives information on how the test will be
    /// evaluated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_target: std::option::Option<crate::model::backtest_result::PerformanceTarget>,

    /// Output only. The line of business (Retail/Commercial) this backtest is for.
    /// Determined by Model, cannot be set by user.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl BacktestResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::BacktestResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::BacktestResult::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::BacktestResult::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::BacktestResult::state].
    pub fn set_state<T: std::convert::Into<crate::model::backtest_result::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::BacktestResult::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [model][crate::model::BacktestResult::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::BacktestResult::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [backtest_periods][crate::model::BacktestResult::backtest_periods].
    pub fn set_backtest_periods<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.backtest_periods = v.into();
        self
    }

    /// Sets the value of [performance_target][crate::model::BacktestResult::performance_target].
    pub fn set_performance_target<
        T: std::convert::Into<std::option::Option<crate::model::backtest_result::PerformanceTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_target = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::BacktestResult::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::BacktestResult::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for BacktestResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.BacktestResult"
    }
}

/// Defines additional types related to BacktestResult
pub mod backtest_result {
    #[allow(unused_imports)]
    use super::*;

    /// PerformanceTarget gives hints on how to evaluate the performance of a
    /// model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceTarget {
        /// Required. A number that gives the tuner a hint on the number of parties
        /// from this data that will be investigated per period (monthly). This is
        /// used to control how the model is evaluated. For example, when trying AML
        /// AI for the first time, we recommend setting this to the number of parties
        /// investigated in an average month, based on alerts from your existing
        /// automated alerting system.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub party_investigations_per_period_hint: i64,
    }

    impl PerformanceTarget {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [party_investigations_per_period_hint][crate::model::backtest_result::PerformanceTarget::party_investigations_per_period_hint].
        pub fn set_party_investigations_per_period_hint<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.party_investigations_per_period_hint = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceTarget {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.financialservices.v1.BacktestResult.PerformanceTarget"
        }
    }

    /// The possible states of a resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of BacktestResult resources that
/// meet the specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBacktestResultsRequest {
    /// Required. The parent of the BacktestResult is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListBacktestResultsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListBacktestResultsRequest, and the last page will return an empty
    /// page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListBacktestResultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListBacktestResultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListBacktestResultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListBacktestResultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListBacktestResultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListBacktestResultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListBacktestResultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListBacktestResultsRequest"
    }
}

/// Response for retrieving a list of BacktestResults
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListBacktestResultsResponse {
    /// List of BacktestResult resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub backtest_results: std::vec::Vec<crate::model::BacktestResult>,

    /// This token should be passed to the next ListBacktestResultsRequest to
    /// retrieve the next page of BacktestResults (empty indicates we are
    /// done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListBacktestResultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListBacktestResultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [backtest_results][crate::model::ListBacktestResultsResponse::backtest_results].
    pub fn set_backtest_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::BacktestResult>,
    {
        use std::iter::Iterator;
        self.backtest_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListBacktestResultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListBacktestResultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListBacktestResultsResponse"
    }
}

impl gax::paginator::PageableResponse for ListBacktestResultsResponse {
    type PageItem = crate::model::BacktestResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.backtest_results
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific BacktestResult resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetBacktestResultRequest {
    /// Required. The resource name of the BacktestResult
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetBacktestResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetBacktestResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetBacktestResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetBacktestResultRequest"
    }
}

/// Request for creating a BacktestResult resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateBacktestResultRequest {
    /// Required. The parent of the BacktestResult is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the BacktestResult
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backtest_result_id: std::string::String,

    /// Required. The BacktestResult that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backtest_result: std::option::Option<crate::model::BacktestResult>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateBacktestResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateBacktestResultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [backtest_result_id][crate::model::CreateBacktestResultRequest::backtest_result_id].
    pub fn set_backtest_result_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.backtest_result_id = v.into();
        self
    }

    /// Sets the value of [backtest_result][crate::model::CreateBacktestResultRequest::backtest_result].
    pub fn set_backtest_result<
        T: std::convert::Into<std::option::Option<crate::model::BacktestResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backtest_result = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateBacktestResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateBacktestResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreateBacktestResultRequest"
    }
}

/// Request for updating a BacktestResult
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateBacktestResultRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// BacktestResult resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the BacktestResult fields that will be updated
    /// according to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub backtest_result: std::option::Option<crate::model::BacktestResult>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateBacktestResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateBacktestResultRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [backtest_result][crate::model::UpdateBacktestResultRequest::backtest_result].
    pub fn set_backtest_result<
        T: std::convert::Into<std::option::Option<crate::model::BacktestResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.backtest_result = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateBacktestResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateBacktestResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdateBacktestResultRequest"
    }
}

/// Request for deleting a BacktestResult.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteBacktestResultRequest {
    /// Required. The resource name of the BacktestResult.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteBacktestResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteBacktestResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteBacktestResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteBacktestResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeleteBacktestResultRequest"
    }
}

/// Request for exporting BacktestResult metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportBacktestResultMetadataRequest {
    /// Required. The resource name of the BacktestResult.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub backtest_result: std::string::String,

    /// Required. BigQuery output where the metadata will be written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub structured_metadata_destination: std::option::Option<crate::model::BigQueryDestination>,
}

impl ExportBacktestResultMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [backtest_result][crate::model::ExportBacktestResultMetadataRequest::backtest_result].
    pub fn set_backtest_result<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.backtest_result = v.into();
        self
    }

    /// Sets the value of [structured_metadata_destination][crate::model::ExportBacktestResultMetadataRequest::structured_metadata_destination].
    pub fn set_structured_metadata_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.structured_metadata_destination = v.into();
        self
    }
}

impl wkt::message::Message for ExportBacktestResultMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportBacktestResultMetadataRequest"
    }
}

/// Response for exporting BacktestResult metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportBacktestResultMetadataResponse {}

impl ExportBacktestResultMetadataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportBacktestResultMetadataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportBacktestResultMetadataResponse"
    }
}

/// BigQueryDestination is a wrapper for BigQuery output information.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BigQueryDestination {
    /// Optional. BigQuery URI to a table, must be of the form
    /// bq://projectId.bqDatasetId.tableId.
    /// Note that the BigQuery dataset must already exist.
    /// VPC-SC restrictions apply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub table_uri: std::string::String,

    /// Required. Whether or not to overwrite destination table. By default the
    /// table won't be overwritten and an error will be returned if the table
    /// exists and contains data.
    pub write_disposition: crate::model::big_query_destination::WriteDisposition,
}

impl BigQueryDestination {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [table_uri][crate::model::BigQueryDestination::table_uri].
    pub fn set_table_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_uri = v.into();
        self
    }

    /// Sets the value of [write_disposition][crate::model::BigQueryDestination::write_disposition].
    pub fn set_write_disposition<
        T: std::convert::Into<crate::model::big_query_destination::WriteDisposition>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.write_disposition = v.into();
        self
    }
}

impl wkt::message::Message for BigQueryDestination {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.BigQueryDestination"
    }
}

/// Defines additional types related to BigQueryDestination
pub mod big_query_destination {
    #[allow(unused_imports)]
    use super::*;

    /// WriteDisposition controls the behavior when the destination table already
    /// exists.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct WriteDisposition(i32);

    impl WriteDisposition {
        /// Default behavior is the same as WRITE_EMPTY.
        pub const WRITE_DISPOSITION_UNSPECIFIED: WriteDisposition = WriteDisposition::new(0);

        /// If the table already exists and contains data, an error is returned.
        pub const WRITE_EMPTY: WriteDisposition = WriteDisposition::new(1);

        /// If the table already exists, the data will be overwritten.
        pub const WRITE_TRUNCATE: WriteDisposition = WriteDisposition::new(2);

        /// Creates a new WriteDisposition instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("WRITE_DISPOSITION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("WRITE_EMPTY"),
                2 => std::borrow::Cow::Borrowed("WRITE_TRUNCATE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "WRITE_DISPOSITION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::WRITE_DISPOSITION_UNSPECIFIED)
                }
                "WRITE_EMPTY" => std::option::Option::Some(Self::WRITE_EMPTY),
                "WRITE_TRUNCATE" => std::option::Option::Some(Self::WRITE_TRUNCATE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for WriteDisposition {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for WriteDisposition {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// The Dataset resource contains summary information about a dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Dataset {
    /// Output only. The resource name of the Dataset.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp of creation of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the most recent update of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The set of BigQuery tables in the dataset.  The key should be the
    /// table type and the value should be the BigQuery tables in the format
    /// `bq://{project}.{dataset}.{table}`.
    /// Current table types are:
    ///
    /// * `party`
    /// * `account_party_link`
    /// * `transaction`
    /// * `risk_case_event`
    /// * `party_supplementary_data`
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub table_specs: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the dataset (creating, active, deleting, etc.)
    pub state: crate::model::dataset::State,

    /// Required. Core time window of the dataset. All tables should have complete
    /// data covering this period.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub date_range: std::option::Option<gtype::model::Interval>,

    /// The timezone of the data, default will act as UTC.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub time_zone: std::option::Option<gtype::model::TimeZone>,
}

impl Dataset {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Dataset::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Dataset::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Dataset::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Dataset::state].
    pub fn set_state<T: std::convert::Into<crate::model::dataset::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [date_range][crate::model::Dataset::date_range].
    pub fn set_date_range<T: std::convert::Into<std::option::Option<gtype::model::Interval>>>(
        mut self,
        v: T,
    ) -> Self {
        self.date_range = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::Dataset::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::option::Option<gtype::model::TimeZone>>>(
        mut self,
        v: T,
    ) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Dataset::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [table_specs][crate::model::Dataset::table_specs].
    pub fn set_table_specs<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.table_specs = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Dataset {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.Dataset"
    }
}

/// Defines additional types related to Dataset
pub mod dataset {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states of a resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of Dataset resources that meet the
/// specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsRequest {
    /// Required. The parent of the Dataset is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListDatasetResponse. It should be copied here to retrieve the
    /// next page of resources. Empty will give the first page of
    /// ListDatasetRequest, and the last page will return an empty page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDatasetsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDatasetsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDatasetsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDatasetsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDatasetsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDatasetsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDatasetsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListDatasetsRequest"
    }
}

/// Response for retrieving a list of Datasets
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDatasetsResponse {
    /// List of Dataset resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub datasets: std::vec::Vec<crate::model::Dataset>,

    /// This token should be passed to the next ListDatasetsRequest to retrieve
    /// the next page of Datasets (empty indicates we are done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListDatasetsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDatasetsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [datasets][crate::model::ListDatasetsResponse::datasets].
    pub fn set_datasets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Dataset>,
    {
        use std::iter::Iterator;
        self.datasets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDatasetsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDatasetsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListDatasetsResponse"
    }
}

impl gax::paginator::PageableResponse for ListDatasetsResponse {
    type PageItem = crate::model::Dataset;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.datasets
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific Dataset resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDatasetRequest {
    /// Required. The resource name of the Dataset
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetDatasetRequest"
    }
}

/// Request for creating a Dataset resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateDatasetRequest {
    /// Required. The parent of the Dataset is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the dataset
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset_id: std::string::String,

    /// Required. The dataset that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateDatasetRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [dataset_id][crate::model::CreateDatasetRequest::dataset_id].
    pub fn set_dataset_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset_id = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::CreateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateDatasetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreateDatasetRequest"
    }
}

/// Request for updating a Dataset
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDatasetRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Dataset resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the dataset fields that will be updated
    /// according to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::Dataset>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDatasetRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::UpdateDatasetRequest::dataset].
    pub fn set_dataset<T: std::convert::Into<std::option::Option<crate::model::Dataset>>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateDatasetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdateDatasetRequest"
    }
}

/// Request for deleting a Dataset.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDatasetRequest {
    /// Required. The resource name of the Dataset.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteDatasetRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDatasetRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteDatasetRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDatasetRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeleteDatasetRequest"
    }
}

/// The EngineConfig resource creates the configuration for training a model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EngineConfig {
    /// Output only. The resource name of the EngineConfig.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engine_config}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp of creation of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the most recent update of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the EngineConfig (creating, active, deleting, etc.)
    pub state: crate::model::engine_config::State,

    /// Required. The resource name of the EngineVersion used in this model tuning.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Optional. Configuration for tuning in creation of the EngineConfig.
    /// This field is required if `hyperparameter_source.type` is not `INHERITED`,
    /// and output-only otherwise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub tuning: std::option::Option<crate::model::engine_config::Tuning>,

    /// Optional. PerformanceTarget gives information on how the tuning and
    /// training will be evaluated. This field is required if
    /// `hyperparameter_source.type` is not `INHERITED`, and output-only otherwise.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub performance_target: std::option::Option<crate::model::engine_config::PerformanceTarget>,

    /// Output only. The line of business (Retail/Commercial) this engine config is
    /// used for. Determined by EngineVersion, cannot be set by user.
    pub line_of_business: crate::model::LineOfBusiness,

    /// Optional. The origin of hyperparameters for the created EngineConfig. The
    /// default is `TUNING`. In this case, the hyperparameters are selected as a
    /// result of a
    /// tuning run.
    pub hyperparameter_source_type: crate::model::engine_config::HyperparameterSourceType,

    /// Optional. Configuration of hyperparameters source EngineConfig.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub hyperparameter_source:
        std::option::Option<crate::model::engine_config::HyperparameterSource>,
}

impl EngineConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EngineConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::EngineConfig::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::EngineConfig::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::EngineConfig::state].
    pub fn set_state<T: std::convert::Into<crate::model::engine_config::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [engine_version][crate::model::EngineConfig::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [tuning][crate::model::EngineConfig::tuning].
    pub fn set_tuning<
        T: std::convert::Into<std::option::Option<crate::model::engine_config::Tuning>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.tuning = v.into();
        self
    }

    /// Sets the value of [performance_target][crate::model::EngineConfig::performance_target].
    pub fn set_performance_target<
        T: std::convert::Into<std::option::Option<crate::model::engine_config::PerformanceTarget>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.performance_target = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::EngineConfig::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }

    /// Sets the value of [hyperparameter_source_type][crate::model::EngineConfig::hyperparameter_source_type].
    pub fn set_hyperparameter_source_type<
        T: std::convert::Into<crate::model::engine_config::HyperparameterSourceType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperparameter_source_type = v.into();
        self
    }

    /// Sets the value of [hyperparameter_source][crate::model::EngineConfig::hyperparameter_source].
    pub fn set_hyperparameter_source<
        T: std::convert::Into<std::option::Option<crate::model::engine_config::HyperparameterSource>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.hyperparameter_source = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::EngineConfig::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for EngineConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.EngineConfig"
    }
}

/// Defines additional types related to EngineConfig
pub mod engine_config {
    #[allow(unused_imports)]
    use super::*;

    /// The parameters needed for the tuning operation, these are used only in
    /// tuning and not passed on to training.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Tuning {
        /// Required. The resource name of the Primary Dataset used in this model
        /// tuning. For information about how primary and auxiliary datasets are
        /// used, refer to the engine version's documentation.  Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub primary_dataset: std::string::String,

        /// Required. End_time specifies the latest time from which labels are used
        /// and from which data is used to generate features for tuning.  End_time
        /// should be no later than the end of the date_range of the dataset.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub end_time: std::option::Option<wkt::Timestamp>,
    }

    impl Tuning {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [primary_dataset][crate::model::engine_config::Tuning::primary_dataset].
        pub fn set_primary_dataset<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.primary_dataset = v.into();
            self
        }

        /// Sets the value of [end_time][crate::model::engine_config::Tuning::end_time].
        pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.end_time = v.into();
            self
        }
    }

    impl wkt::message::Message for Tuning {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.financialservices.v1.EngineConfig.Tuning"
        }
    }

    /// PerformanceTarget gives hints on how to evaluate the performance of a
    /// model.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct PerformanceTarget {
        /// Required. A number that gives the tuner a hint on the number of parties
        /// from this data that will be investigated per period (monthly). This is
        /// used to control how the model is evaluated. For example, when trying AML
        /// AI for the first time, we recommend setting this to the number of parties
        /// investigated in an average month, based on alerts from your existing
        /// automated alerting system.
        #[serde_as(as = "serde_with::DisplayFromStr")]
        pub party_investigations_per_period_hint: i64,
    }

    impl PerformanceTarget {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [party_investigations_per_period_hint][crate::model::engine_config::PerformanceTarget::party_investigations_per_period_hint].
        pub fn set_party_investigations_per_period_hint<T: std::convert::Into<i64>>(
            mut self,
            v: T,
        ) -> Self {
            self.party_investigations_per_period_hint = v.into();
            self
        }
    }

    impl wkt::message::Message for PerformanceTarget {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.financialservices.v1.EngineConfig.PerformanceTarget"
        }
    }

    /// Parameters for bootstrapping an Engine Config with the results of another
    /// one.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct HyperparameterSource {
        /// Required. The resource name of the source EngineConfig whose outputs are
        /// used. Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engine_config}"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_engine_config: std::string::String,

        /// Output only. The resource name of the EngineVersion that was used in the
        /// tuning run. Format:
        /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub source_engine_version: std::string::String,
    }

    impl HyperparameterSource {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [source_engine_config][crate::model::engine_config::HyperparameterSource::source_engine_config].
        pub fn set_source_engine_config<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_engine_config = v.into();
            self
        }

        /// Sets the value of [source_engine_version][crate::model::engine_config::HyperparameterSource::source_engine_version].
        pub fn set_source_engine_version<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.source_engine_version = v.into();
            self
        }
    }

    impl wkt::message::Message for HyperparameterSource {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.financialservices.v1.EngineConfig.HyperparameterSource"
        }
    }

    /// The possible states of a resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// The type of the hyperparameter source.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct HyperparameterSourceType(i32);

    impl HyperparameterSourceType {
        /// Hyperparameter source type is unspecified, defaults to TUNING.
        pub const HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED: HyperparameterSourceType =
            HyperparameterSourceType::new(0);

        /// The EngineConfig creation starts a tuning job which selects the best
        /// hyperparameters.
        pub const TUNING: HyperparameterSourceType = HyperparameterSourceType::new(1);

        /// The hyperparameters are inherited from another EngineConfig.
        pub const INHERITED: HyperparameterSourceType = HyperparameterSourceType::new(2);

        /// Creates a new HyperparameterSourceType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("TUNING"),
                2 => std::borrow::Cow::Borrowed("INHERITED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::HYPERPARAMETER_SOURCE_TYPE_UNSPECIFIED)
                }
                "TUNING" => std::option::Option::Some(Self::TUNING),
                "INHERITED" => std::option::Option::Some(Self::INHERITED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for HyperparameterSourceType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for HyperparameterSourceType {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of EngineConfig resources that
/// meet the specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEngineConfigsRequest {
    /// Required. The parent of the EngineConfig is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListEngineConfigsResponse. It should be copied here to retrieve
    /// the next page of resources. Empty will give the first page of
    /// ListEngineConfigsRequest, and the last page will return an empty
    /// page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEngineConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEngineConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEngineConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEngineConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEngineConfigsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEngineConfigsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEngineConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListEngineConfigsRequest"
    }
}

/// Response for retrieving a list of EngineConfigs
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEngineConfigsResponse {
    /// List of EngineConfig resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub engine_configs: std::vec::Vec<crate::model::EngineConfig>,

    /// This token should be passed to the next ListEngineConfigsRequest to
    /// retrieve the next page of EngineConfigs (empty indicates we are done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListEngineConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEngineConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [engine_configs][crate::model::ListEngineConfigsResponse::engine_configs].
    pub fn set_engine_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EngineConfig>,
    {
        use std::iter::Iterator;
        self.engine_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEngineConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEngineConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListEngineConfigsResponse"
    }
}

impl gax::paginator::PageableResponse for ListEngineConfigsResponse {
    type PageItem = crate::model::EngineConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.engine_configs
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific EngineConfig resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEngineConfigRequest {
    /// Required. The resource name of the EngineConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEngineConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEngineConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEngineConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetEngineConfigRequest"
    }
}

/// Request for creating an EngineConfig resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEngineConfigRequest {
    /// Required. The parent of the EngineConfig is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the EngineConfig
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_config_id: std::string::String,

    /// Required. The EngineConfig that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub engine_config: std::option::Option<crate::model::EngineConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateEngineConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEngineConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [engine_config_id][crate::model::CreateEngineConfigRequest::engine_config_id].
    pub fn set_engine_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config_id = v.into();
        self
    }

    /// Sets the value of [engine_config][crate::model::CreateEngineConfigRequest::engine_config].
    pub fn set_engine_config<
        T: std::convert::Into<std::option::Option<crate::model::EngineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEngineConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEngineConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreateEngineConfigRequest"
    }
}

/// Request for updating an EngineConfig
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEngineConfigRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// EngineConfig resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the EngineConfig fields that will be updated
    /// according to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub engine_config: std::option::Option<crate::model::EngineConfig>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateEngineConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateEngineConfigRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [engine_config][crate::model::UpdateEngineConfigRequest::engine_config].
    pub fn set_engine_config<
        T: std::convert::Into<std::option::Option<crate::model::EngineConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.engine_config = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateEngineConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEngineConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdateEngineConfigRequest"
    }
}

/// Request for deleting an EngineConfig.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEngineConfigRequest {
    /// Required. The resource name of the EngineConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteEngineConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEngineConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEngineConfigRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEngineConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeleteEngineConfigRequest"
    }
}

/// Request for exporting EngineConfig metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEngineConfigMetadataRequest {
    /// Required. The resource name of the EngineConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_config: std::string::String,

    /// Required. BigQuery output where the metadata will be written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub structured_metadata_destination: std::option::Option<crate::model::BigQueryDestination>,
}

impl ExportEngineConfigMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [engine_config][crate::model::ExportEngineConfigMetadataRequest::engine_config].
    pub fn set_engine_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_config = v.into();
        self
    }

    /// Sets the value of [structured_metadata_destination][crate::model::ExportEngineConfigMetadataRequest::structured_metadata_destination].
    pub fn set_structured_metadata_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.structured_metadata_destination = v.into();
        self
    }
}

impl wkt::message::Message for ExportEngineConfigMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportEngineConfigMetadataRequest"
    }
}

/// Response for exporting EngineConfig metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportEngineConfigMetadataResponse {}

impl ExportEngineConfigMetadataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportEngineConfigMetadataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportEngineConfigMetadataResponse"
    }
}

/// EngineVersion controls which version of the engine is used to tune, train,
/// and run the model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct EngineVersion {
    /// Output only. Identifier. The resource name of the EngineVersion
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineVersions/{engine_version}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The state of the version.
    pub state: crate::model::engine_version::State,

    /// Output only. Planned time to stop allowing training/tuning using this
    /// version. Existing trained models can still be used for prediction/backtest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expected_limitation_start_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Planned time to stop supporting the version, in addition
    /// to no training or tuning, models trained on this version
    /// can no longer be used for prediction/backtest.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expected_decommission_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The line of business (Retail/Commercial) this engine version
    /// is used for.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl EngineVersion {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::EngineVersion::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [state][crate::model::EngineVersion::state].
    pub fn set_state<T: std::convert::Into<crate::model::engine_version::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [expected_limitation_start_time][crate::model::EngineVersion::expected_limitation_start_time].
    pub fn set_expected_limitation_start_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_limitation_start_time = v.into();
        self
    }

    /// Sets the value of [expected_decommission_time][crate::model::EngineVersion::expected_decommission_time].
    pub fn set_expected_decommission_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.expected_decommission_time = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::EngineVersion::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }
}

impl wkt::message::Message for EngineVersion {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.EngineVersion"
    }
}

/// Defines additional types related to EngineVersion
pub mod engine_version {
    #[allow(unused_imports)]
    use super::*;

    /// State determines the lifecycle of a version and the models/engine configs
    /// trained with it.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Default state, should never be used.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// Version is available for training and inference.
        pub const ACTIVE: State = State::new(1);

        /// Models using this version can still be run, but new ones cannot be
        /// trained.
        pub const LIMITED: State = State::new(2);

        /// Version is deprecated, listed for informational purposes only.
        pub const DECOMMISSIONED: State = State::new(3);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("ACTIVE"),
                2 => std::borrow::Cow::Borrowed("LIMITED"),
                3 => std::borrow::Cow::Borrowed("DECOMMISSIONED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "LIMITED" => std::option::Option::Some(Self::LIMITED),
                "DECOMMISSIONED" => std::option::Option::Some(Self::DECOMMISSIONED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of EngineVersion resources that meet
/// the specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEngineVersionsRequest {
    /// Required. The parent of the EngineVersion is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The number of resources to be included in the response. The
    /// response contains a next_page_token, which can be used to retrieve the next
    /// page of resources.
    pub page_size: i32,

    /// Optional. In case of paginated results, this is the token that was returned
    /// in the previous ListEngineVersionsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListEngineVersionsRequest, and the last page will return an empty
    /// page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Specify a filter to narrow search results.
    /// If empty or unset will default to "state!=DEPRECATED",
    /// to view deprecated versions use "state:*" or any other filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEngineVersionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEngineVersionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEngineVersionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEngineVersionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEngineVersionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEngineVersionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEngineVersionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListEngineVersionsRequest"
    }
}

/// The response to a list call containing the list of engine versions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEngineVersionsResponse {
    /// List of EngineVersion resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub engine_versions: std::vec::Vec<crate::model::EngineVersion>,

    /// This token should be passed to the next EngineVersionsRequest to retrieve
    /// the next page of EngineVersions (empty indicates we are done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListEngineVersionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEngineVersionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [engine_versions][crate::model::ListEngineVersionsResponse::engine_versions].
    pub fn set_engine_versions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::EngineVersion>,
    {
        use std::iter::Iterator;
        self.engine_versions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEngineVersionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEngineVersionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListEngineVersionsResponse"
    }
}

impl gax::paginator::PageableResponse for ListEngineVersionsResponse {
    type PageItem = crate::model::EngineVersion;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.engine_versions
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific EngineVersion resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEngineVersionRequest {
    /// Required. The resource name of the EngineVersion
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEngineVersionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEngineVersionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEngineVersionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetEngineVersionRequest"
    }
}

/// Instance is a container for the rest of API resources.
/// Only resources in the same instance can interact with each other.
/// Child resources inherit the location (data residency) and encryption (CMEK).
/// The location of the provided input and output in requests must match the
/// location of the instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Timestamp when the Instance was created.
    /// Assigned by the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Timestamp when the Instance was last updated.
    /// Assigned by the server.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. State of the instance.
    /// Assigned by the server.
    pub state: crate::model::instance::State,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Required. The KMS key name used for CMEK (encryption-at-rest).
    /// format:
    /// "projects/{project}/locations/{location}/keyRings/{keyRing}/cryptoKeys/{cryptoKey}"
    /// VPC-SC restrictions apply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::instance::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::Instance::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// The Resource State
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of Instance resources that meet the
/// specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. The parent of the Instance is the location for that Instance.
    /// Every location has exactly one instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListInstancesResponse. It should be copied here to retrieve the
    /// next page of resources. This will be empty for the first instance of
    /// ListInstancesRequest.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListInstancesRequest"
    }
}

/// Response for retrieving a list of Instances
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// List of Instance resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// This token should be passed to the next ListInstancesRequest to retrieve
    /// the next page of Instances.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListInstancesResponse"
    }
}

impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific Instance resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. The resource name of the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetInstanceRequest"
    }
}

/// Request for creating a Instance resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. The parent of the Instance is the location for that Instance.
    /// Every location has exactly one instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreateInstanceRequest"
    }
}

/// Request for updating a Instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Instance resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the instance fields that will be updated
    /// according to the update_mask
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdateInstanceRequest"
    }
}

/// Request for deleting a Instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. The resource name of the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeleteInstanceRequest"
    }
}

/// Request for adding/removing registered parties from BigQuery tables
/// specified by the customer.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRegisteredPartiesRequest {
    /// Required. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. List of BigQuery tables. Union of tables will be taken if there
    /// is more than one table. VPC-SC restrictions apply. format:
    /// "bq://{project}.{bqDatasetID}.{bqTableID}" Use of `datasets` is preferred
    /// over the latter due to its simplicity and the reduced risk of errors
    /// `party_tables` and `datasets` must not be provided at the
    /// same time
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub party_tables: std::vec::Vec<std::string::String>,

    /// Required. Mode of the request.
    pub mode: crate::model::import_registered_parties_request::UpdateMode,

    /// Optional. Is the request will not register the parties, just determine what
    /// woud happen.
    pub validate_only: bool,

    /// Required. LineOfBusiness for the specified registered parties.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl ImportRegisteredPartiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ImportRegisteredPartiesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [mode][crate::model::ImportRegisteredPartiesRequest::mode].
    pub fn set_mode<
        T: std::convert::Into<crate::model::import_registered_parties_request::UpdateMode>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.mode = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::ImportRegisteredPartiesRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::ImportRegisteredPartiesRequest::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }

    /// Sets the value of [party_tables][crate::model::ImportRegisteredPartiesRequest::party_tables].
    pub fn set_party_tables<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.party_tables = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ImportRegisteredPartiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ImportRegisteredPartiesRequest"
    }
}

/// Defines additional types related to ImportRegisteredPartiesRequest
pub mod import_registered_parties_request {
    #[allow(unused_imports)]
    use super::*;

    /// UpdateMode controls the behavior for ImportRegisteredParties.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct UpdateMode(i32);

    impl UpdateMode {
        /// Default mode.
        pub const UPDATE_MODE_UNSPECIFIED: UpdateMode = UpdateMode::new(0);

        /// Replace parties that are removable in Parties Table with new parties.
        pub const REPLACE: UpdateMode = UpdateMode::new(1);

        /// Add new parties to Parties Table.
        pub const APPEND: UpdateMode = UpdateMode::new(2);

        /// Creates a new UpdateMode instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("UPDATE_MODE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("REPLACE"),
                2 => std::borrow::Cow::Borrowed("APPEND"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "UPDATE_MODE_UNSPECIFIED" => {
                    std::option::Option::Some(Self::UPDATE_MODE_UNSPECIFIED)
                }
                "REPLACE" => std::option::Option::Some(Self::REPLACE),
                "APPEND" => std::option::Option::Some(Self::APPEND),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for UpdateMode {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for UpdateMode {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Response for adding/removing registered parties from BigQuery tables.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ImportRegisteredPartiesResponse {
    /// Number of parties added by this operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_added: i64,

    /// Number of parties removed by this operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_removed: i64,

    /// Total number of parties that are registered in this instance, after the
    /// update operation was completed.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_total: i64,

    /// Number of parties that failed to be removed by this operation.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_failed_to_remove: i64,

    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_uptiered: i64,

    /// Total number of parties that are downtiered in this instance
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_downtiered: i64,

    /// Number of parties that failed to be downtiered
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub parties_failed_to_downtier: i64,
}

impl ImportRegisteredPartiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parties_added][crate::model::ImportRegisteredPartiesResponse::parties_added].
    pub fn set_parties_added<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_added = v.into();
        self
    }

    /// Sets the value of [parties_removed][crate::model::ImportRegisteredPartiesResponse::parties_removed].
    pub fn set_parties_removed<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_removed = v.into();
        self
    }

    /// Sets the value of [parties_total][crate::model::ImportRegisteredPartiesResponse::parties_total].
    pub fn set_parties_total<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_total = v.into();
        self
    }

    /// Sets the value of [parties_failed_to_remove][crate::model::ImportRegisteredPartiesResponse::parties_failed_to_remove].
    pub fn set_parties_failed_to_remove<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_failed_to_remove = v.into();
        self
    }

    /// Sets the value of [parties_uptiered][crate::model::ImportRegisteredPartiesResponse::parties_uptiered].
    pub fn set_parties_uptiered<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_uptiered = v.into();
        self
    }

    /// Sets the value of [parties_downtiered][crate::model::ImportRegisteredPartiesResponse::parties_downtiered].
    pub fn set_parties_downtiered<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_downtiered = v.into();
        self
    }

    /// Sets the value of [parties_failed_to_downtier][crate::model::ImportRegisteredPartiesResponse::parties_failed_to_downtier].
    pub fn set_parties_failed_to_downtier<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.parties_failed_to_downtier = v.into();
        self
    }
}

impl wkt::message::Message for ImportRegisteredPartiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ImportRegisteredPartiesResponse"
    }
}

/// Request to export a list of currently registered parties.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportRegisteredPartiesRequest {
    /// Required. The full path to the Instance resource in this API.
    /// format: "projects/{project}/locations/{location}/instances/{instance}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The location to output the RegisteredParties.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub dataset: std::option::Option<crate::model::BigQueryDestination>,

    /// Required. LineOfBusiness to get RegisteredParties from.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl ExportRegisteredPartiesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ExportRegisteredPartiesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::ExportRegisteredPartiesRequest::dataset].
    pub fn set_dataset<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::ExportRegisteredPartiesRequest::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }
}

impl wkt::message::Message for ExportRegisteredPartiesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportRegisteredPartiesRequest"
    }
}

/// Response to export registered parties request.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportRegisteredPartiesResponse {}

impl ExportRegisteredPartiesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportRegisteredPartiesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportRegisteredPartiesResponse"
    }
}

/// Model represents a trained model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Model {
    /// Output only. The resource name of the Model.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp of creation of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the most recent update of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the model (creating, active, deleting, etc.)
    pub state: crate::model::model::State,

    /// Output only. The EngineVersion used in training this model.  This is output
    /// only, and is determined from the EngineConfig used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_version: std::string::String,

    /// Required. The resource name of the EngineConfig the model training will be
    /// based on. Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/engineConfigs/{engineConfig}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub engine_config: std::string::String,

    /// Required. The resource name of the Primary Dataset used in this model
    /// training. For information about how primary and auxiliary datasets are
    /// used, refer to the engine version's documentation.  Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/datasets/{dataset}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub primary_dataset: std::string::String,

    /// Required. End_time specifies the latest time from which labels are used and
    /// from which data is used to generate features for training.  End_time should
    /// be no later than the end of the date_range of the dataset.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The line of business (Retail/Commercial) this model is used
    /// for. Determined by EngineConfig, cannot be set by user.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl Model {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Model::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Model::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Model::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Model::state].
    pub fn set_state<T: std::convert::Into<crate::model::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [engine_version][crate::model::Model::engine_version].
    pub fn set_engine_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_version = v.into();
        self
    }

    /// Sets the value of [engine_config][crate::model::Model::engine_config].
    pub fn set_engine_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.engine_config = v.into();
        self
    }

    /// Sets the value of [primary_dataset][crate::model::Model::primary_dataset].
    pub fn set_primary_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.primary_dataset = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::Model::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::Model::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Model::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Model {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.Model"
    }
}

/// Defines additional types related to Model
pub mod model {
    #[allow(unused_imports)]
    use super::*;

    /// The possible states of a resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of Model resources that meet the
/// specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsRequest {
    /// Required. The parent of the Model is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListModelsResponse. It should be copied here to retrieve the next
    /// page of resources. Empty will give the first page of ListModelsRequest, and
    /// the last page will return an empty page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListModelsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListModelsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListModelsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListModelsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListModelsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListModelsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListModelsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListModelsRequest"
    }
}

/// Response for retrieving a list of Models
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListModelsResponse {
    /// List of Model resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub models: std::vec::Vec<crate::model::Model>,

    /// This token should be passed to the next ListModelsRequest to
    /// retrieve the next page of Models (empty indicicates we are done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListModelsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListModelsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [models][crate::model::ListModelsResponse::models].
    pub fn set_models<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Model>,
    {
        use std::iter::Iterator;
        self.models = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListModelsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListModelsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListModelsResponse"
    }
}

impl gax::paginator::PageableResponse for ListModelsResponse {
    type PageItem = crate::model::Model;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.models
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific Model resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetModelRequest {
    /// Required. The resource name of the Model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetModelRequest"
    }
}

/// Request for creating a Model resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateModelRequest {
    /// Required. The parent of the Model is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the Model
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model_id: std::string::String,

    /// Required. The Model that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateModelRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [model_id][crate::model::CreateModelRequest::model_id].
    pub fn set_model_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model_id = v.into();
        self
    }

    /// Sets the value of [model][crate::model::CreateModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateModelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreateModelRequest"
    }
}

/// Request for updating a Model
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateModelRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// Model resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the Model fields that will be updated according
    /// to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub model: std::option::Option<crate::model::Model>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateModelRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [model][crate::model::UpdateModelRequest::model].
    pub fn set_model<T: std::convert::Into<std::option::Option<crate::model::Model>>>(
        mut self,
        v: T,
    ) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateModelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdateModelRequest"
    }
}

/// Request for deleting a Model.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteModelRequest {
    /// Required. The resource name of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteModelRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteModelRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteModelRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteModelRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeleteModelRequest"
    }
}

/// Request for exporting Model metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelMetadataRequest {
    /// Required. The resource name of the Model.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Required. BigQuery output where the metadata will be written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub structured_metadata_destination: std::option::Option<crate::model::BigQueryDestination>,
}

impl ExportModelMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [model][crate::model::ExportModelMetadataRequest::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [structured_metadata_destination][crate::model::ExportModelMetadataRequest::structured_metadata_destination].
    pub fn set_structured_metadata_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.structured_metadata_destination = v.into();
        self
    }
}

impl wkt::message::Message for ExportModelMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportModelMetadataRequest"
    }
}

/// Response for exporting Model metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportModelMetadataResponse {}

impl ExportModelMetadataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportModelMetadataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportModelMetadataResponse"
    }
}

/// PredictionResult is the result of using a model to create predictions.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PredictionResult {
    /// Output only. The resource name of the PredictionResult.
    /// format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/predictionResults/{prediction_result}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The timestamp of creation of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of the most recent update of this resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Labels
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. State of the PredictionResult (creating, active, deleting,
    /// etc.)
    pub state: crate::model::prediction_result::State,

    /// Required. The resource name of the Dataset to do predictions on
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/dataset/{dataset_id}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub dataset: std::string::String,

    /// Required. The resource name of the Model to use to use to make predictions
    /// Format:
    /// "/projects/{project_num}/locations/{location}/instances/{instance}/models/{model}"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub model: std::string::String,

    /// Required. Specifies the latest time from which data is used to generate
    /// features for predictions.  This time should be no later than the end of the
    /// [date_range][google.cloud.financialservices.v1.Dataset.date_range] of the
    /// dataset.
    ///
    /// [google.cloud.financialservices.v1.Dataset.date_range]: crate::model::Dataset::date_range
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// The number of consecutive months to produce predictions for, ending with
    /// the last full month prior to
    /// [end_time][google.cloud.financialservices.v1.PredictionResult.end_time]
    /// according to the dataset's timezone.
    ///
    /// [google.cloud.financialservices.v1.PredictionResult.end_time]: crate::model::PredictionResult::end_time
    pub prediction_periods: i32,

    /// Required. Where to write the output of the predictions.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub outputs: std::option::Option<crate::model::prediction_result::Outputs>,

    /// Output only. The line of business (Retail/Commercial) this prediction is
    /// for. Determined by Model, cannot be set by user.
    pub line_of_business: crate::model::LineOfBusiness,
}

impl PredictionResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PredictionResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::PredictionResult::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::PredictionResult::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::PredictionResult::state].
    pub fn set_state<T: std::convert::Into<crate::model::prediction_result::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [dataset][crate::model::PredictionResult::dataset].
    pub fn set_dataset<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.dataset = v.into();
        self
    }

    /// Sets the value of [model][crate::model::PredictionResult::model].
    pub fn set_model<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.model = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::PredictionResult::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [prediction_periods][crate::model::PredictionResult::prediction_periods].
    pub fn set_prediction_periods<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.prediction_periods = v.into();
        self
    }

    /// Sets the value of [outputs][crate::model::PredictionResult::outputs].
    pub fn set_outputs<
        T: std::convert::Into<std::option::Option<crate::model::prediction_result::Outputs>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.outputs = v.into();
        self
    }

    /// Sets the value of [line_of_business][crate::model::PredictionResult::line_of_business].
    pub fn set_line_of_business<T: std::convert::Into<crate::model::LineOfBusiness>>(
        mut self,
        v: T,
    ) -> Self {
        self.line_of_business = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::PredictionResult::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for PredictionResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.PredictionResult"
    }
}

/// Defines additional types related to PredictionResult
pub mod prediction_result {
    #[allow(unused_imports)]
    use super::*;

    /// Outputs is a list of places where the operation will write results.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Outputs {
        /// Required. The location to output the predictions.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub prediction_destination: std::option::Option<crate::model::BigQueryDestination>,

        /// The location to output explainability information.  If not specified
        /// no explainability data will be output.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub explainability_destination: std::option::Option<crate::model::BigQueryDestination>,
    }

    impl Outputs {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [prediction_destination][crate::model::prediction_result::Outputs::prediction_destination].
        pub fn set_prediction_destination<
            T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.prediction_destination = v.into();
            self
        }

        /// Sets the value of [explainability_destination][crate::model::prediction_result::Outputs::explainability_destination].
        pub fn set_explainability_destination<
            T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.explainability_destination = v.into();
            self
        }
    }

    impl wkt::message::Message for Outputs {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.financialservices.v1.PredictionResult.Outputs"
        }
    }

    /// The possible states of a resource.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// State is unspecified, should not occur.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The resource has not finished being created.
        pub const CREATING: State = State::new(1);

        /// The resource is active/ready to be used.
        pub const ACTIVE: State = State::new(2);

        /// The resource is in the process of being updated.
        pub const UPDATING: State = State::new(3);

        /// The resource is in the process of being deleted.
        pub const DELETING: State = State::new(4);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("ACTIVE"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "ACTIVE" => std::option::Option::Some(Self::ACTIVE),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Request for retrieving a paginated list of PredictionResult resources that
/// meet the specified criteria.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPredictionResultsRequest {
    /// Required. The parent of the PredictionResult is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// The number of resources to be included in the response. The response
    /// contains a next_page_token, which can be used to retrieve the next page of
    /// resources.
    pub page_size: i32,

    /// In case of paginated results, this is the token that was returned in the
    /// previous ListPredictionResultsResponse. It should be copied here to
    /// retrieve the next page of resources. Empty will give the first page of
    /// ListPredictionResultsRequest, and the last page will return an empty
    /// page_token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Specify a filter to narrow search results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Specify a field to use for ordering.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListPredictionResultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListPredictionResultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListPredictionResultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListPredictionResultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListPredictionResultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListPredictionResultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListPredictionResultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListPredictionResultsRequest"
    }
}

/// Response for retrieving a list of PredictionResults
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListPredictionResultsResponse {
    /// List of PredictionResult resources
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub prediction_results: std::vec::Vec<crate::model::PredictionResult>,

    /// This token should be passed to the next ListPredictionResultsRequest to
    /// retrieve the next page of PredictionResults (empty indicicates we are
    /// done).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListPredictionResultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListPredictionResultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [prediction_results][crate::model::ListPredictionResultsResponse::prediction_results].
    pub fn set_prediction_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::PredictionResult>,
    {
        use std::iter::Iterator;
        self.prediction_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListPredictionResultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListPredictionResultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ListPredictionResultsResponse"
    }
}

impl gax::paginator::PageableResponse for ListPredictionResultsResponse {
    type PageItem = crate::model::PredictionResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.prediction_results
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for retrieving a specific PredictionResult resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetPredictionResultRequest {
    /// Required. The resource name of the PredictionResult
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetPredictionResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetPredictionResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetPredictionResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.GetPredictionResultRequest"
    }
}

/// Request for creating a PredictionResult resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreatePredictionResultRequest {
    /// Required. The parent of the PredictionResult is the Instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource id of the PredictionResult
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prediction_result_id: std::string::String,

    /// Required. The PredictionResult that will be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_result: std::option::Option<crate::model::PredictionResult>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreatePredictionResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreatePredictionResultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [prediction_result_id][crate::model::CreatePredictionResultRequest::prediction_result_id].
    pub fn set_prediction_result_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_result_id = v.into();
        self
    }

    /// Sets the value of [prediction_result][crate::model::CreatePredictionResultRequest::prediction_result].
    pub fn set_prediction_result<
        T: std::convert::Into<std::option::Option<crate::model::PredictionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_result = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreatePredictionResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreatePredictionResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.CreatePredictionResultRequest"
    }
}

/// Request for updating a PredictionResult
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdatePredictionResultRequest {
    /// Optional. Field mask is used to specify the fields to be overwritten in the
    /// PredictionResult resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The new value of the PredictionResult fields that will be updated
    /// according to the update_mask.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub prediction_result: std::option::Option<crate::model::PredictionResult>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdatePredictionResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdatePredictionResultRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [prediction_result][crate::model::UpdatePredictionResultRequest::prediction_result].
    pub fn set_prediction_result<
        T: std::convert::Into<std::option::Option<crate::model::PredictionResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_result = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdatePredictionResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdatePredictionResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.UpdatePredictionResultRequest"
    }
}

/// Request for deleting a PredictionResult.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeletePredictionResultRequest {
    /// Required. The resource name of the PredictionResult.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeletePredictionResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeletePredictionResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeletePredictionResultRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeletePredictionResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.DeletePredictionResultRequest"
    }
}

/// Request for exporting PredictionResult metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportPredictionResultMetadataRequest {
    /// Required. The resource name of the PredictionResult.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub prediction_result: std::string::String,

    /// Required. BigQuery output where the metadata will be written.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub structured_metadata_destination: std::option::Option<crate::model::BigQueryDestination>,
}

impl ExportPredictionResultMetadataRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [prediction_result][crate::model::ExportPredictionResultMetadataRequest::prediction_result].
    pub fn set_prediction_result<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.prediction_result = v.into();
        self
    }

    /// Sets the value of [structured_metadata_destination][crate::model::ExportPredictionResultMetadataRequest::structured_metadata_destination].
    pub fn set_structured_metadata_destination<
        T: std::convert::Into<std::option::Option<crate::model::BigQueryDestination>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.structured_metadata_destination = v.into();
        self
    }
}

impl wkt::message::Message for ExportPredictionResultMetadataRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportPredictionResultMetadataRequest"
    }
}

/// Response for exporting PredictionResult metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ExportPredictionResultMetadataResponse {}

impl ExportPredictionResultMetadataResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ExportPredictionResultMetadataResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.ExportPredictionResultMetadataResponse"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    /// format: "/projects/{project}/..."
    /// VPC-SC restrictions apply.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation of the
    /// operation.
    ///
    /// Successfully cancelled operations have a
    /// [google.longrunning.Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.financialservices.v1.OperationMetadata"
    }
}

/// Indicate which LineOfBusiness a party belongs to.
#[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
pub struct LineOfBusiness(i32);

impl LineOfBusiness {
    /// An unspecified LineOfBusiness. Do not use.
    pub const LINE_OF_BUSINESS_UNSPECIFIED: LineOfBusiness = LineOfBusiness::new(0);

    /// Commercial LineOfBusiness.
    pub const COMMERCIAL: LineOfBusiness = LineOfBusiness::new(1);

    /// Retail LineOfBusiness.
    pub const RETAIL: LineOfBusiness = LineOfBusiness::new(2);

    /// Creates a new LineOfBusiness instance.
    pub(crate) const fn new(value: i32) -> Self {
        Self(value)
    }

    /// Gets the enum value.
    pub fn value(&self) -> i32 {
        self.0
    }

    /// Gets the enum value as a string.
    pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
        match self.0 {
            0 => std::borrow::Cow::Borrowed("LINE_OF_BUSINESS_UNSPECIFIED"),
            1 => std::borrow::Cow::Borrowed("COMMERCIAL"),
            2 => std::borrow::Cow::Borrowed("RETAIL"),
            _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
        }
    }

    /// Creates an enum value from the value name.
    pub fn from_str_name(name: &str) -> std::option::Option<Self> {
        match name {
            "LINE_OF_BUSINESS_UNSPECIFIED" => {
                std::option::Option::Some(Self::LINE_OF_BUSINESS_UNSPECIFIED)
            }
            "COMMERCIAL" => std::option::Option::Some(Self::COMMERCIAL),
            "RETAIL" => std::option::Option::Some(Self::RETAIL),
            _ => std::option::Option::None,
        }
    }
}

impl std::convert::From<i32> for LineOfBusiness {
    fn from(value: i32) -> Self {
        Self::new(value)
    }
}

impl std::default::Default for LineOfBusiness {
    fn default() -> Self {
        Self::new(0)
    }
}
