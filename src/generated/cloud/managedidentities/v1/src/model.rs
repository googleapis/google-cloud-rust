// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OpMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OpMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OpMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OpMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OpMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OpMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OpMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OpMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OpMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OpMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OpMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.OpMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OpMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OpMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OpMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OpMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OpMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [CreateMicrosoftAdDomain][google.cloud.managedidentities.v1.CreateMicrosoftAdDomain]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateMicrosoftAdDomainRequest {
    /// Required. The resource project name and location using the form:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Required. The fully qualified domain name.
    /// e.g. mydomain.myorganization.com, with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, periods and hyphens.
    /// * Must start with a letter.
    /// * Must contain between 2-64 characters.
    /// * Must end with a number or a letter.
    /// * Must not start with period.
    /// * First segement length (mydomain form example above) shouldn't exceed
    ///   15 chars.
    /// * The last segment cannot be fully numeric.
    /// * Must be unique within the customer project.
    pub domain_name: std::string::String,

    /// Required. A Managed Identity domain resource.
    pub domain: std::option::Option<crate::model::Domain>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMicrosoftAdDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMicrosoftAdDomainRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_name][crate::model::CreateMicrosoftAdDomainRequest::domain_name].
    pub fn set_domain_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain_name = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CreateMicrosoftAdDomainRequest::domain].
    pub fn set_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Domain>,
    {
        self.domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain][crate::model::CreateMicrosoftAdDomainRequest::domain].
    pub fn set_or_clear_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Domain>,
    {
        self.domain = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateMicrosoftAdDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.CreateMicrosoftAdDomainRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateMicrosoftAdDomainRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __domain_name,
            __domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateMicrosoftAdDomainRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "domainName" => Ok(__FieldTag::__domain_name),
                            "domain_name" => Ok(__FieldTag::__domain_name),
                            "domain" => Ok(__FieldTag::__domain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateMicrosoftAdDomainRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateMicrosoftAdDomainRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain_name => {
                            if !fields.insert(__FieldTag::__domain_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain_name",
                                ));
                            }
                            result.domain_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain =
                                map.next_value::<std::option::Option<crate::model::Domain>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateMicrosoftAdDomainRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.domain_name.is_empty() {
            state.serialize_entry("domainName", &self.domain_name)?;
        }
        if self.domain.is_some() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetAdminPasswordRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetAdminPasswordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetAdminPasswordRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetAdminPasswordRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetAdminPasswordRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetAdminPasswordRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetAdminPasswordRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetAdminPasswordRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetAdminPasswordResponse {
    /// A random password. See [admin][google.cloud.managedidentities.v1.Domain.admin] for more information.
    ///
    /// [google.cloud.managedidentities.v1.Domain.admin]: crate::model::Domain::admin
    pub password: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetAdminPasswordResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [password][crate::model::ResetAdminPasswordResponse::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetAdminPasswordResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __password,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetAdminPasswordResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "password" => Ok(__FieldTag::__password),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetAdminPasswordResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetAdminPasswordResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__password => {
                            if !fields.insert(__FieldTag::__password) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for password",
                                ));
                            }
                            result.password = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetAdminPasswordResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.password.is_empty() {
            state.serialize_entry("password", &self.password)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDomainsRequest {
    /// Required. The resource name of the domain location using the form:
    /// `projects/{project_id}/locations/global`
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If not specified, a default value of 1000 will be used.
    /// Regardless of the page_size value, the response may include a partial list.
    /// Callers should rely on a response's
    /// [next_page_token][google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]
    /// to determine if there are additional results to list.
    ///
    /// [google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]: crate::model::ListDomainsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous ListDomainsRequest
    /// request, if any.
    pub page_token: std::string::String,

    /// Optional. A filter specifying constraints of a list operation.
    /// For example, `Domain.fqdn="mydomain.myorginization"`.
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results. See
    /// [Sorting
    /// order](https://cloud.google.com/apis/design/design_patterns#sorting_order)
    /// for more information.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDomainsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDomainsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDomainsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDomainsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDomainsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDomainsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDomainsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListDomainsResponse {
    /// A list of Managed Identities Service domains in the project.
    pub domains: std::vec::Vec<crate::model::Domain>,

    /// A token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    pub next_page_token: std::string::String,

    /// A list of locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domains][crate::model::ListDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Domain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDomainsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainsResponse {
    type PageItem = crate::model::Domain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListDomainsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __domains,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListDomainsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "domains" => Ok(__FieldTag::__domains),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListDomainsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListDomainsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__domains => {
                            if !fields.insert(__FieldTag::__domains) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domains",
                                ));
                            }
                            result.domains = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Domain>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListDomainsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.domains.is_empty() {
            state.serialize_entry("domains", &self.domains)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for [GetDomain][google.cloud.managedidentities.v1.GetDomain]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.GetDomainRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetDomainRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetDomainRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetDomainRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetDomainRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetDomainRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [UpdateDomain][google.cloud.managedidentities.v1.UpdateDomain]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateDomainRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in this
    /// field. The elements of the repeated paths field may only include
    /// fields from [Domain][google.cloud.managedidentities.v1.Domain]:
    ///
    /// * `labels`
    /// * `locations`
    /// * `authorized_networks`
    ///
    /// [google.cloud.managedidentities.v1.Domain]: crate::model::Domain
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Domain message with updated fields. Only supported fields specified in
    /// update_mask are updated.
    pub domain: std::option::Option<crate::model::Domain>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateDomainRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [domain][crate::model::UpdateDomainRequest::domain].
    pub fn set_domain<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Domain>,
    {
        self.domain = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [domain][crate::model::UpdateDomainRequest::domain].
    pub fn set_or_clear_domain<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Domain>,
    {
        self.domain = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.UpdateDomainRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateDomainRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __domain,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateDomainRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "domain" => Ok(__FieldTag::__domain),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateDomainRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateDomainRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__domain => {
                            if !fields.insert(__FieldTag::__domain) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for domain",
                                ));
                            }
                            result.domain =
                                map.next_value::<std::option::Option<crate::model::Domain>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateDomainRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.domain.is_some() {
            state.serialize_entry("domain", &self.domain)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DeleteDomain][google.cloud.managedidentities.v1.DeleteDomain]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DeleteDomainRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteDomainRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteDomainRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteDomainRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteDomainRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteDomainRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [AttachTrust][google.cloud.managedidentities.v1.AttachTrust]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AttachTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    /// Required. The domain trust resource.
    pub trust: std::option::Option<crate::model::Trust>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::AttachTrustRequest::trust].
    pub fn set_trust<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trust][crate::model::AttachTrustRequest::trust].
    pub fn set_or_clear_trust<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for AttachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.AttachTrustRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AttachTrustRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __trust,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AttachTrustRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "trust" => Ok(__FieldTag::__trust),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AttachTrustRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AttachTrustRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust => {
                            if !fields.insert(__FieldTag::__trust) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust",
                                ));
                            }
                            result.trust =
                                map.next_value::<std::option::Option<crate::model::Trust>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AttachTrustRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.trust.is_some() {
            state.serialize_entry("trust", &self.trust)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ReconfigureTrust][google.cloud.managedidentities.v1.ReconfigureTrust]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReconfigureTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    /// Required. The fully-qualified target domain name which will be in trust with current
    /// domain.
    pub target_domain_name: std::string::String,

    /// Required. The target DNS server IP addresses to resolve the remote domain involved
    /// in the trust.
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconfigureTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReconfigureTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_domain_name][crate::model::ReconfigureTrustRequest::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::ReconfigureTrustRequest::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconfigureTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ReconfigureTrustRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReconfigureTrustRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_domain_name,
            __target_dns_ip_addresses,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReconfigureTrustRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetDomainName" => Ok(__FieldTag::__target_domain_name),
                            "target_domain_name" => Ok(__FieldTag::__target_domain_name),
                            "targetDnsIpAddresses" => Ok(__FieldTag::__target_dns_ip_addresses),
                            "target_dns_ip_addresses" => Ok(__FieldTag::__target_dns_ip_addresses),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReconfigureTrustRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReconfigureTrustRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_domain_name => {
                            if !fields.insert(__FieldTag::__target_domain_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_domain_name",
                                ));
                            }
                            result.target_domain_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_dns_ip_addresses => {
                            if !fields.insert(__FieldTag::__target_dns_ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_dns_ip_addresses",
                                ));
                            }
                            result.target_dns_ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReconfigureTrustRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_domain_name.is_empty() {
            state.serialize_entry("targetDomainName", &self.target_domain_name)?;
        }
        if !self.target_dns_ip_addresses.is_empty() {
            state.serialize_entry("targetDnsIpAddresses", &self.target_dns_ip_addresses)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [DetachTrust][google.cloud.managedidentities.v1.DetachTrust]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DetachTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    /// Required. The domain trust resource to removed.
    pub trust: std::option::Option<crate::model::Trust>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DetachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::DetachTrustRequest::trust].
    pub fn set_trust<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trust][crate::model::DetachTrustRequest::trust].
    pub fn set_or_clear_trust<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for DetachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DetachTrustRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DetachTrustRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __trust,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DetachTrustRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "trust" => Ok(__FieldTag::__trust),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DetachTrustRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DetachTrustRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust => {
                            if !fields.insert(__FieldTag::__trust) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust",
                                ));
                            }
                            result.trust =
                                map.next_value::<std::option::Option<crate::model::Trust>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DetachTrustRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.trust.is_some() {
            state.serialize_entry("trust", &self.trust)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request message for
/// [ValidateTrust][google.cloud.managedidentities.v1.ValidateTrust]
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ValidateTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    pub name: std::string::String,

    /// Required. The domain trust to validate trust state for.
    pub trust: std::option::Option<crate::model::Trust>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::ValidateTrustRequest::trust].
    pub fn set_trust<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [trust][crate::model::ValidateTrustRequest::trust].
    pub fn set_or_clear_trust<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Trust>,
    {
        self.trust = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ValidateTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ValidateTrustRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ValidateTrustRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __trust,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ValidateTrustRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "trust" => Ok(__FieldTag::__trust),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ValidateTrustRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ValidateTrustRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust => {
                            if !fields.insert(__FieldTag::__trust) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust",
                                ));
                            }
                            result.trust =
                                map.next_value::<std::option::Option<crate::model::Trust>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ValidateTrustRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.trust.is_some() {
            state.serialize_entry("trust", &self.trust)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a managed Microsoft Active Directory domain.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Domain {
    /// Required. The unique name of the domain using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`.
    pub name: std::string::String,

    /// Optional. Resource labels that can contain user-provided metadata.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The full names of the Google Compute Engine
    /// [networks](/compute/docs/networks-and-firewalls#networks) the domain
    /// instance is connected to. Networks can be added using UpdateDomain.
    /// The domain is only available on networks listed in `authorized_networks`.
    /// If CIDR subnets overlap between networks, domain creation will fail.
    pub authorized_networks: std::vec::Vec<std::string::String>,

    /// Required. The CIDR range of internal addresses that are reserved for this
    /// domain. Reserved networks must be /24 or larger. Ranges must be
    /// unique and non-overlapping with existing subnets in
    /// [Domain].[authorized_networks].
    pub reserved_ip_range: std::string::String,

    /// Required. Locations where domain needs to be provisioned.
    /// [regions][compute/docs/regions-zones/]
    /// e.g. us-west1 or us-east4
    /// Service supports up to 4 locations at once. Each location will use a /26
    /// block.
    pub locations: std::vec::Vec<std::string::String>,

    /// Optional. The name of delegated administrator account used to perform
    /// Active Directory operations. If not specified, `setupadmin` will be used.
    pub admin: std::string::String,

    /// Output only. The fully-qualified domain name of the exposed domain used by
    /// clients to connect to the service. Similar to what would be chosen for an
    /// Active Directory set up on an internal network.
    pub fqdn: std::string::String,

    /// Output only. The time the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this domain.
    pub state: crate::model::domain::State,

    /// Output only. Additional information about the current status of this
    /// domain, if available.
    pub status_message: std::string::String,

    /// Output only. The current trusts associated with the domain.
    pub trusts: std::vec::Vec<crate::model::Trust>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Domain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Domain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Domain::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::Domain::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::Domain::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::Domain::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin][crate::model::Domain::admin].
    pub fn set_admin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Domain::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Domain::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Domain::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Domain::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Domain::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Domain::state].
    pub fn set_state<T: std::convert::Into<crate::model::domain::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Domain::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [trusts][crate::model::Domain::trusts].
    pub fn set_trusts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trust>,
    {
        use std::iter::Iterator;
        self.trusts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Domain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Domain"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Domain {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __labels,
            __authorized_networks,
            __reserved_ip_range,
            __locations,
            __admin,
            __fqdn,
            __create_time,
            __update_time,
            __state,
            __status_message,
            __trusts,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Domain")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "labels" => Ok(__FieldTag::__labels),
                            "authorizedNetworks" => Ok(__FieldTag::__authorized_networks),
                            "authorized_networks" => Ok(__FieldTag::__authorized_networks),
                            "reservedIpRange" => Ok(__FieldTag::__reserved_ip_range),
                            "reserved_ip_range" => Ok(__FieldTag::__reserved_ip_range),
                            "locations" => Ok(__FieldTag::__locations),
                            "admin" => Ok(__FieldTag::__admin),
                            "fqdn" => Ok(__FieldTag::__fqdn),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "trusts" => Ok(__FieldTag::__trusts),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Domain;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Domain")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__authorized_networks => {
                            if !fields.insert(__FieldTag::__authorized_networks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for authorized_networks",
                                ));
                            }
                            result.authorized_networks = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__reserved_ip_range => {
                            if !fields.insert(__FieldTag::__reserved_ip_range) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reserved_ip_range",
                                ));
                            }
                            result.reserved_ip_range = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__locations => {
                            if !fields.insert(__FieldTag::__locations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for locations",
                                ));
                            }
                            result.locations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__admin => {
                            if !fields.insert(__FieldTag::__admin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for admin",
                                ));
                            }
                            result.admin = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fqdn => {
                            if !fields.insert(__FieldTag::__fqdn) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fqdn",
                                ));
                            }
                            result.fqdn = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::domain::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trusts => {
                            if !fields.insert(__FieldTag::__trusts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trusts",
                                ));
                            }
                            result.trusts = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Trust>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Domain {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self.authorized_networks.is_empty() {
            state.serialize_entry("authorizedNetworks", &self.authorized_networks)?;
        }
        if !self.reserved_ip_range.is_empty() {
            state.serialize_entry("reservedIpRange", &self.reserved_ip_range)?;
        }
        if !self.locations.is_empty() {
            state.serialize_entry("locations", &self.locations)?;
        }
        if !self.admin.is_empty() {
            state.serialize_entry("admin", &self.admin)?;
        }
        if !self.fqdn.is_empty() {
            state.serialize_entry("fqdn", &self.fqdn)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !self.trusts.is_empty() {
            state.serialize_entry("trusts", &self.trusts)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Domain].
pub mod domain {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a managed domain.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The domain is being created.
        Creating,
        /// The domain has been created and is fully usable.
        Ready,
        /// The domain's configuration is being updated.
        Updating,
        /// The domain is being deleted.
        Deleting,
        /// The domain is being repaired and may be unusable. Details
        /// can be found in the `status_message` field.
        Repairing,
        /// The domain is undergoing maintenance.
        PerformingMaintenance,
        /// The domain is not serving requests.
        Unavailable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Repairing => std::option::Option::Some(5),
                Self::PerformingMaintenance => std::option::Option::Some(6),
                Self::Unavailable => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::PerformingMaintenance => std::option::Option::Some("PERFORMING_MAINTENANCE"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Repairing,
                6 => Self::PerformingMaintenance,
                7 => Self::Unavailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "REPAIRING" => Self::Repairing,
                "PERFORMING_MAINTENANCE" => Self::PerformingMaintenance,
                "UNAVAILABLE" => Self::Unavailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Repairing => serializer.serialize_i32(5),
                Self::PerformingMaintenance => serializer.serialize_i32(6),
                Self::Unavailable => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedidentities.v1.Domain.State",
            ))
        }
    }
}

/// Represents a relationship between two domains. This allows a controller in
/// one domain to authenticate a user in another domain.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Trust {
    /// Required. The fully qualified target domain name which will be in trust with the
    /// current domain.
    pub target_domain_name: std::string::String,

    /// Required. The type of trust represented by the trust resource.
    pub trust_type: crate::model::trust::TrustType,

    /// Required. The trust direction, which decides if the current domain is trusted,
    /// trusting, or both.
    pub trust_direction: crate::model::trust::TrustDirection,

    /// Optional. The trust authentication type, which decides whether the trusted side has
    /// forest/domain wide access or selective access to an approved set of
    /// resources.
    pub selective_authentication: bool,

    /// Required. The target DNS server IP addresses which can resolve the remote domain
    /// involved in the trust.
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,

    /// Required. The trust secret used for the handshake with the target domain. This will
    /// not be stored.
    pub trust_handshake_secret: std::string::String,

    /// Output only. The time the instance was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the trust.
    pub state: crate::model::trust::State,

    /// Output only. Additional information about the current state of the trust, if available.
    pub state_description: std::string::String,

    /// Output only. The last heartbeat time when the trust was known to be connected.
    pub last_trust_heartbeat_time: std::option::Option<wkt::Timestamp>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trust {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_domain_name][crate::model::Trust::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [trust_type][crate::model::Trust::trust_type].
    pub fn set_trust_type<T: std::convert::Into<crate::model::trust::TrustType>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_type = v.into();
        self
    }

    /// Sets the value of [trust_direction][crate::model::Trust::trust_direction].
    pub fn set_trust_direction<T: std::convert::Into<crate::model::trust::TrustDirection>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_direction = v.into();
        self
    }

    /// Sets the value of [selective_authentication][crate::model::Trust::selective_authentication].
    pub fn set_selective_authentication<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.selective_authentication = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::Trust::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trust_handshake_secret][crate::model::Trust::trust_handshake_secret].
    pub fn set_trust_handshake_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_handshake_secret = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Trust::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Trust::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Trust::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Trust::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Trust::state].
    pub fn set_state<T: std::convert::Into<crate::model::trust::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::Trust::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [last_trust_heartbeat_time][crate::model::Trust::last_trust_heartbeat_time].
    pub fn set_last_trust_heartbeat_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_trust_heartbeat_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [last_trust_heartbeat_time][crate::model::Trust::last_trust_heartbeat_time].
    pub fn set_or_clear_last_trust_heartbeat_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.last_trust_heartbeat_time = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Trust {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Trust"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Trust {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __target_domain_name,
            __trust_type,
            __trust_direction,
            __selective_authentication,
            __target_dns_ip_addresses,
            __trust_handshake_secret,
            __create_time,
            __update_time,
            __state,
            __state_description,
            __last_trust_heartbeat_time,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Trust")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "targetDomainName" => Ok(__FieldTag::__target_domain_name),
                            "target_domain_name" => Ok(__FieldTag::__target_domain_name),
                            "trustType" => Ok(__FieldTag::__trust_type),
                            "trust_type" => Ok(__FieldTag::__trust_type),
                            "trustDirection" => Ok(__FieldTag::__trust_direction),
                            "trust_direction" => Ok(__FieldTag::__trust_direction),
                            "selectiveAuthentication" => Ok(__FieldTag::__selective_authentication),
                            "selective_authentication" => {
                                Ok(__FieldTag::__selective_authentication)
                            }
                            "targetDnsIpAddresses" => Ok(__FieldTag::__target_dns_ip_addresses),
                            "target_dns_ip_addresses" => Ok(__FieldTag::__target_dns_ip_addresses),
                            "trustHandshakeSecret" => Ok(__FieldTag::__trust_handshake_secret),
                            "trust_handshake_secret" => Ok(__FieldTag::__trust_handshake_secret),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "state" => Ok(__FieldTag::__state),
                            "stateDescription" => Ok(__FieldTag::__state_description),
                            "state_description" => Ok(__FieldTag::__state_description),
                            "lastTrustHeartbeatTime" => Ok(__FieldTag::__last_trust_heartbeat_time),
                            "last_trust_heartbeat_time" => {
                                Ok(__FieldTag::__last_trust_heartbeat_time)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Trust;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Trust")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__target_domain_name => {
                            if !fields.insert(__FieldTag::__target_domain_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_domain_name",
                                ));
                            }
                            result.target_domain_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust_type => {
                            if !fields.insert(__FieldTag::__trust_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust_type",
                                ));
                            }
                            result.trust_type = map
                                .next_value::<std::option::Option<crate::model::trust::TrustType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__trust_direction => {
                            if !fields.insert(__FieldTag::__trust_direction) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust_direction",
                                ));
                            }
                            result.trust_direction = map.next_value::<std::option::Option<crate::model::trust::TrustDirection>>()?.unwrap_or_default();
                        }
                        __FieldTag::__selective_authentication => {
                            if !fields.insert(__FieldTag::__selective_authentication) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for selective_authentication",
                                ));
                            }
                            result.selective_authentication = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_dns_ip_addresses => {
                            if !fields.insert(__FieldTag::__target_dns_ip_addresses) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_dns_ip_addresses",
                                ));
                            }
                            result.target_dns_ip_addresses = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__trust_handshake_secret => {
                            if !fields.insert(__FieldTag::__trust_handshake_secret) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for trust_handshake_secret",
                                ));
                            }
                            result.trust_handshake_secret = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::trust::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state_description => {
                            if !fields.insert(__FieldTag::__state_description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state_description",
                                ));
                            }
                            result.state_description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__last_trust_heartbeat_time => {
                            if !fields.insert(__FieldTag::__last_trust_heartbeat_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for last_trust_heartbeat_time",
                                ));
                            }
                            result.last_trust_heartbeat_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Trust {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.target_domain_name.is_empty() {
            state.serialize_entry("targetDomainName", &self.target_domain_name)?;
        }
        if !wkt::internal::is_default(&self.trust_type) {
            state.serialize_entry("trustType", &self.trust_type)?;
        }
        if !wkt::internal::is_default(&self.trust_direction) {
            state.serialize_entry("trustDirection", &self.trust_direction)?;
        }
        if !wkt::internal::is_default(&self.selective_authentication) {
            state.serialize_entry("selectiveAuthentication", &self.selective_authentication)?;
        }
        if !self.target_dns_ip_addresses.is_empty() {
            state.serialize_entry("targetDnsIpAddresses", &self.target_dns_ip_addresses)?;
        }
        if !self.trust_handshake_secret.is_empty() {
            state.serialize_entry("trustHandshakeSecret", &self.trust_handshake_secret)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.state_description.is_empty() {
            state.serialize_entry("stateDescription", &self.state_description)?;
        }
        if self.last_trust_heartbeat_time.is_some() {
            state.serialize_entry("lastTrustHeartbeatTime", &self.last_trust_heartbeat_time)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Trust].
pub mod trust {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a domain trust.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The domain trust is being created.
        Creating,
        /// The domain trust is being updated.
        Updating,
        /// The domain trust is being deleted.
        Deleting,
        /// The domain trust is connected.
        Connected,
        /// The domain trust is disconnected.
        Disconnected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Connected => std::option::Option::Some(4),
                Self::Disconnected => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Connected => std::option::Option::Some("CONNECTED"),
                Self::Disconnected => std::option::Option::Some("DISCONNECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Deleting,
                4 => Self::Connected,
                5 => Self::Disconnected,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "CONNECTED" => Self::Connected,
                "DISCONNECTED" => Self::Disconnected,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Connected => serializer.serialize_i32(4),
                Self::Disconnected => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedidentities.v1.Trust.State",
            ))
        }
    }

    /// Represents the different inter-forest trust types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustType {
        /// Not set.
        Unspecified,
        /// The forest trust.
        Forest,
        /// The external domain trust.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustType::value] or
        /// [TrustType::name].
        UnknownValue(trust_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Forest => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRUST_TYPE_UNSPECIFIED"),
                Self::Forest => std::option::Option::Some("FOREST"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Forest,
                2 => Self::External,
                _ => Self::UnknownValue(trust_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRUST_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FOREST" => Self::Forest,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(trust_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Forest => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustType>::new(
                ".google.cloud.managedidentities.v1.Trust.TrustType",
            ))
        }
    }

    /// Represents the direction of trust.
    /// See
    /// [System.DirectoryServices.ActiveDirectory.TrustDirection](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.activedirectory.trustdirection?view=netframework-4.7.2)
    /// for more information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustDirection {
        /// Not set.
        Unspecified,
        /// The inbound direction represents the trusting side.
        Inbound,
        /// The outboud direction represents the trusted side.
        Outbound,
        /// The bidirectional direction represents the trusted / trusting side.
        Bidirectional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustDirection::value] or
        /// [TrustDirection::name].
        UnknownValue(trust_direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustDirection {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inbound => std::option::Option::Some(1),
                Self::Outbound => std::option::Option::Some(2),
                Self::Bidirectional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRUST_DIRECTION_UNSPECIFIED"),
                Self::Inbound => std::option::Option::Some("INBOUND"),
                Self::Outbound => std::option::Option::Some("OUTBOUND"),
                Self::Bidirectional => std::option::Option::Some("BIDIRECTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustDirection {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustDirection {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inbound,
                2 => Self::Outbound,
                3 => Self::Bidirectional,
                _ => Self::UnknownValue(trust_direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustDirection {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRUST_DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "INBOUND" => Self::Inbound,
                "OUTBOUND" => Self::Outbound,
                "BIDIRECTIONAL" => Self::Bidirectional,
                _ => Self::UnknownValue(trust_direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustDirection {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inbound => serializer.serialize_i32(1),
                Self::Outbound => serializer.serialize_i32(2),
                Self::Bidirectional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustDirection {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustDirection>::new(
                ".google.cloud.managedidentities.v1.Trust.TrustDirection",
            ))
        }
    }
}
