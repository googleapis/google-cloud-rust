// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OpMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OpMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OpMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OpMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OpMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OpMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OpMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OpMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OpMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.OpMetadata"
    }
}

/// Request message for
/// [CreateMicrosoftAdDomain][google.cloud.managedidentities.v1.CreateMicrosoftAdDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMicrosoftAdDomainRequest {
    /// Required. The resource project name and location using the form:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The fully qualified domain name.
    /// e.g. mydomain.myorganization.com, with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, periods and hyphens.
    /// * Must start with a letter.
    /// * Must contain between 2-64 characters.
    /// * Must end with a number or a letter.
    /// * Must not start with period.
    /// * First segement length (mydomain form example above) shouldn't exceed
    ///   15 chars.
    /// * The last segment cannot be fully numeric.
    /// * Must be unique within the customer project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain_name: std::string::String,

    /// Required. A Managed Identity domain resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain: std::option::Option<crate::model::Domain>,
}

impl CreateMicrosoftAdDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMicrosoftAdDomainRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_name][crate::model::CreateMicrosoftAdDomainRequest::domain_name].
    pub fn set_domain_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain_name = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CreateMicrosoftAdDomainRequest::domain].
    pub fn set_domain<T: std::convert::Into<std::option::Option<crate::model::Domain>>>(
        mut self,
        v: T,
    ) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for CreateMicrosoftAdDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.CreateMicrosoftAdDomainRequest"
    }
}

/// Request message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetAdminPasswordRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResetAdminPasswordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetAdminPasswordRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordRequest"
    }
}

/// Response message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetAdminPasswordResponse {
    /// A random password. See [admin][google.cloud.managedidentities.v1.Domain.admin] for more information.
    ///
    /// [google.cloud.managedidentities.v1.Domain.admin]: crate::model::Domain::admin
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,
}

impl ResetAdminPasswordResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [password][crate::model::ResetAdminPasswordResponse::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordResponse"
    }
}

/// Request message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainsRequest {
    /// Required. The resource name of the domain location using the form:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If not specified, a default value of 1000 will be used.
    /// Regardless of the page_size value, the response may include a partial list.
    /// Callers should rely on a response's
    /// [next_page_token][google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]
    /// to determine if there are additional results to list.
    ///
    /// [google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]: crate::model::ListDomainsResponse::next_page_token
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous ListDomainsRequest
    /// request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter specifying constraints of a list operation.
    /// For example, `Domain.fqdn="mydomain.myorginization"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results. See
    /// [Sorting
    /// order](https://cloud.google.com/apis/design/design_patterns#sorting_order)
    /// for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDomainsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDomainsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsRequest"
    }
}

/// Response message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainsResponse {
    /// A list of Managed Identities Service domains in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domains: std::vec::Vec<crate::model::Domain>,

    /// A token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// A list of locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [domains][crate::model::ListDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Domain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDomainsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainsResponse {
    type PageItem = crate::model::Domain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for [GetDomain][google.cloud.managedidentities.v1.GetDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.GetDomainRequest"
    }
}

/// Request message for
/// [UpdateDomain][google.cloud.managedidentities.v1.UpdateDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDomainRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in this
    /// field. The elements of the repeated paths field may only include
    /// fields from [Domain][google.cloud.managedidentities.v1.Domain]:
    ///
    /// * `labels`
    /// * `locations`
    /// * `authorized_networks`
    ///
    /// [google.cloud.managedidentities.v1.Domain]: crate::model::Domain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Domain message with updated fields. Only supported fields specified in
    /// update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain: std::option::Option<crate::model::Domain>,
}

impl UpdateDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::UpdateDomainRequest::domain].
    pub fn set_domain<T: std::convert::Into<std::option::Option<crate::model::Domain>>>(
        mut self,
        v: T,
    ) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.UpdateDomainRequest"
    }
}

/// Request message for
/// [DeleteDomain][google.cloud.managedidentities.v1.DeleteDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl DeleteDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DeleteDomainRequest"
    }
}

/// Request message for
/// [AttachTrust][google.cloud.managedidentities.v1.AttachTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,
}

impl AttachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::AttachTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for AttachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.AttachTrustRequest"
    }
}

/// Request message for
/// [ReconfigureTrust][google.cloud.managedidentities.v1.ReconfigureTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReconfigureTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The fully-qualified target domain name which will be in trust with current
    /// domain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_domain_name: std::string::String,

    /// Required. The target DNS server IP addresses to resolve the remote domain involved
    /// in the trust.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,
}

impl ReconfigureTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReconfigureTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_domain_name][crate::model::ReconfigureTrustRequest::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::ReconfigureTrustRequest::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconfigureTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ReconfigureTrustRequest"
    }
}

/// Request message for
/// [DetachTrust][google.cloud.managedidentities.v1.DetachTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetachTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust resource to removed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,
}

impl DetachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DetachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::DetachTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for DetachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DetachTrustRequest"
    }
}

/// Request message for
/// [ValidateTrust][google.cloud.managedidentities.v1.ValidateTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust to validate trust state for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,
}

impl ValidateTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::ValidateTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for ValidateTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ValidateTrustRequest"
    }
}

/// Represents a managed Microsoft Active Directory domain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Domain {
    /// Required. The unique name of the domain using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Resource labels that can contain user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The full names of the Google Compute Engine
    /// [networks](/compute/docs/networks-and-firewalls#networks) the domain
    /// instance is connected to. Networks can be added using UpdateDomain.
    /// The domain is only available on networks listed in `authorized_networks`.
    /// If CIDR subnets overlap between networks, domain creation will fail.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<std::string::String>,

    /// Required. The CIDR range of internal addresses that are reserved for this
    /// domain. Reserved networks must be /24 or larger. Ranges must be
    /// unique and non-overlapping with existing subnets in
    /// [Domain].[authorized_networks].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reserved_ip_range: std::string::String,

    /// Required. Locations where domain needs to be provisioned.
    /// [regions][compute/docs/regions-zones/]
    /// e.g. us-west1 or us-east4
    /// Service supports up to 4 locations at once. Each location will use a /26
    /// block.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// Optional. The name of delegated administrator account used to perform
    /// Active Directory operations. If not specified, `setupadmin` will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub admin: std::string::String,

    /// Output only. The fully-qualified domain name of the exposed domain used by
    /// clients to connect to the service. Similar to what would be chosen for an
    /// Active Directory set up on an internal network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    /// Output only. The time the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this domain.
    pub state: crate::model::domain::State,

    /// Output only. Additional information about the current status of this
    /// domain, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. The current trusts associated with the domain.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trusts: std::vec::Vec<crate::model::Trust>,
}

impl Domain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Domain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::Domain::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [admin][crate::model::Domain::admin].
    pub fn set_admin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Domain::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Domain::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Domain::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Domain::state].
    pub fn set_state<T: std::convert::Into<crate::model::domain::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Domain::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::Domain::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [locations][crate::model::Domain::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trusts][crate::model::Domain::trusts].
    pub fn set_trusts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trust>,
    {
        use std::iter::Iterator;
        self.trusts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Domain::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Domain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Domain"
    }
}

/// Defines additional types related to [Domain].
pub mod domain {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a managed domain.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The domain is being created.
        pub const CREATING: State = State::new(1);

        /// The domain has been created and is fully usable.
        pub const READY: State = State::new(2);

        /// The domain's configuration is being updated.
        pub const UPDATING: State = State::new(3);

        /// The domain is being deleted.
        pub const DELETING: State = State::new(4);

        /// The domain is being repaired and may be unusable. Details
        /// can be found in the `status_message` field.
        pub const REPAIRING: State = State::new(5);

        /// The domain is undergoing maintenance.
        pub const PERFORMING_MAINTENANCE: State = State::new(6);

        /// The domain is not serving requests.
        pub const UNAVAILABLE: State = State::new(7);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("READY"),
                3 => std::borrow::Cow::Borrowed("UPDATING"),
                4 => std::borrow::Cow::Borrowed("DELETING"),
                5 => std::borrow::Cow::Borrowed("REPAIRING"),
                6 => std::borrow::Cow::Borrowed("PERFORMING_MAINTENANCE"),
                7 => std::borrow::Cow::Borrowed("UNAVAILABLE"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "READY" => std::option::Option::Some(Self::READY),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "REPAIRING" => std::option::Option::Some(Self::REPAIRING),
                "PERFORMING_MAINTENANCE" => std::option::Option::Some(Self::PERFORMING_MAINTENANCE),
                "UNAVAILABLE" => std::option::Option::Some(Self::UNAVAILABLE),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }
}

/// Represents a relationship between two domains. This allows a controller in
/// one domain to authenticate a user in another domain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trust {
    /// Required. The fully qualified target domain name which will be in trust with the
    /// current domain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_domain_name: std::string::String,

    /// Required. The type of trust represented by the trust resource.
    pub trust_type: crate::model::trust::TrustType,

    /// Required. The trust direction, which decides if the current domain is trusted,
    /// trusting, or both.
    pub trust_direction: crate::model::trust::TrustDirection,

    /// Optional. The trust authentication type, which decides whether the trusted side has
    /// forest/domain wide access or selective access to an approved set of
    /// resources.
    pub selective_authentication: bool,

    /// Required. The target DNS server IP addresses which can resolve the remote domain
    /// involved in the trust.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,

    /// Required. The trust secret used for the handshake with the target domain. This will
    /// not be stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trust_handshake_secret: std::string::String,

    /// Output only. The time the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the trust.
    pub state: crate::model::trust::State,

    /// Output only. Additional information about the current state of the trust, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_description: std::string::String,

    /// Output only. The last heartbeat time when the trust was known to be connected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_trust_heartbeat_time: std::option::Option<wkt::Timestamp>,
}

impl Trust {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_domain_name][crate::model::Trust::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [trust_type][crate::model::Trust::trust_type].
    pub fn set_trust_type<T: std::convert::Into<crate::model::trust::TrustType>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_type = v.into();
        self
    }

    /// Sets the value of [trust_direction][crate::model::Trust::trust_direction].
    pub fn set_trust_direction<T: std::convert::Into<crate::model::trust::TrustDirection>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_direction = v.into();
        self
    }

    /// Sets the value of [selective_authentication][crate::model::Trust::selective_authentication].
    pub fn set_selective_authentication<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.selective_authentication = v.into();
        self
    }

    /// Sets the value of [trust_handshake_secret][crate::model::Trust::trust_handshake_secret].
    pub fn set_trust_handshake_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_handshake_secret = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Trust::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Trust::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Trust::state].
    pub fn set_state<T: std::convert::Into<crate::model::trust::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::Trust::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [last_trust_heartbeat_time][crate::model::Trust::last_trust_heartbeat_time].
    pub fn set_last_trust_heartbeat_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_trust_heartbeat_time = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::Trust::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Trust {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Trust"
    }
}

/// Defines additional types related to [Trust].
pub mod trust {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a domain trust.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(i32);

    impl State {
        /// Not set.
        pub const STATE_UNSPECIFIED: State = State::new(0);

        /// The domain trust is being created.
        pub const CREATING: State = State::new(1);

        /// The domain trust is being updated.
        pub const UPDATING: State = State::new(2);

        /// The domain trust is being deleted.
        pub const DELETING: State = State::new(3);

        /// The domain trust is connected.
        pub const CONNECTED: State = State::new(4);

        /// The domain trust is disconnected.
        pub const DISCONNECTED: State = State::new(5);

        /// Creates a new State instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("STATE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("CREATING"),
                2 => std::borrow::Cow::Borrowed("UPDATING"),
                3 => std::borrow::Cow::Borrowed("DELETING"),
                4 => std::borrow::Cow::Borrowed("CONNECTED"),
                5 => std::borrow::Cow::Borrowed("DISCONNECTED"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "STATE_UNSPECIFIED" => std::option::Option::Some(Self::STATE_UNSPECIFIED),
                "CREATING" => std::option::Option::Some(Self::CREATING),
                "UPDATING" => std::option::Option::Some(Self::UPDATING),
                "DELETING" => std::option::Option::Some(Self::DELETING),
                "CONNECTED" => std::option::Option::Some(Self::CONNECTED),
                "DISCONNECTED" => std::option::Option::Some(Self::DISCONNECTED),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Represents the different inter-forest trust types.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TrustType(i32);

    impl TrustType {
        /// Not set.
        pub const TRUST_TYPE_UNSPECIFIED: TrustType = TrustType::new(0);

        /// The forest trust.
        pub const FOREST: TrustType = TrustType::new(1);

        /// The external domain trust.
        pub const EXTERNAL: TrustType = TrustType::new(2);

        /// Creates a new TrustType instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TRUST_TYPE_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("FOREST"),
                2 => std::borrow::Cow::Borrowed("EXTERNAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TRUST_TYPE_UNSPECIFIED" => std::option::Option::Some(Self::TRUST_TYPE_UNSPECIFIED),
                "FOREST" => std::option::Option::Some(Self::FOREST),
                "EXTERNAL" => std::option::Option::Some(Self::EXTERNAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TrustType {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TrustType {
        fn default() -> Self {
            Self::new(0)
        }
    }

    /// Represents the direction of trust.
    /// See
    /// [System.DirectoryServices.ActiveDirectory.TrustDirection](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.activedirectory.trustdirection?view=netframework-4.7.2)
    /// for more information.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct TrustDirection(i32);

    impl TrustDirection {
        /// Not set.
        pub const TRUST_DIRECTION_UNSPECIFIED: TrustDirection = TrustDirection::new(0);

        /// The inbound direction represents the trusting side.
        pub const INBOUND: TrustDirection = TrustDirection::new(1);

        /// The outboud direction represents the trusted side.
        pub const OUTBOUND: TrustDirection = TrustDirection::new(2);

        /// The bidirectional direction represents the trusted / trusting side.
        pub const BIDIRECTIONAL: TrustDirection = TrustDirection::new(3);

        /// Creates a new TrustDirection instance.
        pub(crate) const fn new(value: i32) -> Self {
            Self(value)
        }

        /// Gets the enum value.
        pub fn value(&self) -> i32 {
            self.0
        }

        /// Gets the enum value as a string.
        pub fn as_str_name(&self) -> std::borrow::Cow<'static, str> {
            match self.0 {
                0 => std::borrow::Cow::Borrowed("TRUST_DIRECTION_UNSPECIFIED"),
                1 => std::borrow::Cow::Borrowed("INBOUND"),
                2 => std::borrow::Cow::Borrowed("OUTBOUND"),
                3 => std::borrow::Cow::Borrowed("BIDIRECTIONAL"),
                _ => std::borrow::Cow::Owned(std::format!("UNKNOWN-VALUE:{}", self.0)),
            }
        }

        /// Creates an enum value from the value name.
        pub fn from_str_name(name: &str) -> std::option::Option<Self> {
            match name {
                "TRUST_DIRECTION_UNSPECIFIED" => {
                    std::option::Option::Some(Self::TRUST_DIRECTION_UNSPECIFIED)
                }
                "INBOUND" => std::option::Option::Some(Self::INBOUND),
                "OUTBOUND" => std::option::Option::Some(Self::OUTBOUND),
                "BIDIRECTIONAL" => std::option::Option::Some(Self::BIDIRECTIONAL),
                _ => std::option::Option::None,
            }
        }
    }

    impl std::convert::From<i32> for TrustDirection {
        fn from(value: i32) -> Self {
            Self::new(value)
        }
    }

    impl std::default::Default for TrustDirection {
        fn default() -> Self {
            Self::new(0)
        }
    }
}
