// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OpMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OpMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OpMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OpMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OpMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OpMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OpMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OpMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OpMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.OpMetadata"
    }
}

/// Request message for
/// [CreateMicrosoftAdDomain][google.cloud.managedidentities.v1.CreateMicrosoftAdDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateMicrosoftAdDomainRequest {
    /// Required. The resource project name and location using the form:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The fully qualified domain name.
    /// e.g. mydomain.myorganization.com, with the following restrictions:
    ///
    /// * Must contain only lowercase letters, numbers, periods and hyphens.
    /// * Must start with a letter.
    /// * Must contain between 2-64 characters.
    /// * Must end with a number or a letter.
    /// * Must not start with period.
    /// * First segement length (mydomain form example above) shouldn't exceed
    ///   15 chars.
    /// * The last segment cannot be fully numeric.
    /// * Must be unique within the customer project.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub domain_name: std::string::String,

    /// Required. A Managed Identity domain resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain: std::option::Option<crate::model::Domain>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateMicrosoftAdDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateMicrosoftAdDomainRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [domain_name][crate::model::CreateMicrosoftAdDomainRequest::domain_name].
    pub fn set_domain_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.domain_name = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::CreateMicrosoftAdDomainRequest::domain].
    pub fn set_domain<T: std::convert::Into<std::option::Option<crate::model::Domain>>>(
        mut self,
        v: T,
    ) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for CreateMicrosoftAdDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.CreateMicrosoftAdDomainRequest"
    }
}

/// Request message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetAdminPasswordRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetAdminPasswordRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetAdminPasswordRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordRequest"
    }
}

/// Response message for
/// [ResetAdminPassword][google.cloud.managedidentities.v1.ResetAdminPassword]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetAdminPasswordResponse {
    /// A random password. See [admin][google.cloud.managedidentities.v1.Domain.admin] for more information.
    ///
    /// [google.cloud.managedidentities.v1.Domain.admin]: crate::model::Domain::admin
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub password: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetAdminPasswordResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [password][crate::model::ResetAdminPasswordResponse::password].
    pub fn set_password<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.password = v.into();
        self
    }
}

impl wkt::message::Message for ResetAdminPasswordResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ResetAdminPasswordResponse"
    }
}

/// Request message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainsRequest {
    /// Required. The resource name of the domain location using the form:
    /// `projects/{project_id}/locations/global`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. The maximum number of items to return.
    /// If not specified, a default value of 1000 will be used.
    /// Regardless of the page_size value, the response may include a partial list.
    /// Callers should rely on a response's
    /// [next_page_token][google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]
    /// to determine if there are additional results to list.
    ///
    /// [google.cloud.managedidentities.v1.ListDomainsResponse.next_page_token]: crate::model::ListDomainsResponse::next_page_token
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub page_size: i32,

    /// Optional. The `next_page_token` value returned from a previous ListDomainsRequest
    /// request, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. A filter specifying constraints of a list operation.
    /// For example, `Domain.fqdn="mydomain.myorginization"`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Specifies the ordering of results. See
    /// [Sorting
    /// order](https://cloud.google.com/apis/design/design_patterns#sorting_order)
    /// for more information.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListDomainsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListDomainsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListDomainsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListDomainsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListDomainsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListDomainsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsRequest"
    }
}

/// Response message for
/// [ListDomains][google.cloud.managedidentities.v1.ListDomains]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListDomainsResponse {
    /// A list of Managed Identities Service domains in the project.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub domains: std::vec::Vec<crate::model::Domain>,

    /// A token to retrieve the next page of results, or empty if there are no more
    /// results in the list.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// A list of locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListDomainsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [domains][crate::model::ListDomainsResponse::domains].
    pub fn set_domains<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Domain>,
    {
        use std::iter::Iterator;
        self.domains = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListDomainsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListDomainsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListDomainsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ListDomainsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListDomainsResponse {
    type PageItem = crate::model::Domain;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.domains
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Request message for [GetDomain][google.cloud.managedidentities.v1.GetDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.GetDomainRequest"
    }
}

/// Request message for
/// [UpdateDomain][google.cloud.managedidentities.v1.UpdateDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateDomainRequest {
    /// Required. Mask of fields to update. At least one path must be supplied in this
    /// field. The elements of the repeated paths field may only include
    /// fields from [Domain][google.cloud.managedidentities.v1.Domain]:
    ///
    /// * `labels`
    /// * `locations`
    /// * `authorized_networks`
    ///
    /// [google.cloud.managedidentities.v1.Domain]: crate::model::Domain
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. Domain message with updated fields. Only supported fields specified in
    /// update_mask are updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub domain: std::option::Option<crate::model::Domain>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateDomainRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [domain][crate::model::UpdateDomainRequest::domain].
    pub fn set_domain<T: std::convert::Into<std::option::Option<crate::model::Domain>>>(
        mut self,
        v: T,
    ) -> Self {
        self.domain = v.into();
        self
    }
}

impl wkt::message::Message for UpdateDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.UpdateDomainRequest"
    }
}

/// Request message for
/// [DeleteDomain][google.cloud.managedidentities.v1.DeleteDomain]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteDomainRequest {
    /// Required. The domain resource name using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteDomainRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteDomainRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteDomainRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DeleteDomainRequest"
    }
}

/// Request message for
/// [AttachTrust][google.cloud.managedidentities.v1.AttachTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AttachTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AttachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::AttachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::AttachTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for AttachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.AttachTrustRequest"
    }
}

/// Request message for
/// [ReconfigureTrust][google.cloud.managedidentities.v1.ReconfigureTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ReconfigureTrustRequest {
    /// Required. The resource domain name, project name and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The fully-qualified target domain name which will be in trust with current
    /// domain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_domain_name: std::string::String,

    /// Required. The target DNS server IP addresses to resolve the remote domain involved
    /// in the trust.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReconfigureTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReconfigureTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_domain_name][crate::model::ReconfigureTrustRequest::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::ReconfigureTrustRequest::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ReconfigureTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ReconfigureTrustRequest"
    }
}

/// Request message for
/// [DetachTrust][google.cloud.managedidentities.v1.DetachTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DetachTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust resource to removed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DetachTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DetachTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::DetachTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for DetachTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.DetachTrustRequest"
    }
}

/// Request message for
/// [ValidateTrust][google.cloud.managedidentities.v1.ValidateTrust]
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ValidateTrustRequest {
    /// Required. The resource domain name, project name, and location using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The domain trust to validate trust state for.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub trust: std::option::Option<crate::model::Trust>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ValidateTrustRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ValidateTrustRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [trust][crate::model::ValidateTrustRequest::trust].
    pub fn set_trust<T: std::convert::Into<std::option::Option<crate::model::Trust>>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust = v.into();
        self
    }
}

impl wkt::message::Message for ValidateTrustRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.ValidateTrustRequest"
    }
}

/// Represents a managed Microsoft Active Directory domain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Domain {
    /// Required. The unique name of the domain using the form:
    /// `projects/{project_id}/locations/global/domains/{domain_name}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Resource labels that can contain user-provided metadata.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The full names of the Google Compute Engine
    /// [networks](/compute/docs/networks-and-firewalls#networks) the domain
    /// instance is connected to. Networks can be added using UpdateDomain.
    /// The domain is only available on networks listed in `authorized_networks`.
    /// If CIDR subnets overlap between networks, domain creation will fail.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub authorized_networks: std::vec::Vec<std::string::String>,

    /// Required. The CIDR range of internal addresses that are reserved for this
    /// domain. Reserved networks must be /24 or larger. Ranges must be
    /// unique and non-overlapping with existing subnets in
    /// [Domain].[authorized_networks].
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reserved_ip_range: std::string::String,

    /// Required. Locations where domain needs to be provisioned.
    /// [regions][compute/docs/regions-zones/]
    /// e.g. us-west1 or us-east4
    /// Service supports up to 4 locations at once. Each location will use a /26
    /// block.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub locations: std::vec::Vec<std::string::String>,

    /// Optional. The name of delegated administrator account used to perform
    /// Active Directory operations. If not specified, `setupadmin` will be used.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub admin: std::string::String,

    /// Output only. The fully-qualified domain name of the exposed domain used by
    /// clients to connect to the service. Similar to what would be chosen for an
    /// Active Directory set up on an internal network.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub fqdn: std::string::String,

    /// Output only. The time the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of this domain.
    pub state: crate::model::domain::State,

    /// Output only. Additional information about the current status of this
    /// domain, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. The current trusts associated with the domain.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub trusts: std::vec::Vec<crate::model::Trust>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Domain {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Domain::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Domain::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [authorized_networks][crate::model::Domain::authorized_networks].
    pub fn set_authorized_networks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.authorized_networks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [reserved_ip_range][crate::model::Domain::reserved_ip_range].
    pub fn set_reserved_ip_range<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.reserved_ip_range = v.into();
        self
    }

    /// Sets the value of [locations][crate::model::Domain::locations].
    pub fn set_locations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.locations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [admin][crate::model::Domain::admin].
    pub fn set_admin<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.admin = v.into();
        self
    }

    /// Sets the value of [fqdn][crate::model::Domain::fqdn].
    pub fn set_fqdn<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.fqdn = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Domain::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Domain::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Domain::state].
    pub fn set_state<T: std::convert::Into<crate::model::domain::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::Domain::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [trusts][crate::model::Domain::trusts].
    pub fn set_trusts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Trust>,
    {
        use std::iter::Iterator;
        self.trusts = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Domain {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Domain"
    }
}

/// Defines additional types related to [Domain].
pub mod domain {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a managed domain.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The domain is being created.
        Creating,
        /// The domain has been created and is fully usable.
        Ready,
        /// The domain's configuration is being updated.
        Updating,
        /// The domain is being deleted.
        Deleting,
        /// The domain is being repaired and may be unusable. Details
        /// can be found in the `status_message` field.
        Repairing,
        /// The domain is undergoing maintenance.
        PerformingMaintenance,
        /// The domain is not serving requests.
        Unavailable,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Ready => std::option::Option::Some(2),
                Self::Updating => std::option::Option::Some(3),
                Self::Deleting => std::option::Option::Some(4),
                Self::Repairing => std::option::Option::Some(5),
                Self::PerformingMaintenance => std::option::Option::Some(6),
                Self::Unavailable => std::option::Option::Some(7),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Ready => std::option::Option::Some("READY"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Repairing => std::option::Option::Some("REPAIRING"),
                Self::PerformingMaintenance => std::option::Option::Some("PERFORMING_MAINTENANCE"),
                Self::Unavailable => std::option::Option::Some("UNAVAILABLE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Ready,
                3 => Self::Updating,
                4 => Self::Deleting,
                5 => Self::Repairing,
                6 => Self::PerformingMaintenance,
                7 => Self::Unavailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "READY" => Self::Ready,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "REPAIRING" => Self::Repairing,
                "PERFORMING_MAINTENANCE" => Self::PerformingMaintenance,
                "UNAVAILABLE" => Self::Unavailable,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Ready => serializer.serialize_i32(2),
                Self::Updating => serializer.serialize_i32(3),
                Self::Deleting => serializer.serialize_i32(4),
                Self::Repairing => serializer.serialize_i32(5),
                Self::PerformingMaintenance => serializer.serialize_i32(6),
                Self::Unavailable => serializer.serialize_i32(7),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedidentities.v1.Domain.State",
            ))
        }
    }
}

/// Represents a relationship between two domains. This allows a controller in
/// one domain to authenticate a user in another domain.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Trust {
    /// Required. The fully qualified target domain name which will be in trust with the
    /// current domain.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_domain_name: std::string::String,

    /// Required. The type of trust represented by the trust resource.
    pub trust_type: crate::model::trust::TrustType,

    /// Required. The trust direction, which decides if the current domain is trusted,
    /// trusting, or both.
    pub trust_direction: crate::model::trust::TrustDirection,

    /// Optional. The trust authentication type, which decides whether the trusted side has
    /// forest/domain wide access or selective access to an approved set of
    /// resources.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub selective_authentication: bool,

    /// Required. The target DNS server IP addresses which can resolve the remote domain
    /// involved in the trust.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub target_dns_ip_addresses: std::vec::Vec<std::string::String>,

    /// Required. The trust secret used for the handshake with the target domain. This will
    /// not be stored.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub trust_handshake_secret: std::string::String,

    /// Output only. The time the instance was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The last update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The current state of the trust.
    pub state: crate::model::trust::State,

    /// Output only. Additional information about the current state of the trust, if available.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub state_description: std::string::String,

    /// Output only. The last heartbeat time when the trust was known to be connected.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub last_trust_heartbeat_time: std::option::Option<wkt::Timestamp>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Trust {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target_domain_name][crate::model::Trust::target_domain_name].
    pub fn set_target_domain_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.target_domain_name = v.into();
        self
    }

    /// Sets the value of [trust_type][crate::model::Trust::trust_type].
    pub fn set_trust_type<T: std::convert::Into<crate::model::trust::TrustType>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_type = v.into();
        self
    }

    /// Sets the value of [trust_direction][crate::model::Trust::trust_direction].
    pub fn set_trust_direction<T: std::convert::Into<crate::model::trust::TrustDirection>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_direction = v.into();
        self
    }

    /// Sets the value of [selective_authentication][crate::model::Trust::selective_authentication].
    pub fn set_selective_authentication<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.selective_authentication = v.into();
        self
    }

    /// Sets the value of [target_dns_ip_addresses][crate::model::Trust::target_dns_ip_addresses].
    pub fn set_target_dns_ip_addresses<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.target_dns_ip_addresses = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [trust_handshake_secret][crate::model::Trust::trust_handshake_secret].
    pub fn set_trust_handshake_secret<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.trust_handshake_secret = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Trust::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Trust::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Trust::state].
    pub fn set_state<T: std::convert::Into<crate::model::trust::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [state_description][crate::model::Trust::state_description].
    pub fn set_state_description<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.state_description = v.into();
        self
    }

    /// Sets the value of [last_trust_heartbeat_time][crate::model::Trust::last_trust_heartbeat_time].
    pub fn set_last_trust_heartbeat_time<
        T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.last_trust_heartbeat_time = v.into();
        self
    }
}

impl wkt::message::Message for Trust {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.managedidentities.v1.Trust"
    }
}

/// Defines additional types related to [Trust].
pub mod trust {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the different states of a domain trust.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Not set.
        Unspecified,
        /// The domain trust is being created.
        Creating,
        /// The domain trust is being updated.
        Updating,
        /// The domain trust is being deleted.
        Deleting,
        /// The domain trust is connected.
        Connected,
        /// The domain trust is disconnected.
        Disconnected,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Updating => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Connected => std::option::Option::Some(4),
                Self::Disconnected => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Connected => std::option::Option::Some("CONNECTED"),
                Self::Disconnected => std::option::Option::Some("DISCONNECTED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Updating,
                3 => Self::Deleting,
                4 => Self::Connected,
                5 => Self::Disconnected,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "UPDATING" => Self::Updating,
                "DELETING" => Self::Deleting,
                "CONNECTED" => Self::Connected,
                "DISCONNECTED" => Self::Disconnected,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Updating => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Connected => serializer.serialize_i32(4),
                Self::Disconnected => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.managedidentities.v1.Trust.State",
            ))
        }
    }

    /// Represents the different inter-forest trust types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustType {
        /// Not set.
        Unspecified,
        /// The forest trust.
        Forest,
        /// The external domain trust.
        External,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustType::value] or
        /// [TrustType::name].
        UnknownValue(trust_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Forest => std::option::Option::Some(1),
                Self::External => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRUST_TYPE_UNSPECIFIED"),
                Self::Forest => std::option::Option::Some("FOREST"),
                Self::External => std::option::Option::Some("EXTERNAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Forest,
                2 => Self::External,
                _ => Self::UnknownValue(trust_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRUST_TYPE_UNSPECIFIED" => Self::Unspecified,
                "FOREST" => Self::Forest,
                "EXTERNAL" => Self::External,
                _ => Self::UnknownValue(trust_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Forest => serializer.serialize_i32(1),
                Self::External => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustType>::new(
                ".google.cloud.managedidentities.v1.Trust.TrustType",
            ))
        }
    }

    /// Represents the direction of trust.
    /// See
    /// [System.DirectoryServices.ActiveDirectory.TrustDirection](https://docs.microsoft.com/en-us/dotnet/api/system.directoryservices.activedirectory.trustdirection?view=netframework-4.7.2)
    /// for more information.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TrustDirection {
        /// Not set.
        Unspecified,
        /// The inbound direction represents the trusting side.
        Inbound,
        /// The outboud direction represents the trusted side.
        Outbound,
        /// The bidirectional direction represents the trusted / trusting side.
        Bidirectional,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TrustDirection::value] or
        /// [TrustDirection::name].
        UnknownValue(trust_direction::UnknownValue),
    }

    #[doc(hidden)]
    pub mod trust_direction {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TrustDirection {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Inbound => std::option::Option::Some(1),
                Self::Outbound => std::option::Option::Some(2),
                Self::Bidirectional => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TRUST_DIRECTION_UNSPECIFIED"),
                Self::Inbound => std::option::Option::Some("INBOUND"),
                Self::Outbound => std::option::Option::Some("OUTBOUND"),
                Self::Bidirectional => std::option::Option::Some("BIDIRECTIONAL"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TrustDirection {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TrustDirection {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TrustDirection {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Inbound,
                2 => Self::Outbound,
                3 => Self::Bidirectional,
                _ => Self::UnknownValue(trust_direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TrustDirection {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TRUST_DIRECTION_UNSPECIFIED" => Self::Unspecified,
                "INBOUND" => Self::Inbound,
                "OUTBOUND" => Self::Outbound,
                "BIDIRECTIONAL" => Self::Bidirectional,
                _ => Self::UnknownValue(trust_direction::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TrustDirection {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Inbound => serializer.serialize_i32(1),
                Self::Outbound => serializer.serialize_i32(2),
                Self::Bidirectional => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TrustDirection {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TrustDirection>::new(
                ".google.cloud.managedidentities.v1.Trust.TrustDirection",
            ))
        }
    }
}
