// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for `CheckOnboardingStatus` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckOnboardingStatusRequest {
    /// Required. The resource for which the onboarding status should be checked.
    /// Should be in one of the following formats:
    ///
    /// * `projects/{project-number|project-id}/locations/{region}`
    /// * `folders/{folder-number}/locations/{region}`
    /// * `organizations/{organization-number}/locations/{region}`
    pub parent: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckOnboardingStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CheckOnboardingStatusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CheckOnboardingStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckOnboardingStatusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckOnboardingStatusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckOnboardingStatusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckOnboardingStatusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckOnboardingStatusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckOnboardingStatusRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckOnboardingStatusRequest");
        debug_struct.field("parent", &self.parent);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Response message for `CheckOnboardingStatus` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckOnboardingStatusResponse {
    /// The service account that PAM uses to act on this resource.
    pub service_account: std::string::String,

    /// List of issues that are preventing PAM from functioning for this resource
    /// and need to be fixed to complete onboarding. Some issues might not be
    /// detected or reported.
    pub findings: std::vec::Vec<crate::model::check_onboarding_status_response::Finding>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckOnboardingStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::CheckOnboardingStatusResponse::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::CheckOnboardingStatusResponse::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::check_onboarding_status_response::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckOnboardingStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckOnboardingStatusResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __service_account,
            __findings,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckOnboardingStatusResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "findings" => Ok(__FieldTag::__findings),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckOnboardingStatusResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckOnboardingStatusResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__findings => {
                            if !fields.insert(__FieldTag::__findings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for findings",
                                ));
                            }
                            result.findings = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::check_onboarding_status_response::Finding,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckOnboardingStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.findings.is_empty() {
            state.serialize_entry("findings", &self.findings)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CheckOnboardingStatusResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CheckOnboardingStatusResponse");
        debug_struct.field("service_account", &self.service_account);
        debug_struct.field("findings", &self.findings);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [CheckOnboardingStatusResponse].
pub mod check_onboarding_status_response {
    #[allow(unused_imports)]
    use super::*;

    /// Finding represents an issue which prevents PAM from functioning properly
    /// for this resource.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Finding {
        pub finding_type: std::option::Option<
            crate::model::check_onboarding_status_response::finding::FindingType,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Finding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [finding_type][crate::model::check_onboarding_status_response::Finding::finding_type].
        ///
        /// Note that all the setters affecting `finding_type` are mutually
        /// exclusive.
        pub fn set_finding_type<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::check_onboarding_status_response::finding::FindingType,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.finding_type = v.into();
            self
        }

        /// The value of [finding_type][crate::model::check_onboarding_status_response::Finding::finding_type]
        /// if it holds a `IamAccessDenied`, `None` if the field is not set or
        /// holds a different branch.
        pub fn iam_access_denied(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.finding_type.as_ref().and_then(|v| match v {
                crate::model::check_onboarding_status_response::finding::FindingType::IamAccessDenied(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [finding_type][crate::model::check_onboarding_status_response::Finding::finding_type]
        /// to hold a `IamAccessDenied`.
        ///
        /// Note that all the setters affecting `finding_type` are
        /// mutually exclusive.
        pub fn set_iam_access_denied<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.finding_type = std::option::Option::Some(
                crate::model::check_onboarding_status_response::finding::FindingType::IamAccessDenied(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Finding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse.Finding"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Finding {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __iam_access_denied,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Finding")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "iamAccessDenied" => Ok(__FieldTag::__iam_access_denied),
                                "iam_access_denied" => Ok(__FieldTag::__iam_access_denied),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Finding;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Finding")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__iam_access_denied => {
                                if !fields.insert(__FieldTag::__iam_access_denied) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for iam_access_denied",
                                    ));
                                }
                                if result.finding_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `finding_type`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse.Finding.iam_access_denied, latest field was iamAccessDenied",
                                    ));
                                }
                                result.finding_type = std::option::Option::Some(
                                    crate::model::check_onboarding_status_response::finding::FindingType::IamAccessDenied(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::check_onboarding_status_response::finding::IAMAccessDenied>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Finding {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.iam_access_denied() {
                state.serialize_entry("iamAccessDenied", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Finding {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Finding");
            debug_struct.field("finding_type", &self.finding_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Finding].
    pub mod finding {
        #[allow(unused_imports)]
        use super::*;

        /// PAM's service account is being denied access by Cloud IAM.
        /// This can be fixed by granting a role that contains the missing
        /// permissions to the service account or exempting it from deny policies if
        /// they are blocking the access.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IAMAccessDenied {
            /// List of permissions that are being denied.
            pub missing_permissions: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IAMAccessDenied {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [missing_permissions][crate::model::check_onboarding_status_response::finding::IAMAccessDenied::missing_permissions].
            pub fn set_missing_permissions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.missing_permissions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IAMAccessDenied {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse.Finding.IAMAccessDenied"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IAMAccessDenied {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __missing_permissions,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IAMAccessDenied")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "missingPermissions" => Ok(__FieldTag::__missing_permissions),
                                    "missing_permissions" => Ok(__FieldTag::__missing_permissions),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IAMAccessDenied;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IAMAccessDenied")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__missing_permissions => {
                                    if !fields.insert(__FieldTag::__missing_permissions) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for missing_permissions",
                                            ),
                                        );
                                    }
                                    result.missing_permissions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IAMAccessDenied {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.missing_permissions.is_empty() {
                    state.serialize_entry("missingPermissions", &self.missing_permissions)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for IAMAccessDenied {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("IAMAccessDenied");
                debug_struct.field("missing_permissions", &self.missing_permissions);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum FindingType {
            /// PAM's service account is being denied access by Cloud IAM.
            IamAccessDenied(
                std::boxed::Box<
                    crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
                >,
            ),
        }
    }
}

/// An entitlement defines the eligibility of a set of users to obtain
/// predefined access for some time possibly after going through an approval
/// workflow.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. Name of the entitlement.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}/entitlements/{entitlement-id}`
    /// * `folders/{folder-number}/locations/{region}/entitlements/{entitlement-id}`
    /// * `projects/{project-id|project-number}/locations/{region}/entitlements/{entitlement-id}`
    pub name: std::string::String,

    /// Output only. Create time stamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Who can create grants using this entitlement. This list should
    /// contain at most one entry.
    pub eligible_users: std::vec::Vec<crate::model::AccessControlEntry>,

    /// Optional. The approvals needed before access are granted to a requester. No
    /// approvals are needed if this field is null.
    pub approval_workflow: std::option::Option<crate::model::ApprovalWorkflow>,

    /// The access granted to a requester on successful approval.
    pub privileged_access: std::option::Option<crate::model::PrivilegedAccess>,

    /// Required. The maximum amount of time that access is granted for a request.
    /// A requester can ask for a duration less than this, but never more.
    pub max_request_duration: std::option::Option<wkt::Duration>,

    /// Output only. Current state of this entitlement.
    pub state: crate::model::entitlement::State,

    /// Required. The manner in which the requester should provide a justification
    /// for requesting access.
    pub requester_justification_config:
        std::option::Option<crate::model::entitlement::RequesterJustificationConfig>,

    /// Optional. Additional email addresses to be notified based on actions taken.
    pub additional_notification_targets:
        std::option::Option<crate::model::entitlement::AdditionalNotificationTargets>,

    /// An `etag` is used for optimistic concurrency control as a way to prevent
    /// simultaneous updates to the same entitlement. An `etag` is returned in the
    /// response to `GetEntitlement` and the caller should put the `etag` in the
    /// request to `UpdateEntitlement` so that their change is applied on
    /// the same version. If this field is omitted or if there is a mismatch while
    /// updating an entitlement, then the server rejects the request.
    pub etag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entitlement::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Entitlement::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Entitlement::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Entitlement::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [eligible_users][crate::model::Entitlement::eligible_users].
    pub fn set_eligible_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessControlEntry>,
    {
        use std::iter::Iterator;
        self.eligible_users = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [approval_workflow][crate::model::Entitlement::approval_workflow].
    pub fn set_approval_workflow<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalWorkflow>,
    {
        self.approval_workflow = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [approval_workflow][crate::model::Entitlement::approval_workflow].
    pub fn set_or_clear_approval_workflow<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ApprovalWorkflow>,
    {
        self.approval_workflow = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privileged_access][crate::model::Entitlement::privileged_access].
    pub fn set_privileged_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivilegedAccess>,
    {
        self.privileged_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privileged_access][crate::model::Entitlement::privileged_access].
    pub fn set_or_clear_privileged_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivilegedAccess>,
    {
        self.privileged_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [max_request_duration][crate::model::Entitlement::max_request_duration].
    pub fn set_max_request_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_request_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [max_request_duration][crate::model::Entitlement::max_request_duration].
    pub fn set_or_clear_max_request_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.max_request_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [requester_justification_config][crate::model::Entitlement::requester_justification_config].
    pub fn set_requester_justification_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::entitlement::RequesterJustificationConfig>,
    {
        self.requester_justification_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requester_justification_config][crate::model::Entitlement::requester_justification_config].
    pub fn set_or_clear_requester_justification_config<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::entitlement::RequesterJustificationConfig>,
    {
        self.requester_justification_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_notification_targets][crate::model::Entitlement::additional_notification_targets].
    pub fn set_additional_notification_targets<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::entitlement::AdditionalNotificationTargets>,
    {
        self.additional_notification_targets = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [additional_notification_targets][crate::model::Entitlement::additional_notification_targets].
    pub fn set_or_clear_additional_notification_targets<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::entitlement::AdditionalNotificationTargets>,
    {
        self.additional_notification_targets = v.map(|x| x.into());
        self
    }

    /// Sets the value of [etag][crate::model::Entitlement::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Entitlement {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __eligible_users,
            __approval_workflow,
            __privileged_access,
            __max_request_duration,
            __state,
            __requester_justification_config,
            __additional_notification_targets,
            __etag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Entitlement")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "eligibleUsers" => Ok(__FieldTag::__eligible_users),
                            "eligible_users" => Ok(__FieldTag::__eligible_users),
                            "approvalWorkflow" => Ok(__FieldTag::__approval_workflow),
                            "approval_workflow" => Ok(__FieldTag::__approval_workflow),
                            "privilegedAccess" => Ok(__FieldTag::__privileged_access),
                            "privileged_access" => Ok(__FieldTag::__privileged_access),
                            "maxRequestDuration" => Ok(__FieldTag::__max_request_duration),
                            "max_request_duration" => Ok(__FieldTag::__max_request_duration),
                            "state" => Ok(__FieldTag::__state),
                            "requesterJustificationConfig" => {
                                Ok(__FieldTag::__requester_justification_config)
                            }
                            "requester_justification_config" => {
                                Ok(__FieldTag::__requester_justification_config)
                            }
                            "additionalNotificationTargets" => {
                                Ok(__FieldTag::__additional_notification_targets)
                            }
                            "additional_notification_targets" => {
                                Ok(__FieldTag::__additional_notification_targets)
                            }
                            "etag" => Ok(__FieldTag::__etag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Entitlement;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Entitlement")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__eligible_users => {
                            if !fields.insert(__FieldTag::__eligible_users) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for eligible_users",
                                ));
                            }
                            result.eligible_users = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AccessControlEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__approval_workflow => {
                            if !fields.insert(__FieldTag::__approval_workflow) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for approval_workflow",
                                ));
                            }
                            result.approval_workflow = map
                                .next_value::<std::option::Option<crate::model::ApprovalWorkflow>>(
                                )?;
                        }
                        __FieldTag::__privileged_access => {
                            if !fields.insert(__FieldTag::__privileged_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileged_access",
                                ));
                            }
                            result.privileged_access = map
                                .next_value::<std::option::Option<crate::model::PrivilegedAccess>>(
                                )?;
                        }
                        __FieldTag::__max_request_duration => {
                            if !fields.insert(__FieldTag::__max_request_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for max_request_duration",
                                ));
                            }
                            result.max_request_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::entitlement::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__requester_justification_config => {
                            if !fields.insert(__FieldTag::__requester_justification_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requester_justification_config",
                                ));
                            }
                            result.requester_justification_config = map
                                .next_value::<std::option::Option<
                                    crate::model::entitlement::RequesterJustificationConfig,
                                >>()?;
                        }
                        __FieldTag::__additional_notification_targets => {
                            if !fields.insert(__FieldTag::__additional_notification_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_notification_targets",
                                ));
                            }
                            result.additional_notification_targets = map
                                .next_value::<std::option::Option<
                                    crate::model::entitlement::AdditionalNotificationTargets,
                                >>()?;
                        }
                        __FieldTag::__etag => {
                            if !fields.insert(__FieldTag::__etag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for etag",
                                ));
                            }
                            result.etag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Entitlement {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.eligible_users.is_empty() {
            state.serialize_entry("eligibleUsers", &self.eligible_users)?;
        }
        if self.approval_workflow.is_some() {
            state.serialize_entry("approvalWorkflow", &self.approval_workflow)?;
        }
        if self.privileged_access.is_some() {
            state.serialize_entry("privilegedAccess", &self.privileged_access)?;
        }
        if self.max_request_duration.is_some() {
            state.serialize_entry("maxRequestDuration", &self.max_request_duration)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.requester_justification_config.is_some() {
            state.serialize_entry(
                "requesterJustificationConfig",
                &self.requester_justification_config,
            )?;
        }
        if self.additional_notification_targets.is_some() {
            state.serialize_entry(
                "additionalNotificationTargets",
                &self.additional_notification_targets,
            )?;
        }
        if !self.etag.is_empty() {
            state.serialize_entry("etag", &self.etag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Entitlement {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Entitlement");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("eligible_users", &self.eligible_users);
        debug_struct.field("approval_workflow", &self.approval_workflow);
        debug_struct.field("privileged_access", &self.privileged_access);
        debug_struct.field("max_request_duration", &self.max_request_duration);
        debug_struct.field("state", &self.state);
        debug_struct.field(
            "requester_justification_config",
            &self.requester_justification_config,
        );
        debug_struct.field(
            "additional_notification_targets",
            &self.additional_notification_targets,
        );
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Entitlement].
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// Defines how a requester must provide a justification when requesting
    /// access.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct RequesterJustificationConfig {
        /// This is a required field and the user must explicitly opt out if a
        /// justification from the requester isn't mandatory.
        pub justification_type: std::option::Option<
            crate::model::entitlement::requester_justification_config::JustificationType,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl RequesterJustificationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type].
        ///
        /// Note that all the setters affecting `justification_type` are mutually
        /// exclusive.
        pub fn set_justification_type<T: std::convert::Into<std::option::Option<crate::model::entitlement::requester_justification_config::JustificationType>>>(mut self, v: T) -> Self
        {
            self.justification_type = v.into();
            self
        }

        /// The value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// if it holds a `NotMandatory`, `None` if the field is not set or
        /// holds a different branch.
        pub fn not_mandatory(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::entitlement::requester_justification_config::NotMandatory,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.justification_type.as_ref().and_then(|v| match v {
                crate::model::entitlement::requester_justification_config::JustificationType::NotMandatory(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// to hold a `NotMandatory`.
        ///
        /// Note that all the setters affecting `justification_type` are
        /// mutually exclusive.
        pub fn set_not_mandatory<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::entitlement::requester_justification_config::NotMandatory,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.justification_type = std::option::Option::Some(
                crate::model::entitlement::requester_justification_config::JustificationType::NotMandatory(
                    v.into()
                )
            );
            self
        }

        /// The value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// if it holds a `Unstructured`, `None` if the field is not set or
        /// holds a different branch.
        pub fn unstructured(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::entitlement::requester_justification_config::Unstructured,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.justification_type.as_ref().and_then(|v| match v {
                crate::model::entitlement::requester_justification_config::JustificationType::Unstructured(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// to hold a `Unstructured`.
        ///
        /// Note that all the setters affecting `justification_type` are
        /// mutually exclusive.
        pub fn set_unstructured<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::entitlement::requester_justification_config::Unstructured,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.justification_type = std::option::Option::Some(
                crate::model::entitlement::requester_justification_config::JustificationType::Unstructured(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for RequesterJustificationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for RequesterJustificationConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __not_mandatory,
                __unstructured,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for RequesterJustificationConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "notMandatory" => Ok(__FieldTag::__not_mandatory),
                                "not_mandatory" => Ok(__FieldTag::__not_mandatory),
                                "unstructured" => Ok(__FieldTag::__unstructured),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = RequesterJustificationConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct RequesterJustificationConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__not_mandatory => {
                                if !fields.insert(__FieldTag::__not_mandatory) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for not_mandatory",
                                    ));
                                }
                                if result.justification_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `justification_type`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.not_mandatory, latest field was notMandatory",
                                    ));
                                }
                                result.justification_type = std::option::Option::Some(
                                    crate::model::entitlement::requester_justification_config::JustificationType::NotMandatory(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::entitlement::requester_justification_config::NotMandatory>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__unstructured => {
                                if !fields.insert(__FieldTag::__unstructured) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unstructured",
                                    ));
                                }
                                if result.justification_type.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `justification_type`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.unstructured, latest field was unstructured",
                                    ));
                                }
                                result.justification_type = std::option::Option::Some(
                                    crate::model::entitlement::requester_justification_config::JustificationType::Unstructured(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::entitlement::requester_justification_config::Unstructured>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for RequesterJustificationConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.not_mandatory() {
                state.serialize_entry("notMandatory", value)?;
            }
            if let Some(value) = self.unstructured() {
                state.serialize_entry("unstructured", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for RequesterJustificationConfig {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("RequesterJustificationConfig");
            debug_struct.field("justification_type", &self.justification_type);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [RequesterJustificationConfig].
    pub mod requester_justification_config {
        #[allow(unused_imports)]
        use super::*;

        /// The justification is not mandatory but can be provided in any of the
        /// supported formats.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct NotMandatory {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl NotMandatory {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for NotMandatory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.NotMandatory"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for NotMandatory {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for NotMandatory")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = NotMandatory;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct NotMandatory")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for NotMandatory {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for NotMandatory {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("NotMandatory");
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// The requester has to provide a justification in the form of a string.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Unstructured {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Unstructured {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Unstructured {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.Unstructured"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Unstructured {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Unstructured")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Unstructured;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Unstructured")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Unstructured {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Unstructured {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Unstructured");
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// This is a required field and the user must explicitly opt out if a
        /// justification from the requester isn't mandatory.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum JustificationType {
            /// This option means the requester isn't required to provide a
            /// justification.
            NotMandatory(
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::NotMandatory,
                >,
            ),
            /// This option means the requester must provide a string as
            /// justification. If this is selected, the server allows the requester
            /// to provide a justification but doesn't validate it.
            Unstructured(
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::Unstructured,
                >,
            ),
        }
    }

    /// `AdditionalNotificationTargets` includes email addresses to be notified.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AdditionalNotificationTargets {
        /// Optional. Additional email addresses to be notified when a principal
        /// (requester) is granted access.
        pub admin_email_recipients: std::vec::Vec<std::string::String>,

        /// Optional. Additional email address to be notified about an eligible
        /// entitlement.
        pub requester_email_recipients: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AdditionalNotificationTargets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [admin_email_recipients][crate::model::entitlement::AdditionalNotificationTargets::admin_email_recipients].
        pub fn set_admin_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.admin_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [requester_email_recipients][crate::model::entitlement::AdditionalNotificationTargets::requester_email_recipients].
        pub fn set_requester_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.requester_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AdditionalNotificationTargets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.AdditionalNotificationTargets"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AdditionalNotificationTargets {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __admin_email_recipients,
                __requester_email_recipients,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AdditionalNotificationTargets")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "adminEmailRecipients" => Ok(__FieldTag::__admin_email_recipients),
                                "admin_email_recipients" => {
                                    Ok(__FieldTag::__admin_email_recipients)
                                }
                                "requesterEmailRecipients" => {
                                    Ok(__FieldTag::__requester_email_recipients)
                                }
                                "requester_email_recipients" => {
                                    Ok(__FieldTag::__requester_email_recipients)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AdditionalNotificationTargets;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AdditionalNotificationTargets")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__admin_email_recipients => {
                                if !fields.insert(__FieldTag::__admin_email_recipients) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for admin_email_recipients",
                                    ));
                                }
                                result.admin_email_recipients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__requester_email_recipients => {
                                if !fields.insert(__FieldTag::__requester_email_recipients) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for requester_email_recipients",
                                    ));
                                }
                                result.requester_email_recipients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AdditionalNotificationTargets {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.admin_email_recipients.is_empty() {
                state.serialize_entry("adminEmailRecipients", &self.admin_email_recipients)?;
            }
            if !self.requester_email_recipients.is_empty() {
                state.serialize_entry(
                    "requesterEmailRecipients",
                    &self.requester_email_recipients,
                )?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AdditionalNotificationTargets {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AdditionalNotificationTargets");
            debug_struct.field("admin_email_recipients", &self.admin_email_recipients);
            debug_struct.field(
                "requester_email_recipients",
                &self.requester_email_recipients,
            );
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Different states an entitlement can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state. This value is never returned by the server.
        Unspecified,
        /// The entitlement is being created.
        Creating,
        /// The entitlement is available for requesting access.
        Available,
        /// The entitlement is being deleted.
        Deleting,
        /// The entitlement has been deleted.
        Deleted,
        /// The entitlement is being updated.
        Updating,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Creating => std::option::Option::Some(1),
                Self::Available => std::option::Option::Some(2),
                Self::Deleting => std::option::Option::Some(3),
                Self::Deleted => std::option::Option::Some(4),
                Self::Updating => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Creating => std::option::Option::Some("CREATING"),
                Self::Available => std::option::Option::Some("AVAILABLE"),
                Self::Deleting => std::option::Option::Some("DELETING"),
                Self::Deleted => std::option::Option::Some("DELETED"),
                Self::Updating => std::option::Option::Some("UPDATING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Creating,
                2 => Self::Available,
                3 => Self::Deleting,
                4 => Self::Deleted,
                5 => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "CREATING" => Self::Creating,
                "AVAILABLE" => Self::Available,
                "DELETING" => Self::Deleting,
                "DELETED" => Self::Deleted,
                "UPDATING" => Self::Updating,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Creating => serializer.serialize_i32(1),
                Self::Available => serializer.serialize_i32(2),
                Self::Deleting => serializer.serialize_i32(3),
                Self::Deleted => serializer.serialize_i32(4),
                Self::Updating => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.privilegedaccessmanager.v1.Entitlement.State",
            ))
        }
    }
}

/// `AccessControlEntry` is used to control who can do some operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct AccessControlEntry {
    /// Optional. Users who are allowed for the operation. Each entry should be a
    /// valid v1 IAM principal identifier. The format for these is documented at:
    /// <https://cloud.google.com/iam/docs/principal-identifiers#v1>
    pub principals: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AccessControlEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principals][crate::model::AccessControlEntry::principals].
    pub fn set_principals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.principals = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccessControlEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.AccessControlEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AccessControlEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __principals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AccessControlEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "principals" => Ok(__FieldTag::__principals),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AccessControlEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AccessControlEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__principals => {
                            if !fields.insert(__FieldTag::__principals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for principals",
                                ));
                            }
                            result.principals = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AccessControlEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.principals.is_empty() {
            state.serialize_entry("principals", &self.principals)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for AccessControlEntry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AccessControlEntry");
        debug_struct.field("principals", &self.principals);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Different types of approval workflows that can be used to gate privileged
/// access granting.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApprovalWorkflow {
    pub approval_workflow: std::option::Option<crate::model::approval_workflow::ApprovalWorkflow>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApprovalWorkflow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [approval_workflow][crate::model::ApprovalWorkflow::approval_workflow].
    ///
    /// Note that all the setters affecting `approval_workflow` are mutually
    /// exclusive.
    pub fn set_approval_workflow<
        T: std::convert::Into<std::option::Option<crate::model::approval_workflow::ApprovalWorkflow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_workflow = v.into();
        self
    }

    /// The value of [approval_workflow][crate::model::ApprovalWorkflow::approval_workflow]
    /// if it holds a `ManualApprovals`, `None` if the field is not set or
    /// holds a different branch.
    pub fn manual_approvals(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualApprovals>> {
        #[allow(unreachable_patterns)]
        self.approval_workflow.as_ref().and_then(|v| match v {
            crate::model::approval_workflow::ApprovalWorkflow::ManualApprovals(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [approval_workflow][crate::model::ApprovalWorkflow::approval_workflow]
    /// to hold a `ManualApprovals`.
    ///
    /// Note that all the setters affecting `approval_workflow` are
    /// mutually exclusive.
    pub fn set_manual_approvals<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualApprovals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_workflow = std::option::Option::Some(
            crate::model::approval_workflow::ApprovalWorkflow::ManualApprovals(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ApprovalWorkflow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ApprovalWorkflow"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApprovalWorkflow {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __manual_approvals,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApprovalWorkflow")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "manualApprovals" => Ok(__FieldTag::__manual_approvals),
                            "manual_approvals" => Ok(__FieldTag::__manual_approvals),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApprovalWorkflow;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApprovalWorkflow")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__manual_approvals => {
                            if !fields.insert(__FieldTag::__manual_approvals) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for manual_approvals",
                                ));
                            }
                            if result.approval_workflow.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `approval_workflow`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.ApprovalWorkflow.manual_approvals, latest field was manualApprovals",
                                ));
                            }
                            result.approval_workflow = std::option::Option::Some(
                                crate::model::approval_workflow::ApprovalWorkflow::ManualApprovals(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ManualApprovals>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApprovalWorkflow {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.manual_approvals() {
            state.serialize_entry("manualApprovals", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApprovalWorkflow {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApprovalWorkflow");
        debug_struct.field("approval_workflow", &self.approval_workflow);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ApprovalWorkflow].
pub mod approval_workflow {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ApprovalWorkflow {
        /// An approval workflow where users designated as approvers review and act
        /// on the grants.
        ManualApprovals(std::boxed::Box<crate::model::ManualApprovals>),
    }
}

/// A manual approval workflow where users who are designated as approvers
/// need to call the `ApproveGrant`/`DenyGrant` APIs for a grant. The workflow
/// can consist of multiple serial steps where each step defines who can act as
/// approver in that step and how many of those users should approve before the
/// workflow moves to the next step.
///
/// This can be used to create approval workflows such as:
///
/// * Require an approval from any user in a group G.
/// * Require an approval from any k number of users from a Group G.
/// * Require an approval from any user in a group G and then from a user U.
///
/// A single user might be part of the `approvers` ACL for multiple steps in this
/// workflow, but they can only approve once and that approval is only considered
/// to satisfy the approval step at which it was granted.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ManualApprovals {
    /// Optional. Do the approvers need to provide a justification for their
    /// actions?
    pub require_approver_justification: bool,

    /// Optional. List of approval steps in this workflow. These steps are followed
    /// in the specified order sequentially. Only 1 step is supported.
    pub steps: std::vec::Vec<crate::model::manual_approvals::Step>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ManualApprovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [require_approver_justification][crate::model::ManualApprovals::require_approver_justification].
    pub fn set_require_approver_justification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_approver_justification = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::ManualApprovals::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::manual_approvals::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ManualApprovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ManualApprovals"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ManualApprovals {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __require_approver_justification,
            __steps,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ManualApprovals")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "requireApproverJustification" => {
                                Ok(__FieldTag::__require_approver_justification)
                            }
                            "require_approver_justification" => {
                                Ok(__FieldTag::__require_approver_justification)
                            }
                            "steps" => Ok(__FieldTag::__steps),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ManualApprovals;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ManualApprovals")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__require_approver_justification => {
                            if !fields.insert(__FieldTag::__require_approver_justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for require_approver_justification",
                                ));
                            }
                            result.require_approver_justification = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__steps => {
                            if !fields.insert(__FieldTag::__steps) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for steps",
                                ));
                            }
                            result.steps = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::manual_approvals::Step>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ManualApprovals {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.require_approver_justification) {
            state.serialize_entry(
                "requireApproverJustification",
                &self.require_approver_justification,
            )?;
        }
        if !self.steps.is_empty() {
            state.serialize_entry("steps", &self.steps)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ManualApprovals {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ManualApprovals");
        debug_struct.field(
            "require_approver_justification",
            &self.require_approver_justification,
        );
        debug_struct.field("steps", &self.steps);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [ManualApprovals].
pub mod manual_approvals {
    #[allow(unused_imports)]
    use super::*;

    /// Step represents a logical step in a manual approval workflow.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Step {
        /// Optional. The potential set of approvers in this step. This list must
        /// contain at most one entry.
        pub approvers: std::vec::Vec<crate::model::AccessControlEntry>,

        /// Required. How many users from the above list need to approve. If there
        /// aren't enough distinct users in the list, then the workflow indefinitely
        /// blocks. Should always be greater than 0. 1 is the only supported value.
        pub approvals_needed: i32,

        /// Optional. Additional email addresses to be notified when a grant is
        /// pending approval.
        pub approver_email_recipients: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Step {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [approvers][crate::model::manual_approvals::Step::approvers].
        pub fn set_approvers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::AccessControlEntry>,
        {
            use std::iter::Iterator;
            self.approvers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [approvals_needed][crate::model::manual_approvals::Step::approvals_needed].
        pub fn set_approvals_needed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.approvals_needed = v.into();
            self
        }

        /// Sets the value of [approver_email_recipients][crate::model::manual_approvals::Step::approver_email_recipients].
        pub fn set_approver_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.approver_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Step {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ManualApprovals.Step"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Step {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __approvers,
                __approvals_needed,
                __approver_email_recipients,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Step")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "approvers" => Ok(__FieldTag::__approvers),
                                "approvalsNeeded" => Ok(__FieldTag::__approvals_needed),
                                "approvals_needed" => Ok(__FieldTag::__approvals_needed),
                                "approverEmailRecipients" => {
                                    Ok(__FieldTag::__approver_email_recipients)
                                }
                                "approver_email_recipients" => {
                                    Ok(__FieldTag::__approver_email_recipients)
                                }
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Step;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Step")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__approvers => {
                                if !fields.insert(__FieldTag::__approvers) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for approvers",
                                    ));
                                }
                                result.approvers = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::AccessControlEntry>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__approvals_needed => {
                                if !fields.insert(__FieldTag::__approvals_needed) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for approvals_needed",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.approvals_needed =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__approver_email_recipients => {
                                if !fields.insert(__FieldTag::__approver_email_recipients) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for approver_email_recipients",
                                    ));
                                }
                                result.approver_email_recipients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Step {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.approvers.is_empty() {
                state.serialize_entry("approvers", &self.approvers)?;
            }
            if !wkt::internal::is_default(&self.approvals_needed) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry("approvalsNeeded", &__With(&self.approvals_needed))?;
            }
            if !self.approver_email_recipients.is_empty() {
                state
                    .serialize_entry("approverEmailRecipients", &self.approver_email_recipients)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Step {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Step");
            debug_struct.field("approvers", &self.approvers);
            debug_struct.field("approvals_needed", &self.approvals_needed);
            debug_struct.field("approver_email_recipients", &self.approver_email_recipients);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }
}

/// Privileged access that this service can be used to gate.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct PrivilegedAccess {
    pub access_type: std::option::Option<crate::model::privileged_access::AccessType>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PrivilegedAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [access_type][crate::model::PrivilegedAccess::access_type].
    ///
    /// Note that all the setters affecting `access_type` are mutually
    /// exclusive.
    pub fn set_access_type<
        T: std::convert::Into<std::option::Option<crate::model::privileged_access::AccessType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_type = v.into();
        self
    }

    /// The value of [access_type][crate::model::PrivilegedAccess::access_type]
    /// if it holds a `GcpIamAccess`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcp_iam_access(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privileged_access::GcpIamAccess>> {
        #[allow(unreachable_patterns)]
        self.access_type.as_ref().and_then(|v| match v {
            crate::model::privileged_access::AccessType::GcpIamAccess(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [access_type][crate::model::PrivilegedAccess::access_type]
    /// to hold a `GcpIamAccess`.
    ///
    /// Note that all the setters affecting `access_type` are
    /// mutually exclusive.
    pub fn set_gcp_iam_access<
        T: std::convert::Into<std::boxed::Box<crate::model::privileged_access::GcpIamAccess>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_type = std::option::Option::Some(
            crate::model::privileged_access::AccessType::GcpIamAccess(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivilegedAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PrivilegedAccess {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcp_iam_access,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PrivilegedAccess")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcpIamAccess" => Ok(__FieldTag::__gcp_iam_access),
                            "gcp_iam_access" => Ok(__FieldTag::__gcp_iam_access),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PrivilegedAccess;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PrivilegedAccess")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcp_iam_access => {
                            if !fields.insert(__FieldTag::__gcp_iam_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcp_iam_access",
                                ));
                            }
                            if result.access_type.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `access_type`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.PrivilegedAccess.gcp_iam_access, latest field was gcpIamAccess",
                                ));
                            }
                            result.access_type = std::option::Option::Some(
                                crate::model::privileged_access::AccessType::GcpIamAccess(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::privileged_access::GcpIamAccess,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PrivilegedAccess {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcp_iam_access() {
            state.serialize_entry("gcpIamAccess", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for PrivilegedAccess {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("PrivilegedAccess");
        debug_struct.field("access_type", &self.access_type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [PrivilegedAccess].
pub mod privileged_access {
    #[allow(unused_imports)]
    use super::*;

    /// `GcpIamAccess` represents IAM based access control on a Google Cloud
    /// resource. Refer to <https://cloud.google.com/iam/docs> to understand more
    /// about IAM.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GcpIamAccess {
        /// Required. The type of this resource.
        pub resource_type: std::string::String,

        /// Required. Name of the resource.
        pub resource: std::string::String,

        /// Required. Role bindings that are created on successful grant.
        pub role_bindings:
            std::vec::Vec<crate::model::privileged_access::gcp_iam_access::RoleBinding>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GcpIamAccess {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_type][crate::model::privileged_access::GcpIamAccess::resource_type].
        pub fn set_resource_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::privileged_access::GcpIamAccess::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [role_bindings][crate::model::privileged_access::GcpIamAccess::role_bindings].
        pub fn set_role_bindings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::privileged_access::gcp_iam_access::RoleBinding>,
        {
            use std::iter::Iterator;
            self.role_bindings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcpIamAccess {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess.GcpIamAccess"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GcpIamAccess {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __resource_type,
                __resource,
                __role_bindings,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GcpIamAccess")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "resourceType" => Ok(__FieldTag::__resource_type),
                                "resource_type" => Ok(__FieldTag::__resource_type),
                                "resource" => Ok(__FieldTag::__resource),
                                "roleBindings" => Ok(__FieldTag::__role_bindings),
                                "role_bindings" => Ok(__FieldTag::__role_bindings),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GcpIamAccess;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GcpIamAccess")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__resource_type => {
                                if !fields.insert(__FieldTag::__resource_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource_type",
                                    ));
                                }
                                result.resource_type = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__resource => {
                                if !fields.insert(__FieldTag::__resource) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for resource",
                                    ));
                                }
                                result.resource = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__role_bindings => {
                                if !fields.insert(__FieldTag::__role_bindings) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for role_bindings",
                                    ));
                                }
                                result.role_bindings = map.next_value::<std::option::Option<std::vec::Vec<crate::model::privileged_access::gcp_iam_access::RoleBinding>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GcpIamAccess {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.resource_type.is_empty() {
                state.serialize_entry("resourceType", &self.resource_type)?;
            }
            if !self.resource.is_empty() {
                state.serialize_entry("resource", &self.resource)?;
            }
            if !self.role_bindings.is_empty() {
                state.serialize_entry("roleBindings", &self.role_bindings)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for GcpIamAccess {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("GcpIamAccess");
            debug_struct.field("resource_type", &self.resource_type);
            debug_struct.field("resource", &self.resource);
            debug_struct.field("role_bindings", &self.role_bindings);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [GcpIamAccess].
    pub mod gcp_iam_access {
        #[allow(unused_imports)]
        use super::*;

        /// IAM role bindings that are created after a successful grant.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct RoleBinding {
            /// Required. IAM role to be granted.
            /// <https://cloud.google.com/iam/docs/roles-overview>.
            pub role: std::string::String,

            /// Optional. The expression field of the IAM condition to be associated
            /// with the role. If specified, a user with an active grant for this
            /// entitlement is able to access the resource only if this condition
            /// evaluates to true for their request.
            ///
            /// This field uses the same CEL format as IAM and supports all attributes
            /// that IAM supports, except tags.
            /// <https://cloud.google.com/iam/docs/conditions-overview#attributes>.
            pub condition_expression: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl RoleBinding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [role][crate::model::privileged_access::gcp_iam_access::RoleBinding::role].
            pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.role = v.into();
                self
            }

            /// Sets the value of [condition_expression][crate::model::privileged_access::gcp_iam_access::RoleBinding::condition_expression].
            pub fn set_condition_expression<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.condition_expression = v.into();
                self
            }
        }

        impl wkt::message::Message for RoleBinding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess.GcpIamAccess.RoleBinding"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for RoleBinding {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __role,
                    __condition_expression,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for RoleBinding")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "role" => Ok(__FieldTag::__role),
                                    "conditionExpression" => Ok(__FieldTag::__condition_expression),
                                    "condition_expression" => {
                                        Ok(__FieldTag::__condition_expression)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = RoleBinding;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct RoleBinding")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__role => {
                                    if !fields.insert(__FieldTag::__role) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for role"),
                                        );
                                    }
                                    result.role = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__condition_expression => {
                                    if !fields.insert(__FieldTag::__condition_expression) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for condition_expression",
                                            ),
                                        );
                                    }
                                    result.condition_expression = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for RoleBinding {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.role.is_empty() {
                    state.serialize_entry("role", &self.role)?;
                }
                if !self.condition_expression.is_empty() {
                    state.serialize_entry("conditionExpression", &self.condition_expression)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for RoleBinding {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("RoleBinding");
                debug_struct.field("role", &self.role);
                debug_struct.field("condition_expression", &self.condition_expression);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }
    }

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AccessType {
        /// Access to a Google Cloud resource through IAM.
        GcpIamAccess(std::boxed::Box<crate::model::privileged_access::GcpIamAccess>),
    }
}

/// Message for requesting list of entitlements.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent which owns the entitlement resources.
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntitlementsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntitlementsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListEntitlementsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitlementsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitlementsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitlementsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEntitlementsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntitlementsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing entitlements.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of entitlements.
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEntitlementsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListEntitlementsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListEntitlementsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitlements,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListEntitlementsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitlements" => Ok(__FieldTag::__entitlements),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListEntitlementsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListEntitlementsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitlements => {
                            if !fields.insert(__FieldTag::__entitlements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlements",
                                ));
                            }
                            result.entitlements = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entitlement>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListEntitlementsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entitlements.is_empty() {
            state.serialize_entry("entitlements", &self.entitlements)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListEntitlementsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListEntitlementsResponse");
        debug_struct.field("entitlements", &self.entitlements);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `SearchEntitlements` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchEntitlementsRequest {
    /// Required. The parent which owns the entitlement resources.
    pub parent: std::string::String,

    /// Required. Only entitlements where the calling user has this access are
    /// returned.
    pub caller_access_type: crate::model::search_entitlements_request::CallerAccessType,

    /// Optional. Only entitlements matching this filter are returned in the
    /// response.
    pub filter: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [caller_access_type][crate::model::SearchEntitlementsRequest::caller_access_type].
    pub fn set_caller_access_type<
        T: std::convert::Into<crate::model::search_entitlements_request::CallerAccessType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.caller_access_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchEntitlementsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchEntitlementsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchEntitlementsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __caller_access_type,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchEntitlementsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "callerAccessType" => Ok(__FieldTag::__caller_access_type),
                            "caller_access_type" => Ok(__FieldTag::__caller_access_type),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchEntitlementsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchEntitlementsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__caller_access_type => {
                            if !fields.insert(__FieldTag::__caller_access_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for caller_access_type",
                                ));
                            }
                            result.caller_access_type = map
                                .next_value::<std::option::Option<
                                    crate::model::search_entitlements_request::CallerAccessType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchEntitlementsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.caller_access_type) {
            state.serialize_entry("callerAccessType", &self.caller_access_type)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchEntitlementsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchEntitlementsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("caller_access_type", &self.caller_access_type);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchEntitlementsRequest].
pub mod search_entitlements_request {
    #[allow(unused_imports)]
    use super::*;

    /// Different types of access a user can have on the entitlement resource.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CallerAccessType {
        /// Unspecified access type.
        Unspecified,
        /// The user has access to create grants using this entitlement.
        GrantRequester,
        /// The user has access to approve/deny grants created under this
        /// entitlement.
        GrantApprover,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CallerAccessType::value] or
        /// [CallerAccessType::name].
        UnknownValue(caller_access_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod caller_access_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CallerAccessType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::GrantRequester => std::option::Option::Some(1),
                Self::GrantApprover => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("CALLER_ACCESS_TYPE_UNSPECIFIED"),
                Self::GrantRequester => std::option::Option::Some("GRANT_REQUESTER"),
                Self::GrantApprover => std::option::Option::Some("GRANT_APPROVER"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CallerAccessType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CallerAccessType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CallerAccessType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::GrantRequester,
                2 => Self::GrantApprover,
                _ => Self::UnknownValue(caller_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CallerAccessType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CALLER_ACCESS_TYPE_UNSPECIFIED" => Self::Unspecified,
                "GRANT_REQUESTER" => Self::GrantRequester,
                "GRANT_APPROVER" => Self::GrantApprover,
                _ => Self::UnknownValue(caller_access_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CallerAccessType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::GrantRequester => serializer.serialize_i32(1),
                Self::GrantApprover => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CallerAccessType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CallerAccessType>::new(
                ".google.cloud.privilegedaccessmanager.v1.SearchEntitlementsRequest.CallerAccessType"))
        }
    }
}

/// Response message for `SearchEntitlements` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchEntitlementsResponse {
    /// The list of entitlements.
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlements][crate::model::SearchEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchEntitlementsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchEntitlementsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitlements,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchEntitlementsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitlements" => Ok(__FieldTag::__entitlements),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchEntitlementsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchEntitlementsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitlements => {
                            if !fields.insert(__FieldTag::__entitlements) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlements",
                                ));
                            }
                            result.entitlements = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Entitlement>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchEntitlementsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.entitlements.is_empty() {
            state.serialize_entry("entitlements", &self.entitlements)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchEntitlementsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchEntitlementsResponse");
        debug_struct.field("entitlements", &self.entitlements);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting an entitlement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetEntitlementRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntitlementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.GetEntitlementRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetEntitlementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetEntitlementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetEntitlementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetEntitlementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetEntitlementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetEntitlementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetEntitlementRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating an entitlement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateEntitlementRequest {
    /// Required. Name of the parent resource for the entitlement.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}`
    /// * `folders/{folder-number}/locations/{region}`
    /// * `projects/{project-id|project-number}/locations/{region}`
    pub parent: std::string::String,

    /// Required. The ID to use for this entitlement. This becomes the last part of
    /// the resource name.
    ///
    /// This value should be 4-63 characters in length, and valid characters are
    /// "[a-z]", "[0-9]", and "-". The first character should be from [a-z].
    ///
    /// This value should be unique among all other entitlements under the
    /// specified `parent`.
    pub entitlement_id: std::string::String,

    /// Required. The resource being created
    pub entitlement: std::option::Option<crate::model::Entitlement>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request and returns the
    /// previous operation's response. This prevents clients from accidentally
    /// creating duplicate entitlements.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntitlementRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CreateEntitlementRequest::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [entitlement][crate::model::CreateEntitlementRequest::entitlement].
    pub fn set_entitlement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entitlement>,
    {
        self.entitlement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entitlement][crate::model::CreateEntitlementRequest::entitlement].
    pub fn set_or_clear_entitlement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entitlement>,
    {
        self.entitlement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEntitlementRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CreateEntitlementRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateEntitlementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __entitlement_id,
            __entitlement,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateEntitlementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "entitlementId" => Ok(__FieldTag::__entitlement_id),
                            "entitlement_id" => Ok(__FieldTag::__entitlement_id),
                            "entitlement" => Ok(__FieldTag::__entitlement),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateEntitlementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateEntitlementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement_id => {
                            if !fields.insert(__FieldTag::__entitlement_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement_id",
                                ));
                            }
                            result.entitlement_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__entitlement => {
                            if !fields.insert(__FieldTag::__entitlement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement",
                                ));
                            }
                            result.entitlement =
                                map.next_value::<std::option::Option<crate::model::Entitlement>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateEntitlementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.entitlement_id.is_empty() {
            state.serialize_entry("entitlementId", &self.entitlement_id)?;
        }
        if self.entitlement.is_some() {
            state.serialize_entry("entitlement", &self.entitlement)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateEntitlementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateEntitlementRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("entitlement_id", &self.entitlement_id);
        debug_struct.field("entitlement", &self.entitlement);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for deleting an entitlement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteEntitlementRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    /// Optional. If set to true, any child grant under this entitlement is also
    /// deleted. (Otherwise, the request only works if the entitlement has no child
    /// grant.)
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntitlementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEntitlementRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntitlementRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.DeleteEntitlementRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteEntitlementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteEntitlementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteEntitlementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteEntitlementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteEntitlementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DeleteEntitlementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteEntitlementRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for updating an entitlement.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateEntitlementRequest {
    /// Required. The entitlement resource that is updated.
    pub entitlement: std::option::Option<crate::model::Entitlement>,

    /// Required. The list of fields to update. A field is overwritten if, and only
    /// if, it is in the mask. Any immutable fields set in the mask are ignored by
    /// the server. Repeated fields and map fields are only allowed in the last
    /// position of a `paths` string and overwrite the existing values. Hence an
    /// update to a repeated field or a map should contain the entire list of
    /// values. The fields specified in the update_mask are relative to the
    /// resource and not to the request.
    /// (e.g. `MaxRequestDuration`; *not* `entitlement.MaxRequestDuration`)
    /// A value of '*' for this field refers to full replacement of the resource.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlement][crate::model::UpdateEntitlementRequest::entitlement].
    pub fn set_entitlement<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Entitlement>,
    {
        self.entitlement = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [entitlement][crate::model::UpdateEntitlementRequest::entitlement].
    pub fn set_or_clear_entitlement<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Entitlement>,
    {
        self.entitlement = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntitlementRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateEntitlementRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.UpdateEntitlementRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateEntitlementRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __entitlement,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateEntitlementRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "entitlement" => Ok(__FieldTag::__entitlement),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateEntitlementRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateEntitlementRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__entitlement => {
                            if !fields.insert(__FieldTag::__entitlement) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for entitlement",
                                ));
                            }
                            result.entitlement =
                                map.next_value::<std::option::Option<crate::model::Entitlement>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateEntitlementRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.entitlement.is_some() {
            state.serialize_entry("entitlement", &self.entitlement)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for UpdateEntitlementRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateEntitlementRequest");
        debug_struct.field("entitlement", &self.entitlement);
        debug_struct.field("update_mask", &self.update_mask);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// A grant represents a request from a user for obtaining the access specified
/// in an entitlement they are eligible for.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Grant {
    /// Identifier. Name of this grant.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    /// * `folders/{folder-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    /// * `projects/{project-id|project-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    ///
    /// The last segment of this name (`{grant-id}`) is autogenerated.
    pub name: std::string::String,

    /// Output only. Create time stamp.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Username of the user who created this grant.
    pub requester: std::string::String,

    /// Required. The amount of time access is needed for. This value should be
    /// less than the `max_request_duration` value of the entitlement.
    pub requested_duration: std::option::Option<wkt::Duration>,

    /// Optional. Justification of why this access is needed.
    pub justification: std::option::Option<crate::model::Justification>,

    /// Output only. Current state of this grant.
    pub state: crate::model::grant::State,

    /// Output only. Timeline of this grant.
    pub timeline: std::option::Option<crate::model::grant::Timeline>,

    /// Output only. The access that would be granted by this grant.
    pub privileged_access: std::option::Option<crate::model::PrivilegedAccess>,

    /// Output only. Audit trail of access provided by this grant. If unspecified
    /// then access was never granted.
    pub audit_trail: std::option::Option<crate::model::grant::AuditTrail>,

    /// Optional. Additional email addresses to notify for all the actions
    /// performed on the grant.
    pub additional_email_recipients: std::vec::Vec<std::string::String>,

    /// Output only. Flag set by the PAM system to indicate that policy bindings
    /// made by this grant have been modified from outside PAM.
    ///
    /// After it is set, this flag remains set forever irrespective of the grant
    /// state. A `true` value here indicates that PAM no longer has any certainty
    /// on the access a user has because of this grant.
    pub externally_modified: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Grant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Grant::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Grant::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Grant::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Grant::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Grant::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [requester][crate::model::Grant::requester].
    pub fn set_requester<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requester = v.into();
        self
    }

    /// Sets the value of [requested_duration][crate::model::Grant::requested_duration].
    pub fn set_requested_duration<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.requested_duration = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [requested_duration][crate::model::Grant::requested_duration].
    pub fn set_or_clear_requested_duration<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Duration>,
    {
        self.requested_duration = v.map(|x| x.into());
        self
    }

    /// Sets the value of [justification][crate::model::Grant::justification].
    pub fn set_justification<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Justification>,
    {
        self.justification = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [justification][crate::model::Grant::justification].
    pub fn set_or_clear_justification<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Justification>,
    {
        self.justification = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::Grant::state].
    pub fn set_state<T: std::convert::Into<crate::model::grant::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [timeline][crate::model::Grant::timeline].
    pub fn set_timeline<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::grant::Timeline>,
    {
        self.timeline = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [timeline][crate::model::Grant::timeline].
    pub fn set_or_clear_timeline<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::grant::Timeline>,
    {
        self.timeline = v.map(|x| x.into());
        self
    }

    /// Sets the value of [privileged_access][crate::model::Grant::privileged_access].
    pub fn set_privileged_access<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::PrivilegedAccess>,
    {
        self.privileged_access = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [privileged_access][crate::model::Grant::privileged_access].
    pub fn set_or_clear_privileged_access<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::PrivilegedAccess>,
    {
        self.privileged_access = v.map(|x| x.into());
        self
    }

    /// Sets the value of [audit_trail][crate::model::Grant::audit_trail].
    pub fn set_audit_trail<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::grant::AuditTrail>,
    {
        self.audit_trail = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [audit_trail][crate::model::Grant::audit_trail].
    pub fn set_or_clear_audit_trail<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::grant::AuditTrail>,
    {
        self.audit_trail = v.map(|x| x.into());
        self
    }

    /// Sets the value of [additional_email_recipients][crate::model::Grant::additional_email_recipients].
    pub fn set_additional_email_recipients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_email_recipients = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [externally_modified][crate::model::Grant::externally_modified].
    pub fn set_externally_modified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.externally_modified = v.into();
        self
    }
}

impl wkt::message::Message for Grant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Grant {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __update_time,
            __requester,
            __requested_duration,
            __justification,
            __state,
            __timeline,
            __privileged_access,
            __audit_trail,
            __additional_email_recipients,
            __externally_modified,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Grant")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "requester" => Ok(__FieldTag::__requester),
                            "requestedDuration" => Ok(__FieldTag::__requested_duration),
                            "requested_duration" => Ok(__FieldTag::__requested_duration),
                            "justification" => Ok(__FieldTag::__justification),
                            "state" => Ok(__FieldTag::__state),
                            "timeline" => Ok(__FieldTag::__timeline),
                            "privilegedAccess" => Ok(__FieldTag::__privileged_access),
                            "privileged_access" => Ok(__FieldTag::__privileged_access),
                            "auditTrail" => Ok(__FieldTag::__audit_trail),
                            "audit_trail" => Ok(__FieldTag::__audit_trail),
                            "additionalEmailRecipients" => {
                                Ok(__FieldTag::__additional_email_recipients)
                            }
                            "additional_email_recipients" => {
                                Ok(__FieldTag::__additional_email_recipients)
                            }
                            "externallyModified" => Ok(__FieldTag::__externally_modified),
                            "externally_modified" => Ok(__FieldTag::__externally_modified),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Grant;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Grant")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__requester => {
                            if !fields.insert(__FieldTag::__requester) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requester",
                                ));
                            }
                            result.requester = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_duration => {
                            if !fields.insert(__FieldTag::__requested_duration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_duration",
                                ));
                            }
                            result.requested_duration =
                                map.next_value::<std::option::Option<wkt::Duration>>()?;
                        }
                        __FieldTag::__justification => {
                            if !fields.insert(__FieldTag::__justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for justification",
                                ));
                            }
                            result.justification = map
                                .next_value::<std::option::Option<crate::model::Justification>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::grant::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__timeline => {
                            if !fields.insert(__FieldTag::__timeline) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeline",
                                ));
                            }
                            result.timeline = map
                                .next_value::<std::option::Option<crate::model::grant::Timeline>>(
                                )?;
                        }
                        __FieldTag::__privileged_access => {
                            if !fields.insert(__FieldTag::__privileged_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for privileged_access",
                                ));
                            }
                            result.privileged_access = map
                                .next_value::<std::option::Option<crate::model::PrivilegedAccess>>(
                                )?;
                        }
                        __FieldTag::__audit_trail => {
                            if !fields.insert(__FieldTag::__audit_trail) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for audit_trail",
                                ));
                            }
                            result.audit_trail = map
                                .next_value::<std::option::Option<crate::model::grant::AuditTrail>>(
                                )?;
                        }
                        __FieldTag::__additional_email_recipients => {
                            if !fields.insert(__FieldTag::__additional_email_recipients) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for additional_email_recipients",
                                ));
                            }
                            result.additional_email_recipients = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__externally_modified => {
                            if !fields.insert(__FieldTag::__externally_modified) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for externally_modified",
                                ));
                            }
                            result.externally_modified = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Grant {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !self.requester.is_empty() {
            state.serialize_entry("requester", &self.requester)?;
        }
        if self.requested_duration.is_some() {
            state.serialize_entry("requestedDuration", &self.requested_duration)?;
        }
        if self.justification.is_some() {
            state.serialize_entry("justification", &self.justification)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.timeline.is_some() {
            state.serialize_entry("timeline", &self.timeline)?;
        }
        if self.privileged_access.is_some() {
            state.serialize_entry("privilegedAccess", &self.privileged_access)?;
        }
        if self.audit_trail.is_some() {
            state.serialize_entry("auditTrail", &self.audit_trail)?;
        }
        if !self.additional_email_recipients.is_empty() {
            state.serialize_entry(
                "additionalEmailRecipients",
                &self.additional_email_recipients,
            )?;
        }
        if !wkt::internal::is_default(&self.externally_modified) {
            state.serialize_entry("externallyModified", &self.externally_modified)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Grant {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Grant");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("requester", &self.requester);
        debug_struct.field("requested_duration", &self.requested_duration);
        debug_struct.field("justification", &self.justification);
        debug_struct.field("state", &self.state);
        debug_struct.field("timeline", &self.timeline);
        debug_struct.field("privileged_access", &self.privileged_access);
        debug_struct.field("audit_trail", &self.audit_trail);
        debug_struct.field(
            "additional_email_recipients",
            &self.additional_email_recipients,
        );
        debug_struct.field("externally_modified", &self.externally_modified);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Grant].
pub mod grant {
    #[allow(unused_imports)]
    use super::*;

    /// Timeline of a grant describing what happened to it and when.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Timeline {
        /// Output only. The events that have occurred on this grant. This list
        /// contains entries in the same order as they occurred. The first entry is
        /// always be of type `Requested` and there is always at least one entry in
        /// this array.
        pub events: std::vec::Vec<crate::model::grant::timeline::Event>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Timeline {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [events][crate::model::grant::Timeline::events].
        pub fn set_events<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::grant::timeline::Event>,
        {
            use std::iter::Iterator;
            self.events = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Timeline {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Timeline {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __events,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Timeline")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "events" => Ok(__FieldTag::__events),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Timeline;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Timeline")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__events => {
                                if !fields.insert(__FieldTag::__events) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for events",
                                    ));
                                }
                                result.events = map
                                    .next_value::<std::option::Option<
                                        std::vec::Vec<crate::model::grant::timeline::Event>,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Timeline {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.events.is_empty() {
                state.serialize_entry("events", &self.events)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for Timeline {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("Timeline");
            debug_struct.field("events", &self.events);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Defines additional types related to [Timeline].
    pub mod timeline {
        #[allow(unused_imports)]
        use super::*;

        /// A single operation on the grant.
        #[derive(Clone, Default, PartialEq)]
        #[non_exhaustive]
        pub struct Event {
            /// Output only. The time (as recorded at server) when this event occurred.
            pub event_time: std::option::Option<wkt::Timestamp>,

            pub event: std::option::Option<crate::model::grant::timeline::event::Event>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl Event {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [event_time][crate::model::grant::timeline::Event::event_time].
            pub fn set_event_time<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.event_time = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [event_time][crate::model::grant::timeline::Event::event_time].
            pub fn set_or_clear_event_time<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<wkt::Timestamp>,
            {
                self.event_time = v.map(|x| x.into());
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event].
            ///
            /// Note that all the setters affecting `event` are mutually
            /// exclusive.
            pub fn set_event<
                T: std::convert::Into<
                        std::option::Option<crate::model::grant::timeline::event::Event>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = v.into();
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Requested`, `None` if the field is not set or
            /// holds a different branch.
            pub fn requested(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Requested>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Requested(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Requested`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_requested<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::grant::timeline::event::Requested>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Requested(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Approved`, `None` if the field is not set or
            /// holds a different branch.
            pub fn approved(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Approved>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Approved(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Approved`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_approved<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Approved>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Approved(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Denied`, `None` if the field is not set or
            /// holds a different branch.
            pub fn denied(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Denied>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Denied(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Denied`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_denied<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Denied>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Denied(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Revoked`, `None` if the field is not set or
            /// holds a different branch.
            pub fn revoked(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Revoked>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Revoked(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Revoked`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_revoked<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Revoked>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Revoked(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Scheduled`, `None` if the field is not set or
            /// holds a different branch.
            pub fn scheduled(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Scheduled>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Scheduled(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Scheduled`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_scheduled<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::grant::timeline::event::Scheduled>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Scheduled(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Activated`, `None` if the field is not set or
            /// holds a different branch.
            pub fn activated(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Activated>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Activated(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Activated`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_activated<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::grant::timeline::event::Activated>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Activated(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `ActivationFailed`, `None` if the field is not set or
            /// holds a different branch.
            pub fn activation_failed(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::ActivationFailed(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `ActivationFailed`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_activation_failed<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::ActivationFailed(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Expired`, `None` if the field is not set or
            /// holds a different branch.
            pub fn expired(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Expired>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Expired(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Expired`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_expired<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Expired>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Expired(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Ended`, `None` if the field is not set or
            /// holds a different branch.
            pub fn ended(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Ended>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Ended(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Ended`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_ended<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Ended>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Ended(v.into()),
                );
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `ExternallyModified`, `None` if the field is not set or
            /// holds a different branch.
            pub fn externally_modified(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::ExternallyModified(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `ExternallyModified`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_externally_modified<
                T: std::convert::Into<
                        std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
                    >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::ExternallyModified(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Event {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for Event {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __requested,
                    __approved,
                    __denied,
                    __revoked,
                    __scheduled,
                    __activated,
                    __activation_failed,
                    __expired,
                    __ended,
                    __externally_modified,
                    __event_time,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for Event")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "requested" => Ok(__FieldTag::__requested),
                                    "approved" => Ok(__FieldTag::__approved),
                                    "denied" => Ok(__FieldTag::__denied),
                                    "revoked" => Ok(__FieldTag::__revoked),
                                    "scheduled" => Ok(__FieldTag::__scheduled),
                                    "activated" => Ok(__FieldTag::__activated),
                                    "activationFailed" => Ok(__FieldTag::__activation_failed),
                                    "activation_failed" => Ok(__FieldTag::__activation_failed),
                                    "expired" => Ok(__FieldTag::__expired),
                                    "ended" => Ok(__FieldTag::__ended),
                                    "externallyModified" => Ok(__FieldTag::__externally_modified),
                                    "externally_modified" => Ok(__FieldTag::__externally_modified),
                                    "eventTime" => Ok(__FieldTag::__event_time),
                                    "event_time" => Ok(__FieldTag::__event_time),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = Event;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct Event")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__requested => {
                                    if !fields.insert(__FieldTag::__requested) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for requested",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.requested, latest field was requested",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Requested(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Requested,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__approved => {
                                    if !fields.insert(__FieldTag::__approved) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for approved",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.approved, latest field was approved",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Approved(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Approved,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__denied => {
                                    if !fields.insert(__FieldTag::__denied) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for denied"),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.denied, latest field was denied",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Denied(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Denied,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__revoked => {
                                    if !fields.insert(__FieldTag::__revoked) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for revoked",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.revoked, latest field was revoked",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Revoked(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Revoked,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__scheduled => {
                                    if !fields.insert(__FieldTag::__scheduled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for scheduled",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.scheduled, latest field was scheduled",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Scheduled(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Scheduled,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__activated => {
                                    if !fields.insert(__FieldTag::__activated) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for activated",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.activated, latest field was activated",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Activated(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Activated,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__activation_failed => {
                                    if !fields.insert(__FieldTag::__activation_failed) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for activation_failed",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.activation_failed, latest field was activationFailed",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::ActivationFailed(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__expired => {
                                    if !fields.insert(__FieldTag::__expired) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for expired",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.expired, latest field was expired",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Expired(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Expired,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__ended => {
                                    if !fields.insert(__FieldTag::__ended) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for ended"),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.ended, latest field was ended",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::Ended(
                                            map.next_value::<std::option::Option<
                                                std::boxed::Box<
                                                    crate::model::grant::timeline::event::Ended,
                                                >,
                                            >>()?
                                            .unwrap_or_default(),
                                        ),
                                    );
                                }
                                __FieldTag::__externally_modified => {
                                    if !fields.insert(__FieldTag::__externally_modified) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for externally_modified",
                                            ),
                                        );
                                    }
                                    if result.event.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `event`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.externally_modified, latest field was externallyModified",
                                            ),
                                        );
                                    }
                                    result.event = std::option::Option::Some(
                                        crate::model::grant::timeline::event::Event::ExternallyModified(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__event_time => {
                                    if !fields.insert(__FieldTag::__event_time) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for event_time",
                                            ),
                                        );
                                    }
                                    result.event_time =
                                        map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for Event {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.requested() {
                    state.serialize_entry("requested", value)?;
                }
                if let Some(value) = self.approved() {
                    state.serialize_entry("approved", value)?;
                }
                if let Some(value) = self.denied() {
                    state.serialize_entry("denied", value)?;
                }
                if let Some(value) = self.revoked() {
                    state.serialize_entry("revoked", value)?;
                }
                if let Some(value) = self.scheduled() {
                    state.serialize_entry("scheduled", value)?;
                }
                if let Some(value) = self.activated() {
                    state.serialize_entry("activated", value)?;
                }
                if let Some(value) = self.activation_failed() {
                    state.serialize_entry("activationFailed", value)?;
                }
                if let Some(value) = self.expired() {
                    state.serialize_entry("expired", value)?;
                }
                if let Some(value) = self.ended() {
                    state.serialize_entry("ended", value)?;
                }
                if let Some(value) = self.externally_modified() {
                    state.serialize_entry("externallyModified", value)?;
                }
                if self.event_time.is_some() {
                    state.serialize_entry("eventTime", &self.event_time)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        impl std::fmt::Debug for Event {
            fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                let mut debug_struct = f.debug_struct("Event");
                debug_struct.field("event_time", &self.event_time);
                debug_struct.field("event", &self.event);
                if !self._unknown_fields.is_empty() {
                    debug_struct.field("_unknown_fields", &self._unknown_fields);
                }
                debug_struct.finish()
            }
        }

        /// Defines additional types related to [Event].
        pub mod event {
            #[allow(unused_imports)]
            use super::*;

            /// An event representing that a grant was requested.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Requested {
                /// Output only. The time at which this grant expires unless the approval
                /// workflow completes. If omitted, then the request never expires.
                pub expire_time: std::option::Option<wkt::Timestamp>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Requested {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [expire_time][crate::model::grant::timeline::event::Requested::expire_time].
                pub fn set_expire_time<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Timestamp>,
                {
                    self.expire_time = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [expire_time][crate::model::grant::timeline::event::Requested::expire_time].
                pub fn set_or_clear_expire_time<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<wkt::Timestamp>,
                {
                    self.expire_time = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for Requested {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Requested"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Requested {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __expire_time,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Requested")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "expireTime" => Ok(__FieldTag::__expire_time),
                                        "expire_time" => Ok(__FieldTag::__expire_time),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Requested;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Requested")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__expire_time => {
                                        if !fields.insert(__FieldTag::__expire_time) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for expire_time",
                                                ),
                                            );
                                        }
                                        result.expire_time = map
                                            .next_value::<std::option::Option<wkt::Timestamp>>()?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Requested {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.expire_time.is_some() {
                        state.serialize_entry("expireTime", &self.expire_time)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Requested {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Requested");
                    debug_struct.field("expire_time", &self.expire_time);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant was approved.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Approved {
                /// Output only. The reason provided by the approver for approving the
                /// grant.
                pub reason: std::string::String,

                /// Output only. Username of the user who approved the grant.
                pub actor: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Approved {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Approved::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Approved::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Approved {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Approved"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Approved {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __reason,
                        __actor,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Approved")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "reason" => Ok(__FieldTag::__reason),
                                        "actor" => Ok(__FieldTag::__actor),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Approved;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Approved")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__reason => {
                                        if !fields.insert(__FieldTag::__reason) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for reason",
                                                ),
                                            );
                                        }
                                        result.reason = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__actor => {
                                        if !fields.insert(__FieldTag::__actor) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for actor",
                                                ),
                                            );
                                        }
                                        result.actor = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Approved {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.reason.is_empty() {
                        state.serialize_entry("reason", &self.reason)?;
                    }
                    if !self.actor.is_empty() {
                        state.serialize_entry("actor", &self.actor)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Approved {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Approved");
                    debug_struct.field("reason", &self.reason);
                    debug_struct.field("actor", &self.actor);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant was denied.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Denied {
                /// Output only. The reason provided by the approver for denying the
                /// grant.
                pub reason: std::string::String,

                /// Output only. Username of the user who denied the grant.
                pub actor: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Denied {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Denied::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Denied::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Denied {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Denied"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Denied {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __reason,
                        __actor,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Denied")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "reason" => Ok(__FieldTag::__reason),
                                        "actor" => Ok(__FieldTag::__actor),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Denied;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Denied")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__reason => {
                                        if !fields.insert(__FieldTag::__reason) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for reason",
                                                ),
                                            );
                                        }
                                        result.reason = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__actor => {
                                        if !fields.insert(__FieldTag::__actor) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for actor",
                                                ),
                                            );
                                        }
                                        result.actor = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Denied {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.reason.is_empty() {
                        state.serialize_entry("reason", &self.reason)?;
                    }
                    if !self.actor.is_empty() {
                        state.serialize_entry("actor", &self.actor)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Denied {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Denied");
                    debug_struct.field("reason", &self.reason);
                    debug_struct.field("actor", &self.actor);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant was revoked.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Revoked {
                /// Output only. The reason provided by the user for revoking the grant.
                pub reason: std::string::String,

                /// Output only. Username of the user who revoked the grant.
                pub actor: std::string::String,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Revoked {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Revoked::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Revoked::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Revoked {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Revoked"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Revoked {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __reason,
                        __actor,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Revoked")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "reason" => Ok(__FieldTag::__reason),
                                        "actor" => Ok(__FieldTag::__actor),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Revoked;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Revoked")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__reason => {
                                        if !fields.insert(__FieldTag::__reason) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for reason",
                                                ),
                                            );
                                        }
                                        result.reason = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::__actor => {
                                        if !fields.insert(__FieldTag::__actor) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for actor",
                                                ),
                                            );
                                        }
                                        result.actor = map
                                            .next_value::<std::option::Option<std::string::String>>(
                                            )?
                                            .unwrap_or_default();
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Revoked {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self.reason.is_empty() {
                        state.serialize_entry("reason", &self.reason)?;
                    }
                    if !self.actor.is_empty() {
                        state.serialize_entry("actor", &self.actor)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Revoked {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Revoked");
                    debug_struct.field("reason", &self.reason);
                    debug_struct.field("actor", &self.actor);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant has been scheduled to be
            /// activated later.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Scheduled {
                /// Output only. The time at which the access is granted.
                pub scheduled_activation_time: std::option::Option<wkt::Timestamp>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Scheduled {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [scheduled_activation_time][crate::model::grant::timeline::event::Scheduled::scheduled_activation_time].
                pub fn set_scheduled_activation_time<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<wkt::Timestamp>,
                {
                    self.scheduled_activation_time = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [scheduled_activation_time][crate::model::grant::timeline::event::Scheduled::scheduled_activation_time].
                pub fn set_or_clear_scheduled_activation_time<T>(
                    mut self,
                    v: std::option::Option<T>,
                ) -> Self
                where
                    T: std::convert::Into<wkt::Timestamp>,
                {
                    self.scheduled_activation_time = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for Scheduled {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Scheduled"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Scheduled {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __scheduled_activation_time,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Scheduled")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "scheduledActivationTime" => {
                                            Ok(__FieldTag::__scheduled_activation_time)
                                        }
                                        "scheduled_activation_time" => {
                                            Ok(__FieldTag::__scheduled_activation_time)
                                        }
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Scheduled;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Scheduled")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__scheduled_activation_time => {
                                        if !fields.insert(__FieldTag::__scheduled_activation_time) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for scheduled_activation_time",
                                                ),
                                            );
                                        }
                                        result.scheduled_activation_time =
                                            map.next_value::<std::option::Option<wkt::Timestamp>>(
                                            )?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Scheduled {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.scheduled_activation_time.is_some() {
                        state.serialize_entry(
                            "scheduledActivationTime",
                            &self.scheduled_activation_time,
                        )?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Scheduled {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Scheduled");
                    debug_struct
                        .field("scheduled_activation_time", &self.scheduled_activation_time);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant was successfully
            /// activated.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Activated {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Activated {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Activated {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Activated"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Activated {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Activated")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Activated;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Activated")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Activated {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Activated {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Activated");
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant activation failed.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ActivationFailed {
                /// Output only. The error that occurred while activating the grant.
                pub error: std::option::Option<rpc::model::Status>,

                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ActivationFailed {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error][crate::model::grant::timeline::event::ActivationFailed::error].
                pub fn set_error<T>(mut self, v: T) -> Self
                where
                    T: std::convert::Into<rpc::model::Status>,
                {
                    self.error = std::option::Option::Some(v.into());
                    self
                }

                /// Sets or clears the value of [error][crate::model::grant::timeline::event::ActivationFailed::error].
                pub fn set_or_clear_error<T>(mut self, v: std::option::Option<T>) -> Self
                where
                    T: std::convert::Into<rpc::model::Status>,
                {
                    self.error = v.map(|x| x.into());
                    self
                }
            }

            impl wkt::message::Message for ActivationFailed {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.ActivationFailed"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ActivationFailed {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        __error,
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ActivationFailed")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    match value {
                                        "error" => Ok(__FieldTag::__error),
                                        _ => Ok(__FieldTag::Unknown(value.to_string())),
                                    }
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ActivationFailed;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ActivationFailed")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut fields = std::collections::HashSet::new();
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::__error => {
                                        if !fields.insert(__FieldTag::__error) {
                                            return std::result::Result::Err(
                                                A::Error::duplicate_field(
                                                    "multiple values for error",
                                                ),
                                            );
                                        }
                                        result.error = map
                                            .next_value::<std::option::Option<rpc::model::Status>>(
                                            )?;
                                    }
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ActivationFailed {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if self.error.is_some() {
                        state.serialize_entry("error", &self.error)?;
                    }
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ActivationFailed {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ActivationFailed");
                    debug_struct.field("error", &self.error);
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant was expired.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Expired {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Expired {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Expired {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Expired"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Expired {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Expired")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Expired;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Expired")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Expired {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Expired {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Expired");
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the grant has ended.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct Ended {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl Ended {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Ended {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Ended"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for Ended {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for Ended")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = Ended;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct Ended")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for Ended {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for Ended {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("Ended");
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            /// An event representing that the policy bindings made by this grant were
            /// modified externally.
            #[derive(Clone, Default, PartialEq)]
            #[non_exhaustive]
            pub struct ExternallyModified {
                _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
            }

            impl ExternallyModified {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for ExternallyModified {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.ExternallyModified"
                }
            }

            #[doc(hidden)]
            impl<'de> serde::de::Deserialize<'de> for ExternallyModified {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    #[allow(non_camel_case_types)]
                    #[doc(hidden)]
                    #[derive(PartialEq, Eq, Hash)]
                    enum __FieldTag {
                        Unknown(std::string::String),
                    }
                    impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                        where
                            D: serde::Deserializer<'de>,
                        {
                            struct Visitor;
                            impl<'de> serde::de::Visitor<'de> for Visitor {
                                type Value = __FieldTag;
                                fn expecting(
                                    &self,
                                    formatter: &mut std::fmt::Formatter,
                                ) -> std::fmt::Result {
                                    formatter.write_str("a field name for ExternallyModified")
                                }
                                fn visit_str<E>(
                                    self,
                                    value: &str,
                                ) -> std::result::Result<Self::Value, E>
                                where
                                    E: serde::de::Error,
                                {
                                    use std::result::Result::Ok;
                                    use std::string::ToString;
                                    Ok(__FieldTag::Unknown(value.to_string()))
                                }
                            }
                            deserializer.deserialize_identifier(Visitor)
                        }
                    }
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = ExternallyModified;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("struct ExternallyModified")
                        }
                        fn visit_map<A>(
                            self,
                            mut map: A,
                        ) -> std::result::Result<Self::Value, A::Error>
                        where
                            A: serde::de::MapAccess<'de>,
                        {
                            #[allow(unused_imports)]
                            use serde::de::Error;
                            use std::option::Option::Some;
                            let mut result = Self::Value::new();
                            while let Some(tag) = map.next_key::<__FieldTag>()? {
                                #[allow(clippy::match_single_binding)]
                                match tag {
                                    __FieldTag::Unknown(key) => {
                                        let value = map.next_value::<serde_json::Value>()?;
                                        result._unknown_fields.insert(key, value);
                                    }
                                }
                            }
                            std::result::Result::Ok(result)
                        }
                    }
                    deserializer.deserialize_any(Visitor)
                }
            }

            #[doc(hidden)]
            impl serde::ser::Serialize for ExternallyModified {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    use serde::ser::SerializeMap;
                    #[allow(unused_imports)]
                    use std::option::Option::Some;
                    let mut state = serializer.serialize_map(std::option::Option::None)?;
                    if !self._unknown_fields.is_empty() {
                        for (key, value) in self._unknown_fields.iter() {
                            state.serialize_entry(key, &value)?;
                        }
                    }
                    state.end()
                }
            }

            impl std::fmt::Debug for ExternallyModified {
                fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
                    let mut debug_struct = f.debug_struct("ExternallyModified");
                    if !self._unknown_fields.is_empty() {
                        debug_struct.field("_unknown_fields", &self._unknown_fields);
                    }
                    debug_struct.finish()
                }
            }

            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Event {
                /// The grant was requested.
                Requested(std::boxed::Box<crate::model::grant::timeline::event::Requested>),
                /// The grant was approved.
                Approved(std::boxed::Box<crate::model::grant::timeline::event::Approved>),
                /// The grant was denied.
                Denied(std::boxed::Box<crate::model::grant::timeline::event::Denied>),
                /// The grant was revoked.
                Revoked(std::boxed::Box<crate::model::grant::timeline::event::Revoked>),
                /// The grant has been scheduled to give access.
                Scheduled(std::boxed::Box<crate::model::grant::timeline::event::Scheduled>),
                /// The grant was successfully activated to give access.
                Activated(std::boxed::Box<crate::model::grant::timeline::event::Activated>),
                /// There was a non-retriable error while trying to give access.
                ActivationFailed(
                    std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
                ),
                /// The approval workflow did not complete in the necessary duration,
                /// and so the grant is expired.
                Expired(std::boxed::Box<crate::model::grant::timeline::event::Expired>),
                /// Access given by the grant ended automatically as the approved
                /// duration was over.
                Ended(std::boxed::Box<crate::model::grant::timeline::event::Ended>),
                /// The policy bindings made by grant have been modified outside of PAM.
                ExternallyModified(
                    std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
                ),
            }
        }
    }

    /// Audit trail for the access provided by this grant.
    #[derive(Clone, Default, PartialEq)]
    #[non_exhaustive]
    pub struct AuditTrail {
        /// Output only. The time at which access was given.
        pub access_grant_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time at which the system removed access. This could be
        /// because of an automatic expiry or because of a revocation.
        ///
        /// If unspecified, then access hasn't been removed yet.
        pub access_remove_time: std::option::Option<wkt::Timestamp>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl AuditTrail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_grant_time][crate::model::grant::AuditTrail::access_grant_time].
        pub fn set_access_grant_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.access_grant_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [access_grant_time][crate::model::grant::AuditTrail::access_grant_time].
        pub fn set_or_clear_access_grant_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.access_grant_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [access_remove_time][crate::model::grant::AuditTrail::access_remove_time].
        pub fn set_access_remove_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.access_remove_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [access_remove_time][crate::model::grant::AuditTrail::access_remove_time].
        pub fn set_or_clear_access_remove_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.access_remove_time = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for AuditTrail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.AuditTrail"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for AuditTrail {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __access_grant_time,
                __access_remove_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for AuditTrail")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "accessGrantTime" => Ok(__FieldTag::__access_grant_time),
                                "access_grant_time" => Ok(__FieldTag::__access_grant_time),
                                "accessRemoveTime" => Ok(__FieldTag::__access_remove_time),
                                "access_remove_time" => Ok(__FieldTag::__access_remove_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = AuditTrail;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct AuditTrail")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__access_grant_time => {
                                if !fields.insert(__FieldTag::__access_grant_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_grant_time",
                                    ));
                                }
                                result.access_grant_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::__access_remove_time => {
                                if !fields.insert(__FieldTag::__access_remove_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for access_remove_time",
                                    ));
                                }
                                result.access_remove_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for AuditTrail {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.access_grant_time.is_some() {
                state.serialize_entry("accessGrantTime", &self.access_grant_time)?;
            }
            if self.access_remove_time.is_some() {
                state.serialize_entry("accessRemoveTime", &self.access_remove_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    impl std::fmt::Debug for AuditTrail {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            let mut debug_struct = f.debug_struct("AuditTrail");
            debug_struct.field("access_grant_time", &self.access_grant_time);
            debug_struct.field("access_remove_time", &self.access_remove_time);
            if !self._unknown_fields.is_empty() {
                debug_struct.field("_unknown_fields", &self._unknown_fields);
            }
            debug_struct.finish()
        }
    }

    /// Different states a grant can be in.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Unspecified state. This value is never returned by the server.
        Unspecified,
        /// The entitlement had an approval workflow configured and this grant is
        /// waiting for the workflow to complete.
        ApprovalAwaited,
        /// The approval workflow completed with a denied result. No access is
        /// granted for this grant. This is a terminal state.
        Denied,
        /// The approval workflow completed successfully with an approved result or
        /// none was configured. Access is provided at an appropriate time.
        Scheduled,
        /// Access is being given.
        Activating,
        /// Access was successfully given and is currently active.
        Active,
        /// The system could not give access due to a non-retriable error. This is a
        /// terminal state.
        ActivationFailed,
        /// Expired after waiting for the approval workflow to complete. This is a
        /// terminal state.
        Expired,
        /// Access is being revoked.
        Revoking,
        /// Access was revoked by a user. This is a terminal state.
        Revoked,
        /// System took back access as the requested duration was over. This is a
        /// terminal state.
        Ended,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::ApprovalAwaited => std::option::Option::Some(1),
                Self::Denied => std::option::Option::Some(3),
                Self::Scheduled => std::option::Option::Some(4),
                Self::Activating => std::option::Option::Some(5),
                Self::Active => std::option::Option::Some(6),
                Self::ActivationFailed => std::option::Option::Some(7),
                Self::Expired => std::option::Option::Some(8),
                Self::Revoking => std::option::Option::Some(9),
                Self::Revoked => std::option::Option::Some(10),
                Self::Ended => std::option::Option::Some(11),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::ApprovalAwaited => std::option::Option::Some("APPROVAL_AWAITED"),
                Self::Denied => std::option::Option::Some("DENIED"),
                Self::Scheduled => std::option::Option::Some("SCHEDULED"),
                Self::Activating => std::option::Option::Some("ACTIVATING"),
                Self::Active => std::option::Option::Some("ACTIVE"),
                Self::ActivationFailed => std::option::Option::Some("ACTIVATION_FAILED"),
                Self::Expired => std::option::Option::Some("EXPIRED"),
                Self::Revoking => std::option::Option::Some("REVOKING"),
                Self::Revoked => std::option::Option::Some("REVOKED"),
                Self::Ended => std::option::Option::Some("ENDED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::ApprovalAwaited,
                3 => Self::Denied,
                4 => Self::Scheduled,
                5 => Self::Activating,
                6 => Self::Active,
                7 => Self::ActivationFailed,
                8 => Self::Expired,
                9 => Self::Revoking,
                10 => Self::Revoked,
                11 => Self::Ended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "APPROVAL_AWAITED" => Self::ApprovalAwaited,
                "DENIED" => Self::Denied,
                "SCHEDULED" => Self::Scheduled,
                "ACTIVATING" => Self::Activating,
                "ACTIVE" => Self::Active,
                "ACTIVATION_FAILED" => Self::ActivationFailed,
                "EXPIRED" => Self::Expired,
                "REVOKING" => Self::Revoking,
                "REVOKED" => Self::Revoked,
                "ENDED" => Self::Ended,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::ApprovalAwaited => serializer.serialize_i32(1),
                Self::Denied => serializer.serialize_i32(3),
                Self::Scheduled => serializer.serialize_i32(4),
                Self::Activating => serializer.serialize_i32(5),
                Self::Active => serializer.serialize_i32(6),
                Self::ActivationFailed => serializer.serialize_i32(7),
                Self::Expired => serializer.serialize_i32(8),
                Self::Revoking => serializer.serialize_i32(9),
                Self::Revoked => serializer.serialize_i32(10),
                Self::Ended => serializer.serialize_i32(11),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.privilegedaccessmanager.v1.Grant.State",
            ))
        }
    }
}

/// Justification represents a justification for requesting access.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct Justification {
    pub justification: std::option::Option<crate::model::justification::Justification>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Justification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [justification][crate::model::Justification::justification].
    ///
    /// Note that all the setters affecting `justification` are mutually
    /// exclusive.
    pub fn set_justification<
        T: std::convert::Into<std::option::Option<crate::model::justification::Justification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.justification = v.into();
        self
    }

    /// The value of [justification][crate::model::Justification::justification]
    /// if it holds a `UnstructuredJustification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn unstructured_justification(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.justification.as_ref().and_then(|v| match v {
            crate::model::justification::Justification::UnstructuredJustification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [justification][crate::model::Justification::justification]
    /// to hold a `UnstructuredJustification`.
    ///
    /// Note that all the setters affecting `justification` are
    /// mutually exclusive.
    pub fn set_unstructured_justification<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.justification = std::option::Option::Some(
            crate::model::justification::Justification::UnstructuredJustification(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Justification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Justification"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Justification {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __unstructured_justification,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Justification")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "unstructuredJustification" => {
                                Ok(__FieldTag::__unstructured_justification)
                            }
                            "unstructured_justification" => {
                                Ok(__FieldTag::__unstructured_justification)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Justification;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Justification")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__unstructured_justification => {
                            if !fields.insert(__FieldTag::__unstructured_justification) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unstructured_justification",
                                ));
                            }
                            if result.justification.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `justification`, a oneof with full ID .google.cloud.privilegedaccessmanager.v1.Justification.unstructured_justification, latest field was unstructuredJustification",
                                ));
                            }
                            result.justification = std::option::Option::Some(
                                crate::model::justification::Justification::UnstructuredJustification(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Justification {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.unstructured_justification() {
            state.serialize_entry("unstructuredJustification", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for Justification {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Justification");
        debug_struct.field("justification", &self.justification);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [Justification].
pub mod justification {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Justification {
        /// A free form textual justification. The system only ensures that this
        /// is not empty. No other kind of validation is performed on the string.
        UnstructuredJustification(std::string::String),
    }
}

/// Message for requesting list of grants.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGrantsRequest {
    /// Required. The parent resource which owns the grants.
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    pub order_by: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGrantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGrantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGrantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGrantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGrantsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGrantsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGrantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListGrantsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGrantsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __filter,
            __order_by,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGrantsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGrantsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGrantsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGrantsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGrantsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGrantsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for response to listing grants.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ListGrantsResponse {
    /// The list of grants.
    pub grants: std::vec::Vec<crate::model::Grant>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGrantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grants][crate::model::ListGrantsResponse::grants].
    pub fn set_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Grant>,
    {
        use std::iter::Iterator;
        self.grants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGrantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGrantsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGrantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListGrantsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGrantsResponse {
    type PageItem = crate::model::Grant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.grants
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListGrantsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __grants,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListGrantsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "grants" => Ok(__FieldTag::__grants),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListGrantsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListGrantsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__grants => {
                            if !fields.insert(__FieldTag::__grants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grants",
                                ));
                            }
                            result.grants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Grant>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListGrantsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grants.is_empty() {
            state.serialize_entry("grants", &self.grants)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ListGrantsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGrantsResponse");
        debug_struct.field("grants", &self.grants);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `SearchGrants` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchGrantsRequest {
    /// Required. The parent which owns the grant resources.
    pub parent: std::string::String,

    /// Required. Only grants which the caller is related to by this relationship
    /// are returned in the response.
    pub caller_relationship: crate::model::search_grants_request::CallerRelationshipType,

    /// Optional. Only grants matching this filter are returned in the response.
    pub filter: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchGrantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchGrantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [caller_relationship][crate::model::SearchGrantsRequest::caller_relationship].
    pub fn set_caller_relationship<
        T: std::convert::Into<crate::model::search_grants_request::CallerRelationshipType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.caller_relationship = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchGrantsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchGrantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchGrantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchGrantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchGrantsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchGrantsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __caller_relationship,
            __filter,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchGrantsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "callerRelationship" => Ok(__FieldTag::__caller_relationship),
                            "caller_relationship" => Ok(__FieldTag::__caller_relationship),
                            "filter" => Ok(__FieldTag::__filter),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchGrantsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchGrantsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__caller_relationship => {
                            if !fields.insert(__FieldTag::__caller_relationship) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for caller_relationship",
                                ));
                            }
                            result.caller_relationship = map
                                .next_value::<std::option::Option<
                                    crate::model::search_grants_request::CallerRelationshipType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchGrantsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.caller_relationship) {
            state.serialize_entry("callerRelationship", &self.caller_relationship)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchGrantsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchGrantsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("caller_relationship", &self.caller_relationship);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Defines additional types related to [SearchGrantsRequest].
pub mod search_grants_request {
    #[allow(unused_imports)]
    use super::*;

    /// Different types of relationships a user can have with a grant.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CallerRelationshipType {
        /// Unspecified caller relationship type.
        Unspecified,
        /// The user created this grant by calling `CreateGrant` earlier.
        HadCreated,
        /// The user is an approver for the entitlement that this grant is parented
        /// under and can currently approve/deny it.
        CanApprove,
        /// The caller had successfully approved/denied this grant earlier.
        HadApproved,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [CallerRelationshipType::value] or
        /// [CallerRelationshipType::name].
        UnknownValue(caller_relationship_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod caller_relationship_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl CallerRelationshipType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::HadCreated => std::option::Option::Some(1),
                Self::CanApprove => std::option::Option::Some(2),
                Self::HadApproved => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => {
                    std::option::Option::Some("CALLER_RELATIONSHIP_TYPE_UNSPECIFIED")
                }
                Self::HadCreated => std::option::Option::Some("HAD_CREATED"),
                Self::CanApprove => std::option::Option::Some("CAN_APPROVE"),
                Self::HadApproved => std::option::Option::Some("HAD_APPROVED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for CallerRelationshipType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for CallerRelationshipType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for CallerRelationshipType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::HadCreated,
                2 => Self::CanApprove,
                3 => Self::HadApproved,
                _ => Self::UnknownValue(caller_relationship_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for CallerRelationshipType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "CALLER_RELATIONSHIP_TYPE_UNSPECIFIED" => Self::Unspecified,
                "HAD_CREATED" => Self::HadCreated,
                "CAN_APPROVE" => Self::CanApprove,
                "HAD_APPROVED" => Self::HadApproved,
                _ => Self::UnknownValue(caller_relationship_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for CallerRelationshipType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::HadCreated => serializer.serialize_i32(1),
                Self::CanApprove => serializer.serialize_i32(2),
                Self::HadApproved => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for CallerRelationshipType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<CallerRelationshipType>::new(
                ".google.cloud.privilegedaccessmanager.v1.SearchGrantsRequest.CallerRelationshipType"))
        }
    }
}

/// Response message for `SearchGrants` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchGrantsResponse {
    /// The list of grants.
    pub grants: std::vec::Vec<crate::model::Grant>,

    /// A token identifying a page of results the server should return.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchGrantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [grants][crate::model::SearchGrantsResponse::grants].
    pub fn set_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Grant>,
    {
        use std::iter::Iterator;
        self.grants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchGrantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchGrantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchGrantsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchGrantsResponse {
    type PageItem = crate::model::Grant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.grants
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchGrantsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __grants,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchGrantsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "grants" => Ok(__FieldTag::__grants),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchGrantsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchGrantsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__grants => {
                            if !fields.insert(__FieldTag::__grants) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grants",
                                ));
                            }
                            result.grants = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Grant>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchGrantsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.grants.is_empty() {
            state.serialize_entry("grants", &self.grants)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for SearchGrantsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("SearchGrantsResponse");
        debug_struct.field("grants", &self.grants);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for getting a grant.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct GetGrantRequest {
    /// Required. Name of the resource.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.GetGrantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetGrantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetGrantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetGrantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetGrantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetGrantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for GetGrantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGrantRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `ApproveGrant` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct ApproveGrantRequest {
    /// Required. Name of the grant resource which is being approved.
    pub name: std::string::String,

    /// Optional. The reason for approving this grant. This is required if the
    /// `require_approver_justification` field of the `ManualApprovals` workflow
    /// used in this grant is true.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ApproveGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::ApproveGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for ApproveGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ApproveGrantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ApproveGrantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ApproveGrantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ApproveGrantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ApproveGrantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ApproveGrantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for ApproveGrantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ApproveGrantRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("reason", &self.reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `DenyGrant` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct DenyGrantRequest {
    /// Required. Name of the grant resource which is being denied.
    pub name: std::string::String,

    /// Optional. The reason for denying this grant. This is required if
    /// `require_approver_justification` field of the `ManualApprovals` workflow
    /// used in this grant is true.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DenyGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DenyGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::DenyGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for DenyGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.DenyGrantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DenyGrantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DenyGrantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DenyGrantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DenyGrantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DenyGrantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for DenyGrantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DenyGrantRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("reason", &self.reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Request message for `RevokeGrant` method.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct RevokeGrantRequest {
    /// Required. Name of the grant resource which is being revoked.
    pub name: std::string::String,

    /// Optional. The reason for revoking this grant.
    pub reason: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RevokeGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevokeGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::RevokeGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for RevokeGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.RevokeGrantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RevokeGrantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __reason,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RevokeGrantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "reason" => Ok(__FieldTag::__reason),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RevokeGrantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RevokeGrantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__reason => {
                            if !fields.insert(__FieldTag::__reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for reason",
                                ));
                            }
                            result.reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RevokeGrantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.reason.is_empty() {
            state.serialize_entry("reason", &self.reason)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for RevokeGrantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RevokeGrantRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("reason", &self.reason);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Message for creating a grant
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateGrantRequest {
    /// Required. Name of the parent entitlement for which this grant is being
    /// requested.
    pub parent: std::string::String,

    /// Required. The resource being created.
    pub grant: std::option::Option<crate::model::Grant>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate grants.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGrantRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [grant][crate::model::CreateGrantRequest::grant].
    pub fn set_grant<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Grant>,
    {
        self.grant = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [grant][crate::model::CreateGrantRequest::grant].
    pub fn set_or_clear_grant<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Grant>,
    {
        self.grant = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGrantRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CreateGrantRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateGrantRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __grant,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateGrantRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "grant" => Ok(__FieldTag::__grant),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateGrantRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateGrantRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__grant => {
                            if !fields.insert(__FieldTag::__grant) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for grant",
                                ));
                            }
                            result.grant =
                                map.next_value::<std::option::Option<crate::model::Grant>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateGrantRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.grant.is_some() {
            state.serialize_entry("grant", &self.grant)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for CreateGrantRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGrantRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("grant", &self.grant);
        debug_struct.field("request_id", &self.request_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    pub api_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

impl std::fmt::Debug for OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
