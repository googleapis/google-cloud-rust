// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Request message for `CheckOnboardingStatus` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckOnboardingStatusRequest {
    /// Required. The resource for which the onboarding status should be checked.
    /// Should be in one of the following formats:
    ///
    /// * `projects/{project-number|project-id}/locations/{region}`
    /// * `folders/{folder-number}/locations/{region}`
    /// * `organizations/{organization-number}/locations/{region}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,
}

impl CheckOnboardingStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CheckOnboardingStatusRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }
}

impl wkt::message::Message for CheckOnboardingStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusRequest"
    }
}

/// Response message for `CheckOnboardingStatus` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckOnboardingStatusResponse {
    /// The service account that PAM uses to act on this resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service_account: std::string::String,

    /// List of issues that are preventing PAM from functioning for this resource
    /// and need to be fixed to complete onboarding. Some issues might not be
    /// detected or reported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub findings: std::vec::Vec<crate::model::check_onboarding_status_response::Finding>,
}

impl CheckOnboardingStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service_account][crate::model::CheckOnboardingStatusResponse::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [findings][crate::model::CheckOnboardingStatusResponse::findings].
    pub fn set_findings<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::check_onboarding_status_response::Finding>,
    {
        use std::iter::Iterator;
        self.findings = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CheckOnboardingStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse"
    }
}

/// Defines additional types related to CheckOnboardingStatusResponse
pub mod check_onboarding_status_response {
    #[allow(unused_imports)]
    use super::*;

    /// Finding represents an issue which prevents PAM from functioning properly
    /// for this resource.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Finding {
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub finding_type: std::option::Option<
            crate::model::check_onboarding_status_response::finding::FindingType,
        >,
    }

    impl Finding {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `finding_type`.
        pub fn set_finding_type<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::check_onboarding_status_response::finding::FindingType,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.finding_type = v.into();
            self
        }

        /// The value of [finding_type][crate::model::check_onboarding_status_response::Finding::finding_type]
        /// if it holds a `IamAccessDenied`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_iam_access_denied(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.finding_type.as_ref().and_then(|v| match v {
                crate::model::check_onboarding_status_response::finding::FindingType::IamAccessDenied(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [finding_type][crate::model::check_onboarding_status_response::Finding::finding_type]
        /// to hold a `IamAccessDenied`.
        ///
        /// Note that all the setters affecting `finding_type` are
        /// mutually exclusive.
        pub fn set_iam_access_denied<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.finding_type = std::option::Option::Some(
                crate::model::check_onboarding_status_response::finding::FindingType::IamAccessDenied(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for Finding {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse.Finding"
        }
    }

    /// Defines additional types related to Finding
    pub mod finding {
        #[allow(unused_imports)]
        use super::*;

        /// PAM's service account is being denied access by Cloud IAM.
        /// This can be fixed by granting a role that contains the missing
        /// permissions to the service account or exempting it from deny policies if
        /// they are blocking the access.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct IAMAccessDenied {
            /// List of permissions that are being denied.
            #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
            pub missing_permissions: std::vec::Vec<std::string::String>,
        }

        impl IAMAccessDenied {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [missing_permissions][crate::model::check_onboarding_status_response::finding::IAMAccessDenied::missing_permissions].
            pub fn set_missing_permissions<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.missing_permissions = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IAMAccessDenied {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CheckOnboardingStatusResponse.Finding.IAMAccessDenied"
            }
        }

        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum FindingType {
            /// PAM's service account is being denied access by Cloud IAM.
            IamAccessDenied(
                std::boxed::Box<
                    crate::model::check_onboarding_status_response::finding::IAMAccessDenied,
                >,
            ),
        }
    }
}

/// An entitlement defines the eligibility of a set of users to obtain
/// predefined access for some time possibly after going through an approval
/// workflow.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Entitlement {
    /// Identifier. Name of the entitlement.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}/entitlements/{entitlement-id}`
    /// * `folders/{folder-number}/locations/{region}/entitlements/{entitlement-id}`
    /// * `projects/{project-id|project-number}/locations/{region}/entitlements/{entitlement-id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Who can create grants using this entitlement. This list should
    /// contain at most one entry.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub eligible_users: std::vec::Vec<crate::model::AccessControlEntry>,

    /// Optional. The approvals needed before access are granted to a requester. No
    /// approvals are needed if this field is null.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub approval_workflow: std::option::Option<crate::model::ApprovalWorkflow>,

    /// The access granted to a requester on successful approval.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privileged_access: std::option::Option<crate::model::PrivilegedAccess>,

    /// Required. The maximum amount of time that access is granted for a request.
    /// A requester can ask for a duration less than this, but never more.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub max_request_duration: std::option::Option<wkt::Duration>,

    /// Output only. Current state of this entitlement.
    pub state: crate::model::entitlement::State,

    /// Required. The manner in which the requester should provide a justification
    /// for requesting access.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requester_justification_config:
        std::option::Option<crate::model::entitlement::RequesterJustificationConfig>,

    /// Optional. Additional email addresses to be notified based on actions taken.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub additional_notification_targets:
        std::option::Option<crate::model::entitlement::AdditionalNotificationTargets>,

    /// An `etag` is used for optimistic concurrency control as a way to prevent
    /// simultaneous updates to the same entitlement. An `etag` is returned in the
    /// response to `GetEntitlement` and the caller should put the `etag` in the
    /// request to `UpdateEntitlement` so that their change is applied on
    /// the same version. If this field is omitted or if there is a mismatch while
    /// updating an entitlement, then the server rejects the request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,
}

impl Entitlement {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Entitlement::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Entitlement::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Entitlement::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [approval_workflow][crate::model::Entitlement::approval_workflow].
    pub fn set_approval_workflow<
        T: std::convert::Into<std::option::Option<crate::model::ApprovalWorkflow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_workflow = v.into();
        self
    }

    /// Sets the value of [privileged_access][crate::model::Entitlement::privileged_access].
    pub fn set_privileged_access<
        T: std::convert::Into<std::option::Option<crate::model::PrivilegedAccess>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileged_access = v.into();
        self
    }

    /// Sets the value of [max_request_duration][crate::model::Entitlement::max_request_duration].
    pub fn set_max_request_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.max_request_duration = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Entitlement::state].
    pub fn set_state<T: std::convert::Into<crate::model::entitlement::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [requester_justification_config][crate::model::Entitlement::requester_justification_config].
    pub fn set_requester_justification_config<
        T: std::convert::Into<
            std::option::Option<crate::model::entitlement::RequesterJustificationConfig>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.requester_justification_config = v.into();
        self
    }

    /// Sets the value of [additional_notification_targets][crate::model::Entitlement::additional_notification_targets].
    pub fn set_additional_notification_targets<
        T: std::convert::Into<
            std::option::Option<crate::model::entitlement::AdditionalNotificationTargets>,
        >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.additional_notification_targets = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::Entitlement::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [eligible_users][crate::model::Entitlement::eligible_users].
    pub fn set_eligible_users<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AccessControlEntry>,
    {
        use std::iter::Iterator;
        self.eligible_users = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Entitlement {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement"
    }
}

/// Defines additional types related to Entitlement
pub mod entitlement {
    #[allow(unused_imports)]
    use super::*;

    /// Defines how a requester must provide a justification when requesting
    /// access.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct RequesterJustificationConfig {
        /// This is a required field and the user must explicitly opt out if a
        /// justification from the requester isn't mandatory.
        #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
        pub justification_type: std::option::Option<
            crate::model::entitlement::requester_justification_config::JustificationType,
        >,
    }

    impl RequesterJustificationConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of `justification_type`.
        pub fn set_justification_type<
            T: std::convert::Into<
                std::option::Option<
                    crate::model::entitlement::requester_justification_config::JustificationType,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.justification_type = v.into();
            self
        }

        /// The value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// if it holds a `NotMandatory`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_not_mandatory(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::entitlement::requester_justification_config::NotMandatory,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.justification_type.as_ref().and_then(|v| match v {
                crate::model::entitlement::requester_justification_config::JustificationType::NotMandatory(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// The value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// if it holds a `Unstructured`, `None` if the field is not set or
        /// holds a different branch.
        pub fn get_unstructured(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::entitlement::requester_justification_config::Unstructured,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.justification_type.as_ref().and_then(|v| match v {
                crate::model::entitlement::requester_justification_config::JustificationType::Unstructured(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// to hold a `NotMandatory`.
        ///
        /// Note that all the setters affecting `justification_type` are
        /// mutually exclusive.
        pub fn set_not_mandatory<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::NotMandatory,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.justification_type = std::option::Option::Some(
                crate::model::entitlement::requester_justification_config::JustificationType::NotMandatory(
                    v.into()
                )
            );
            self
        }

        /// Sets the value of [justification_type][crate::model::entitlement::RequesterJustificationConfig::justification_type]
        /// to hold a `Unstructured`.
        ///
        /// Note that all the setters affecting `justification_type` are
        /// mutually exclusive.
        pub fn set_unstructured<
            T: std::convert::Into<
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::Unstructured,
                >,
            >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.justification_type = std::option::Option::Some(
                crate::model::entitlement::requester_justification_config::JustificationType::Unstructured(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for RequesterJustificationConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig"
        }
    }

    /// Defines additional types related to RequesterJustificationConfig
    pub mod requester_justification_config {
        #[allow(unused_imports)]
        use super::*;

        /// The justification is not mandatory but can be provided in any of the
        /// supported formats.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct NotMandatory {}

        impl NotMandatory {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for NotMandatory {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.NotMandatory"
            }
        }

        /// The requester has to provide a justification in the form of a string.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Unstructured {}

        impl Unstructured {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for Unstructured {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.RequesterJustificationConfig.Unstructured"
            }
        }

        /// This is a required field and the user must explicitly opt out if a
        /// justification from the requester isn't mandatory.
        #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(rename_all = "camelCase")]
        #[non_exhaustive]
        pub enum JustificationType {
            /// This option means the requester isn't required to provide a
            /// justification.
            NotMandatory(
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::NotMandatory,
                >,
            ),
            /// This option means the requester must provide a string as
            /// justification. If this is selected, the server allows the requester
            /// to provide a justification but doesn't validate it.
            Unstructured(
                std::boxed::Box<
                    crate::model::entitlement::requester_justification_config::Unstructured,
                >,
            ),
        }
    }

    /// `AdditionalNotificationTargets` includes email addresses to be notified.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AdditionalNotificationTargets {
        /// Optional. Additional email addresses to be notified when a principal
        /// (requester) is granted access.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub admin_email_recipients: std::vec::Vec<std::string::String>,

        /// Optional. Additional email address to be notified about an eligible
        /// entitlement.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub requester_email_recipients: std::vec::Vec<std::string::String>,
    }

    impl AdditionalNotificationTargets {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [admin_email_recipients][crate::model::entitlement::AdditionalNotificationTargets::admin_email_recipients].
        pub fn set_admin_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.admin_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [requester_email_recipients][crate::model::entitlement::AdditionalNotificationTargets::requester_email_recipients].
        pub fn set_requester_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.requester_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for AdditionalNotificationTargets {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Entitlement.AdditionalNotificationTargets"
        }
    }

    /// Different states an entitlement can be in.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state. This value is never returned by the server.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The entitlement is being created.
        pub const CREATING: State = State::new("CREATING");

        /// The entitlement is available for requesting access.
        pub const AVAILABLE: State = State::new("AVAILABLE");

        /// The entitlement is being deleted.
        pub const DELETING: State = State::new("DELETING");

        /// The entitlement has been deleted.
        pub const DELETED: State = State::new("DELETED");

        /// The entitlement is being updated.
        pub const UPDATING: State = State::new("UPDATING");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// `AccessControlEntry` is used to control who can do some operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AccessControlEntry {
    /// Optional. Users who are allowed for the operation. Each entry should be a
    /// valid v1 IAM principal identifier. The format for these is documented at:
    /// <https://cloud.google.com/iam/docs/principal-identifiers#v1>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub principals: std::vec::Vec<std::string::String>,
}

impl AccessControlEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [principals][crate::model::AccessControlEntry::principals].
    pub fn set_principals<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.principals = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for AccessControlEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.AccessControlEntry"
    }
}

/// Different types of approval workflows that can be used to gate privileged
/// access granting.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApprovalWorkflow {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub approval_workflow: std::option::Option<crate::model::approval_workflow::ApprovalWorkflow>,
}

impl ApprovalWorkflow {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `approval_workflow`.
    pub fn set_approval_workflow<
        T: std::convert::Into<std::option::Option<crate::model::approval_workflow::ApprovalWorkflow>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_workflow = v.into();
        self
    }

    /// The value of [approval_workflow][crate::model::ApprovalWorkflow::approval_workflow]
    /// if it holds a `ManualApprovals`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_manual_approvals(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ManualApprovals>> {
        #[allow(unreachable_patterns)]
        self.approval_workflow.as_ref().and_then(|v| match v {
            crate::model::approval_workflow::ApprovalWorkflow::ManualApprovals(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [approval_workflow][crate::model::ApprovalWorkflow::approval_workflow]
    /// to hold a `ManualApprovals`.
    ///
    /// Note that all the setters affecting `approval_workflow` are
    /// mutually exclusive.
    pub fn set_manual_approvals<
        T: std::convert::Into<std::boxed::Box<crate::model::ManualApprovals>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.approval_workflow = std::option::Option::Some(
            crate::model::approval_workflow::ApprovalWorkflow::ManualApprovals(v.into()),
        );
        self
    }
}

impl wkt::message::Message for ApprovalWorkflow {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ApprovalWorkflow"
    }
}

/// Defines additional types related to ApprovalWorkflow
pub mod approval_workflow {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ApprovalWorkflow {
        /// An approval workflow where users designated as approvers review and act
        /// on the grants.
        ManualApprovals(std::boxed::Box<crate::model::ManualApprovals>),
    }
}

/// A manual approval workflow where users who are designated as approvers
/// need to call the `ApproveGrant`/`DenyGrant` APIs for a grant. The workflow
/// can consist of multiple serial steps where each step defines who can act as
/// approver in that step and how many of those users should approve before the
/// workflow moves to the next step.
///
/// This can be used to create approval workflows such as:
///
/// * Require an approval from any user in a group G.
/// * Require an approval from any k number of users from a Group G.
/// * Require an approval from any user in a group G and then from a user U.
///
/// A single user might be part of the `approvers` ACL for multiple steps in this
/// workflow, but they can only approve once and that approval is only considered
/// to satisfy the approval step at which it was granted.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ManualApprovals {
    /// Optional. Do the approvers need to provide a justification for their
    /// actions?
    pub require_approver_justification: bool,

    /// Optional. List of approval steps in this workflow. These steps are followed
    /// in the specified order sequentially. Only 1 step is supported.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub steps: std::vec::Vec<crate::model::manual_approvals::Step>,
}

impl ManualApprovals {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [require_approver_justification][crate::model::ManualApprovals::require_approver_justification].
    pub fn set_require_approver_justification<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.require_approver_justification = v.into();
        self
    }

    /// Sets the value of [steps][crate::model::ManualApprovals::steps].
    pub fn set_steps<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::manual_approvals::Step>,
    {
        use std::iter::Iterator;
        self.steps = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ManualApprovals {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ManualApprovals"
    }
}

/// Defines additional types related to ManualApprovals
pub mod manual_approvals {
    #[allow(unused_imports)]
    use super::*;

    /// Step represents a logical step in a manual approval workflow.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Step {
        /// Optional. The potential set of approvers in this step. This list must
        /// contain at most one entry.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub approvers: std::vec::Vec<crate::model::AccessControlEntry>,

        /// Required. How many users from the above list need to approve. If there
        /// aren't enough distinct users in the list, then the workflow indefinitely
        /// blocks. Should always be greater than 0. 1 is the only supported value.
        pub approvals_needed: i32,

        /// Optional. Additional email addresses to be notified when a grant is
        /// pending approval.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub approver_email_recipients: std::vec::Vec<std::string::String>,
    }

    impl Step {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [approvals_needed][crate::model::manual_approvals::Step::approvals_needed].
        pub fn set_approvals_needed<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.approvals_needed = v.into();
            self
        }

        /// Sets the value of [approvers][crate::model::manual_approvals::Step::approvers].
        pub fn set_approvers<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::AccessControlEntry>,
        {
            use std::iter::Iterator;
            self.approvers = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [approver_email_recipients][crate::model::manual_approvals::Step::approver_email_recipients].
        pub fn set_approver_email_recipients<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.approver_email_recipients = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Step {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ManualApprovals.Step"
        }
    }
}

/// Privileged access that this service can be used to gate.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct PrivilegedAccess {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub access_type: std::option::Option<crate::model::privileged_access::AccessType>,
}

impl PrivilegedAccess {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `access_type`.
    pub fn set_access_type<
        T: std::convert::Into<std::option::Option<crate::model::privileged_access::AccessType>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_type = v.into();
        self
    }

    /// The value of [access_type][crate::model::PrivilegedAccess::access_type]
    /// if it holds a `GcpIamAccess`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gcp_iam_access(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::privileged_access::GcpIamAccess>> {
        #[allow(unreachable_patterns)]
        self.access_type.as_ref().and_then(|v| match v {
            crate::model::privileged_access::AccessType::GcpIamAccess(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [access_type][crate::model::PrivilegedAccess::access_type]
    /// to hold a `GcpIamAccess`.
    ///
    /// Note that all the setters affecting `access_type` are
    /// mutually exclusive.
    pub fn set_gcp_iam_access<
        T: std::convert::Into<std::boxed::Box<crate::model::privileged_access::GcpIamAccess>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.access_type = std::option::Option::Some(
            crate::model::privileged_access::AccessType::GcpIamAccess(v.into()),
        );
        self
    }
}

impl wkt::message::Message for PrivilegedAccess {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess"
    }
}

/// Defines additional types related to PrivilegedAccess
pub mod privileged_access {
    #[allow(unused_imports)]
    use super::*;

    /// `GcpIamAccess` represents IAM based access control on a Google Cloud
    /// resource. Refer to <https://cloud.google.com/iam/docs> to understand more
    /// about IAM.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct GcpIamAccess {
        /// Required. The type of this resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource_type: std::string::String,

        /// Required. Name of the resource.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub resource: std::string::String,

        /// Required. Role bindings that are created on successful grant.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub role_bindings:
            std::vec::Vec<crate::model::privileged_access::gcp_iam_access::RoleBinding>,
    }

    impl GcpIamAccess {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [resource_type][crate::model::privileged_access::GcpIamAccess::resource_type].
        pub fn set_resource_type<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.resource_type = v.into();
            self
        }

        /// Sets the value of [resource][crate::model::privileged_access::GcpIamAccess::resource].
        pub fn set_resource<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.resource = v.into();
            self
        }

        /// Sets the value of [role_bindings][crate::model::privileged_access::GcpIamAccess::role_bindings].
        pub fn set_role_bindings<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::privileged_access::gcp_iam_access::RoleBinding>,
        {
            use std::iter::Iterator;
            self.role_bindings = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for GcpIamAccess {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess.GcpIamAccess"
        }
    }

    /// Defines additional types related to GcpIamAccess
    pub mod gcp_iam_access {
        #[allow(unused_imports)]
        use super::*;

        /// IAM role bindings that are created after a successful grant.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct RoleBinding {
            /// Required. IAM role to be granted.
            /// <https://cloud.google.com/iam/docs/roles-overview>.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub role: std::string::String,

            /// Optional. The expression field of the IAM condition to be associated
            /// with the role. If specified, a user with an active grant for this
            /// entitlement is able to access the resource only if this condition
            /// evaluates to true for their request.
            ///
            /// This field uses the same CEL format as IAM and supports all attributes
            /// that IAM supports, except tags.
            /// <https://cloud.google.com/iam/docs/conditions-overview#attributes>.
            #[serde(skip_serializing_if = "std::string::String::is_empty")]
            pub condition_expression: std::string::String,
        }

        impl RoleBinding {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [role][crate::model::privileged_access::gcp_iam_access::RoleBinding::role].
            pub fn set_role<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.role = v.into();
                self
            }

            /// Sets the value of [condition_expression][crate::model::privileged_access::gcp_iam_access::RoleBinding::condition_expression].
            pub fn set_condition_expression<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.condition_expression = v.into();
                self
            }
        }

        impl wkt::message::Message for RoleBinding {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.PrivilegedAccess.GcpIamAccess.RoleBinding"
            }
        }
    }

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum AccessType {
        /// Access to a Google Cloud resource through IAM.
        GcpIamAccess(std::boxed::Box<crate::model::privileged_access::GcpIamAccess>),
    }
}

/// Message for requesting list of entitlements.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsRequest {
    /// Required. The parent which owns the entitlement resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListEntitlementsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListEntitlementsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListEntitlementsRequest"
    }
}

/// Message for response to listing entitlements.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListEntitlementsResponse {
    /// The list of entitlements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entitlements][crate::model::ListEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListEntitlementsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListEntitlementsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for `SearchEntitlements` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntitlementsRequest {
    /// Required. The parent which owns the entitlement resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Only entitlements where the calling user has this access are
    /// returned.
    pub caller_access_type: crate::model::search_entitlements_request::CallerAccessType,

    /// Optional. Only entitlements matching this filter are returned in the
    /// response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl SearchEntitlementsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchEntitlementsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [caller_access_type][crate::model::SearchEntitlementsRequest::caller_access_type].
    pub fn set_caller_access_type<
        T: std::convert::Into<crate::model::search_entitlements_request::CallerAccessType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.caller_access_type = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchEntitlementsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchEntitlementsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchEntitlementsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchEntitlementsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchEntitlementsRequest"
    }
}

/// Defines additional types related to SearchEntitlementsRequest
pub mod search_entitlements_request {
    #[allow(unused_imports)]
    use super::*;

    /// Different types of access a user can have on the entitlement resource.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CallerAccessType(std::borrow::Cow<'static, str>);

    impl CallerAccessType {
        /// Creates a new CallerAccessType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CallerAccessType](CallerAccessType)
    pub mod caller_access_type {
        use super::CallerAccessType;

        /// Unspecified access type.
        pub const CALLER_ACCESS_TYPE_UNSPECIFIED: CallerAccessType =
            CallerAccessType::new("CALLER_ACCESS_TYPE_UNSPECIFIED");

        /// The user has access to create grants using this entitlement.
        pub const GRANT_REQUESTER: CallerAccessType = CallerAccessType::new("GRANT_REQUESTER");

        /// The user has access to approve/deny grants created under this
        /// entitlement.
        pub const GRANT_APPROVER: CallerAccessType = CallerAccessType::new("GRANT_APPROVER");
    }

    impl std::convert::From<std::string::String> for CallerAccessType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Response message for `SearchEntitlements` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchEntitlementsResponse {
    /// The list of entitlements.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub entitlements: std::vec::Vec<crate::model::Entitlement>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchEntitlementsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchEntitlementsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [entitlements][crate::model::SearchEntitlementsResponse::entitlements].
    pub fn set_entitlements<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Entitlement>,
    {
        use std::iter::Iterator;
        self.entitlements = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchEntitlementsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchEntitlementsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchEntitlementsResponse {
    type PageItem = crate::model::Entitlement;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.entitlements
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting an entitlement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetEntitlementRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetEntitlementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.GetEntitlementRequest"
    }
}

/// Message for creating an entitlement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateEntitlementRequest {
    /// Required. Name of the parent resource for the entitlement.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}`
    /// * `folders/{folder-number}/locations/{region}`
    /// * `projects/{project-id|project-number}/locations/{region}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The ID to use for this entitlement. This becomes the last part of
    /// the resource name.
    ///
    /// This value should be 4-63 characters in length, and valid characters are
    /// "[a-z]", "[0-9]", and "-". The first character should be from [a-z].
    ///
    /// This value should be unique among all other entitlements under the
    /// specified `parent`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub entitlement_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entitlement: std::option::Option<crate::model::Entitlement>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request and returns the
    /// previous operation's response. This prevents clients from accidentally
    /// creating duplicate entitlements.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateEntitlementRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [entitlement_id][crate::model::CreateEntitlementRequest::entitlement_id].
    pub fn set_entitlement_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entitlement_id = v.into();
        self
    }

    /// Sets the value of [entitlement][crate::model::CreateEntitlementRequest::entitlement].
    pub fn set_entitlement<
        T: std::convert::Into<std::option::Option<crate::model::Entitlement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entitlement = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateEntitlementRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CreateEntitlementRequest"
    }
}

/// Message for deleting an entitlement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteEntitlementRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, any child grant under this entitlement is also
    /// deleted. (Otherwise, the request only works if the entitlement has no child
    /// grant.)
    pub force: bool,
}

impl DeleteEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteEntitlementRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteEntitlementRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteEntitlementRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.DeleteEntitlementRequest"
    }
}

/// Message for updating an entitlement.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateEntitlementRequest {
    /// Required. The entitlement resource that is updated.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub entitlement: std::option::Option<crate::model::Entitlement>,

    /// Required. The list of fields to update. A field is overwritten if, and only
    /// if, it is in the mask. Any immutable fields set in the mask are ignored by
    /// the server. Repeated fields and map fields are only allowed in the last
    /// position of a `paths` string and overwrite the existing values. Hence an
    /// update to a repeated field or a map should contain the entire list of
    /// values. The fields specified in the update_mask are relative to the
    /// resource and not to the request.
    /// (e.g. `MaxRequestDuration`; *not* `entitlement.MaxRequestDuration`)
    /// A value of '*' for this field refers to full replacement of the resource.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,
}

impl UpdateEntitlementRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entitlement][crate::model::UpdateEntitlementRequest::entitlement].
    pub fn set_entitlement<
        T: std::convert::Into<std::option::Option<crate::model::Entitlement>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entitlement = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateEntitlementRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }
}

impl wkt::message::Message for UpdateEntitlementRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.UpdateEntitlementRequest"
    }
}

/// A grant represents a request from a user for obtaining the access specified
/// in an entitlement they are eligible for.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Grant {
    /// Identifier. Name of this grant.
    /// Possible formats:
    ///
    /// * `organizations/{organization-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    /// * `folders/{folder-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    /// * `projects/{project-id|project-number}/locations/{region}/entitlements/{entitlement-id}/grants/{grant-id}`
    ///
    /// The last segment of this name (`{grant-id}`) is autogenerated.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. Create time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Update time stamp.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Username of the user who created this grant.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub requester: std::string::String,

    /// Required. The amount of time access is needed for. This value should be
    /// less than the `max_request_duration` value of the entitlement.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub requested_duration: std::option::Option<wkt::Duration>,

    /// Optional. Justification of why this access is needed.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub justification: std::option::Option<crate::model::Justification>,

    /// Output only. Current state of this grant.
    pub state: crate::model::grant::State,

    /// Output only. Timeline of this grant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub timeline: std::option::Option<crate::model::grant::Timeline>,

    /// Output only. The access that would be granted by this grant.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub privileged_access: std::option::Option<crate::model::PrivilegedAccess>,

    /// Output only. Audit trail of access provided by this grant. If unspecified
    /// then access was never granted.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub audit_trail: std::option::Option<crate::model::grant::AuditTrail>,

    /// Optional. Additional email addresses to notify for all the actions
    /// performed on the grant.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub additional_email_recipients: std::vec::Vec<std::string::String>,

    /// Output only. Flag set by the PAM system to indicate that policy bindings
    /// made by this grant have been modified from outside PAM.
    ///
    /// After it is set, this flag remains set forever irrespective of the grant
    /// state. A `true` value here indicates that PAM no longer has any certainty
    /// on the access a user has because of this grant.
    pub externally_modified: bool,
}

impl Grant {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Grant::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Grant::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Grant::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [requester][crate::model::Grant::requester].
    pub fn set_requester<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.requester = v.into();
        self
    }

    /// Sets the value of [requested_duration][crate::model::Grant::requested_duration].
    pub fn set_requested_duration<T: std::convert::Into<std::option::Option<wkt::Duration>>>(
        mut self,
        v: T,
    ) -> Self {
        self.requested_duration = v.into();
        self
    }

    /// Sets the value of [justification][crate::model::Grant::justification].
    pub fn set_justification<
        T: std::convert::Into<std::option::Option<crate::model::Justification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.justification = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Grant::state].
    pub fn set_state<T: std::convert::Into<crate::model::grant::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [timeline][crate::model::Grant::timeline].
    pub fn set_timeline<
        T: std::convert::Into<std::option::Option<crate::model::grant::Timeline>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.timeline = v.into();
        self
    }

    /// Sets the value of [privileged_access][crate::model::Grant::privileged_access].
    pub fn set_privileged_access<
        T: std::convert::Into<std::option::Option<crate::model::PrivilegedAccess>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.privileged_access = v.into();
        self
    }

    /// Sets the value of [audit_trail][crate::model::Grant::audit_trail].
    pub fn set_audit_trail<
        T: std::convert::Into<std::option::Option<crate::model::grant::AuditTrail>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.audit_trail = v.into();
        self
    }

    /// Sets the value of [externally_modified][crate::model::Grant::externally_modified].
    pub fn set_externally_modified<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.externally_modified = v.into();
        self
    }

    /// Sets the value of [additional_email_recipients][crate::model::Grant::additional_email_recipients].
    pub fn set_additional_email_recipients<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.additional_email_recipients = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for Grant {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant"
    }
}

/// Defines additional types related to Grant
pub mod grant {
    #[allow(unused_imports)]
    use super::*;

    /// Timeline of a grant describing what happened to it and when.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Timeline {
        /// Output only. The events that have occurred on this grant. This list
        /// contains entries in the same order as they occurred. The first entry is
        /// always be of type `Requested` and there is always at least one entry in
        /// this array.
        #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
        pub events: std::vec::Vec<crate::model::grant::timeline::Event>,
    }

    impl Timeline {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [events][crate::model::grant::Timeline::events].
        pub fn set_events<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::grant::timeline::Event>,
        {
            use std::iter::Iterator;
            self.events = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Timeline {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline"
        }
    }

    /// Defines additional types related to Timeline
    pub mod timeline {
        #[allow(unused_imports)]
        use super::*;

        /// A single operation on the grant.
        #[serde_with::serde_as]
        #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
        #[serde(default, rename_all = "camelCase")]
        #[non_exhaustive]
        pub struct Event {
            /// Output only. The time (as recorded at server) when this event occurred.
            #[serde(skip_serializing_if = "std::option::Option::is_none")]
            pub event_time: std::option::Option<wkt::Timestamp>,

            #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
            pub event: std::option::Option<crate::model::grant::timeline::event::Event>,
        }

        impl Event {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [event_time][crate::model::grant::timeline::Event::event_time].
            pub fn set_event_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
                mut self,
                v: T,
            ) -> Self {
                self.event_time = v.into();
                self
            }

            /// Sets the value of `event`.
            pub fn set_event<
                T: std::convert::Into<
                    std::option::Option<crate::model::grant::timeline::event::Event>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = v.into();
                self
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Requested`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_requested(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Requested>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Requested(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Approved`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_approved(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Approved>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Approved(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Denied`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_denied(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Denied>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Denied(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Revoked`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_revoked(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Revoked>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Revoked(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Scheduled`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_scheduled(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Scheduled>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Scheduled(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Activated`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_activated(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::Activated>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Activated(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `ActivationFailed`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_activation_failed(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::ActivationFailed(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Expired`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_expired(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Expired>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Expired(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `Ended`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_ended(
                &self,
            ) -> std::option::Option<&std::boxed::Box<crate::model::grant::timeline::event::Ended>>
            {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::Ended(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// The value of [event][crate::model::grant::timeline::Event::event]
            /// if it holds a `ExternallyModified`, `None` if the field is not set or
            /// holds a different branch.
            pub fn get_externally_modified(
                &self,
            ) -> std::option::Option<
                &std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
            > {
                #[allow(unreachable_patterns)]
                self.event.as_ref().and_then(|v| match v {
                    crate::model::grant::timeline::event::Event::ExternallyModified(v) => {
                        std::option::Option::Some(v)
                    }
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Requested`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_requested<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::grant::timeline::event::Requested>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Requested(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Approved`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_approved<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Approved>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Approved(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Denied`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_denied<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Denied>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Denied(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Revoked`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_revoked<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Revoked>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Revoked(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Scheduled`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_scheduled<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::grant::timeline::event::Scheduled>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Scheduled(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Activated`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_activated<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::grant::timeline::event::Activated>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Activated(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `ActivationFailed`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_activation_failed<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::ActivationFailed(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Expired`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_expired<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Expired>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Expired(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `Ended`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_ended<
                T: std::convert::Into<std::boxed::Box<crate::model::grant::timeline::event::Ended>>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::Ended(v.into()),
                );
                self
            }

            /// Sets the value of [event][crate::model::grant::timeline::Event::event]
            /// to hold a `ExternallyModified`.
            ///
            /// Note that all the setters affecting `event` are
            /// mutually exclusive.
            pub fn set_externally_modified<
                T: std::convert::Into<
                    std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
                >,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.event = std::option::Option::Some(
                    crate::model::grant::timeline::event::Event::ExternallyModified(v.into()),
                );
                self
            }
        }

        impl wkt::message::Message for Event {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event"
            }
        }

        /// Defines additional types related to Event
        pub mod event {
            #[allow(unused_imports)]
            use super::*;

            /// An event representing that a grant was requested.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Requested {
                /// Output only. The time at which this grant expires unless the approval
                /// workflow completes. If omitted, then the request never expires.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub expire_time: std::option::Option<wkt::Timestamp>,
            }

            impl Requested {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [expire_time][crate::model::grant::timeline::event::Requested::expire_time].
                pub fn set_expire_time<
                    T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.expire_time = v.into();
                    self
                }
            }

            impl wkt::message::Message for Requested {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Requested"
                }
            }

            /// An event representing that the grant was approved.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Approved {
                /// Output only. The reason provided by the approver for approving the
                /// grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub reason: std::string::String,

                /// Output only. Username of the user who approved the grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub actor: std::string::String,
            }

            impl Approved {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Approved::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Approved::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Approved {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Approved"
                }
            }

            /// An event representing that the grant was denied.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Denied {
                /// Output only. The reason provided by the approver for denying the
                /// grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub reason: std::string::String,

                /// Output only. Username of the user who denied the grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub actor: std::string::String,
            }

            impl Denied {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Denied::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Denied::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Denied {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Denied"
                }
            }

            /// An event representing that the grant was revoked.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Revoked {
                /// Output only. The reason provided by the user for revoking the grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub reason: std::string::String,

                /// Output only. Username of the user who revoked the grant.
                #[serde(skip_serializing_if = "std::string::String::is_empty")]
                pub actor: std::string::String,
            }

            impl Revoked {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [reason][crate::model::grant::timeline::event::Revoked::reason].
                pub fn set_reason<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.reason = v.into();
                    self
                }

                /// Sets the value of [actor][crate::model::grant::timeline::event::Revoked::actor].
                pub fn set_actor<T: std::convert::Into<std::string::String>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.actor = v.into();
                    self
                }
            }

            impl wkt::message::Message for Revoked {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Revoked"
                }
            }

            /// An event representing that the grant has been scheduled to be
            /// activated later.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Scheduled {
                /// Output only. The time at which the access is granted.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub scheduled_activation_time: std::option::Option<wkt::Timestamp>,
            }

            impl Scheduled {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [scheduled_activation_time][crate::model::grant::timeline::event::Scheduled::scheduled_activation_time].
                pub fn set_scheduled_activation_time<
                    T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
                >(
                    mut self,
                    v: T,
                ) -> Self {
                    self.scheduled_activation_time = v.into();
                    self
                }
            }

            impl wkt::message::Message for Scheduled {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Scheduled"
                }
            }

            /// An event representing that the grant was successfully
            /// activated.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Activated {}

            impl Activated {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Activated {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Activated"
                }
            }

            /// An event representing that the grant activation failed.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ActivationFailed {
                /// Output only. The error that occurred while activating the grant.
                #[serde(skip_serializing_if = "std::option::Option::is_none")]
                pub error: std::option::Option<rpc::model::Status>,
            }

            impl ActivationFailed {
                pub fn new() -> Self {
                    std::default::Default::default()
                }

                /// Sets the value of [error][crate::model::grant::timeline::event::ActivationFailed::error].
                pub fn set_error<T: std::convert::Into<std::option::Option<rpc::model::Status>>>(
                    mut self,
                    v: T,
                ) -> Self {
                    self.error = v.into();
                    self
                }
            }

            impl wkt::message::Message for ActivationFailed {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.ActivationFailed"
                }
            }

            /// An event representing that the grant was expired.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Expired {}

            impl Expired {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Expired {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Expired"
                }
            }

            /// An event representing that the grant has ended.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct Ended {}

            impl Ended {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for Ended {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.Ended"
                }
            }

            /// An event representing that the policy bindings made by this grant were
            /// modified externally.
            #[serde_with::serde_as]
            #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(default, rename_all = "camelCase")]
            #[non_exhaustive]
            pub struct ExternallyModified {}

            impl ExternallyModified {
                pub fn new() -> Self {
                    std::default::Default::default()
                }
            }

            impl wkt::message::Message for ExternallyModified {
                fn typename() -> &'static str {
                    "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.Timeline.Event.ExternallyModified"
                }
            }

            #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
            #[serde(rename_all = "camelCase")]
            #[non_exhaustive]
            pub enum Event {
                /// The grant was requested.
                Requested(std::boxed::Box<crate::model::grant::timeline::event::Requested>),
                /// The grant was approved.
                Approved(std::boxed::Box<crate::model::grant::timeline::event::Approved>),
                /// The grant was denied.
                Denied(std::boxed::Box<crate::model::grant::timeline::event::Denied>),
                /// The grant was revoked.
                Revoked(std::boxed::Box<crate::model::grant::timeline::event::Revoked>),
                /// The grant has been scheduled to give access.
                Scheduled(std::boxed::Box<crate::model::grant::timeline::event::Scheduled>),
                /// The grant was successfully activated to give access.
                Activated(std::boxed::Box<crate::model::grant::timeline::event::Activated>),
                /// There was a non-retriable error while trying to give access.
                ActivationFailed(
                    std::boxed::Box<crate::model::grant::timeline::event::ActivationFailed>,
                ),
                /// The approval workflow did not complete in the necessary duration,
                /// and so the grant is expired.
                Expired(std::boxed::Box<crate::model::grant::timeline::event::Expired>),
                /// Access given by the grant ended automatically as the approved
                /// duration was over.
                Ended(std::boxed::Box<crate::model::grant::timeline::event::Ended>),
                /// The policy bindings made by grant have been modified outside of PAM.
                ExternallyModified(
                    std::boxed::Box<crate::model::grant::timeline::event::ExternallyModified>,
                ),
            }
        }
    }

    /// Audit trail for the access provided by this grant.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct AuditTrail {
        /// Output only. The time at which access was given.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub access_grant_time: std::option::Option<wkt::Timestamp>,

        /// Output only. The time at which the system removed access. This could be
        /// because of an automatic expiry or because of a revocation.
        ///
        /// If unspecified, then access hasn't been removed yet.
        #[serde(skip_serializing_if = "std::option::Option::is_none")]
        pub access_remove_time: std::option::Option<wkt::Timestamp>,
    }

    impl AuditTrail {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [access_grant_time][crate::model::grant::AuditTrail::access_grant_time].
        pub fn set_access_grant_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
            mut self,
            v: T,
        ) -> Self {
            self.access_grant_time = v.into();
            self
        }

        /// Sets the value of [access_remove_time][crate::model::grant::AuditTrail::access_remove_time].
        pub fn set_access_remove_time<
            T: std::convert::Into<std::option::Option<wkt::Timestamp>>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.access_remove_time = v.into();
            self
        }
    }

    impl wkt::message::Message for AuditTrail {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Grant.AuditTrail"
        }
    }

    /// Different states a grant can be in.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct State(std::borrow::Cow<'static, str>);

    impl State {
        /// Creates a new State instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// Unspecified state. This value is never returned by the server.
        pub const STATE_UNSPECIFIED: State = State::new("STATE_UNSPECIFIED");

        /// The entitlement had an approval workflow configured and this grant is
        /// waiting for the workflow to complete.
        pub const APPROVAL_AWAITED: State = State::new("APPROVAL_AWAITED");

        /// The approval workflow completed with a denied result. No access is
        /// granted for this grant. This is a terminal state.
        pub const DENIED: State = State::new("DENIED");

        /// The approval workflow completed successfully with an approved result or
        /// none was configured. Access is provided at an appropriate time.
        pub const SCHEDULED: State = State::new("SCHEDULED");

        /// Access is being given.
        pub const ACTIVATING: State = State::new("ACTIVATING");

        /// Access was successfully given and is currently active.
        pub const ACTIVE: State = State::new("ACTIVE");

        /// The system could not give access due to a non-retriable error. This is a
        /// terminal state.
        pub const ACTIVATION_FAILED: State = State::new("ACTIVATION_FAILED");

        /// Expired after waiting for the approval workflow to complete. This is a
        /// terminal state.
        pub const EXPIRED: State = State::new("EXPIRED");

        /// Access is being revoked.
        pub const REVOKING: State = State::new("REVOKING");

        /// Access was revoked by a user. This is a terminal state.
        pub const REVOKED: State = State::new("REVOKED");

        /// System took back access as the requested duration was over. This is a
        /// terminal state.
        pub const ENDED: State = State::new("ENDED");
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Justification represents a justification for requesting access.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Justification {
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub justification: std::option::Option<crate::model::justification::Justification>,
}

impl Justification {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of `justification`.
    pub fn set_justification<
        T: std::convert::Into<std::option::Option<crate::model::justification::Justification>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.justification = v.into();
        self
    }

    /// The value of [justification][crate::model::Justification::justification]
    /// if it holds a `UnstructuredJustification`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_unstructured_justification(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.justification.as_ref().and_then(|v| match v {
            crate::model::justification::Justification::UnstructuredJustification(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [justification][crate::model::Justification::justification]
    /// to hold a `UnstructuredJustification`.
    ///
    /// Note that all the setters affecting `justification` are
    /// mutually exclusive.
    pub fn set_unstructured_justification<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.justification = std::option::Option::Some(
            crate::model::justification::Justification::UnstructuredJustification(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Justification {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.Justification"
    }
}

/// Defines additional types related to Justification
pub mod justification {
    #[allow(unused_imports)]
    use super::*;

    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Justification {
        /// A free form textual justification. The system only ensures that this
        /// is not empty. No other kind of validation is performed on the string.
        UnstructuredJustification(std::string::String),
    }
}

/// Message for requesting list of grants.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGrantsRequest {
    /// Required. The parent resource which owns the grants.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, the server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,
}

impl ListGrantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGrantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGrantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGrantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGrantsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGrantsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGrantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListGrantsRequest"
    }
}

/// Message for response to listing grants.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGrantsResponse {
    /// The list of grants.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grants: std::vec::Vec<crate::model::Grant>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListGrantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListGrantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [grants][crate::model::ListGrantsResponse::grants].
    pub fn set_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Grant>,
    {
        use std::iter::Iterator;
        self.grants = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGrantsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGrantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ListGrantsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListGrantsResponse {
    type PageItem = crate::model::Grant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.grants
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request message for `SearchGrants` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchGrantsRequest {
    /// Required. The parent which owns the grant resources.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Only grants which the caller is related to by this relationship
    /// are returned in the response.
    pub caller_relationship: crate::model::search_grants_request::CallerRelationshipType,

    /// Optional. Only grants matching this filter are returned in the response.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Requested page size. The server may return fewer items than
    /// requested. If unspecified, server picks an appropriate default.
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,
}

impl SearchGrantsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::SearchGrantsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [caller_relationship][crate::model::SearchGrantsRequest::caller_relationship].
    pub fn set_caller_relationship<
        T: std::convert::Into<crate::model::search_grants_request::CallerRelationshipType>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.caller_relationship = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchGrantsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchGrantsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchGrantsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchGrantsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchGrantsRequest"
    }
}

/// Defines additional types related to SearchGrantsRequest
pub mod search_grants_request {
    #[allow(unused_imports)]
    use super::*;

    /// Different types of relationships a user can have with a grant.
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    pub struct CallerRelationshipType(std::borrow::Cow<'static, str>);

    impl CallerRelationshipType {
        /// Creates a new CallerRelationshipType instance.
        pub const fn new(v: &'static str) -> Self {
            Self(std::borrow::Cow::Borrowed(v))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            &self.0
        }
    }

    /// Useful constants to work with [CallerRelationshipType](CallerRelationshipType)
    pub mod caller_relationship_type {
        use super::CallerRelationshipType;

        /// Unspecified caller relationship type.
        pub const CALLER_RELATIONSHIP_TYPE_UNSPECIFIED: CallerRelationshipType =
            CallerRelationshipType::new("CALLER_RELATIONSHIP_TYPE_UNSPECIFIED");

        /// The user created this grant by calling `CreateGrant` earlier.
        pub const HAD_CREATED: CallerRelationshipType = CallerRelationshipType::new("HAD_CREATED");

        /// The user is an approver for the entitlement that this grant is parented
        /// under and can currently approve/deny it.
        pub const CAN_APPROVE: CallerRelationshipType = CallerRelationshipType::new("CAN_APPROVE");

        /// The caller had successfully approved/denied this grant earlier.
        pub const HAD_APPROVED: CallerRelationshipType =
            CallerRelationshipType::new("HAD_APPROVED");
    }

    impl std::convert::From<std::string::String> for CallerRelationshipType {
        fn from(value: std::string::String) -> Self {
            Self(std::borrow::Cow::Owned(value))
        }
    }
}

/// Response message for `SearchGrants` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct SearchGrantsResponse {
    /// The list of grants.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub grants: std::vec::Vec<crate::model::Grant>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,
}

impl SearchGrantsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::SearchGrantsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [grants][crate::model::SearchGrantsResponse::grants].
    pub fn set_grants<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Grant>,
    {
        use std::iter::Iterator;
        self.grants = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for SearchGrantsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.SearchGrantsResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for SearchGrantsResponse {
    type PageItem = crate::model::Grant;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.grants
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Message for getting a grant.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGrantRequest {
    /// Required. Name of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.GetGrantRequest"
    }
}

/// Request message for `ApproveGrant` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ApproveGrantRequest {
    /// Required. Name of the grant resource which is being approved.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The reason for approving this grant. This is required if the
    /// `require_approver_justification` field of the `ManualApprovals` workflow
    /// used in this grant is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,
}

impl ApproveGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ApproveGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::ApproveGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for ApproveGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.ApproveGrantRequest"
    }
}

/// Request message for `DenyGrant` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DenyGrantRequest {
    /// Required. Name of the grant resource which is being denied.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The reason for denying this grant. This is required if
    /// `require_approver_justification` field of the `ManualApprovals` workflow
    /// used in this grant is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,
}

impl DenyGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DenyGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::DenyGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for DenyGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.DenyGrantRequest"
    }
}

/// Request message for `RevokeGrant` method.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RevokeGrantRequest {
    /// Required. Name of the grant resource which is being revoked.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. The reason for revoking this grant.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub reason: std::string::String,
}

impl RevokeGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RevokeGrantRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [reason][crate::model::RevokeGrantRequest::reason].
    pub fn set_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.reason = v.into();
        self
    }
}

impl wkt::message::Message for RevokeGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.RevokeGrantRequest"
    }
}

/// Message for creating a grant
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGrantRequest {
    /// Required. Name of the parent entitlement for which this grant is being
    /// requested.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource being created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub grant: std::option::Option<crate::model::Grant>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server knows to
    /// ignore the request if it has already been completed. The server guarantees
    /// this for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, ignores the second request. This prevents
    /// clients from accidentally creating duplicate grants.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateGrantRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGrantRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [grant][crate::model::CreateGrantRequest::grant].
    pub fn set_grant<T: std::convert::Into<std::option::Option<crate::model::Grant>>>(
        mut self,
        v: T,
    ) -> Self {
        self.grant = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGrantRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateGrantRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.CreateGrantRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.privilegedaccessmanager.v1.OperationMetadata"
    }
}
