// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Defines flags that are used to run the diagnostic tool
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiagnosticConfig {
    /// Required. User Cloud Storage bucket location (REQUIRED).
    /// Must be formatted with path prefix (`gs://$GCS_BUCKET`).
    ///
    /// Permissions:
    /// User Managed Notebooks:
    ///
    /// - storage.buckets.writer: Must be given to the project's service account
    ///   attached to VM.
    ///   Google Managed Notebooks:
    /// - storage.buckets.writer: Must be given to the project's service account or
    ///   user credentials attached to VM depending on authentication mode.
    ///
    /// Cloud Storage bucket Log file will be written to
    /// `gs://$GCS_BUCKET/$RELATIVE_PATH/$VM_DATE_$TIME.tar.gz`
    pub gcs_bucket: std::string::String,

    /// Optional. Defines the relative storage path in the Cloud Storage bucket
    /// where the diagnostic logs will be written: Default path will be the root
    /// directory of the Cloud Storage bucket
    /// (`gs://$GCS_BUCKET/$DATE_$TIME.tar.gz`) Example of full path where Log file
    /// will be written: `gs://$GCS_BUCKET/$RELATIVE_PATH/`
    pub relative_path: std::string::String,

    /// Optional. Enables flag to repair service for instance
    pub enable_repair_flag: bool,

    /// Optional. Enables flag to capture packets from the instance for 30 seconds
    pub enable_packet_capture_flag: bool,

    /// Optional. Enables flag to copy all `/home/jupyter` folder contents
    pub enable_copy_home_files_flag: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnosticConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_bucket][crate::model::DiagnosticConfig::gcs_bucket].
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_bucket = v.into();
        self
    }

    /// Sets the value of [relative_path][crate::model::DiagnosticConfig::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [enable_repair_flag][crate::model::DiagnosticConfig::enable_repair_flag].
    pub fn set_enable_repair_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_repair_flag = v.into();
        self
    }

    /// Sets the value of [enable_packet_capture_flag][crate::model::DiagnosticConfig::enable_packet_capture_flag].
    pub fn set_enable_packet_capture_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_packet_capture_flag = v.into();
        self
    }

    /// Sets the value of [enable_copy_home_files_flag][crate::model::DiagnosticConfig::enable_copy_home_files_flag].
    pub fn set_enable_copy_home_files_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_copy_home_files_flag = v.into();
        self
    }
}

impl wkt::message::Message for DiagnosticConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DiagnosticConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiagnosticConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_bucket,
            __relative_path,
            __enable_repair_flag,
            __enable_packet_capture_flag,
            __enable_copy_home_files_flag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiagnosticConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsBucket" => Ok(__FieldTag::__gcs_bucket),
                            "gcs_bucket" => Ok(__FieldTag::__gcs_bucket),
                            "relativePath" => Ok(__FieldTag::__relative_path),
                            "relative_path" => Ok(__FieldTag::__relative_path),
                            "enableRepairFlag" => Ok(__FieldTag::__enable_repair_flag),
                            "enable_repair_flag" => Ok(__FieldTag::__enable_repair_flag),
                            "enablePacketCaptureFlag" => {
                                Ok(__FieldTag::__enable_packet_capture_flag)
                            }
                            "enable_packet_capture_flag" => {
                                Ok(__FieldTag::__enable_packet_capture_flag)
                            }
                            "enableCopyHomeFilesFlag" => {
                                Ok(__FieldTag::__enable_copy_home_files_flag)
                            }
                            "enable_copy_home_files_flag" => {
                                Ok(__FieldTag::__enable_copy_home_files_flag)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiagnosticConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiagnosticConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_bucket => {
                            if !fields.insert(__FieldTag::__gcs_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_bucket",
                                ));
                            }
                            result.gcs_bucket = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__relative_path => {
                            if !fields.insert(__FieldTag::__relative_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relative_path",
                                ));
                            }
                            result.relative_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_repair_flag => {
                            if !fields.insert(__FieldTag::__enable_repair_flag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_repair_flag",
                                ));
                            }
                            result.enable_repair_flag = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_packet_capture_flag => {
                            if !fields.insert(__FieldTag::__enable_packet_capture_flag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_packet_capture_flag",
                                ));
                            }
                            result.enable_packet_capture_flag = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_copy_home_files_flag => {
                            if !fields.insert(__FieldTag::__enable_copy_home_files_flag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_copy_home_files_flag",
                                ));
                            }
                            result.enable_copy_home_files_flag = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiagnosticConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.gcs_bucket.is_empty() {
            state.serialize_entry("gcsBucket", &self.gcs_bucket)?;
        }
        if !self.relative_path.is_empty() {
            state.serialize_entry("relativePath", &self.relative_path)?;
        }
        if !wkt::internal::is_default(&self.enable_repair_flag) {
            state.serialize_entry("enableRepairFlag", &self.enable_repair_flag)?;
        }
        if !wkt::internal::is_default(&self.enable_packet_capture_flag) {
            state.serialize_entry("enablePacketCaptureFlag", &self.enable_packet_capture_flag)?;
        }
        if !wkt::internal::is_default(&self.enable_copy_home_files_flag) {
            state.serialize_entry("enableCopyHomeFilesFlag", &self.enable_copy_home_files_flag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The definition of an Event for a managed / semi-managed notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Event {
    /// Optional. Event report time.
    pub report_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Event type.
    pub r#type: crate::model::event::EventType,

    /// Optional. Event details. This field is used to pass event information.
    pub details: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_time][crate::model::Event::report_time].
    pub fn set_report_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.report_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [report_time][crate::model::Event::report_time].
    pub fn set_or_clear_report_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.report_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::EventType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::Event::details].
    pub fn set_details<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.Event"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Event {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __report_time,
            __type,
            __details,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Event")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "reportTime" => Ok(__FieldTag::__report_time),
                            "report_time" => Ok(__FieldTag::__report_time),
                            "type" => Ok(__FieldTag::__type),
                            "details" => Ok(__FieldTag::__details),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Event;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Event")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__report_time => {
                            if !fields.insert(__FieldTag::__report_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for report_time",
                                ));
                            }
                            result.report_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<crate::model::event::EventType>>(
                                )?
                                .unwrap_or_default();
                        }
                        __FieldTag::__details => {
                            if !fields.insert(__FieldTag::__details) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for details",
                                ));
                            }
                            result.details = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Event {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.report_time.is_some() {
            state.serialize_entry("reportTime", &self.report_time)?;
        }
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !self.details.is_empty() {
            state.serialize_entry("details", &self.details)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Event].
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the event types.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum EventType {
        /// Event is not specified.
        Unspecified,
        /// The instance / runtime is idle
        Idle,
        /// The instance / runtime is available.
        /// This event indicates that instance / runtime underlying compute is
        /// operational.
        Heartbeat,
        /// The instance / runtime health is available.
        /// This event indicates that instance / runtime health information.
        Health,
        /// The instance / runtime is available.
        /// This event allows instance / runtime to send Host maintenance
        /// information to Control Plane.
        /// <https://cloud.google.com/compute/docs/gpus/gpu-host-maintenance>
        Maintenance,
        /// The instance / runtime is available.
        /// This event indicates that the instance had metadata that needs to be
        /// modified.
        MetadataChange,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [EventType::value] or
        /// [EventType::name].
        UnknownValue(event_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod event_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl EventType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Idle => std::option::Option::Some(1),
                Self::Heartbeat => std::option::Option::Some(2),
                Self::Health => std::option::Option::Some(3),
                Self::Maintenance => std::option::Option::Some(4),
                Self::MetadataChange => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("EVENT_TYPE_UNSPECIFIED"),
                Self::Idle => std::option::Option::Some("IDLE"),
                Self::Heartbeat => std::option::Option::Some("HEARTBEAT"),
                Self::Health => std::option::Option::Some("HEALTH"),
                Self::Maintenance => std::option::Option::Some("MAINTENANCE"),
                Self::MetadataChange => std::option::Option::Some("METADATA_CHANGE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for EventType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Idle,
                2 => Self::Heartbeat,
                3 => Self::Health,
                4 => Self::Maintenance,
                5 => Self::MetadataChange,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for EventType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "EVENT_TYPE_UNSPECIFIED" => Self::Unspecified,
                "IDLE" => Self::Idle,
                "HEARTBEAT" => Self::Heartbeat,
                "HEALTH" => Self::Health,
                "MAINTENANCE" => Self::Maintenance,
                "METADATA_CHANGE" => Self::MetadataChange,
                _ => Self::UnknownValue(event_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Idle => serializer.serialize_i32(1),
                Self::Heartbeat => serializer.serialize_i32(2),
                Self::Health => serializer.serialize_i32(3),
                Self::Maintenance => serializer.serialize_i32(4),
                Self::MetadataChange => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<EventType>::new(
                ".google.cloud.notebooks.v2.Event.EventType",
            ))
        }
    }
}

/// The definition of a network interface resource attached to a VM.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NetworkInterface {
    /// Optional. The name of the VPC that this VM instance is in.
    /// Format:
    /// `projects/{project_id}/global/networks/{network_id}`
    pub network: std::string::String,

    /// Optional. The name of the subnet that this VM instance is in.
    /// Format:
    /// `projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}`
    pub subnet: std::string::String,

    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    pub nic_type: crate::model::network_interface::NicType,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::NetworkInterface::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<T: std::convert::Into<crate::model::network_interface::NicType>>(
        mut self,
        v: T,
    ) -> Self {
        self.nic_type = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.NetworkInterface"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NetworkInterface {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __network,
            __subnet,
            __nic_type,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NetworkInterface")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "network" => Ok(__FieldTag::__network),
                            "subnet" => Ok(__FieldTag::__subnet),
                            "nicType" => Ok(__FieldTag::__nic_type),
                            "nic_type" => Ok(__FieldTag::__nic_type),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NetworkInterface;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NetworkInterface")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__network => {
                            if !fields.insert(__FieldTag::__network) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network",
                                ));
                            }
                            result.network = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__subnet => {
                            if !fields.insert(__FieldTag::__subnet) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for subnet",
                                ));
                            }
                            result.subnet = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__nic_type => {
                            if !fields.insert(__FieldTag::__nic_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for nic_type",
                                ));
                            }
                            result.nic_type = map.next_value::<std::option::Option<crate::model::network_interface::NicType>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NetworkInterface {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.network.is_empty() {
            state.serialize_entry("network", &self.network)?;
        }
        if !self.subnet.is_empty() {
            state.serialize_entry("subnet", &self.subnet)?;
        }
        if !wkt::internal::is_default(&self.nic_type) {
            state.serialize_entry("nicType", &self.nic_type)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NetworkInterface].
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// The type of vNIC driver.
    /// Default should be NIC_TYPE_UNSPECIFIED.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum NicType {
        /// No type specified.
        Unspecified,
        /// VIRTIO
        VirtioNet,
        /// GVNIC
        Gvnic,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [NicType::value] or
        /// [NicType::name].
        UnknownValue(nic_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod nic_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl NicType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::VirtioNet => std::option::Option::Some(1),
                Self::Gvnic => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("NIC_TYPE_UNSPECIFIED"),
                Self::VirtioNet => std::option::Option::Some("VIRTIO_NET"),
                Self::Gvnic => std::option::Option::Some("GVNIC"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for NicType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::VirtioNet,
                2 => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for NicType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "NIC_TYPE_UNSPECIFIED" => Self::Unspecified,
                "VIRTIO_NET" => Self::VirtioNet,
                "GVNIC" => Self::Gvnic,
                _ => Self::UnknownValue(nic_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::VirtioNet => serializer.serialize_i32(1),
                Self::Gvnic => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<NicType>::new(
                ".google.cloud.notebooks.v2.NetworkInterface.NicType",
            ))
        }
    }
}

/// Definition of a custom Compute Engine virtual machine image for starting a
/// notebook instance with the environment installed directly on the VM.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct VmImage {
    /// Required. The name of the Google Cloud project that this VM image belongs
    /// to. Format: `{project_id}`
    pub project: std::string::String,

    /// The reference to an external Compute Engine VM image.
    pub image: std::option::Option<crate::model::vm_image::Image>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl VmImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::VmImage::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of [image][crate::model::VmImage::image].
    ///
    /// Note that all the setters affecting `image` are mutually
    /// exclusive.
    pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::vm_image::Image>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = v.into();
        self
    }

    /// The value of [image][crate::model::VmImage::image]
    /// if it holds a `Name`, `None` if the field is not set or
    /// holds a different branch.
    pub fn name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::vm_image::Image::Name(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::VmImage::image]
    /// to hold a `Name`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = std::option::Option::Some(crate::model::vm_image::Image::Name(v.into()));
        self
    }

    /// The value of [image][crate::model::VmImage::image]
    /// if it holds a `Family`, `None` if the field is not set or
    /// holds a different branch.
    pub fn family(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::vm_image::Image::Family(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::VmImage::image]
    /// to hold a `Family`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = std::option::Option::Some(crate::model::vm_image::Image::Family(v.into()));
        self
    }
}

impl wkt::message::Message for VmImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.VmImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for VmImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __project,
            __name,
            __family,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for VmImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "project" => Ok(__FieldTag::__project),
                            "name" => Ok(__FieldTag::__name),
                            "family" => Ok(__FieldTag::__family),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = VmImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct VmImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__project => {
                            if !fields.insert(__FieldTag::__project) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for project",
                                ));
                            }
                            result.project = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.notebooks.v2.VmImage.name, latest field was name",
                                ));
                            }
                            result.image =
                                std::option::Option::Some(crate::model::vm_image::Image::Name(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::__family => {
                            if !fields.insert(__FieldTag::__family) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for family",
                                ));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.notebooks.v2.VmImage.family, latest field was family",
                                ));
                            }
                            result.image =
                                std::option::Option::Some(crate::model::vm_image::Image::Family(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ));
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for VmImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.project.is_empty() {
            state.serialize_entry("project", &self.project)?;
        }
        if let Some(value) = self.name() {
            state.serialize_entry("name", value)?;
        }
        if let Some(value) = self.family() {
            state.serialize_entry("family", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [VmImage].
pub mod vm_image {
    #[allow(unused_imports)]
    use super::*;

    /// The reference to an external Compute Engine VM image.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Image {
        /// Optional. Use VM image name to find the image.
        Name(std::string::String),
        /// Optional. Use this VM image family to find the image; the newest image in
        /// this family will be used.
        Family(std::string::String),
    }
}

/// Definition of a container image for starting a notebook instance with the
/// environment installed in a container.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ContainerImage {
    /// Required. The path to the container image repository. For example:
    /// `gcr.io/{project_id}/{image_name}`
    pub repository: std::string::String,

    /// Optional. The tag of the container image. If not specified, this defaults
    /// to the latest tag.
    pub tag: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ContainerImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::ContainerImage::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::ContainerImage::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for ContainerImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ContainerImage"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ContainerImage {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repository,
            __tag,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ContainerImage")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repository" => Ok(__FieldTag::__repository),
                            "tag" => Ok(__FieldTag::__tag),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ContainerImage;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ContainerImage")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tag => {
                            if !fields.insert(__FieldTag::__tag) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tag",
                                ));
                            }
                            result.tag = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ContainerImage {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.repository.is_empty() {
            state.serialize_entry("repository", &self.repository)?;
        }
        if !self.tag.is_empty() {
            state.serialize_entry("tag", &self.tag)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An accelerator configuration for a VM instance
/// Definition of a hardware accelerator. Note that there is no check on `type`
/// and `core_count` combinations. TPUs are not supported.
/// See [GPUs on Compute
/// Engine](https://cloud.google.com/compute/docs/gpus/#gpus-list) to find a
/// valid combination.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Optional. Type of this accelerator.
    pub r#type: crate::model::accelerator_config::AcceleratorType,

    /// Optional. Count of cores of this accelerator.
    pub core_count: i64,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AcceleratorConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::accelerator_config::AcceleratorType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [core_count][crate::model::AcceleratorConfig::core_count].
    pub fn set_core_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.core_count = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.AcceleratorConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for AcceleratorConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __type,
            __core_count,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for AcceleratorConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "type" => Ok(__FieldTag::__type),
                            "coreCount" => Ok(__FieldTag::__core_count),
                            "core_count" => Ok(__FieldTag::__core_count),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = AcceleratorConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct AcceleratorConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__type => {
                            if !fields.insert(__FieldTag::__type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for type",
                                ));
                            }
                            result.r#type = map
                                .next_value::<std::option::Option<
                                    crate::model::accelerator_config::AcceleratorType,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__core_count => {
                            if !fields.insert(__FieldTag::__core_count) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for core_count",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.core_count = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for AcceleratorConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.r#type) {
            state.serialize_entry("type", &self.r#type)?;
        }
        if !wkt::internal::is_default(&self.core_count) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("coreCount", &__With(&self.core_count))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [AcceleratorConfig].
pub mod accelerator_config {
    #[allow(unused_imports)]
    use super::*;

    /// Definition of the types of hardware accelerators that can be used on
    /// this instance.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum AcceleratorType {
        /// Accelerator type is not specified.
        Unspecified,
        /// Accelerator type is Nvidia Tesla P100.
        NvidiaTeslaP100,
        /// Accelerator type is Nvidia Tesla V100.
        NvidiaTeslaV100,
        /// Accelerator type is Nvidia Tesla P4.
        NvidiaTeslaP4,
        /// Accelerator type is Nvidia Tesla T4.
        NvidiaTeslaT4,
        /// Accelerator type is Nvidia Tesla A100 - 40GB.
        NvidiaTeslaA100,
        /// Accelerator type is Nvidia Tesla A100 - 80GB.
        NvidiaA10080Gb,
        /// Accelerator type is Nvidia Tesla L4.
        NvidiaL4,
        /// Accelerator type is NVIDIA Tesla T4 Virtual Workstations.
        NvidiaTeslaT4Vws,
        /// Accelerator type is NVIDIA Tesla P100 Virtual Workstations.
        NvidiaTeslaP100Vws,
        /// Accelerator type is NVIDIA Tesla P4 Virtual Workstations.
        NvidiaTeslaP4Vws,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [AcceleratorType::value] or
        /// [AcceleratorType::name].
        UnknownValue(accelerator_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod accelerator_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl AcceleratorType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NvidiaTeslaP100 => std::option::Option::Some(2),
                Self::NvidiaTeslaV100 => std::option::Option::Some(3),
                Self::NvidiaTeslaP4 => std::option::Option::Some(4),
                Self::NvidiaTeslaT4 => std::option::Option::Some(5),
                Self::NvidiaTeslaA100 => std::option::Option::Some(11),
                Self::NvidiaA10080Gb => std::option::Option::Some(12),
                Self::NvidiaL4 => std::option::Option::Some(13),
                Self::NvidiaTeslaT4Vws => std::option::Option::Some(8),
                Self::NvidiaTeslaP100Vws => std::option::Option::Some(9),
                Self::NvidiaTeslaP4Vws => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACCELERATOR_TYPE_UNSPECIFIED"),
                Self::NvidiaTeslaP100 => std::option::Option::Some("NVIDIA_TESLA_P100"),
                Self::NvidiaTeslaV100 => std::option::Option::Some("NVIDIA_TESLA_V100"),
                Self::NvidiaTeslaP4 => std::option::Option::Some("NVIDIA_TESLA_P4"),
                Self::NvidiaTeslaT4 => std::option::Option::Some("NVIDIA_TESLA_T4"),
                Self::NvidiaTeslaA100 => std::option::Option::Some("NVIDIA_TESLA_A100"),
                Self::NvidiaA10080Gb => std::option::Option::Some("NVIDIA_A100_80GB"),
                Self::NvidiaL4 => std::option::Option::Some("NVIDIA_L4"),
                Self::NvidiaTeslaT4Vws => std::option::Option::Some("NVIDIA_TESLA_T4_VWS"),
                Self::NvidiaTeslaP100Vws => std::option::Option::Some("NVIDIA_TESLA_P100_VWS"),
                Self::NvidiaTeslaP4Vws => std::option::Option::Some("NVIDIA_TESLA_P4_VWS"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for AcceleratorType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for AcceleratorType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for AcceleratorType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                2 => Self::NvidiaTeslaP100,
                3 => Self::NvidiaTeslaV100,
                4 => Self::NvidiaTeslaP4,
                5 => Self::NvidiaTeslaT4,
                8 => Self::NvidiaTeslaT4Vws,
                9 => Self::NvidiaTeslaP100Vws,
                10 => Self::NvidiaTeslaP4Vws,
                11 => Self::NvidiaTeslaA100,
                12 => Self::NvidiaA10080Gb,
                13 => Self::NvidiaL4,
                _ => Self::UnknownValue(accelerator_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for AcceleratorType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACCELERATOR_TYPE_UNSPECIFIED" => Self::Unspecified,
                "NVIDIA_TESLA_P100" => Self::NvidiaTeslaP100,
                "NVIDIA_TESLA_V100" => Self::NvidiaTeslaV100,
                "NVIDIA_TESLA_P4" => Self::NvidiaTeslaP4,
                "NVIDIA_TESLA_T4" => Self::NvidiaTeslaT4,
                "NVIDIA_TESLA_A100" => Self::NvidiaTeslaA100,
                "NVIDIA_A100_80GB" => Self::NvidiaA10080Gb,
                "NVIDIA_L4" => Self::NvidiaL4,
                "NVIDIA_TESLA_T4_VWS" => Self::NvidiaTeslaT4Vws,
                "NVIDIA_TESLA_P100_VWS" => Self::NvidiaTeslaP100Vws,
                "NVIDIA_TESLA_P4_VWS" => Self::NvidiaTeslaP4Vws,
                _ => Self::UnknownValue(accelerator_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for AcceleratorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NvidiaTeslaP100 => serializer.serialize_i32(2),
                Self::NvidiaTeslaV100 => serializer.serialize_i32(3),
                Self::NvidiaTeslaP4 => serializer.serialize_i32(4),
                Self::NvidiaTeslaT4 => serializer.serialize_i32(5),
                Self::NvidiaTeslaA100 => serializer.serialize_i32(11),
                Self::NvidiaA10080Gb => serializer.serialize_i32(12),
                Self::NvidiaL4 => serializer.serialize_i32(13),
                Self::NvidiaTeslaT4Vws => serializer.serialize_i32(8),
                Self::NvidiaTeslaP100Vws => serializer.serialize_i32(9),
                Self::NvidiaTeslaP4Vws => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AcceleratorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<AcceleratorType>::new(
                ".google.cloud.notebooks.v2.AcceleratorConfig.AcceleratorType",
            ))
        }
    }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
/// Not all combinations are valid.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Optional. Defines whether the VM instance has Secure Boot enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails. Disabled by default.
    pub enable_secure_boot: bool,

    /// Optional. Defines whether the VM instance has the vTPM enabled. Enabled by
    /// default.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the VM instance has integrity monitoring enabled.
    ///
    /// Enables monitoring and attestation of the boot integrity of the VM
    /// instance. The attestation is performed against the integrity policy
    /// baseline. This baseline is initially derived from the implicitly trusted
    /// boot image when the VM instance is created. Enabled by default.
    pub enable_integrity_monitoring: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ShieldedInstanceConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ShieldedInstanceConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_secure_boot,
            __enable_vtpm,
            __enable_integrity_monitoring,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ShieldedInstanceConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableSecureBoot" => Ok(__FieldTag::__enable_secure_boot),
                            "enable_secure_boot" => Ok(__FieldTag::__enable_secure_boot),
                            "enableVtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enable_vtpm" => Ok(__FieldTag::__enable_vtpm),
                            "enableIntegrityMonitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            "enable_integrity_monitoring" => {
                                Ok(__FieldTag::__enable_integrity_monitoring)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ShieldedInstanceConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ShieldedInstanceConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_secure_boot => {
                            if !fields.insert(__FieldTag::__enable_secure_boot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_secure_boot",
                                ));
                            }
                            result.enable_secure_boot = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_vtpm => {
                            if !fields.insert(__FieldTag::__enable_vtpm) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_vtpm",
                                ));
                            }
                            result.enable_vtpm = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_integrity_monitoring => {
                            if !fields.insert(__FieldTag::__enable_integrity_monitoring) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_integrity_monitoring",
                                ));
                            }
                            result.enable_integrity_monitoring = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ShieldedInstanceConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_secure_boot) {
            state.serialize_entry("enableSecureBoot", &self.enable_secure_boot)?;
        }
        if !wkt::internal::is_default(&self.enable_vtpm) {
            state.serialize_entry("enableVtpm", &self.enable_vtpm)?;
        }
        if !wkt::internal::is_default(&self.enable_integrity_monitoring) {
            state.serialize_entry(
                "enableIntegrityMonitoring",
                &self.enable_integrity_monitoring,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A GPU driver configuration
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GPUDriverConfig {
    /// Optional. Whether the end user authorizes Google Cloud to install GPU
    /// driver on this VM instance. If this field is empty or set to false, the GPU
    /// driver won't be installed. Only applicable to instances with GPUs.
    pub enable_gpu_driver: bool,

    /// Optional. Specify a custom Cloud Storage path where the GPU driver is
    /// stored. If not specified, we'll automatically choose from official GPU
    /// drivers.
    pub custom_gpu_driver_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GPUDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_gpu_driver][crate::model::GPUDriverConfig::enable_gpu_driver].
    pub fn set_enable_gpu_driver<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_gpu_driver = v.into();
        self
    }

    /// Sets the value of [custom_gpu_driver_path][crate::model::GPUDriverConfig::custom_gpu_driver_path].
    pub fn set_custom_gpu_driver_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_gpu_driver_path = v.into();
        self
    }
}

impl wkt::message::Message for GPUDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GPUDriverConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GPUDriverConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __enable_gpu_driver,
            __custom_gpu_driver_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GPUDriverConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "enableGpuDriver" => Ok(__FieldTag::__enable_gpu_driver),
                            "enable_gpu_driver" => Ok(__FieldTag::__enable_gpu_driver),
                            "customGpuDriverPath" => Ok(__FieldTag::__custom_gpu_driver_path),
                            "custom_gpu_driver_path" => Ok(__FieldTag::__custom_gpu_driver_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GPUDriverConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GPUDriverConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__enable_gpu_driver => {
                            if !fields.insert(__FieldTag::__enable_gpu_driver) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_gpu_driver",
                                ));
                            }
                            result.enable_gpu_driver = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__custom_gpu_driver_path => {
                            if !fields.insert(__FieldTag::__custom_gpu_driver_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for custom_gpu_driver_path",
                                ));
                            }
                            result.custom_gpu_driver_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GPUDriverConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.enable_gpu_driver) {
            state.serialize_entry("enableGpuDriver", &self.enable_gpu_driver)?;
        }
        if !self.custom_gpu_driver_path.is_empty() {
            state.serialize_entry("customGpuDriverPath", &self.custom_gpu_driver_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// An instance-attached disk resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataDisk {
    /// Optional. The size of the disk in GB attached to this VM instance, up to a
    /// maximum of 64000 GB (64 TB). If not specified, this defaults to 100.
    pub disk_size_gb: i64,

    /// Optional. Input only. Indicates the type of the disk.
    pub disk_type: crate::model::DiskType,

    /// Optional. Input only. Disk encryption method used on the boot and data
    /// disks, defaults to GMEK.
    pub disk_encryption: crate::model::DiskEncryption,

    /// Optional. Input only. The KMS key used to encrypt the disks, only
    /// applicable if disk_encryption is CMEK. Format:
    /// `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
    ///
    /// Learn more about using your own encryption keys.
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_size_gb][crate::model::DataDisk::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::DataDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::DiskType>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_encryption][crate::model::DataDisk::disk_encryption].
    pub fn set_disk_encryption<T: std::convert::Into<crate::model::DiskEncryption>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_encryption = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::DataDisk::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for DataDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DataDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_size_gb,
            __disk_type,
            __disk_encryption,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "diskEncryption" => Ok(__FieldTag::__disk_encryption),
                            "disk_encryption" => Ok(__FieldTag::__disk_encryption),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<crate::model::DiskType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_encryption => {
                            if !fields.insert(__FieldTag::__disk_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption",
                                ));
                            }
                            result.disk_encryption = map
                                .next_value::<std::option::Option<crate::model::DiskEncryption>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.disk_encryption) {
            state.serialize_entry("diskEncryption", &self.disk_encryption)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The definition of a boot disk.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct BootDisk {
    /// Optional. The size of the boot disk in GB attached to this instance, up to
    /// a maximum of 64000 GB (64 TB). If not specified, this defaults to the
    /// recommended value of 150GB.
    pub disk_size_gb: i64,

    /// Optional. Indicates the type of the disk.
    pub disk_type: crate::model::DiskType,

    /// Optional. Input only. Disk encryption method used on the boot and data
    /// disks, defaults to GMEK.
    pub disk_encryption: crate::model::DiskEncryption,

    /// Optional. Input only. The KMS key used to encrypt the disks, only
    /// applicable if disk_encryption is CMEK. Format:
    /// `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
    ///
    /// Learn more about using your own encryption keys.
    pub kms_key: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl BootDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_size_gb][crate::model::BootDisk::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::BootDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::DiskType>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_encryption][crate::model::BootDisk::disk_encryption].
    pub fn set_disk_encryption<T: std::convert::Into<crate::model::DiskEncryption>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_encryption = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::BootDisk::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for BootDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.BootDisk"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for BootDisk {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __disk_size_gb,
            __disk_type,
            __disk_encryption,
            __kms_key,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for BootDisk")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "diskSizeGb" => Ok(__FieldTag::__disk_size_gb),
                            "disk_size_gb" => Ok(__FieldTag::__disk_size_gb),
                            "diskType" => Ok(__FieldTag::__disk_type),
                            "disk_type" => Ok(__FieldTag::__disk_type),
                            "diskEncryption" => Ok(__FieldTag::__disk_encryption),
                            "disk_encryption" => Ok(__FieldTag::__disk_encryption),
                            "kmsKey" => Ok(__FieldTag::__kms_key),
                            "kms_key" => Ok(__FieldTag::__kms_key),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = BootDisk;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct BootDisk")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__disk_size_gb => {
                            if !fields.insert(__FieldTag::__disk_size_gb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_size_gb",
                                ));
                            }
                            struct __With(std::option::Option<i64>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.disk_size_gb = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__disk_type => {
                            if !fields.insert(__FieldTag::__disk_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_type",
                                ));
                            }
                            result.disk_type = map
                                .next_value::<std::option::Option<crate::model::DiskType>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disk_encryption => {
                            if !fields.insert(__FieldTag::__disk_encryption) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disk_encryption",
                                ));
                            }
                            result.disk_encryption = map
                                .next_value::<std::option::Option<crate::model::DiskEncryption>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key => {
                            if !fields.insert(__FieldTag::__kms_key) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key",
                                ));
                            }
                            result.kms_key = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for BootDisk {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.disk_size_gb) {
            struct __With<'a>(&'a i64);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("diskSizeGb", &__With(&self.disk_size_gb))?;
        }
        if !wkt::internal::is_default(&self.disk_type) {
            state.serialize_entry("diskType", &self.disk_type)?;
        }
        if !wkt::internal::is_default(&self.disk_encryption) {
            state.serialize_entry("diskEncryption", &self.disk_encryption)?;
        }
        if !self.kms_key.is_empty() {
            state.serialize_entry("kmsKey", &self.kms_key)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// A service account that acts as an identity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Optional. Email address of the service account.
    pub email: std::string::String,

    /// Output only. The list of scopes to be made available for this service
    /// account. Set by the CLH to <https://www.googleapis.com/auth/cloud-platform>
    pub scopes: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ServiceAccount"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ServiceAccount {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __email,
            __scopes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ServiceAccount")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "email" => Ok(__FieldTag::__email),
                            "scopes" => Ok(__FieldTag::__scopes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ServiceAccount;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ServiceAccount")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__email => {
                            if !fields.insert(__FieldTag::__email) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email",
                                ));
                            }
                            result.email = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__scopes => {
                            if !fields.insert(__FieldTag::__scopes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for scopes",
                                ));
                            }
                            result.scopes = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ServiceAccount {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.email.is_empty() {
            state.serialize_entry("email", &self.email)?;
        }
        if !self.scopes.is_empty() {
            state.serialize_entry("scopes", &self.scopes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// The definition of how to configure a VM instance outside of Resources and
/// Identity.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GceSetup {
    /// Optional. The machine type of the VM instance.
    /// <https://cloud.google.com/compute/docs/machine-resource>
    pub machine_type: std::string::String,

    /// Optional. The hardware accelerators used on this instance. If you use
    /// accelerators, make sure that your configuration has
    /// [enough vCPUs and memory to support the `machine_type` you have
    /// selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
    /// Currently supports only one accelerator configuration.
    pub accelerator_configs: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. The service account that serves as an identity for the VM
    /// instance. Currently supports only one service account.
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Optional. The boot disk for the VM.
    pub boot_disk: std::option::Option<crate::model::BootDisk>,

    /// Optional. Data disks attached to the VM instance.
    /// Currently supports only one data disk.
    pub data_disks: std::vec::Vec<crate::model::DataDisk>,

    /// Optional. Shielded VM configuration.
    /// [Images using supported Shielded VM
    /// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Optional. The network interfaces for the VM.
    /// Supports only one interface.
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. If true, no external IP will be assigned to this VM instance.
    pub disable_public_ip: bool,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. Custom metadata to apply to this instance.
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Flag to enable ip forwarding or not, default false/off.
    /// <https://cloud.google.com/vpc/docs/using-routes#canipforward>
    pub enable_ip_forwarding: bool,

    /// Optional. Configuration for GPU drivers.
    pub gpu_driver_config: std::option::Option<crate::model::GPUDriverConfig>,

    /// Type of the image; can be one of VM image, or container image.
    pub image: std::option::Option<crate::model::gce_setup::Image>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GceSetup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::GceSetup::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [accelerator_configs][crate::model::GceSetup::accelerator_configs].
    pub fn set_accelerator_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerator_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_accounts][crate::model::GceSetup::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [boot_disk][crate::model::GceSetup::boot_disk].
    pub fn set_boot_disk<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [boot_disk][crate::model::GceSetup::boot_disk].
    pub fn set_or_clear_boot_disk<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::BootDisk>,
    {
        self.boot_disk = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_disks][crate::model::GceSetup::data_disks].
    pub fn set_data_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataDisk>,
    {
        use std::iter::Iterator;
        self.data_disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::GceSetup::shielded_instance_config].
    pub fn set_shielded_instance_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [shielded_instance_config][crate::model::GceSetup::shielded_instance_config].
    pub fn set_or_clear_shielded_instance_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ShieldedInstanceConfig>,
    {
        self.shielded_instance_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [network_interfaces][crate::model::GceSetup::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disable_public_ip][crate::model::GceSetup::disable_public_ip].
    pub fn set_disable_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_public_ip = v.into();
        self
    }

    /// Sets the value of [tags][crate::model::GceSetup::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::GceSetup::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [enable_ip_forwarding][crate::model::GceSetup::enable_ip_forwarding].
    pub fn set_enable_ip_forwarding<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_ip_forwarding = v.into();
        self
    }

    /// Sets the value of [gpu_driver_config][crate::model::GceSetup::gpu_driver_config].
    pub fn set_gpu_driver_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GPUDriverConfig>,
    {
        self.gpu_driver_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [gpu_driver_config][crate::model::GceSetup::gpu_driver_config].
    pub fn set_or_clear_gpu_driver_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GPUDriverConfig>,
    {
        self.gpu_driver_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [image][crate::model::GceSetup::image].
    ///
    /// Note that all the setters affecting `image` are mutually
    /// exclusive.
    pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::gce_setup::Image>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = v.into();
        self
    }

    /// The value of [image][crate::model::GceSetup::image]
    /// if it holds a `VmImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn vm_image(&self) -> std::option::Option<&std::boxed::Box<crate::model::VmImage>> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::gce_setup::Image::VmImage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::GceSetup::image]
    /// to hold a `VmImage`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_vm_image<T: std::convert::Into<std::boxed::Box<crate::model::VmImage>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = std::option::Option::Some(crate::model::gce_setup::Image::VmImage(v.into()));
        self
    }

    /// The value of [image][crate::model::GceSetup::image]
    /// if it holds a `ContainerImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn container_image(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContainerImage>> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::gce_setup::Image::ContainerImage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::GceSetup::image]
    /// to hold a `ContainerImage`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_container_image<
        T: std::convert::Into<std::boxed::Box<crate::model::ContainerImage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image =
            std::option::Option::Some(crate::model::gce_setup::Image::ContainerImage(v.into()));
        self
    }
}

impl wkt::message::Message for GceSetup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GceSetup"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GceSetup {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __machine_type,
            __accelerator_configs,
            __service_accounts,
            __vm_image,
            __container_image,
            __boot_disk,
            __data_disks,
            __shielded_instance_config,
            __network_interfaces,
            __disable_public_ip,
            __tags,
            __metadata,
            __enable_ip_forwarding,
            __gpu_driver_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GceSetup")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "machineType" => Ok(__FieldTag::__machine_type),
                            "machine_type" => Ok(__FieldTag::__machine_type),
                            "acceleratorConfigs" => Ok(__FieldTag::__accelerator_configs),
                            "accelerator_configs" => Ok(__FieldTag::__accelerator_configs),
                            "serviceAccounts" => Ok(__FieldTag::__service_accounts),
                            "service_accounts" => Ok(__FieldTag::__service_accounts),
                            "vmImage" => Ok(__FieldTag::__vm_image),
                            "vm_image" => Ok(__FieldTag::__vm_image),
                            "containerImage" => Ok(__FieldTag::__container_image),
                            "container_image" => Ok(__FieldTag::__container_image),
                            "bootDisk" => Ok(__FieldTag::__boot_disk),
                            "boot_disk" => Ok(__FieldTag::__boot_disk),
                            "dataDisks" => Ok(__FieldTag::__data_disks),
                            "data_disks" => Ok(__FieldTag::__data_disks),
                            "shieldedInstanceConfig" => Ok(__FieldTag::__shielded_instance_config),
                            "shielded_instance_config" => {
                                Ok(__FieldTag::__shielded_instance_config)
                            }
                            "networkInterfaces" => Ok(__FieldTag::__network_interfaces),
                            "network_interfaces" => Ok(__FieldTag::__network_interfaces),
                            "disablePublicIp" => Ok(__FieldTag::__disable_public_ip),
                            "disable_public_ip" => Ok(__FieldTag::__disable_public_ip),
                            "tags" => Ok(__FieldTag::__tags),
                            "metadata" => Ok(__FieldTag::__metadata),
                            "enableIpForwarding" => Ok(__FieldTag::__enable_ip_forwarding),
                            "enable_ip_forwarding" => Ok(__FieldTag::__enable_ip_forwarding),
                            "gpuDriverConfig" => Ok(__FieldTag::__gpu_driver_config),
                            "gpu_driver_config" => Ok(__FieldTag::__gpu_driver_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GceSetup;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GceSetup")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__machine_type => {
                            if !fields.insert(__FieldTag::__machine_type) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for machine_type",
                                ));
                            }
                            result.machine_type = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__accelerator_configs => {
                            if !fields.insert(__FieldTag::__accelerator_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for accelerator_configs",
                                ));
                            }
                            result.accelerator_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::AcceleratorConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_accounts => {
                            if !fields.insert(__FieldTag::__service_accounts) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_accounts",
                                ));
                            }
                            result.service_accounts =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::ServiceAccount>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_image => {
                            if !fields.insert(__FieldTag::__vm_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_image",
                                ));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.notebooks.v2.GceSetup.vm_image, latest field was vmImage",
                                ));
                            }
                            result.image =
                                std::option::Option::Some(
                                    crate::model::gce_setup::Image::VmImage(
                                        map.next_value::<std::option::Option<
                                            std::boxed::Box<crate::model::VmImage>,
                                        >>()?
                                        .unwrap_or_default(),
                                    ),
                                );
                        }
                        __FieldTag::__container_image => {
                            if !fields.insert(__FieldTag::__container_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image",
                                ));
                            }
                            if result.image.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `image`, a oneof with full ID .google.cloud.notebooks.v2.GceSetup.container_image, latest field was containerImage",
                                ));
                            }
                            result.image = std::option::Option::Some(
                                crate::model::gce_setup::Image::ContainerImage(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::ContainerImage>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__boot_disk => {
                            if !fields.insert(__FieldTag::__boot_disk) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for boot_disk",
                                ));
                            }
                            result.boot_disk =
                                map.next_value::<std::option::Option<crate::model::BootDisk>>()?;
                        }
                        __FieldTag::__data_disks => {
                            if !fields.insert(__FieldTag::__data_disks) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_disks",
                                ));
                            }
                            result.data_disks = map.next_value::<std::option::Option<std::vec::Vec<crate::model::DataDisk>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__shielded_instance_config => {
                            if !fields.insert(__FieldTag::__shielded_instance_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for shielded_instance_config",
                                ));
                            }
                            result.shielded_instance_config = map.next_value::<std::option::Option<crate::model::ShieldedInstanceConfig>>()?
                                ;
                        }
                        __FieldTag::__network_interfaces => {
                            if !fields.insert(__FieldTag::__network_interfaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for network_interfaces",
                                ));
                            }
                            result.network_interfaces =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::NetworkInterface>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disable_public_ip => {
                            if !fields.insert(__FieldTag::__disable_public_ip) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_public_ip",
                                ));
                            }
                            result.disable_public_ip = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__tags => {
                            if !fields.insert(__FieldTag::__tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for tags",
                                ));
                            }
                            result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__metadata => {
                            if !fields.insert(__FieldTag::__metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for metadata",
                                ));
                            }
                            result.metadata = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__enable_ip_forwarding => {
                            if !fields.insert(__FieldTag::__enable_ip_forwarding) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for enable_ip_forwarding",
                                ));
                            }
                            result.enable_ip_forwarding = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gpu_driver_config => {
                            if !fields.insert(__FieldTag::__gpu_driver_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gpu_driver_config",
                                ));
                            }
                            result.gpu_driver_config = map
                                .next_value::<std::option::Option<crate::model::GPUDriverConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GceSetup {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.machine_type.is_empty() {
            state.serialize_entry("machineType", &self.machine_type)?;
        }
        if !self.accelerator_configs.is_empty() {
            state.serialize_entry("acceleratorConfigs", &self.accelerator_configs)?;
        }
        if !self.service_accounts.is_empty() {
            state.serialize_entry("serviceAccounts", &self.service_accounts)?;
        }
        if let Some(value) = self.vm_image() {
            state.serialize_entry("vmImage", value)?;
        }
        if let Some(value) = self.container_image() {
            state.serialize_entry("containerImage", value)?;
        }
        if self.boot_disk.is_some() {
            state.serialize_entry("bootDisk", &self.boot_disk)?;
        }
        if !self.data_disks.is_empty() {
            state.serialize_entry("dataDisks", &self.data_disks)?;
        }
        if self.shielded_instance_config.is_some() {
            state.serialize_entry("shieldedInstanceConfig", &self.shielded_instance_config)?;
        }
        if !self.network_interfaces.is_empty() {
            state.serialize_entry("networkInterfaces", &self.network_interfaces)?;
        }
        if !wkt::internal::is_default(&self.disable_public_ip) {
            state.serialize_entry("disablePublicIp", &self.disable_public_ip)?;
        }
        if !self.tags.is_empty() {
            state.serialize_entry("tags", &self.tags)?;
        }
        if !self.metadata.is_empty() {
            state.serialize_entry("metadata", &self.metadata)?;
        }
        if !wkt::internal::is_default(&self.enable_ip_forwarding) {
            state.serialize_entry("enableIpForwarding", &self.enable_ip_forwarding)?;
        }
        if self.gpu_driver_config.is_some() {
            state.serialize_entry("gpuDriverConfig", &self.gpu_driver_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [GceSetup].
pub mod gce_setup {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the image; can be one of VM image, or container image.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Image {
        /// Optional. Use a Compute Engine VM image to start the notebook instance.
        VmImage(std::boxed::Box<crate::model::VmImage>),
        /// Optional. Use a container image to start the notebook instance.
        ContainerImage(std::boxed::Box<crate::model::ContainerImage>),
    }
}

/// The entry of VM image upgrade history.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeHistoryEntry {
    /// Optional. The snapshot of the boot disk of this notebook instance before
    /// upgrade.
    pub snapshot: std::string::String,

    /// Optional. The VM image before this instance upgrade.
    pub vm_image: std::string::String,

    /// Optional. The container image before this instance upgrade.
    pub container_image: std::string::String,

    /// Optional. The framework of this notebook instance.
    pub framework: std::string::String,

    /// Optional. The version of the notebook instance before this upgrade.
    pub version: std::string::String,

    /// Output only. The state of this instance upgrade history entry.
    pub state: crate::model::upgrade_history_entry::State,

    /// Immutable. The time that this instance upgrade history entry is created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Action. Rolloback or Upgrade.
    pub action: crate::model::upgrade_history_entry::Action,

    /// Optional. Target VM Version, like m63.
    pub target_version: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeHistoryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::UpgradeHistoryEntry::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }

    /// Sets the value of [vm_image][crate::model::UpgradeHistoryEntry::vm_image].
    pub fn set_vm_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_image = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::UpgradeHistoryEntry::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [framework][crate::model::UpgradeHistoryEntry::framework].
    pub fn set_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.framework = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeHistoryEntry::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeHistoryEntry::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_history_entry::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UpgradeHistoryEntry::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::UpgradeHistoryEntry::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action][crate::model::UpgradeHistoryEntry::action].
    pub fn set_action<T: std::convert::Into<crate::model::upgrade_history_entry::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeHistoryEntry::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeHistoryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpgradeHistoryEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeHistoryEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __snapshot,
            __vm_image,
            __container_image,
            __framework,
            __version,
            __state,
            __create_time,
            __action,
            __target_version,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeHistoryEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "snapshot" => Ok(__FieldTag::__snapshot),
                            "vmImage" => Ok(__FieldTag::__vm_image),
                            "vm_image" => Ok(__FieldTag::__vm_image),
                            "containerImage" => Ok(__FieldTag::__container_image),
                            "container_image" => Ok(__FieldTag::__container_image),
                            "framework" => Ok(__FieldTag::__framework),
                            "version" => Ok(__FieldTag::__version),
                            "state" => Ok(__FieldTag::__state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "action" => Ok(__FieldTag::__action),
                            "targetVersion" => Ok(__FieldTag::__target_version),
                            "target_version" => Ok(__FieldTag::__target_version),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeHistoryEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeHistoryEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__snapshot => {
                            if !fields.insert(__FieldTag::__snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for snapshot",
                                ));
                            }
                            result.snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vm_image => {
                            if !fields.insert(__FieldTag::__vm_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vm_image",
                                ));
                            }
                            result.vm_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__container_image => {
                            if !fields.insert(__FieldTag::__container_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for container_image",
                                ));
                            }
                            result.container_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__framework => {
                            if !fields.insert(__FieldTag::__framework) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for framework",
                                ));
                            }
                            result.framework = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__version => {
                            if !fields.insert(__FieldTag::__version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for version",
                                ));
                            }
                            result.version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::upgrade_history_entry::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__action => {
                            if !fields.insert(__FieldTag::__action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for action",
                                ));
                            }
                            result.action =
                                map.next_value::<std::option::Option<
                                    crate::model::upgrade_history_entry::Action,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_version => {
                            if !fields.insert(__FieldTag::__target_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_version",
                                ));
                            }
                            result.target_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeHistoryEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.snapshot.is_empty() {
            state.serialize_entry("snapshot", &self.snapshot)?;
        }
        if !self.vm_image.is_empty() {
            state.serialize_entry("vmImage", &self.vm_image)?;
        }
        if !self.container_image.is_empty() {
            state.serialize_entry("containerImage", &self.container_image)?;
        }
        if !self.framework.is_empty() {
            state.serialize_entry("framework", &self.framework)?;
        }
        if !self.version.is_empty() {
            state.serialize_entry("version", &self.version)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !wkt::internal::is_default(&self.action) {
            state.serialize_entry("action", &self.action)?;
        }
        if !self.target_version.is_empty() {
            state.serialize_entry("targetVersion", &self.target_version)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [UpgradeHistoryEntry].
pub mod upgrade_history_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the states of this upgrade history entry.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// State is not specified.
        Unspecified,
        /// The instance upgrade is started.
        Started,
        /// The instance upgrade is succeeded.
        Succeeded,
        /// The instance upgrade is failed.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Started => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Failed => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Started => std::option::Option::Some("STARTED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Started,
                2 => Self::Succeeded,
                3 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "STARTED" => Self::Started,
                "SUCCEEDED" => Self::Succeeded,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Started => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Failed => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.notebooks.v2.UpgradeHistoryEntry.State",
            ))
        }
    }

    /// The definition of operations of this upgrade history entry.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Operation is not specified.
        Unspecified,
        /// Upgrade.
        Upgrade,
        /// Rollback.
        Rollback,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Action::value] or
        /// [Action::name].
        UnknownValue(action::UnknownValue),
    }

    #[doc(hidden)]
    pub mod action {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Action {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Upgrade => std::option::Option::Some(1),
                Self::Rollback => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("ACTION_UNSPECIFIED"),
                Self::Upgrade => std::option::Option::Some("UPGRADE"),
                Self::Rollback => std::option::Option::Some("ROLLBACK"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Action {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Upgrade,
                2 => Self::Rollback,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Action {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "ACTION_UNSPECIFIED" => Self::Unspecified,
                "UPGRADE" => Self::Upgrade,
                "ROLLBACK" => Self::Rollback,
                _ => Self::UnknownValue(action::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Upgrade => serializer.serialize_i32(1),
                Self::Rollback => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Action>::new(
                ".google.cloud.notebooks.v2.UpgradeHistoryEntry.Action",
            ))
        }
    }
}

/// The definition of a notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The name of this notebook instance. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    /// Output only. The proxy endpoint that is used to access the Jupyter
    /// notebook.
    pub proxy_uri: std::string::String,

    /// Optional. Input only. The owner of this instance after creation. Format:
    /// `alias@example.com`
    ///
    /// Currently supports one owner only. If not specified, all of the service
    /// account users of your VM instance's service account can use
    /// the instance.
    pub instance_owners: std::vec::Vec<std::string::String>,

    /// Output only. Email address of entity that sent original CreateInstance
    /// request.
    pub creator: std::string::String,

    /// Output only. The state of this instance.
    pub state: crate::model::State,

    /// Output only. The upgrade history of this instance.
    pub upgrade_history: std::vec::Vec<crate::model::UpgradeHistoryEntry>,

    /// Output only. Unique ID of the resource.
    pub id: std::string::String,

    /// Output only. Instance health_state.
    pub health_state: crate::model::HealthState,

    /// Output only. Additional information about instance health.
    /// Example:
    ///
    /// ```norust
    /// healthInfo": {
    ///   "docker_proxy_agent_status": "1",
    ///   "docker_status": "1",
    ///   "jupyterlab_api_status": "-1",
    ///   "jupyterlab_status": "-1",
    ///   "updated": "2020-10-18 09:40:03.573409"
    /// }
    /// ```
    pub health_info: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Instance creation time.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instance update time.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. If true, the notebook instance will not register with the proxy.
    pub disable_proxy_access: bool,

    /// Optional. Labels to apply to this instance.
    /// These can be later modified by the UpdateInstance method.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Setup for the Notebook instance.
    pub infrastructure: std::option::Option<crate::model::instance::Infrastructure>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [proxy_uri][crate::model::Instance::proxy_uri].
    pub fn set_proxy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_uri = v.into();
        self
    }

    /// Sets the value of [instance_owners][crate::model::Instance::instance_owners].
    pub fn set_instance_owners<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_owners = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [creator][crate::model::Instance::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [upgrade_history][crate::model::Instance::upgrade_history].
    pub fn set_upgrade_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeHistoryEntry>,
    {
        use std::iter::Iterator;
        self.upgrade_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [health_state][crate::model::Instance::health_state].
    pub fn set_health_state<T: std::convert::Into<crate::model::HealthState>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_state = v.into();
        self
    }

    /// Sets the value of [health_info][crate::model::Instance::health_info].
    pub fn set_health_info<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_info = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Instance::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Instance::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disable_proxy_access][crate::model::Instance::disable_proxy_access].
    pub fn set_disable_proxy_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_proxy_access = v.into();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [infrastructure][crate::model::Instance::infrastructure].
    ///
    /// Note that all the setters affecting `infrastructure` are mutually
    /// exclusive.
    pub fn set_infrastructure<
        T: std::convert::Into<std::option::Option<crate::model::instance::Infrastructure>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure = v.into();
        self
    }

    /// The value of [infrastructure][crate::model::Instance::infrastructure]
    /// if it holds a `GceSetup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gce_setup(&self) -> std::option::Option<&std::boxed::Box<crate::model::GceSetup>> {
        #[allow(unreachable_patterns)]
        self.infrastructure.as_ref().and_then(|v| match v {
            crate::model::instance::Infrastructure::GceSetup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [infrastructure][crate::model::Instance::infrastructure]
    /// to hold a `GceSetup`.
    ///
    /// Note that all the setters affecting `infrastructure` are
    /// mutually exclusive.
    pub fn set_gce_setup<T: std::convert::Into<std::boxed::Box<crate::model::GceSetup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure =
            std::option::Option::Some(crate::model::instance::Infrastructure::GceSetup(v.into()));
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.Instance"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Instance {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __gce_setup,
            __proxy_uri,
            __instance_owners,
            __creator,
            __state,
            __upgrade_history,
            __id,
            __health_state,
            __health_info,
            __create_time,
            __update_time,
            __disable_proxy_access,
            __labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Instance")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "gceSetup" => Ok(__FieldTag::__gce_setup),
                            "gce_setup" => Ok(__FieldTag::__gce_setup),
                            "proxyUri" => Ok(__FieldTag::__proxy_uri),
                            "proxy_uri" => Ok(__FieldTag::__proxy_uri),
                            "instanceOwners" => Ok(__FieldTag::__instance_owners),
                            "instance_owners" => Ok(__FieldTag::__instance_owners),
                            "creator" => Ok(__FieldTag::__creator),
                            "state" => Ok(__FieldTag::__state),
                            "upgradeHistory" => Ok(__FieldTag::__upgrade_history),
                            "upgrade_history" => Ok(__FieldTag::__upgrade_history),
                            "id" => Ok(__FieldTag::__id),
                            "healthState" => Ok(__FieldTag::__health_state),
                            "health_state" => Ok(__FieldTag::__health_state),
                            "healthInfo" => Ok(__FieldTag::__health_info),
                            "health_info" => Ok(__FieldTag::__health_info),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "disableProxyAccess" => Ok(__FieldTag::__disable_proxy_access),
                            "disable_proxy_access" => Ok(__FieldTag::__disable_proxy_access),
                            "labels" => Ok(__FieldTag::__labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Instance;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Instance")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__gce_setup => {
                            if !fields.insert(__FieldTag::__gce_setup) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gce_setup",
                                ));
                            }
                            if result.infrastructure.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `infrastructure`, a oneof with full ID .google.cloud.notebooks.v2.Instance.gce_setup, latest field was gceSetup",
                                ));
                            }
                            result.infrastructure = std::option::Option::Some(
                                crate::model::instance::Infrastructure::GceSetup(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::GceSetup>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__proxy_uri => {
                            if !fields.insert(__FieldTag::__proxy_uri) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for proxy_uri",
                                ));
                            }
                            result.proxy_uri = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_owners => {
                            if !fields.insert(__FieldTag::__instance_owners) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_owners",
                                ));
                            }
                            result.instance_owners = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__creator => {
                            if !fields.insert(__FieldTag::__creator) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for creator",
                                ));
                            }
                            result.creator = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<crate::model::State>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_history => {
                            if !fields.insert(__FieldTag::__upgrade_history) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_history",
                                ));
                            }
                            result.upgrade_history = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::UpgradeHistoryEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__id => {
                            if !fields.insert(__FieldTag::__id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for id",
                                ));
                            }
                            result.id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_state => {
                            if !fields.insert(__FieldTag::__health_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_state",
                                ));
                            }
                            result.health_state = map
                                .next_value::<std::option::Option<crate::model::HealthState>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__health_info => {
                            if !fields.insert(__FieldTag::__health_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for health_info",
                                ));
                            }
                            result.health_info = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__disable_proxy_access => {
                            if !fields.insert(__FieldTag::__disable_proxy_access) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disable_proxy_access",
                                ));
                            }
                            result.disable_proxy_access = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Instance {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if let Some(value) = self.gce_setup() {
            state.serialize_entry("gceSetup", value)?;
        }
        if !self.proxy_uri.is_empty() {
            state.serialize_entry("proxyUri", &self.proxy_uri)?;
        }
        if !self.instance_owners.is_empty() {
            state.serialize_entry("instanceOwners", &self.instance_owners)?;
        }
        if !self.creator.is_empty() {
            state.serialize_entry("creator", &self.creator)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.upgrade_history.is_empty() {
            state.serialize_entry("upgradeHistory", &self.upgrade_history)?;
        }
        if !self.id.is_empty() {
            state.serialize_entry("id", &self.id)?;
        }
        if !wkt::internal::is_default(&self.health_state) {
            state.serialize_entry("healthState", &self.health_state)?;
        }
        if !self.health_info.is_empty() {
            state.serialize_entry("healthInfo", &self.health_info)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if !wkt::internal::is_default(&self.disable_proxy_access) {
            state.serialize_entry("disableProxyAccess", &self.disable_proxy_access)?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Instance].
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Setup for the Notebook instance.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Infrastructure {
        /// Optional. Compute Engine setup for the notebook. Uses notebook-defined
        /// fields.
        GceSetup(std::boxed::Box<crate::model::GceSetup>),
    }
}

/// Represents the metadata of the long-running operation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    pub api_version: std::string::String,

    /// API endpoint name of this operation.
    pub endpoint: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::OperationMetadata::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.OperationMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for OperationMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __create_time,
            __end_time,
            __target,
            __verb,
            __status_message,
            __requested_cancellation,
            __api_version,
            __endpoint,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for OperationMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "endTime" => Ok(__FieldTag::__end_time),
                            "end_time" => Ok(__FieldTag::__end_time),
                            "target" => Ok(__FieldTag::__target),
                            "verb" => Ok(__FieldTag::__verb),
                            "statusMessage" => Ok(__FieldTag::__status_message),
                            "status_message" => Ok(__FieldTag::__status_message),
                            "requestedCancellation" => Ok(__FieldTag::__requested_cancellation),
                            "requested_cancellation" => Ok(__FieldTag::__requested_cancellation),
                            "apiVersion" => Ok(__FieldTag::__api_version),
                            "api_version" => Ok(__FieldTag::__api_version),
                            "endpoint" => Ok(__FieldTag::__endpoint),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = OperationMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct OperationMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__end_time => {
                            if !fields.insert(__FieldTag::__end_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for end_time",
                                ));
                            }
                            result.end_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__verb => {
                            if !fields.insert(__FieldTag::__verb) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for verb",
                                ));
                            }
                            result.verb = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__status_message => {
                            if !fields.insert(__FieldTag::__status_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for status_message",
                                ));
                            }
                            result.status_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__requested_cancellation => {
                            if !fields.insert(__FieldTag::__requested_cancellation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for requested_cancellation",
                                ));
                            }
                            result.requested_cancellation = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__api_version => {
                            if !fields.insert(__FieldTag::__api_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for api_version",
                                ));
                            }
                            result.api_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__endpoint => {
                            if !fields.insert(__FieldTag::__endpoint) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for endpoint",
                                ));
                            }
                            result.endpoint = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for OperationMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.end_time.is_some() {
            state.serialize_entry("endTime", &self.end_time)?;
        }
        if !self.target.is_empty() {
            state.serialize_entry("target", &self.target)?;
        }
        if !self.verb.is_empty() {
            state.serialize_entry("verb", &self.verb)?;
        }
        if !self.status_message.is_empty() {
            state.serialize_entry("statusMessage", &self.status_message)?;
        }
        if !wkt::internal::is_default(&self.requested_cancellation) {
            state.serialize_entry("requestedCancellation", &self.requested_cancellation)?;
        }
        if !self.api_version.is_empty() {
            state.serialize_entry("apiVersion", &self.api_version)?;
        }
        if !self.endpoint.is_empty() {
            state.serialize_entry("endpoint", &self.endpoint)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for listing notebook instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. Format:
    /// `parent=projects/{project_id}/locations/{location}`
    pub parent: std::string::String,

    /// Optional. Maximum return size of the list call.
    pub page_size: i32,

    /// Optional. A previous returned page token that can be used to continue
    /// listing from the last result.
    pub page_token: std::string::String,

    /// Optional. Sort results. Supported values are "name", "name desc" or ""
    /// (unsorted).
    pub order_by: std::string::String,

    /// Optional. List filter.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ListInstancesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for listing notebook instances.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// A list of returned instances.
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Page token that can be used to continue listing from the last result in the
    /// next list call.
    pub next_page_token: std::string::String,

    /// Locations that could not be reached. For example,
    /// ['us-west1-a', 'us-central1-b'].
    /// A ListInstancesResponse will only contain either instances or unreachables,
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ListInstancesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListInstancesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instances,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListInstancesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instances" => Ok(__FieldTag::__instances),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListInstancesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListInstancesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instances => {
                            if !fields.insert(__FieldTag::__instances) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instances",
                                ));
                            }
                            result.instances = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Instance>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListInstancesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.instances.is_empty() {
            state.serialize_entry("instances", &self.instances)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for getting a notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for creating a notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. Format:
    /// `parent=projects/{project_id}/locations/{location}`
    pub parent: std::string::String,

    /// Required. User-defined unique ID of this instance.
    pub instance_id: std::string::String,

    /// Required. The instance to be created.
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CreateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __instance_id,
            __instance,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "instanceId" => Ok(__FieldTag::__instance_id),
                            "instance_id" => Ok(__FieldTag::__instance_id),
                            "instance" => Ok(__FieldTag::__instance),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance_id => {
                            if !fields.insert(__FieldTag::__instance_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance_id",
                                ));
                            }
                            result.instance_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !self.instance_id.is_empty() {
            state.serialize_entry("instanceId", &self.instance_id)?;
        }
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for updating a notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. A representation of an instance.
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. Mask used to update an instance
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_or_clear_instance<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Instance>,
    {
        self.instance = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpdateInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __instance,
            __update_mask,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "instance" => Ok(__FieldTag::__instance),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__instance => {
                            if !fields.insert(__FieldTag::__instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for instance",
                                ));
                            }
                            result.instance =
                                map.next_value::<std::option::Option<crate::model::Instance>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.instance.is_some() {
            state.serialize_entry("instance", &self.instance)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for deleting a notebook instance.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    /// Optional. Idempotent request UUID.
    pub request_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DeleteInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __request_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "requestId" => Ok(__FieldTag::__request_id),
                            "request_id" => Ok(__FieldTag::__request_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__request_id => {
                            if !fields.insert(__FieldTag::__request_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for request_id",
                                ));
                            }
                            result.request_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.request_id.is_empty() {
            state.serialize_entry("requestId", &self.request_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for starting a notebook instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StartInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.StartInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StartInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StartInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StartInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StartInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StartInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for stopping a notebook instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct StopInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl StopInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.StopInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for StopInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for StopInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = StopInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct StopInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for StopInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for resetting a notebook instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ResetInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for checking if a notebook instance is upgradeable.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckInstanceUpgradabilityRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub notebook_instance: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckInstanceUpgradabilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_instance][crate::model::CheckInstanceUpgradabilityRequest::notebook_instance].
    pub fn set_notebook_instance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_instance = v.into();
        self
    }
}

impl wkt::message::Message for CheckInstanceUpgradabilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CheckInstanceUpgradabilityRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckInstanceUpgradabilityRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __notebook_instance,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckInstanceUpgradabilityRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "notebookInstance" => Ok(__FieldTag::__notebook_instance),
                            "notebook_instance" => Ok(__FieldTag::__notebook_instance),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckInstanceUpgradabilityRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckInstanceUpgradabilityRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__notebook_instance => {
                            if !fields.insert(__FieldTag::__notebook_instance) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook_instance",
                                ));
                            }
                            result.notebook_instance = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckInstanceUpgradabilityRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.notebook_instance.is_empty() {
            state.serialize_entry("notebookInstance", &self.notebook_instance)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Response for checking if a notebook instance is upgradeable.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CheckInstanceUpgradabilityResponse {
    /// If an instance is upgradeable.
    pub upgradeable: bool,

    /// The version this instance will be upgraded to if calling the upgrade
    /// endpoint. This field will only be populated if field upgradeable is true.
    pub upgrade_version: std::string::String,

    /// Additional information about upgrade.
    pub upgrade_info: std::string::String,

    /// The new image self link this instance will be upgraded to if calling the
    /// upgrade endpoint. This field will only be populated if field upgradeable
    /// is true.
    pub upgrade_image: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CheckInstanceUpgradabilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upgradeable][crate::model::CheckInstanceUpgradabilityResponse::upgradeable].
    pub fn set_upgradeable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.upgradeable = v.into();
        self
    }

    /// Sets the value of [upgrade_version][crate::model::CheckInstanceUpgradabilityResponse::upgrade_version].
    pub fn set_upgrade_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_version = v.into();
        self
    }

    /// Sets the value of [upgrade_info][crate::model::CheckInstanceUpgradabilityResponse::upgrade_info].
    pub fn set_upgrade_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_info = v.into();
        self
    }

    /// Sets the value of [upgrade_image][crate::model::CheckInstanceUpgradabilityResponse::upgrade_image].
    pub fn set_upgrade_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_image = v.into();
        self
    }
}

impl wkt::message::Message for CheckInstanceUpgradabilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CheckInstanceUpgradabilityResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CheckInstanceUpgradabilityResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __upgradeable,
            __upgrade_version,
            __upgrade_info,
            __upgrade_image,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CheckInstanceUpgradabilityResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "upgradeable" => Ok(__FieldTag::__upgradeable),
                            "upgradeVersion" => Ok(__FieldTag::__upgrade_version),
                            "upgrade_version" => Ok(__FieldTag::__upgrade_version),
                            "upgradeInfo" => Ok(__FieldTag::__upgrade_info),
                            "upgrade_info" => Ok(__FieldTag::__upgrade_info),
                            "upgradeImage" => Ok(__FieldTag::__upgrade_image),
                            "upgrade_image" => Ok(__FieldTag::__upgrade_image),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CheckInstanceUpgradabilityResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CheckInstanceUpgradabilityResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__upgradeable => {
                            if !fields.insert(__FieldTag::__upgradeable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgradeable",
                                ));
                            }
                            result.upgradeable = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_version => {
                            if !fields.insert(__FieldTag::__upgrade_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_version",
                                ));
                            }
                            result.upgrade_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_info => {
                            if !fields.insert(__FieldTag::__upgrade_info) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_info",
                                ));
                            }
                            result.upgrade_info = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__upgrade_image => {
                            if !fields.insert(__FieldTag::__upgrade_image) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for upgrade_image",
                                ));
                            }
                            result.upgrade_image = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CheckInstanceUpgradabilityResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.upgradeable) {
            state.serialize_entry("upgradeable", &self.upgradeable)?;
        }
        if !self.upgrade_version.is_empty() {
            state.serialize_entry("upgradeVersion", &self.upgrade_version)?;
        }
        if !self.upgrade_info.is_empty() {
            state.serialize_entry("upgradeInfo", &self.upgrade_info)?;
        }
        if !self.upgrade_image.is_empty() {
            state.serialize_entry("upgradeImage", &self.upgrade_image)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for upgrading a notebook instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpgradeInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpgradeInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpgradeInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpgradeInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpgradeInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpgradeInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpgradeInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpgradeInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for rollbacking a notebook instance
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RollbackInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    /// Required. The snapshot for rollback.
    /// Example: "projects/test-project/global/snapshots/krwlzipynril".
    pub target_snapshot: std::string::String,

    /// Required. Output only. Revision Id
    pub revision_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RollbackInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_snapshot][crate::model::RollbackInstanceRequest::target_snapshot].
    pub fn set_target_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_snapshot = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackInstanceRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.RollbackInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RollbackInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __target_snapshot,
            __revision_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RollbackInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "targetSnapshot" => Ok(__FieldTag::__target_snapshot),
                            "target_snapshot" => Ok(__FieldTag::__target_snapshot),
                            "revisionId" => Ok(__FieldTag::__revision_id),
                            "revision_id" => Ok(__FieldTag::__revision_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RollbackInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RollbackInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__target_snapshot => {
                            if !fields.insert(__FieldTag::__target_snapshot) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target_snapshot",
                                ));
                            }
                            result.target_snapshot = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision_id => {
                            if !fields.insert(__FieldTag::__revision_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision_id",
                                ));
                            }
                            result.revision_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RollbackInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.target_snapshot.is_empty() {
            state.serialize_entry("targetSnapshot", &self.target_snapshot)?;
        }
        if !self.revision_id.is_empty() {
            state.serialize_entry("revisionId", &self.revision_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Request for creating a notebook instance diagnostic file.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DiagnoseInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    pub name: std::string::String,

    /// Required. Defines flags that are used to run the diagnostic tool
    pub diagnostic_config: std::option::Option<crate::model::DiagnosticConfig>,

    /// Optional. Maxmium amount of time in minutes before the operation times out.
    pub timeout_minutes: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DiagnoseInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiagnoseInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [diagnostic_config][crate::model::DiagnoseInstanceRequest::diagnostic_config].
    pub fn set_diagnostic_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DiagnosticConfig>,
    {
        self.diagnostic_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [diagnostic_config][crate::model::DiagnoseInstanceRequest::diagnostic_config].
    pub fn set_or_clear_diagnostic_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DiagnosticConfig>,
    {
        self.diagnostic_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [timeout_minutes][crate::model::DiagnoseInstanceRequest::timeout_minutes].
    pub fn set_timeout_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_minutes = v.into();
        self
    }
}

impl wkt::message::Message for DiagnoseInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DiagnoseInstanceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DiagnoseInstanceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __diagnostic_config,
            __timeout_minutes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DiagnoseInstanceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "diagnosticConfig" => Ok(__FieldTag::__diagnostic_config),
                            "diagnostic_config" => Ok(__FieldTag::__diagnostic_config),
                            "timeoutMinutes" => Ok(__FieldTag::__timeout_minutes),
                            "timeout_minutes" => Ok(__FieldTag::__timeout_minutes),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DiagnoseInstanceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DiagnoseInstanceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__diagnostic_config => {
                            if !fields.insert(__FieldTag::__diagnostic_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for diagnostic_config",
                                ));
                            }
                            result.diagnostic_config = map
                                .next_value::<std::option::Option<crate::model::DiagnosticConfig>>(
                                )?;
                        }
                        __FieldTag::__timeout_minutes => {
                            if !fields.insert(__FieldTag::__timeout_minutes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for timeout_minutes",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.timeout_minutes =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DiagnoseInstanceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.diagnostic_config.is_some() {
            state.serialize_entry("diagnosticConfig", &self.diagnostic_config)?;
        }
        if !wkt::internal::is_default(&self.timeout_minutes) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("timeoutMinutes", &__With(&self.timeout_minutes))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Definition of the disk encryption options.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DiskEncryption {
    /// Disk encryption is not specified.
    Unspecified,
    /// Use Google managed encryption keys to encrypt the boot disk.
    Gmek,
    /// Use customer managed encryption keys to encrypt the boot disk.
    Cmek,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DiskEncryption::value] or
    /// [DiskEncryption::name].
    UnknownValue(disk_encryption::UnknownValue),
}

#[doc(hidden)]
pub mod disk_encryption {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DiskEncryption {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Gmek => std::option::Option::Some(1),
            Self::Cmek => std::option::Option::Some(2),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DISK_ENCRYPTION_UNSPECIFIED"),
            Self::Gmek => std::option::Option::Some("GMEK"),
            Self::Cmek => std::option::Option::Some("CMEK"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DiskEncryption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DiskEncryption {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DiskEncryption {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Gmek,
            2 => Self::Cmek,
            _ => Self::UnknownValue(disk_encryption::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DiskEncryption {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DISK_ENCRYPTION_UNSPECIFIED" => Self::Unspecified,
            "GMEK" => Self::Gmek,
            "CMEK" => Self::Cmek,
            _ => Self::UnknownValue(disk_encryption::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DiskEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Gmek => serializer.serialize_i32(1),
            Self::Cmek => serializer.serialize_i32(2),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DiskEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskEncryption>::new(
            ".google.cloud.notebooks.v2.DiskEncryption",
        ))
    }
}

/// Possible disk types.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum DiskType {
    /// Disk type not set.
    Unspecified,
    /// Standard persistent disk type.
    PdStandard,
    /// SSD persistent disk type.
    PdSsd,
    /// Balanced persistent disk type.
    PdBalanced,
    /// Extreme persistent disk type.
    PdExtreme,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [DiskType::value] or
    /// [DiskType::name].
    UnknownValue(disk_type::UnknownValue),
}

#[doc(hidden)]
pub mod disk_type {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl DiskType {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::PdStandard => std::option::Option::Some(1),
            Self::PdSsd => std::option::Option::Some(2),
            Self::PdBalanced => std::option::Option::Some(3),
            Self::PdExtreme => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("DISK_TYPE_UNSPECIFIED"),
            Self::PdStandard => std::option::Option::Some("PD_STANDARD"),
            Self::PdSsd => std::option::Option::Some("PD_SSD"),
            Self::PdBalanced => std::option::Option::Some("PD_BALANCED"),
            Self::PdExtreme => std::option::Option::Some("PD_EXTREME"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for DiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for DiskType {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for DiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::PdStandard,
            2 => Self::PdSsd,
            3 => Self::PdBalanced,
            4 => Self::PdExtreme,
            _ => Self::UnknownValue(disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for DiskType {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "DISK_TYPE_UNSPECIFIED" => Self::Unspecified,
            "PD_STANDARD" => Self::PdStandard,
            "PD_SSD" => Self::PdSsd,
            "PD_BALANCED" => Self::PdBalanced,
            "PD_EXTREME" => Self::PdExtreme,
            _ => Self::UnknownValue(disk_type::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for DiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::PdStandard => serializer.serialize_i32(1),
            Self::PdSsd => serializer.serialize_i32(2),
            Self::PdBalanced => serializer.serialize_i32(3),
            Self::PdExtreme => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for DiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<DiskType>::new(
            ".google.cloud.notebooks.v2.DiskType",
        ))
    }
}

/// The definition of the states of this instance.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum State {
    /// State is not specified.
    Unspecified,
    /// The control logic is starting the instance.
    Starting,
    /// The control logic is installing required frameworks and registering the
    /// instance with notebook proxy
    Provisioning,
    /// The instance is running.
    Active,
    /// The control logic is stopping the instance.
    Stopping,
    /// The instance is stopped.
    Stopped,
    /// The instance is deleted.
    Deleted,
    /// The instance is upgrading.
    Upgrading,
    /// The instance is being created.
    Initializing,
    /// The instance is suspending.
    Suspending,
    /// The instance is suspended.
    Suspended,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [State::value] or
    /// [State::name].
    UnknownValue(state::UnknownValue),
}

#[doc(hidden)]
pub mod state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl State {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Starting => std::option::Option::Some(1),
            Self::Provisioning => std::option::Option::Some(2),
            Self::Active => std::option::Option::Some(3),
            Self::Stopping => std::option::Option::Some(4),
            Self::Stopped => std::option::Option::Some(5),
            Self::Deleted => std::option::Option::Some(6),
            Self::Upgrading => std::option::Option::Some(7),
            Self::Initializing => std::option::Option::Some(8),
            Self::Suspending => std::option::Option::Some(9),
            Self::Suspended => std::option::Option::Some(10),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
            Self::Starting => std::option::Option::Some("STARTING"),
            Self::Provisioning => std::option::Option::Some("PROVISIONING"),
            Self::Active => std::option::Option::Some("ACTIVE"),
            Self::Stopping => std::option::Option::Some("STOPPING"),
            Self::Stopped => std::option::Option::Some("STOPPED"),
            Self::Deleted => std::option::Option::Some("DELETED"),
            Self::Upgrading => std::option::Option::Some("UPGRADING"),
            Self::Initializing => std::option::Option::Some("INITIALIZING"),
            Self::Suspending => std::option::Option::Some("SUSPENDING"),
            Self::Suspended => std::option::Option::Some("SUSPENDED"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for State {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Starting,
            2 => Self::Provisioning,
            3 => Self::Active,
            4 => Self::Stopping,
            5 => Self::Stopped,
            6 => Self::Deleted,
            7 => Self::Upgrading,
            8 => Self::Initializing,
            9 => Self::Suspending,
            10 => Self::Suspended,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for State {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "STATE_UNSPECIFIED" => Self::Unspecified,
            "STARTING" => Self::Starting,
            "PROVISIONING" => Self::Provisioning,
            "ACTIVE" => Self::Active,
            "STOPPING" => Self::Stopping,
            "STOPPED" => Self::Stopped,
            "DELETED" => Self::Deleted,
            "UPGRADING" => Self::Upgrading,
            "INITIALIZING" => Self::Initializing,
            "SUSPENDING" => Self::Suspending,
            "SUSPENDED" => Self::Suspended,
            _ => Self::UnknownValue(state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Starting => serializer.serialize_i32(1),
            Self::Provisioning => serializer.serialize_i32(2),
            Self::Active => serializer.serialize_i32(3),
            Self::Stopping => serializer.serialize_i32(4),
            Self::Stopped => serializer.serialize_i32(5),
            Self::Deleted => serializer.serialize_i32(6),
            Self::Upgrading => serializer.serialize_i32(7),
            Self::Initializing => serializer.serialize_i32(8),
            Self::Suspending => serializer.serialize_i32(9),
            Self::Suspended => serializer.serialize_i32(10),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
            ".google.cloud.notebooks.v2.State",
        ))
    }
}

/// The instance health state.
///
/// # Working with unknown values
///
/// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
/// additional enum variants at any time. Adding new variants is not considered
/// a breaking change. Applications should write their code in anticipation of:
///
/// - New values appearing in future releases of the client library, **and**
/// - New values received dynamically, without application changes.
///
/// Please consult the [Working with enums] section in the user guide for some
/// guidelines.
///
/// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
#[derive(Clone, Debug, PartialEq)]
#[non_exhaustive]
pub enum HealthState {
    /// The instance substate is unknown.
    Unspecified,
    /// The instance is known to be in an healthy state
    /// (for example, critical daemons are running)
    /// Applies to ACTIVE state.
    Healthy,
    /// The instance is known to be in an unhealthy state
    /// (for example, critical daemons are not running)
    /// Applies to ACTIVE state.
    Unhealthy,
    /// The instance has not installed health monitoring agent.
    /// Applies to ACTIVE state.
    AgentNotInstalled,
    /// The instance health monitoring agent is not running.
    /// Applies to ACTIVE state.
    AgentNotRunning,
    /// If set, the enum was initialized with an unknown value.
    ///
    /// Applications can examine the value using [HealthState::value] or
    /// [HealthState::name].
    UnknownValue(health_state::UnknownValue),
}

#[doc(hidden)]
pub mod health_state {
    #[allow(unused_imports)]
    use super::*;
    #[derive(Clone, Debug, PartialEq)]
    pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
}

impl HealthState {
    /// Gets the enum value.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the string representation of enums.
    pub fn value(&self) -> std::option::Option<i32> {
        match self {
            Self::Unspecified => std::option::Option::Some(0),
            Self::Healthy => std::option::Option::Some(1),
            Self::Unhealthy => std::option::Option::Some(2),
            Self::AgentNotInstalled => std::option::Option::Some(3),
            Self::AgentNotRunning => std::option::Option::Some(4),
            Self::UnknownValue(u) => u.0.value(),
        }
    }

    /// Gets the enum value as a string.
    ///
    /// Returns `None` if the enum contains an unknown value deserialized from
    /// the integer representation of enums.
    pub fn name(&self) -> std::option::Option<&str> {
        match self {
            Self::Unspecified => std::option::Option::Some("HEALTH_STATE_UNSPECIFIED"),
            Self::Healthy => std::option::Option::Some("HEALTHY"),
            Self::Unhealthy => std::option::Option::Some("UNHEALTHY"),
            Self::AgentNotInstalled => std::option::Option::Some("AGENT_NOT_INSTALLED"),
            Self::AgentNotRunning => std::option::Option::Some("AGENT_NOT_RUNNING"),
            Self::UnknownValue(u) => u.0.name(),
        }
    }
}

impl std::default::Default for HealthState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0)
    }
}

impl std::fmt::Display for HealthState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
        wkt::internal::display_enum(f, self.name(), self.value())
    }
}

impl std::convert::From<i32> for HealthState {
    fn from(value: i32) -> Self {
        match value {
            0 => Self::Unspecified,
            1 => Self::Healthy,
            2 => Self::Unhealthy,
            3 => Self::AgentNotInstalled,
            4 => Self::AgentNotRunning,
            _ => Self::UnknownValue(health_state::UnknownValue(
                wkt::internal::UnknownEnumValue::Integer(value),
            )),
        }
    }
}

impl std::convert::From<&str> for HealthState {
    fn from(value: &str) -> Self {
        use std::string::ToString;
        match value {
            "HEALTH_STATE_UNSPECIFIED" => Self::Unspecified,
            "HEALTHY" => Self::Healthy,
            "UNHEALTHY" => Self::Unhealthy,
            "AGENT_NOT_INSTALLED" => Self::AgentNotInstalled,
            "AGENT_NOT_RUNNING" => Self::AgentNotRunning,
            _ => Self::UnknownValue(health_state::UnknownValue(
                wkt::internal::UnknownEnumValue::String(value.to_string()),
            )),
        }
    }
}

impl serde::ser::Serialize for HealthState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::Serializer,
    {
        match self {
            Self::Unspecified => serializer.serialize_i32(0),
            Self::Healthy => serializer.serialize_i32(1),
            Self::Unhealthy => serializer.serialize_i32(2),
            Self::AgentNotInstalled => serializer.serialize_i32(3),
            Self::AgentNotRunning => serializer.serialize_i32(4),
            Self::UnknownValue(u) => u.0.serialize(serializer),
        }
    }
}

impl<'de> serde::de::Deserialize<'de> for HealthState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        deserializer.deserialize_any(wkt::internal::EnumVisitor::<HealthState>::new(
            ".google.cloud.notebooks.v2.HealthState",
        ))
    }
}
