// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Defines flags that are used to run the diagnostic tool
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiagnosticConfig {
    /// Required. User Cloud Storage bucket location (REQUIRED).
    /// Must be formatted with path prefix (`gs://$GCS_BUCKET`).
    ///
    /// Permissions:
    /// User Managed Notebooks:
    ///
    /// - storage.buckets.writer: Must be given to the project's service account
    ///   attached to VM.
    ///   Google Managed Notebooks:
    /// - storage.buckets.writer: Must be given to the project's service account or
    ///   user credentials attached to VM depending on authentication mode.
    ///
    /// Cloud Storage bucket Log file will be written to
    /// `gs://$GCS_BUCKET/$RELATIVE_PATH/$VM_DATE_$TIME.tar.gz`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub gcs_bucket: std::string::String,

    /// Optional. Defines the relative storage path in the Cloud Storage bucket
    /// where the diagnostic logs will be written: Default path will be the root
    /// directory of the Cloud Storage bucket
    /// (`gs://$GCS_BUCKET/$DATE_$TIME.tar.gz`) Example of full path where Log file
    /// will be written: `gs://$GCS_BUCKET/$RELATIVE_PATH/`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub relative_path: std::string::String,

    /// Optional. Enables flag to repair service for instance
    pub enable_repair_flag: bool,

    /// Optional. Enables flag to capture packets from the instance for 30 seconds
    pub enable_packet_capture_flag: bool,

    /// Optional. Enables flag to copy all `/home/jupyter` folder contents
    pub enable_copy_home_files_flag: bool,
}

impl DiagnosticConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [gcs_bucket][crate::model::DiagnosticConfig::gcs_bucket].
    pub fn set_gcs_bucket<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.gcs_bucket = v.into();
        self
    }

    /// Sets the value of [relative_path][crate::model::DiagnosticConfig::relative_path].
    pub fn set_relative_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.relative_path = v.into();
        self
    }

    /// Sets the value of [enable_repair_flag][crate::model::DiagnosticConfig::enable_repair_flag].
    pub fn set_enable_repair_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_repair_flag = v.into();
        self
    }

    /// Sets the value of [enable_packet_capture_flag][crate::model::DiagnosticConfig::enable_packet_capture_flag].
    pub fn set_enable_packet_capture_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_packet_capture_flag = v.into();
        self
    }

    /// Sets the value of [enable_copy_home_files_flag][crate::model::DiagnosticConfig::enable_copy_home_files_flag].
    pub fn set_enable_copy_home_files_flag<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_copy_home_files_flag = v.into();
        self
    }
}

impl wkt::message::Message for DiagnosticConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DiagnosticConfig"
    }
}

/// The definition of an Event for a managed / semi-managed notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Event {
    /// Optional. Event report time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub report_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Event type.
    #[serde(rename = "type")]
    pub r#type: crate::model::event::EventType,

    /// Optional. Event details. This field is used to pass event information.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub details: std::collections::HashMap<std::string::String, std::string::String>,
}

impl Event {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [report_time][crate::model::Event::report_time].
    pub fn set_report_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.report_time = v.into();
        self
    }

    /// Sets the value of [r#type][crate::model::Event::type].
    pub fn set_type<T: std::convert::Into<crate::model::event::EventType>>(mut self, v: T) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [details][crate::model::Event::details].
    pub fn set_details<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.details = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for Event {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.Event"
    }
}

/// Defines additional types related to Event
pub mod event {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the event types.
    #[derive(Clone, Debug, PartialEq)]
    pub struct EventType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [EventType](EventType)
    pub mod event_type {
        use super::EventType;

        /// Event is not specified.
        pub const EVENT_TYPE_UNSPECIFIED: EventType = EventType::known("EVENT_TYPE_UNSPECIFIED", 0);

        /// The instance / runtime is idle
        pub const IDLE: EventType = EventType::known("IDLE", 1);

        /// The instance / runtime is available.
        /// This event indicates that instance / runtime underlying compute is
        /// operational.
        pub const HEARTBEAT: EventType = EventType::known("HEARTBEAT", 2);

        /// The instance / runtime health is available.
        /// This event indicates that instance / runtime health information.
        pub const HEALTH: EventType = EventType::known("HEALTH", 3);

        /// The instance / runtime is available.
        /// This event allows instance / runtime to send Host maintenance
        /// information to Control Plane.
        /// <https://cloud.google.com/compute/docs/gpus/gpu-host-maintenance>
        pub const MAINTENANCE: EventType = EventType::known("MAINTENANCE", 4);

        /// The instance / runtime is available.
        /// This event indicates that the instance had metadata that needs to be
        /// modified.
        pub const METADATA_CHANGE: EventType = EventType::known("METADATA_CHANGE", 5);
    }

    impl EventType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for EventType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for EventType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(EventType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(EventType::from(val)),
                Enumeration::UnknownNum { str } => Ok(EventType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for EventType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "EVENT_TYPE_UNSPECIFIED" => event_type::EVENT_TYPE_UNSPECIFIED,
                "IDLE" => event_type::IDLE,
                "HEARTBEAT" => event_type::HEARTBEAT,
                "HEALTH" => event_type::HEALTH,
                "MAINTENANCE" => event_type::MAINTENANCE,
                "METADATA_CHANGE" => event_type::METADATA_CHANGE,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for EventType {
        fn from(value: i32) -> Self {
            match value {
                0 => event_type::EVENT_TYPE_UNSPECIFIED,
                1 => event_type::IDLE,
                2 => event_type::HEARTBEAT,
                3 => event_type::HEALTH,
                4 => event_type::MAINTENANCE,
                5 => event_type::METADATA_CHANGE,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for EventType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// The definition of a network interface resource attached to a VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct NetworkInterface {
    /// Optional. The name of the VPC that this VM instance is in.
    /// Format:
    /// `projects/{project_id}/global/networks/{network_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub network: std::string::String,

    /// Optional. The name of the subnet that this VM instance is in.
    /// Format:
    /// `projects/{project_id}/regions/{region}/subnetworks/{subnetwork_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub subnet: std::string::String,

    /// Optional. The type of vNIC to be used on this interface. This may be gVNIC
    /// or VirtioNet.
    pub nic_type: crate::model::network_interface::NicType,
}

impl NetworkInterface {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [network][crate::model::NetworkInterface::network].
    pub fn set_network<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.network = v.into();
        self
    }

    /// Sets the value of [subnet][crate::model::NetworkInterface::subnet].
    pub fn set_subnet<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.subnet = v.into();
        self
    }

    /// Sets the value of [nic_type][crate::model::NetworkInterface::nic_type].
    pub fn set_nic_type<T: std::convert::Into<crate::model::network_interface::NicType>>(
        mut self,
        v: T,
    ) -> Self {
        self.nic_type = v.into();
        self
    }
}

impl wkt::message::Message for NetworkInterface {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.NetworkInterface"
    }
}

/// Defines additional types related to NetworkInterface
pub mod network_interface {
    #[allow(unused_imports)]
    use super::*;

    /// The type of vNIC driver.
    /// Default should be NIC_TYPE_UNSPECIFIED.
    #[derive(Clone, Debug, PartialEq)]
    pub struct NicType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [NicType](NicType)
    pub mod nic_type {
        use super::NicType;

        /// No type specified.
        pub const NIC_TYPE_UNSPECIFIED: NicType = NicType::known("NIC_TYPE_UNSPECIFIED", 0);

        /// VIRTIO
        pub const VIRTIO_NET: NicType = NicType::known("VIRTIO_NET", 1);

        /// GVNIC
        pub const GVNIC: NicType = NicType::known("GVNIC", 2);
    }

    impl NicType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for NicType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for NicType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(NicType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(NicType::from(val)),
                Enumeration::UnknownNum { str } => Ok(NicType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for NicType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "NIC_TYPE_UNSPECIFIED" => nic_type::NIC_TYPE_UNSPECIFIED,
                "VIRTIO_NET" => nic_type::VIRTIO_NET,
                "GVNIC" => nic_type::GVNIC,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for NicType {
        fn from(value: i32) -> Self {
            match value {
                0 => nic_type::NIC_TYPE_UNSPECIFIED,
                1 => nic_type::VIRTIO_NET,
                2 => nic_type::GVNIC,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for NicType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// Definition of a custom Compute Engine virtual machine image for starting a
/// notebook instance with the environment installed directly on the VM.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct VmImage {
    /// Required. The name of the Google Cloud project that this VM image belongs
    /// to. Format: `{project_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub project: std::string::String,

    /// The reference to an external Compute Engine VM image.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub image: std::option::Option<crate::model::vm_image::Image>,
}

impl VmImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [project][crate::model::VmImage::project].
    pub fn set_project<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.project = v.into();
        self
    }

    /// Sets the value of `image`.
    pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::vm_image::Image>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = v.into();
        self
    }

    /// The value of [image][crate::model::VmImage::image]
    /// if it holds a `Name`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_name(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::vm_image::Image::Name(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [image][crate::model::VmImage::image]
    /// if it holds a `Family`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_family(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::vm_image::Image::Family(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::VmImage::image]
    /// to hold a `Name`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = std::option::Option::Some(crate::model::vm_image::Image::Name(v.into()));
        self
    }

    /// Sets the value of [image][crate::model::VmImage::image]
    /// to hold a `Family`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_family<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.image = std::option::Option::Some(crate::model::vm_image::Image::Family(v.into()));
        self
    }
}

impl wkt::message::Message for VmImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.VmImage"
    }
}

/// Defines additional types related to VmImage
pub mod vm_image {
    #[allow(unused_imports)]
    use super::*;

    /// The reference to an external Compute Engine VM image.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Image {
        /// Optional. Use VM image name to find the image.
        Name(std::string::String),
        /// Optional. Use this VM image family to find the image; the newest image in
        /// this family will be used.
        Family(std::string::String),
    }
}

/// Definition of a container image for starting a notebook instance with the
/// environment installed in a container.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ContainerImage {
    /// Required. The path to the container image repository. For example:
    /// `gcr.io/{project_id}/{image_name}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub repository: std::string::String,

    /// Optional. The tag of the container image. If not specified, this defaults
    /// to the latest tag.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub tag: std::string::String,
}

impl ContainerImage {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repository][crate::model::ContainerImage::repository].
    pub fn set_repository<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository = v.into();
        self
    }

    /// Sets the value of [tag][crate::model::ContainerImage::tag].
    pub fn set_tag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.tag = v.into();
        self
    }
}

impl wkt::message::Message for ContainerImage {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ContainerImage"
    }
}

/// An accelerator configuration for a VM instance
/// Definition of a hardware accelerator. Note that there is no check on `type`
/// and `core_count` combinations. TPUs are not supported.
/// See [GPUs on Compute
/// Engine](https://cloud.google.com/compute/docs/gpus/#gpus-list) to find a
/// valid combination.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct AcceleratorConfig {
    /// Optional. Type of this accelerator.
    #[serde(rename = "type")]
    pub r#type: crate::model::accelerator_config::AcceleratorType,

    /// Optional. Count of cores of this accelerator.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub core_count: i64,
}

impl AcceleratorConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [r#type][crate::model::AcceleratorConfig::type].
    pub fn set_type<T: std::convert::Into<crate::model::accelerator_config::AcceleratorType>>(
        mut self,
        v: T,
    ) -> Self {
        self.r#type = v.into();
        self
    }

    /// Sets the value of [core_count][crate::model::AcceleratorConfig::core_count].
    pub fn set_core_count<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.core_count = v.into();
        self
    }
}

impl wkt::message::Message for AcceleratorConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.AcceleratorConfig"
    }
}

/// Defines additional types related to AcceleratorConfig
pub mod accelerator_config {
    #[allow(unused_imports)]
    use super::*;

    /// Definition of the types of hardware accelerators that can be used on
    /// this instance.
    #[derive(Clone, Debug, PartialEq)]
    pub struct AcceleratorType(wkt::enumerations::Enumeration);

    /// Useful constants to work with [AcceleratorType](AcceleratorType)
    pub mod accelerator_type {
        use super::AcceleratorType;

        /// Accelerator type is not specified.
        pub const ACCELERATOR_TYPE_UNSPECIFIED: AcceleratorType =
            AcceleratorType::known("ACCELERATOR_TYPE_UNSPECIFIED", 0);

        /// Accelerator type is Nvidia Tesla P100.
        pub const NVIDIA_TESLA_P100: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_P100", 2);

        /// Accelerator type is Nvidia Tesla V100.
        pub const NVIDIA_TESLA_V100: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_V100", 3);

        /// Accelerator type is Nvidia Tesla P4.
        pub const NVIDIA_TESLA_P4: AcceleratorType = AcceleratorType::known("NVIDIA_TESLA_P4", 4);

        /// Accelerator type is Nvidia Tesla T4.
        pub const NVIDIA_TESLA_T4: AcceleratorType = AcceleratorType::known("NVIDIA_TESLA_T4", 5);

        /// Accelerator type is Nvidia Tesla A100 - 40GB.
        pub const NVIDIA_TESLA_A100: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_A100", 11);

        /// Accelerator type is Nvidia Tesla A100 - 80GB.
        pub const NVIDIA_A100_80GB: AcceleratorType =
            AcceleratorType::known("NVIDIA_A100_80GB", 12);

        /// Accelerator type is Nvidia Tesla L4.
        pub const NVIDIA_L4: AcceleratorType = AcceleratorType::known("NVIDIA_L4", 13);

        /// Accelerator type is NVIDIA Tesla T4 Virtual Workstations.
        pub const NVIDIA_TESLA_T4_VWS: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_T4_VWS", 8);

        /// Accelerator type is NVIDIA Tesla P100 Virtual Workstations.
        pub const NVIDIA_TESLA_P100_VWS: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_P100_VWS", 9);

        /// Accelerator type is NVIDIA Tesla P4 Virtual Workstations.
        pub const NVIDIA_TESLA_P4_VWS: AcceleratorType =
            AcceleratorType::known("NVIDIA_TESLA_P4_VWS", 10);
    }

    impl AcceleratorType {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for AcceleratorType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for AcceleratorType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(AcceleratorType::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(AcceleratorType::from(val)),
                Enumeration::UnknownNum { str } => Ok(AcceleratorType::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for AcceleratorType {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "ACCELERATOR_TYPE_UNSPECIFIED" => accelerator_type::ACCELERATOR_TYPE_UNSPECIFIED,
                "NVIDIA_TESLA_P100" => accelerator_type::NVIDIA_TESLA_P100,
                "NVIDIA_TESLA_V100" => accelerator_type::NVIDIA_TESLA_V100,
                "NVIDIA_TESLA_P4" => accelerator_type::NVIDIA_TESLA_P4,
                "NVIDIA_TESLA_T4" => accelerator_type::NVIDIA_TESLA_T4,
                "NVIDIA_TESLA_A100" => accelerator_type::NVIDIA_TESLA_A100,
                "NVIDIA_A100_80GB" => accelerator_type::NVIDIA_A100_80GB,
                "NVIDIA_L4" => accelerator_type::NVIDIA_L4,
                "NVIDIA_TESLA_T4_VWS" => accelerator_type::NVIDIA_TESLA_T4_VWS,
                "NVIDIA_TESLA_P100_VWS" => accelerator_type::NVIDIA_TESLA_P100_VWS,
                "NVIDIA_TESLA_P4_VWS" => accelerator_type::NVIDIA_TESLA_P4_VWS,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for AcceleratorType {
        fn from(value: i32) -> Self {
            match value {
                0 => accelerator_type::ACCELERATOR_TYPE_UNSPECIFIED,
                2 => accelerator_type::NVIDIA_TESLA_P100,
                3 => accelerator_type::NVIDIA_TESLA_V100,
                4 => accelerator_type::NVIDIA_TESLA_P4,
                5 => accelerator_type::NVIDIA_TESLA_T4,
                8 => accelerator_type::NVIDIA_TESLA_T4_VWS,
                9 => accelerator_type::NVIDIA_TESLA_P100_VWS,
                10 => accelerator_type::NVIDIA_TESLA_P4_VWS,
                11 => accelerator_type::NVIDIA_TESLA_A100,
                12 => accelerator_type::NVIDIA_A100_80GB,
                13 => accelerator_type::NVIDIA_L4,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for AcceleratorType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// A set of Shielded Instance options.
/// See [Images using supported Shielded VM
/// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
/// Not all combinations are valid.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ShieldedInstanceConfig {
    /// Optional. Defines whether the VM instance has Secure Boot enabled.
    ///
    /// Secure Boot helps ensure that the system only runs authentic software by
    /// verifying the digital signature of all boot components, and halting the
    /// boot process if signature verification fails. Disabled by default.
    pub enable_secure_boot: bool,

    /// Optional. Defines whether the VM instance has the vTPM enabled. Enabled by
    /// default.
    pub enable_vtpm: bool,

    /// Optional. Defines whether the VM instance has integrity monitoring enabled.
    ///
    /// Enables monitoring and attestation of the boot integrity of the VM
    /// instance. The attestation is performed against the integrity policy
    /// baseline. This baseline is initially derived from the implicitly trusted
    /// boot image when the VM instance is created. Enabled by default.
    pub enable_integrity_monitoring: bool,
}

impl ShieldedInstanceConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_secure_boot][crate::model::ShieldedInstanceConfig::enable_secure_boot].
    pub fn set_enable_secure_boot<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_secure_boot = v.into();
        self
    }

    /// Sets the value of [enable_vtpm][crate::model::ShieldedInstanceConfig::enable_vtpm].
    pub fn set_enable_vtpm<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_vtpm = v.into();
        self
    }

    /// Sets the value of [enable_integrity_monitoring][crate::model::ShieldedInstanceConfig::enable_integrity_monitoring].
    pub fn set_enable_integrity_monitoring<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_integrity_monitoring = v.into();
        self
    }
}

impl wkt::message::Message for ShieldedInstanceConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ShieldedInstanceConfig"
    }
}

/// A GPU driver configuration
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GPUDriverConfig {
    /// Optional. Whether the end user authorizes Google Cloud to install GPU
    /// driver on this VM instance. If this field is empty or set to false, the GPU
    /// driver won't be installed. Only applicable to instances with GPUs.
    pub enable_gpu_driver: bool,

    /// Optional. Specify a custom Cloud Storage path where the GPU driver is
    /// stored. If not specified, we'll automatically choose from official GPU
    /// drivers.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub custom_gpu_driver_path: std::string::String,
}

impl GPUDriverConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [enable_gpu_driver][crate::model::GPUDriverConfig::enable_gpu_driver].
    pub fn set_enable_gpu_driver<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_gpu_driver = v.into();
        self
    }

    /// Sets the value of [custom_gpu_driver_path][crate::model::GPUDriverConfig::custom_gpu_driver_path].
    pub fn set_custom_gpu_driver_path<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.custom_gpu_driver_path = v.into();
        self
    }
}

impl wkt::message::Message for GPUDriverConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GPUDriverConfig"
    }
}

/// An instance-attached disk resource.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DataDisk {
    /// Optional. The size of the disk in GB attached to this VM instance, up to a
    /// maximum of 64000 GB (64 TB). If not specified, this defaults to 100.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,

    /// Optional. Input only. Indicates the type of the disk.
    pub disk_type: crate::model::DiskType,

    /// Optional. Input only. Disk encryption method used on the boot and data
    /// disks, defaults to GMEK.
    pub disk_encryption: crate::model::DiskEncryption,

    /// Optional. Input only. The KMS key used to encrypt the disks, only
    /// applicable if disk_encryption is CMEK. Format:
    /// `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
    ///
    /// Learn more about using your own encryption keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,
}

impl DataDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_size_gb][crate::model::DataDisk::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::DataDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::DiskType>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_encryption][crate::model::DataDisk::disk_encryption].
    pub fn set_disk_encryption<T: std::convert::Into<crate::model::DiskEncryption>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_encryption = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::DataDisk::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for DataDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DataDisk"
    }
}

/// The definition of a boot disk.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct BootDisk {
    /// Optional. The size of the boot disk in GB attached to this instance, up to
    /// a maximum of 64000 GB (64 TB). If not specified, this defaults to the
    /// recommended value of 150GB.
    #[serde_as(as = "serde_with::DisplayFromStr")]
    pub disk_size_gb: i64,

    /// Optional. Indicates the type of the disk.
    pub disk_type: crate::model::DiskType,

    /// Optional. Input only. Disk encryption method used on the boot and data
    /// disks, defaults to GMEK.
    pub disk_encryption: crate::model::DiskEncryption,

    /// Optional. Input only. The KMS key used to encrypt the disks, only
    /// applicable if disk_encryption is CMEK. Format:
    /// `projects/{project_id}/locations/{location}/keyRings/{key_ring_id}/cryptoKeys/{key_id}`
    ///
    /// Learn more about using your own encryption keys.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub kms_key: std::string::String,
}

impl BootDisk {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [disk_size_gb][crate::model::BootDisk::disk_size_gb].
    pub fn set_disk_size_gb<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.disk_size_gb = v.into();
        self
    }

    /// Sets the value of [disk_type][crate::model::BootDisk::disk_type].
    pub fn set_disk_type<T: std::convert::Into<crate::model::DiskType>>(mut self, v: T) -> Self {
        self.disk_type = v.into();
        self
    }

    /// Sets the value of [disk_encryption][crate::model::BootDisk::disk_encryption].
    pub fn set_disk_encryption<T: std::convert::Into<crate::model::DiskEncryption>>(
        mut self,
        v: T,
    ) -> Self {
        self.disk_encryption = v.into();
        self
    }

    /// Sets the value of [kms_key][crate::model::BootDisk::kms_key].
    pub fn set_kms_key<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key = v.into();
        self
    }
}

impl wkt::message::Message for BootDisk {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.BootDisk"
    }
}

/// A service account that acts as an identity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceAccount {
    /// Optional. Email address of the service account.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub email: std::string::String,

    /// Output only. The list of scopes to be made available for this service
    /// account. Set by the CLH to <https://www.googleapis.com/auth/cloud-platform>
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub scopes: std::vec::Vec<std::string::String>,
}

impl ServiceAccount {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [email][crate::model::ServiceAccount::email].
    pub fn set_email<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email = v.into();
        self
    }

    /// Sets the value of [scopes][crate::model::ServiceAccount::scopes].
    pub fn set_scopes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.scopes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ServiceAccount {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ServiceAccount"
    }
}

/// The definition of how to configure a VM instance outside of Resources and
/// Identity.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GceSetup {
    /// Optional. The machine type of the VM instance.
    /// <https://cloud.google.com/compute/docs/machine-resource>
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub machine_type: std::string::String,

    /// Optional. The hardware accelerators used on this instance. If you use
    /// accelerators, make sure that your configuration has
    /// [enough vCPUs and memory to support the `machine_type` you have
    /// selected](https://cloud.google.com/compute/docs/gpus/#gpus-list).
    /// Currently supports only one accelerator configuration.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub accelerator_configs: std::vec::Vec<crate::model::AcceleratorConfig>,

    /// Optional. The service account that serves as an identity for the VM
    /// instance. Currently supports only one service account.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub service_accounts: std::vec::Vec<crate::model::ServiceAccount>,

    /// Optional. The boot disk for the VM.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub boot_disk: std::option::Option<crate::model::BootDisk>,

    /// Optional. Data disks attached to the VM instance.
    /// Currently supports only one data disk.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub data_disks: std::vec::Vec<crate::model::DataDisk>,

    /// Optional. Shielded VM configuration.
    /// [Images using supported Shielded VM
    /// features](https://cloud.google.com/compute/docs/instances/modifying-shielded-vm).
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub shielded_instance_config: std::option::Option<crate::model::ShieldedInstanceConfig>,

    /// Optional. The network interfaces for the VM.
    /// Supports only one interface.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub network_interfaces: std::vec::Vec<crate::model::NetworkInterface>,

    /// Optional. If true, no external IP will be assigned to this VM instance.
    pub disable_public_ip: bool,

    /// Optional. The Compute Engine tags to add to runtime (see [Tagging
    /// instances](https://cloud.google.com/compute/docs/label-or-tag-resources#tags)).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub tags: std::vec::Vec<std::string::String>,

    /// Optional. Custom metadata to apply to this instance.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub metadata: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Flag to enable ip forwarding or not, default false/off.
    /// <https://cloud.google.com/vpc/docs/using-routes#canipforward>
    pub enable_ip_forwarding: bool,

    /// Optional. Configuration for GPU drivers.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub gpu_driver_config: std::option::Option<crate::model::GPUDriverConfig>,

    /// Type of the image; can be one of VM image, or container image.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub image: std::option::Option<crate::model::gce_setup::Image>,
}

impl GceSetup {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [machine_type][crate::model::GceSetup::machine_type].
    pub fn set_machine_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.machine_type = v.into();
        self
    }

    /// Sets the value of [boot_disk][crate::model::GceSetup::boot_disk].
    pub fn set_boot_disk<T: std::convert::Into<std::option::Option<crate::model::BootDisk>>>(
        mut self,
        v: T,
    ) -> Self {
        self.boot_disk = v.into();
        self
    }

    /// Sets the value of [shielded_instance_config][crate::model::GceSetup::shielded_instance_config].
    pub fn set_shielded_instance_config<
        T: std::convert::Into<std::option::Option<crate::model::ShieldedInstanceConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.shielded_instance_config = v.into();
        self
    }

    /// Sets the value of [disable_public_ip][crate::model::GceSetup::disable_public_ip].
    pub fn set_disable_public_ip<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_public_ip = v.into();
        self
    }

    /// Sets the value of [enable_ip_forwarding][crate::model::GceSetup::enable_ip_forwarding].
    pub fn set_enable_ip_forwarding<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.enable_ip_forwarding = v.into();
        self
    }

    /// Sets the value of [gpu_driver_config][crate::model::GceSetup::gpu_driver_config].
    pub fn set_gpu_driver_config<
        T: std::convert::Into<std::option::Option<crate::model::GPUDriverConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.gpu_driver_config = v.into();
        self
    }

    /// Sets the value of [accelerator_configs][crate::model::GceSetup::accelerator_configs].
    pub fn set_accelerator_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::AcceleratorConfig>,
    {
        use std::iter::Iterator;
        self.accelerator_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [service_accounts][crate::model::GceSetup::service_accounts].
    pub fn set_service_accounts<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ServiceAccount>,
    {
        use std::iter::Iterator;
        self.service_accounts = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_disks][crate::model::GceSetup::data_disks].
    pub fn set_data_disks<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DataDisk>,
    {
        use std::iter::Iterator;
        self.data_disks = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [network_interfaces][crate::model::GceSetup::network_interfaces].
    pub fn set_network_interfaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::NetworkInterface>,
    {
        use std::iter::Iterator;
        self.network_interfaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [tags][crate::model::GceSetup::tags].
    pub fn set_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [metadata][crate::model::GceSetup::metadata].
    pub fn set_metadata<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.metadata = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `image`.
    pub fn set_image<T: std::convert::Into<std::option::Option<crate::model::gce_setup::Image>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = v.into();
        self
    }

    /// The value of [image][crate::model::GceSetup::image]
    /// if it holds a `VmImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_vm_image(&self) -> std::option::Option<&std::boxed::Box<crate::model::VmImage>> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::gce_setup::Image::VmImage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// The value of [image][crate::model::GceSetup::image]
    /// if it holds a `ContainerImage`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_container_image(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::ContainerImage>> {
        #[allow(unreachable_patterns)]
        self.image.as_ref().and_then(|v| match v {
            crate::model::gce_setup::Image::ContainerImage(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [image][crate::model::GceSetup::image]
    /// to hold a `VmImage`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_vm_image<T: std::convert::Into<std::boxed::Box<crate::model::VmImage>>>(
        mut self,
        v: T,
    ) -> Self {
        self.image = std::option::Option::Some(crate::model::gce_setup::Image::VmImage(v.into()));
        self
    }

    /// Sets the value of [image][crate::model::GceSetup::image]
    /// to hold a `ContainerImage`.
    ///
    /// Note that all the setters affecting `image` are
    /// mutually exclusive.
    pub fn set_container_image<
        T: std::convert::Into<std::boxed::Box<crate::model::ContainerImage>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.image =
            std::option::Option::Some(crate::model::gce_setup::Image::ContainerImage(v.into()));
        self
    }
}

impl wkt::message::Message for GceSetup {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GceSetup"
    }
}

/// Defines additional types related to GceSetup
pub mod gce_setup {
    #[allow(unused_imports)]
    use super::*;

    /// Type of the image; can be one of VM image, or container image.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Image {
        /// Optional. Use a Compute Engine VM image to start the notebook instance.
        VmImage(std::boxed::Box<crate::model::VmImage>),
        /// Optional. Use a container image to start the notebook instance.
        ContainerImage(std::boxed::Box<crate::model::ContainerImage>),
    }
}

/// The entry of VM image upgrade history.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeHistoryEntry {
    /// Optional. The snapshot of the boot disk of this notebook instance before
    /// upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub snapshot: std::string::String,

    /// Optional. The VM image before this instance upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub vm_image: std::string::String,

    /// Optional. The container image before this instance upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub container_image: std::string::String,

    /// Optional. The framework of this notebook instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub framework: std::string::String,

    /// Optional. The version of the notebook instance before this upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub version: std::string::String,

    /// Output only. The state of this instance upgrade history entry.
    pub state: crate::model::upgrade_history_entry::State,

    /// Immutable. The time that this instance upgrade history entry is created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Action. Rolloback or Upgrade.
    pub action: crate::model::upgrade_history_entry::Action,

    /// Optional. Target VM Version, like m63.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_version: std::string::String,
}

impl UpgradeHistoryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [snapshot][crate::model::UpgradeHistoryEntry::snapshot].
    pub fn set_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.snapshot = v.into();
        self
    }

    /// Sets the value of [vm_image][crate::model::UpgradeHistoryEntry::vm_image].
    pub fn set_vm_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.vm_image = v.into();
        self
    }

    /// Sets the value of [container_image][crate::model::UpgradeHistoryEntry::container_image].
    pub fn set_container_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.container_image = v.into();
        self
    }

    /// Sets the value of [framework][crate::model::UpgradeHistoryEntry::framework].
    pub fn set_framework<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.framework = v.into();
        self
    }

    /// Sets the value of [version][crate::model::UpgradeHistoryEntry::version].
    pub fn set_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.version = v.into();
        self
    }

    /// Sets the value of [state][crate::model::UpgradeHistoryEntry::state].
    pub fn set_state<T: std::convert::Into<crate::model::upgrade_history_entry::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::UpgradeHistoryEntry::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [action][crate::model::UpgradeHistoryEntry::action].
    pub fn set_action<T: std::convert::Into<crate::model::upgrade_history_entry::Action>>(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// Sets the value of [target_version][crate::model::UpgradeHistoryEntry::target_version].
    pub fn set_target_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_version = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeHistoryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpgradeHistoryEntry"
    }
}

/// Defines additional types related to UpgradeHistoryEntry
pub mod upgrade_history_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The definition of the states of this upgrade history entry.
    #[derive(Clone, Debug, PartialEq)]
    pub struct State(wkt::enumerations::Enumeration);

    /// Useful constants to work with [State](State)
    pub mod state {
        use super::State;

        /// State is not specified.
        pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

        /// The instance upgrade is started.
        pub const STARTED: State = State::known("STARTED", 1);

        /// The instance upgrade is succeeded.
        pub const SUCCEEDED: State = State::known("SUCCEEDED", 2);

        /// The instance upgrade is failed.
        pub const FAILED: State = State::known("FAILED", 3);
    }

    impl State {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(State::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
                Enumeration::UnknownNum { str } => Ok(State::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for State {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
                "STARTED" => state::STARTED,
                "SUCCEEDED" => state::SUCCEEDED,
                "FAILED" => state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => state::STATE_UNSPECIFIED,
                1 => state::STARTED,
                2 => state::SUCCEEDED,
                3 => state::FAILED,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }

    /// The definition of operations of this upgrade history entry.
    #[derive(Clone, Debug, PartialEq)]
    pub struct Action(wkt::enumerations::Enumeration);

    /// Useful constants to work with [Action](Action)
    pub mod action {
        use super::Action;

        /// Operation is not specified.
        pub const ACTION_UNSPECIFIED: Action = Action::known("ACTION_UNSPECIFIED", 0);

        /// Upgrade.
        pub const UPGRADE: Action = Action::known("UPGRADE", 1);

        /// Rollback.
        pub const ROLLBACK: Action = Action::known("ROLLBACK", 2);
    }

    impl Action {
        pub(crate) const fn known(str: &'static str, val: i32) -> Self {
            Self(wkt::enumerations::Enumeration::known(str, val))
        }

        /// Gets the enum value.
        pub fn value(&self) -> &str {
            self.0.value()
        }

        /// Gets the numeric value of the enum (if available).
        pub fn numeric_value(&self) -> std::option::Option<i32> {
            self.0.numeric_value()
        }
    }

    impl serde::ser::Serialize for Action {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            self.0.serialize(serializer)
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Action {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            use std::convert::From;
            use std::result::Result::Ok;
            use wkt::enumerations::Enumeration;
            match Enumeration::deserialize(deserializer)? {
                Enumeration::Known { str: _, val } => Ok(Action::from(val)),
                Enumeration::UnknownStr { val, str: _ } => Ok(Action::from(val)),
                Enumeration::UnknownNum { str } => Ok(Action::from(str)),
            }
        }
    }

    impl std::convert::From<std::string::String> for Action {
        fn from(value: std::string::String) -> Self {
            match value.as_str() {
                "ACTION_UNSPECIFIED" => action::ACTION_UNSPECIFIED,
                "UPGRADE" => action::UPGRADE,
                "ROLLBACK" => action::ROLLBACK,
                _ => Self(wkt::enumerations::Enumeration::known_str(value)),
            }
        }
    }

    impl std::convert::From<i32> for Action {
        fn from(value: i32) -> Self {
            match value {
                0 => action::ACTION_UNSPECIFIED,
                1 => action::UPGRADE,
                2 => action::ROLLBACK,
                _ => Self(wkt::enumerations::Enumeration::known_num(value)),
            }
        }
    }

    impl std::default::Default for Action {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0_i32)
        }
    }
}

/// The definition of a notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Instance {
    /// Output only. The name of this notebook instance. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. The proxy endpoint that is used to access the Jupyter
    /// notebook.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub proxy_uri: std::string::String,

    /// Optional. Input only. The owner of this instance after creation. Format:
    /// `alias@example.com`
    ///
    /// Currently supports one owner only. If not specified, all of the service
    /// account users of your VM instance's service account can use
    /// the instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instance_owners: std::vec::Vec<std::string::String>,

    /// Output only. Email address of entity that sent original CreateInstance
    /// request.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub creator: std::string::String,

    /// Output only. The state of this instance.
    pub state: crate::model::State,

    /// Output only. The upgrade history of this instance.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub upgrade_history: std::vec::Vec<crate::model::UpgradeHistoryEntry>,

    /// Output only. Unique ID of the resource.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub id: std::string::String,

    /// Output only. Instance health_state.
    pub health_state: crate::model::HealthState,

    /// Output only. Additional information about instance health.
    /// Example:
    ///
    /// ```norust
    /// healthInfo": {
    ///   "docker_proxy_agent_status": "1",
    ///   "docker_status": "1",
    ///   "jupyterlab_api_status": "-1",
    ///   "jupyterlab_status": "-1",
    ///   "updated": "2020-10-18 09:40:03.573409"
    /// }
    /// ```
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub health_info: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Instance creation time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Instance update time.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Optional. If true, the notebook instance will not register with the proxy.
    pub disable_proxy_access: bool,

    /// Optional. Labels to apply to this instance.
    /// These can be later modified by the UpdateInstance method.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Setup for the Notebook instance.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub infrastructure: std::option::Option<crate::model::instance::Infrastructure>,
}

impl Instance {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Instance::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [proxy_uri][crate::model::Instance::proxy_uri].
    pub fn set_proxy_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.proxy_uri = v.into();
        self
    }

    /// Sets the value of [creator][crate::model::Instance::creator].
    pub fn set_creator<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.creator = v.into();
        self
    }

    /// Sets the value of [state][crate::model::Instance::state].
    pub fn set_state<T: std::convert::Into<crate::model::State>>(mut self, v: T) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [id][crate::model::Instance::id].
    pub fn set_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.id = v.into();
        self
    }

    /// Sets the value of [health_state][crate::model::Instance::health_state].
    pub fn set_health_state<T: std::convert::Into<crate::model::HealthState>>(
        mut self,
        v: T,
    ) -> Self {
        self.health_state = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Instance::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [update_time][crate::model::Instance::update_time].
    pub fn set_update_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_time = v.into();
        self
    }

    /// Sets the value of [disable_proxy_access][crate::model::Instance::disable_proxy_access].
    pub fn set_disable_proxy_access<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disable_proxy_access = v.into();
        self
    }

    /// Sets the value of [instance_owners][crate::model::Instance::instance_owners].
    pub fn set_instance_owners<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.instance_owners = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [upgrade_history][crate::model::Instance::upgrade_history].
    pub fn set_upgrade_history<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::UpgradeHistoryEntry>,
    {
        use std::iter::Iterator;
        self.upgrade_history = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [health_info][crate::model::Instance::health_info].
    pub fn set_health_info<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.health_info = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [labels][crate::model::Instance::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of `infrastructure`.
    pub fn set_infrastructure<
        T: std::convert::Into<std::option::Option<crate::model::instance::Infrastructure>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure = v.into();
        self
    }

    /// The value of [infrastructure][crate::model::Instance::infrastructure]
    /// if it holds a `GceSetup`, `None` if the field is not set or
    /// holds a different branch.
    pub fn get_gce_setup(&self) -> std::option::Option<&std::boxed::Box<crate::model::GceSetup>> {
        #[allow(unreachable_patterns)]
        self.infrastructure.as_ref().and_then(|v| match v {
            crate::model::instance::Infrastructure::GceSetup(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [infrastructure][crate::model::Instance::infrastructure]
    /// to hold a `GceSetup`.
    ///
    /// Note that all the setters affecting `infrastructure` are
    /// mutually exclusive.
    pub fn set_gce_setup<T: std::convert::Into<std::boxed::Box<crate::model::GceSetup>>>(
        mut self,
        v: T,
    ) -> Self {
        self.infrastructure =
            std::option::Option::Some(crate::model::instance::Infrastructure::GceSetup(v.into()));
        self
    }
}

impl wkt::message::Message for Instance {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.Instance"
    }
}

/// Defines additional types related to Instance
pub mod instance {
    #[allow(unused_imports)]
    use super::*;

    /// Setup for the Notebook instance.
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum Infrastructure {
        /// Optional. Compute Engine setup for the notebook. Uses notebook-defined
        /// fields.
        GceSetup(std::boxed::Box<crate::model::GceSetup>),
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Identifies whether the user has requested cancellation
    /// of the operation. Operations that have successfully been cancelled
    /// have [Operation.error][] value with a
    /// [google.rpc.Status.code][google.rpc.Status.code] of 1, corresponding to
    /// `Code.CANCELLED`.
    ///
    /// [google.rpc.Status.code]: rpc::model::Status::code
    pub requested_cancellation: bool,

    /// API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    /// API endpoint name of this operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub endpoint: std::string::String,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.create_time = v.into();
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T: std::convert::Into<std::option::Option<wkt::Timestamp>>>(
        mut self,
        v: T,
    ) -> Self {
        self.end_time = v.into();
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }

    /// Sets the value of [endpoint][crate::model::OperationMetadata::endpoint].
    pub fn set_endpoint<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.endpoint = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.OperationMetadata"
    }
}

/// Request for listing notebook instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesRequest {
    /// Required. Format:
    /// `parent=projects/{project_id}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Maximum return size of the list call.
    pub page_size: i32,

    /// Optional. A previous returned page token that can be used to continue
    /// listing from the last result.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Sort results. Supported values are "name", "name desc" or ""
    /// (unsorted).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    /// Optional. List filter.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,
}

impl ListInstancesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListInstancesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListInstancesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListInstancesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListInstancesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListInstancesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListInstancesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ListInstancesRequest"
    }
}

/// Response for listing notebook instances.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListInstancesResponse {
    /// A list of returned instances.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub instances: std::vec::Vec<crate::model::Instance>,

    /// Page token that can be used to continue listing from the last result in the
    /// next list call.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached. For example,
    /// ['us-west1-a', 'us-central1-b'].
    /// A ListInstancesResponse will only contain either instances or unreachables,
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,
}

impl ListInstancesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [next_page_token][crate::model::ListInstancesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [instances][crate::model::ListInstancesResponse::instances].
    pub fn set_instances<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Instance>,
    {
        use std::iter::Iterator;
        self.instances = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListInstancesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListInstancesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ListInstancesResponse"
    }
}

#[cfg(feature = "unstable-stream")]
impl gax::paginator::PageableResponse for ListInstancesResponse {
    type PageItem = crate::model::Instance;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.instances
    }

    fn next_page_token(&self) -> std::string::String {
        gax::paginator::extract_token(&self.next_page_token)
    }
}

/// Request for getting a notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl GetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.GetInstanceRequest"
    }
}

/// Request for creating a notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateInstanceRequest {
    /// Required. Format:
    /// `parent=projects/{project_id}/locations/{location}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. User-defined unique ID of this instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub instance_id: std::string::String,

    /// Required. The instance to be created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Optional. Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl CreateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateInstanceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [instance_id][crate::model::CreateInstanceRequest::instance_id].
    pub fn set_instance_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.instance_id = v.into();
        self
    }

    /// Sets the value of [instance][crate::model::CreateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CreateInstanceRequest"
    }
}

/// Request for updating a notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateInstanceRequest {
    /// Required. A representation of an instance.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub instance: std::option::Option<crate::model::Instance>,

    /// Required. Mask used to update an instance
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Optional. Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl UpdateInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [instance][crate::model::UpdateInstanceRequest::instance].
    pub fn set_instance<T: std::convert::Into<std::option::Option<crate::model::Instance>>>(
        mut self,
        v: T,
    ) -> Self {
        self.instance = v.into();
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateInstanceRequest::update_mask].
    pub fn set_update_mask<T: std::convert::Into<std::option::Option<wkt::FieldMask>>>(
        mut self,
        v: T,
    ) -> Self {
        self.update_mask = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for UpdateInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpdateInstanceRequest"
    }
}

/// Request for deleting a notebook instance.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. Idempotent request UUID.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,
}

impl DeleteInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteInstanceRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }
}

impl wkt::message::Message for DeleteInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DeleteInstanceRequest"
    }
}

/// Request for starting a notebook instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StartInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StartInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StartInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StartInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.StartInstanceRequest"
    }
}

/// Request for stopping a notebook instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct StopInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl StopInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::StopInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for StopInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.StopInstanceRequest"
    }
}

/// Request for resetting a notebook instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ResetInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl ResetInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ResetInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.ResetInstanceRequest"
    }
}

/// Request for checking if a notebook instance is upgradeable.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckInstanceUpgradabilityRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub notebook_instance: std::string::String,
}

impl CheckInstanceUpgradabilityRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [notebook_instance][crate::model::CheckInstanceUpgradabilityRequest::notebook_instance].
    pub fn set_notebook_instance<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.notebook_instance = v.into();
        self
    }
}

impl wkt::message::Message for CheckInstanceUpgradabilityRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CheckInstanceUpgradabilityRequest"
    }
}

/// Response for checking if a notebook instance is upgradeable.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CheckInstanceUpgradabilityResponse {
    /// If an instance is upgradeable.
    pub upgradeable: bool,

    /// The version this instance will be upgraded to if calling the upgrade
    /// endpoint. This field will only be populated if field upgradeable is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upgrade_version: std::string::String,

    /// Additional information about upgrade.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upgrade_info: std::string::String,

    /// The new image self link this instance will be upgraded to if calling the
    /// upgrade endpoint. This field will only be populated if field upgradeable
    /// is true.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub upgrade_image: std::string::String,
}

impl CheckInstanceUpgradabilityResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [upgradeable][crate::model::CheckInstanceUpgradabilityResponse::upgradeable].
    pub fn set_upgradeable<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.upgradeable = v.into();
        self
    }

    /// Sets the value of [upgrade_version][crate::model::CheckInstanceUpgradabilityResponse::upgrade_version].
    pub fn set_upgrade_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_version = v.into();
        self
    }

    /// Sets the value of [upgrade_info][crate::model::CheckInstanceUpgradabilityResponse::upgrade_info].
    pub fn set_upgrade_info<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_info = v.into();
        self
    }

    /// Sets the value of [upgrade_image][crate::model::CheckInstanceUpgradabilityResponse::upgrade_image].
    pub fn set_upgrade_image<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.upgrade_image = v.into();
        self
    }
}

impl wkt::message::Message for CheckInstanceUpgradabilityResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.CheckInstanceUpgradabilityResponse"
    }
}

/// Request for upgrading a notebook instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpgradeInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,
}

impl UpgradeInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::UpgradeInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for UpgradeInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.UpgradeInstanceRequest"
    }
}

/// Request for rollbacking a notebook instance
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct RollbackInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. The snapshot for rollback.
    /// Example: "projects/test-project/global/snapshots/krwlzipynril".
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target_snapshot: std::string::String,

    /// Required. Output only. Revision Id
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub revision_id: std::string::String,
}

impl RollbackInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::RollbackInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [target_snapshot][crate::model::RollbackInstanceRequest::target_snapshot].
    pub fn set_target_snapshot<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target_snapshot = v.into();
        self
    }

    /// Sets the value of [revision_id][crate::model::RollbackInstanceRequest::revision_id].
    pub fn set_revision_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision_id = v.into();
        self
    }
}

impl wkt::message::Message for RollbackInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.RollbackInstanceRequest"
    }
}

/// Request for creating a notebook instance diagnostic file.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DiagnoseInstanceRequest {
    /// Required. Format:
    /// `projects/{project_id}/locations/{location}/instances/{instance_id}`
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Defines flags that are used to run the diagnostic tool
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub diagnostic_config: std::option::Option<crate::model::DiagnosticConfig>,

    /// Optional. Maxmium amount of time in minutes before the operation times out.
    pub timeout_minutes: i32,
}

impl DiagnoseInstanceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DiagnoseInstanceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [diagnostic_config][crate::model::DiagnoseInstanceRequest::diagnostic_config].
    pub fn set_diagnostic_config<
        T: std::convert::Into<std::option::Option<crate::model::DiagnosticConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.diagnostic_config = v.into();
        self
    }

    /// Sets the value of [timeout_minutes][crate::model::DiagnoseInstanceRequest::timeout_minutes].
    pub fn set_timeout_minutes<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.timeout_minutes = v.into();
        self
    }
}

impl wkt::message::Message for DiagnoseInstanceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.notebooks.v2.DiagnoseInstanceRequest"
    }
}

/// Definition of the disk encryption options.
#[derive(Clone, Debug, PartialEq)]
pub struct DiskEncryption(wkt::enumerations::Enumeration);

/// Useful constants to work with [DiskEncryption](DiskEncryption)
pub mod disk_encryption {
    use super::DiskEncryption;

    /// Disk encryption is not specified.
    pub const DISK_ENCRYPTION_UNSPECIFIED: DiskEncryption =
        DiskEncryption::known("DISK_ENCRYPTION_UNSPECIFIED", 0);

    /// Use Google managed encryption keys to encrypt the boot disk.
    pub const GMEK: DiskEncryption = DiskEncryption::known("GMEK", 1);

    /// Use customer managed encryption keys to encrypt the boot disk.
    pub const CMEK: DiskEncryption = DiskEncryption::known("CMEK", 2);
}

impl DiskEncryption {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for DiskEncryption {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for DiskEncryption {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(DiskEncryption::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(DiskEncryption::from(val)),
            Enumeration::UnknownNum { str } => Ok(DiskEncryption::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for DiskEncryption {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "DISK_ENCRYPTION_UNSPECIFIED" => disk_encryption::DISK_ENCRYPTION_UNSPECIFIED,
            "GMEK" => disk_encryption::GMEK,
            "CMEK" => disk_encryption::CMEK,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for DiskEncryption {
    fn from(value: i32) -> Self {
        match value {
            0 => disk_encryption::DISK_ENCRYPTION_UNSPECIFIED,
            1 => disk_encryption::GMEK,
            2 => disk_encryption::CMEK,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for DiskEncryption {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// Possible disk types.
#[derive(Clone, Debug, PartialEq)]
pub struct DiskType(wkt::enumerations::Enumeration);

/// Useful constants to work with [DiskType](DiskType)
pub mod disk_type {
    use super::DiskType;

    /// Disk type not set.
    pub const DISK_TYPE_UNSPECIFIED: DiskType = DiskType::known("DISK_TYPE_UNSPECIFIED", 0);

    /// Standard persistent disk type.
    pub const PD_STANDARD: DiskType = DiskType::known("PD_STANDARD", 1);

    /// SSD persistent disk type.
    pub const PD_SSD: DiskType = DiskType::known("PD_SSD", 2);

    /// Balanced persistent disk type.
    pub const PD_BALANCED: DiskType = DiskType::known("PD_BALANCED", 3);

    /// Extreme persistent disk type.
    pub const PD_EXTREME: DiskType = DiskType::known("PD_EXTREME", 4);
}

impl DiskType {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for DiskType {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for DiskType {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(DiskType::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(DiskType::from(val)),
            Enumeration::UnknownNum { str } => Ok(DiskType::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for DiskType {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "DISK_TYPE_UNSPECIFIED" => disk_type::DISK_TYPE_UNSPECIFIED,
            "PD_STANDARD" => disk_type::PD_STANDARD,
            "PD_SSD" => disk_type::PD_SSD,
            "PD_BALANCED" => disk_type::PD_BALANCED,
            "PD_EXTREME" => disk_type::PD_EXTREME,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for DiskType {
    fn from(value: i32) -> Self {
        match value {
            0 => disk_type::DISK_TYPE_UNSPECIFIED,
            1 => disk_type::PD_STANDARD,
            2 => disk_type::PD_SSD,
            3 => disk_type::PD_BALANCED,
            4 => disk_type::PD_EXTREME,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for DiskType {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The definition of the states of this instance.
#[derive(Clone, Debug, PartialEq)]
pub struct State(wkt::enumerations::Enumeration);

/// Useful constants to work with [State](State)
pub mod state {
    use super::State;

    /// State is not specified.
    pub const STATE_UNSPECIFIED: State = State::known("STATE_UNSPECIFIED", 0);

    /// The control logic is starting the instance.
    pub const STARTING: State = State::known("STARTING", 1);

    /// The control logic is installing required frameworks and registering the
    /// instance with notebook proxy
    pub const PROVISIONING: State = State::known("PROVISIONING", 2);

    /// The instance is running.
    pub const ACTIVE: State = State::known("ACTIVE", 3);

    /// The control logic is stopping the instance.
    pub const STOPPING: State = State::known("STOPPING", 4);

    /// The instance is stopped.
    pub const STOPPED: State = State::known("STOPPED", 5);

    /// The instance is deleted.
    pub const DELETED: State = State::known("DELETED", 6);

    /// The instance is upgrading.
    pub const UPGRADING: State = State::known("UPGRADING", 7);

    /// The instance is being created.
    pub const INITIALIZING: State = State::known("INITIALIZING", 8);

    /// The instance is suspending.
    pub const SUSPENDING: State = State::known("SUSPENDING", 9);

    /// The instance is suspended.
    pub const SUSPENDED: State = State::known("SUSPENDED", 10);
}

impl State {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for State {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for State {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(State::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(State::from(val)),
            Enumeration::UnknownNum { str } => Ok(State::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for State {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "STATE_UNSPECIFIED" => state::STATE_UNSPECIFIED,
            "STARTING" => state::STARTING,
            "PROVISIONING" => state::PROVISIONING,
            "ACTIVE" => state::ACTIVE,
            "STOPPING" => state::STOPPING,
            "STOPPED" => state::STOPPED,
            "DELETED" => state::DELETED,
            "UPGRADING" => state::UPGRADING,
            "INITIALIZING" => state::INITIALIZING,
            "SUSPENDING" => state::SUSPENDING,
            "SUSPENDED" => state::SUSPENDED,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for State {
    fn from(value: i32) -> Self {
        match value {
            0 => state::STATE_UNSPECIFIED,
            1 => state::STARTING,
            2 => state::PROVISIONING,
            3 => state::ACTIVE,
            4 => state::STOPPING,
            5 => state::STOPPED,
            6 => state::DELETED,
            7 => state::UPGRADING,
            8 => state::INITIALIZING,
            9 => state::SUSPENDING,
            10 => state::SUSPENDED,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for State {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}

/// The instance health state.
#[derive(Clone, Debug, PartialEq)]
pub struct HealthState(wkt::enumerations::Enumeration);

/// Useful constants to work with [HealthState](HealthState)
pub mod health_state {
    use super::HealthState;

    /// The instance substate is unknown.
    pub const HEALTH_STATE_UNSPECIFIED: HealthState =
        HealthState::known("HEALTH_STATE_UNSPECIFIED", 0);

    /// The instance is known to be in an healthy state
    /// (for example, critical daemons are running)
    /// Applies to ACTIVE state.
    pub const HEALTHY: HealthState = HealthState::known("HEALTHY", 1);

    /// The instance is known to be in an unhealthy state
    /// (for example, critical daemons are not running)
    /// Applies to ACTIVE state.
    pub const UNHEALTHY: HealthState = HealthState::known("UNHEALTHY", 2);

    /// The instance has not installed health monitoring agent.
    /// Applies to ACTIVE state.
    pub const AGENT_NOT_INSTALLED: HealthState = HealthState::known("AGENT_NOT_INSTALLED", 3);

    /// The instance health monitoring agent is not running.
    /// Applies to ACTIVE state.
    pub const AGENT_NOT_RUNNING: HealthState = HealthState::known("AGENT_NOT_RUNNING", 4);
}

impl HealthState {
    pub(crate) const fn known(str: &'static str, val: i32) -> Self {
        Self(wkt::enumerations::Enumeration::known(str, val))
    }

    /// Gets the enum value.
    pub fn value(&self) -> &str {
        self.0.value()
    }

    /// Gets the numeric value of the enum (if available).
    pub fn numeric_value(&self) -> std::option::Option<i32> {
        self.0.numeric_value()
    }
}

impl serde::ser::Serialize for HealthState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        self.0.serialize(serializer)
    }
}

impl<'de> serde::de::Deserialize<'de> for HealthState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        use std::convert::From;
        use std::result::Result::Ok;
        use wkt::enumerations::Enumeration;
        match Enumeration::deserialize(deserializer)? {
            Enumeration::Known { str: _, val } => Ok(HealthState::from(val)),
            Enumeration::UnknownStr { val, str: _ } => Ok(HealthState::from(val)),
            Enumeration::UnknownNum { str } => Ok(HealthState::from(str)),
        }
    }
}

impl std::convert::From<std::string::String> for HealthState {
    fn from(value: std::string::String) -> Self {
        match value.as_str() {
            "HEALTH_STATE_UNSPECIFIED" => health_state::HEALTH_STATE_UNSPECIFIED,
            "HEALTHY" => health_state::HEALTHY,
            "UNHEALTHY" => health_state::UNHEALTHY,
            "AGENT_NOT_INSTALLED" => health_state::AGENT_NOT_INSTALLED,
            "AGENT_NOT_RUNNING" => health_state::AGENT_NOT_RUNNING,
            _ => Self(wkt::enumerations::Enumeration::known_str(value)),
        }
    }
}

impl std::convert::From<i32> for HealthState {
    fn from(value: i32) -> Self {
        match value {
            0 => health_state::HEALTH_STATE_UNSPECIFIED,
            1 => health_state::HEALTHY,
            2 => health_state::UNHEALTHY,
            3 => health_state::AGENT_NOT_INSTALLED,
            4 => health_state::AGENT_NOT_RUNNING,
            _ => Self(wkt::enumerations::Enumeration::known_num(value)),
        }
    }
}

impl std::default::Default for HealthState {
    fn default() -> Self {
        use std::convert::From;
        Self::from(0_i32)
    }
}
