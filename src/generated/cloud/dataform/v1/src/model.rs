// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate gtype;
extern crate iam_v1;
extern crate lazy_static;
extern crate location;
extern crate reqwest;
extern crate rpc;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Describes encryption state of a resource.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DataEncryptionState {
    /// Required. The KMS key version name with which data of a resource is
    /// encrypted.
    pub kms_key_version_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DataEncryptionState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [kms_key_version_name][crate::model::DataEncryptionState::kms_key_version_name].
    pub fn set_kms_key_version_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.kms_key_version_name = v.into();
        self
    }
}

impl wkt::message::Message for DataEncryptionState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DataEncryptionState"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DataEncryptionState {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __kms_key_version_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DataEncryptionState")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "kmsKeyVersionName" => Ok(__FieldTag::__kms_key_version_name),
                            "kms_key_version_name" => Ok(__FieldTag::__kms_key_version_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DataEncryptionState;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DataEncryptionState")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__kms_key_version_name => {
                            if !fields.insert(__FieldTag::__kms_key_version_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_version_name",
                                ));
                            }
                            result.kms_key_version_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DataEncryptionState {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.kms_key_version_name.is_empty() {
            state.serialize_entry("kmsKeyVersionName", &self.kms_key_version_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Dataform Git repository.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Repository {
    /// Identifier. The repository's name.
    pub name: std::string::String,

    /// Output only. The timestamp of when the repository was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Optional. The repository's user-friendly name.
    pub display_name: std::string::String,

    /// Optional. If set, configures this repository to be linked to a Git remote.
    pub git_remote_settings: std::option::Option<crate::model::repository::GitRemoteSettings>,

    /// Optional. The name of the Secret Manager secret version to be used to
    /// interpolate variables into the .npmrc file for package installation
    /// operations. Must be in the format `projects/*/secrets/*/versions/*`. The
    /// file itself must be in a JSON format.
    pub npmrc_environment_variables_secret_version: std::string::String,

    /// Optional. If set, fields of `workspace_compilation_overrides` override the
    /// default compilation settings that are specified in dataform.json when
    /// creating workspace-scoped compilation results. See documentation for
    /// `WorkspaceCompilationOverrides` for more information.
    pub workspace_compilation_overrides:
        std::option::Option<crate::model::repository::WorkspaceCompilationOverrides>,

    /// Optional. Repository user labels.
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. Input only. If set to true, the authenticated user will be
    /// granted the roles/dataform.admin role on the created repository.
    pub set_authenticated_user_admin: bool,

    /// Optional. The service account to run workflow invocations under.
    pub service_account: std::string::String,

    /// Optional. The reference to a KMS encryption key. If provided, it will be
    /// used to encrypt user data in the repository and all child resources. It is
    /// not possible to add or update the encryption key after the repository is
    /// created. Example:
    /// `projects/{kms_project}/locations/{location}/keyRings/{key_location}/cryptoKeys/{key}`
    pub kms_key_name: std::string::String,

    /// Output only. A data encryption state of a Git repository if this Repository
    /// is protected by a KMS key.
    pub data_encryption_state: std::option::Option<crate::model::DataEncryptionState>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Repository {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Repository::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Repository::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Repository::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [display_name][crate::model::Repository::display_name].
    pub fn set_display_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.display_name = v.into();
        self
    }

    /// Sets the value of [git_remote_settings][crate::model::Repository::git_remote_settings].
    pub fn set_git_remote_settings<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::repository::GitRemoteSettings>,
    {
        self.git_remote_settings = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_remote_settings][crate::model::Repository::git_remote_settings].
    pub fn set_or_clear_git_remote_settings<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::repository::GitRemoteSettings>,
    {
        self.git_remote_settings = v.map(|x| x.into());
        self
    }

    /// Sets the value of [npmrc_environment_variables_secret_version][crate::model::Repository::npmrc_environment_variables_secret_version].
    pub fn set_npmrc_environment_variables_secret_version<
        T: std::convert::Into<std::string::String>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.npmrc_environment_variables_secret_version = v.into();
        self
    }

    /// Sets the value of [workspace_compilation_overrides][crate::model::Repository::workspace_compilation_overrides].
    pub fn set_workspace_compilation_overrides<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::repository::WorkspaceCompilationOverrides>,
    {
        self.workspace_compilation_overrides = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workspace_compilation_overrides][crate::model::Repository::workspace_compilation_overrides].
    pub fn set_or_clear_workspace_compilation_overrides<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::repository::WorkspaceCompilationOverrides>,
    {
        self.workspace_compilation_overrides = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Repository::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [set_authenticated_user_admin][crate::model::Repository::set_authenticated_user_admin].
    pub fn set_set_authenticated_user_admin<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.set_authenticated_user_admin = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::Repository::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }

    /// Sets the value of [kms_key_name][crate::model::Repository::kms_key_name].
    pub fn set_kms_key_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.kms_key_name = v.into();
        self
    }

    /// Sets the value of [data_encryption_state][crate::model::Repository::data_encryption_state].
    pub fn set_data_encryption_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_encryption_state][crate::model::Repository::data_encryption_state].
    pub fn set_or_clear_data_encryption_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::Repository::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::Repository::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Repository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.Repository"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Repository {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __display_name,
            __git_remote_settings,
            __npmrc_environment_variables_secret_version,
            __workspace_compilation_overrides,
            __labels,
            __set_authenticated_user_admin,
            __service_account,
            __kms_key_name,
            __data_encryption_state,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Repository")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "displayName" => Ok(__FieldTag::__display_name),
                            "display_name" => Ok(__FieldTag::__display_name),
                            "gitRemoteSettings" => Ok(__FieldTag::__git_remote_settings),
                            "git_remote_settings" => Ok(__FieldTag::__git_remote_settings),
                            "npmrcEnvironmentVariablesSecretVersion" => {
                                Ok(__FieldTag::__npmrc_environment_variables_secret_version)
                            }
                            "npmrc_environment_variables_secret_version" => {
                                Ok(__FieldTag::__npmrc_environment_variables_secret_version)
                            }
                            "workspaceCompilationOverrides" => {
                                Ok(__FieldTag::__workspace_compilation_overrides)
                            }
                            "workspace_compilation_overrides" => {
                                Ok(__FieldTag::__workspace_compilation_overrides)
                            }
                            "labels" => Ok(__FieldTag::__labels),
                            "setAuthenticatedUserAdmin" => {
                                Ok(__FieldTag::__set_authenticated_user_admin)
                            }
                            "set_authenticated_user_admin" => {
                                Ok(__FieldTag::__set_authenticated_user_admin)
                            }
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            "kmsKeyName" => Ok(__FieldTag::__kms_key_name),
                            "kms_key_name" => Ok(__FieldTag::__kms_key_name),
                            "dataEncryptionState" => Ok(__FieldTag::__data_encryption_state),
                            "data_encryption_state" => Ok(__FieldTag::__data_encryption_state),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Repository;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Repository")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__display_name => {
                            if !fields.insert(__FieldTag::__display_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for display_name",
                                ));
                            }
                            result.display_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_remote_settings => {
                            if !fields.insert(__FieldTag::__git_remote_settings) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_remote_settings",
                                ));
                            }
                            result.git_remote_settings =
                                map.next_value::<std::option::Option<
                                    crate::model::repository::GitRemoteSettings,
                                >>()?;
                        }
                        __FieldTag::__npmrc_environment_variables_secret_version => {
                            if !fields
                                .insert(__FieldTag::__npmrc_environment_variables_secret_version)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for npmrc_environment_variables_secret_version",
                                ));
                            }
                            result.npmrc_environment_variables_secret_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workspace_compilation_overrides => {
                            if !fields.insert(__FieldTag::__workspace_compilation_overrides) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace_compilation_overrides",
                                ));
                            }
                            result.workspace_compilation_overrides = map
                                .next_value::<std::option::Option<
                                    crate::model::repository::WorkspaceCompilationOverrides,
                                >>()?;
                        }
                        __FieldTag::__labels => {
                            if !fields.insert(__FieldTag::__labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for labels",
                                ));
                            }
                            result.labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__set_authenticated_user_admin => {
                            if !fields.insert(__FieldTag::__set_authenticated_user_admin) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for set_authenticated_user_admin",
                                ));
                            }
                            result.set_authenticated_user_admin = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__kms_key_name => {
                            if !fields.insert(__FieldTag::__kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for kms_key_name",
                                ));
                            }
                            result.kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_encryption_state => {
                            if !fields.insert(__FieldTag::__data_encryption_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_encryption_state",
                                ));
                            }
                            result.data_encryption_state = map.next_value::<std::option::Option<crate::model::DataEncryptionState>>()?
                                ;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Repository {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if !self.display_name.is_empty() {
            state.serialize_entry("displayName", &self.display_name)?;
        }
        if self.git_remote_settings.is_some() {
            state.serialize_entry("gitRemoteSettings", &self.git_remote_settings)?;
        }
        if !self.npmrc_environment_variables_secret_version.is_empty() {
            state.serialize_entry(
                "npmrcEnvironmentVariablesSecretVersion",
                &self.npmrc_environment_variables_secret_version,
            )?;
        }
        if self.workspace_compilation_overrides.is_some() {
            state.serialize_entry(
                "workspaceCompilationOverrides",
                &self.workspace_compilation_overrides,
            )?;
        }
        if !self.labels.is_empty() {
            state.serialize_entry("labels", &self.labels)?;
        }
        if !wkt::internal::is_default(&self.set_authenticated_user_admin) {
            state.serialize_entry(
                "setAuthenticatedUserAdmin",
                &self.set_authenticated_user_admin,
            )?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self.kms_key_name.is_empty() {
            state.serialize_entry("kmsKeyName", &self.kms_key_name)?;
        }
        if self.data_encryption_state.is_some() {
            state.serialize_entry("dataEncryptionState", &self.data_encryption_state)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [Repository].
pub mod repository {
    #[allow(unused_imports)]
    use super::*;

    /// Controls Git remote configuration for a repository.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct GitRemoteSettings {
        /// Required. The Git remote's URL.
        pub url: std::string::String,

        /// Required. The Git remote's default branch name.
        pub default_branch: std::string::String,

        /// Optional. The name of the Secret Manager secret version to use as an
        /// authentication token for Git operations. Must be in the format
        /// `projects/*/secrets/*/versions/*`.
        pub authentication_token_secret_version: std::string::String,

        /// Optional. Authentication fields for remote uris using SSH protocol.
        pub ssh_authentication_config: std::option::Option<
            crate::model::repository::git_remote_settings::SshAuthenticationConfig,
        >,

        /// Output only. Deprecated: The field does not contain any token status
        /// information.
        #[deprecated]
        pub token_status: crate::model::repository::git_remote_settings::TokenStatus,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl GitRemoteSettings {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [url][crate::model::repository::GitRemoteSettings::url].
        pub fn set_url<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.url = v.into();
            self
        }

        /// Sets the value of [default_branch][crate::model::repository::GitRemoteSettings::default_branch].
        pub fn set_default_branch<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_branch = v.into();
            self
        }

        /// Sets the value of [authentication_token_secret_version][crate::model::repository::GitRemoteSettings::authentication_token_secret_version].
        pub fn set_authentication_token_secret_version<
            T: std::convert::Into<std::string::String>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.authentication_token_secret_version = v.into();
            self
        }

        /// Sets the value of [ssh_authentication_config][crate::model::repository::GitRemoteSettings::ssh_authentication_config].
        pub fn set_ssh_authentication_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::repository::git_remote_settings::SshAuthenticationConfig,
                >,
        {
            self.ssh_authentication_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [ssh_authentication_config][crate::model::repository::GitRemoteSettings::ssh_authentication_config].
        pub fn set_or_clear_ssh_authentication_config<T>(
            mut self,
            v: std::option::Option<T>,
        ) -> Self
        where
            T: std::convert::Into<
                    crate::model::repository::git_remote_settings::SshAuthenticationConfig,
                >,
        {
            self.ssh_authentication_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [token_status][crate::model::repository::GitRemoteSettings::token_status].
        #[deprecated]
        pub fn set_token_status<
            T: std::convert::Into<crate::model::repository::git_remote_settings::TokenStatus>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.token_status = v.into();
            self
        }
    }

    impl wkt::message::Message for GitRemoteSettings {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.Repository.GitRemoteSettings"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for GitRemoteSettings {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __url,
                __default_branch,
                __authentication_token_secret_version,
                __ssh_authentication_config,
                __token_status,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for GitRemoteSettings")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "url" => Ok(__FieldTag::__url),
                                "defaultBranch" => Ok(__FieldTag::__default_branch),
                                "default_branch" => Ok(__FieldTag::__default_branch),
                                "authenticationTokenSecretVersion" => {
                                    Ok(__FieldTag::__authentication_token_secret_version)
                                }
                                "authentication_token_secret_version" => {
                                    Ok(__FieldTag::__authentication_token_secret_version)
                                }
                                "sshAuthenticationConfig" => {
                                    Ok(__FieldTag::__ssh_authentication_config)
                                }
                                "ssh_authentication_config" => {
                                    Ok(__FieldTag::__ssh_authentication_config)
                                }
                                "tokenStatus" => Ok(__FieldTag::__token_status),
                                "token_status" => Ok(__FieldTag::__token_status),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = GitRemoteSettings;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct GitRemoteSettings")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__url => {
                                if !fields.insert(__FieldTag::__url) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for url",
                                    ));
                                }
                                result.url = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__default_branch => {
                                if !fields.insert(__FieldTag::__default_branch) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_branch",
                                    ));
                                }
                                result.default_branch = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__authentication_token_secret_version => {
                                if !fields.insert(__FieldTag::__authentication_token_secret_version)
                                {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for authentication_token_secret_version",
                                    ));
                                }
                                result.authentication_token_secret_version = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__ssh_authentication_config => {
                                if !fields.insert(__FieldTag::__ssh_authentication_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for ssh_authentication_config",
                                    ));
                                }
                                result.ssh_authentication_config = map.next_value::<std::option::Option<crate::model::repository::git_remote_settings::SshAuthenticationConfig>>()?
                                    ;
                            }
                            __FieldTag::__token_status => {
                                if !fields.insert(__FieldTag::__token_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for token_status",
                                    ));
                                }
                                result.token_status = map
                                    .next_value::<std::option::Option<
                                        crate::model::repository::git_remote_settings::TokenStatus,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for GitRemoteSettings {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.url.is_empty() {
                state.serialize_entry("url", &self.url)?;
            }
            if !self.default_branch.is_empty() {
                state.serialize_entry("defaultBranch", &self.default_branch)?;
            }
            if !self.authentication_token_secret_version.is_empty() {
                state.serialize_entry(
                    "authenticationTokenSecretVersion",
                    &self.authentication_token_secret_version,
                )?;
            }
            if self.ssh_authentication_config.is_some() {
                state
                    .serialize_entry("sshAuthenticationConfig", &self.ssh_authentication_config)?;
            }
            if !wkt::internal::is_default(&self.token_status) {
                state.serialize_entry("tokenStatus", &self.token_status)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [GitRemoteSettings].
    pub mod git_remote_settings {
        #[allow(unused_imports)]
        use super::*;

        /// Configures fields for performing SSH authentication.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SshAuthenticationConfig {
            /// Required. The name of the Secret Manager secret version to use as a
            /// ssh private key for Git operations.
            /// Must be in the format `projects/*/secrets/*/versions/*`.
            pub user_private_key_secret_version: std::string::String,

            /// Required. Content of a public SSH key to verify an identity of a remote
            /// Git host.
            pub host_public_key: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SshAuthenticationConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [user_private_key_secret_version][crate::model::repository::git_remote_settings::SshAuthenticationConfig::user_private_key_secret_version].
            pub fn set_user_private_key_secret_version<
                T: std::convert::Into<std::string::String>,
            >(
                mut self,
                v: T,
            ) -> Self {
                self.user_private_key_secret_version = v.into();
                self
            }

            /// Sets the value of [host_public_key][crate::model::repository::git_remote_settings::SshAuthenticationConfig::host_public_key].
            pub fn set_host_public_key<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.host_public_key = v.into();
                self
            }
        }

        impl wkt::message::Message for SshAuthenticationConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.Repository.GitRemoteSettings.SshAuthenticationConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SshAuthenticationConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __user_private_key_secret_version,
                    __host_public_key,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SshAuthenticationConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "userPrivateKeySecretVersion" => {
                                        Ok(__FieldTag::__user_private_key_secret_version)
                                    }
                                    "user_private_key_secret_version" => {
                                        Ok(__FieldTag::__user_private_key_secret_version)
                                    }
                                    "hostPublicKey" => Ok(__FieldTag::__host_public_key),
                                    "host_public_key" => Ok(__FieldTag::__host_public_key),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SshAuthenticationConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SshAuthenticationConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__user_private_key_secret_version => {
                                    if !fields.insert(__FieldTag::__user_private_key_secret_version)
                                    {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for user_private_key_secret_version",
                                            ),
                                        );
                                    }
                                    result.user_private_key_secret_version = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__host_public_key => {
                                    if !fields.insert(__FieldTag::__host_public_key) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for host_public_key",
                                            ),
                                        );
                                    }
                                    result.host_public_key = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SshAuthenticationConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.user_private_key_secret_version.is_empty() {
                    state.serialize_entry(
                        "userPrivateKeySecretVersion",
                        &self.user_private_key_secret_version,
                    )?;
                }
                if !self.host_public_key.is_empty() {
                    state.serialize_entry("hostPublicKey", &self.host_public_key)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The status of the authentication token.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum TokenStatus {
            /// Default value. This value is unused.
            Unspecified,
            /// The token could not be found in Secret Manager (or the Dataform
            /// Service Account did not have permission to access it).
            NotFound,
            /// The token could not be used to authenticate against the Git remote.
            Invalid,
            /// The token was used successfully to authenticate against the Git remote.
            Valid,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [TokenStatus::value] or
            /// [TokenStatus::name].
            UnknownValue(token_status::UnknownValue),
        }

        #[doc(hidden)]
        pub mod token_status {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl TokenStatus {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::NotFound => std::option::Option::Some(1),
                    Self::Invalid => std::option::Option::Some(2),
                    Self::Valid => std::option::Option::Some(3),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("TOKEN_STATUS_UNSPECIFIED"),
                    Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                    Self::Invalid => std::option::Option::Some("INVALID"),
                    Self::Valid => std::option::Option::Some("VALID"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for TokenStatus {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for TokenStatus {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for TokenStatus {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::NotFound,
                    2 => Self::Invalid,
                    3 => Self::Valid,
                    _ => Self::UnknownValue(token_status::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for TokenStatus {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "TOKEN_STATUS_UNSPECIFIED" => Self::Unspecified,
                    "NOT_FOUND" => Self::NotFound,
                    "INVALID" => Self::Invalid,
                    "VALID" => Self::Valid,
                    _ => Self::UnknownValue(token_status::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for TokenStatus {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::NotFound => serializer.serialize_i32(1),
                    Self::Invalid => serializer.serialize_i32(2),
                    Self::Valid => serializer.serialize_i32(3),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for TokenStatus {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<TokenStatus>::new(
                    ".google.cloud.dataform.v1.Repository.GitRemoteSettings.TokenStatus",
                ))
            }
        }
    }

    /// Configures workspace compilation overrides for a repository.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct WorkspaceCompilationOverrides {
        /// Optional. The default database (Google Cloud project ID).
        pub default_database: std::string::String,

        /// Optional. The suffix that should be appended to all schema (BigQuery
        /// dataset ID) names.
        pub schema_suffix: std::string::String,

        /// Optional. The prefix that should be prepended to all table names.
        pub table_prefix: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl WorkspaceCompilationOverrides {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [default_database][crate::model::repository::WorkspaceCompilationOverrides::default_database].
        pub fn set_default_database<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.default_database = v.into();
            self
        }

        /// Sets the value of [schema_suffix][crate::model::repository::WorkspaceCompilationOverrides::schema_suffix].
        pub fn set_schema_suffix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.schema_suffix = v.into();
            self
        }

        /// Sets the value of [table_prefix][crate::model::repository::WorkspaceCompilationOverrides::table_prefix].
        pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.table_prefix = v.into();
            self
        }
    }

    impl wkt::message::Message for WorkspaceCompilationOverrides {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.Repository.WorkspaceCompilationOverrides"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for WorkspaceCompilationOverrides {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __default_database,
                __schema_suffix,
                __table_prefix,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for WorkspaceCompilationOverrides")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "defaultDatabase" => Ok(__FieldTag::__default_database),
                                "default_database" => Ok(__FieldTag::__default_database),
                                "schemaSuffix" => Ok(__FieldTag::__schema_suffix),
                                "schema_suffix" => Ok(__FieldTag::__schema_suffix),
                                "tablePrefix" => Ok(__FieldTag::__table_prefix),
                                "table_prefix" => Ok(__FieldTag::__table_prefix),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = WorkspaceCompilationOverrides;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct WorkspaceCompilationOverrides")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__default_database => {
                                if !fields.insert(__FieldTag::__default_database) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for default_database",
                                    ));
                                }
                                result.default_database = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__schema_suffix => {
                                if !fields.insert(__FieldTag::__schema_suffix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for schema_suffix",
                                    ));
                                }
                                result.schema_suffix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__table_prefix => {
                                if !fields.insert(__FieldTag::__table_prefix) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for table_prefix",
                                    ));
                                }
                                result.table_prefix = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for WorkspaceCompilationOverrides {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.default_database.is_empty() {
                state.serialize_entry("defaultDatabase", &self.default_database)?;
            }
            if !self.schema_suffix.is_empty() {
                state.serialize_entry("schemaSuffix", &self.schema_suffix)?;
            }
            if !self.table_prefix.is_empty() {
                state.serialize_entry("tablePrefix", &self.table_prefix)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// `ListRepositories` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRepositoriesRequest {
    /// Required. The location in which to list repositories. Must be in the format
    /// `projects/*/locations/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of repositories to return. The server may return
    /// fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListRepositories` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListRepositories`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    pub order_by: std::string::String,

    /// Optional. Filter for the returned list.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListRepositoriesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListRepositoriesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListRepositoriesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListRepositoriesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRepositoriesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRepositoriesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRepositoriesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRepositoriesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRepositoriesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListRepositories` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListRepositoriesResponse {
    /// List of repositories.
    pub repositories: std::vec::Vec<crate::model::Repository>,

    /// A token which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [repositories][crate::model::ListRepositoriesResponse::repositories].
    pub fn set_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Repository>,
    {
        use std::iter::Iterator;
        self.repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListRepositoriesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListRepositoriesResponse {
    type PageItem = crate::model::Repository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListRepositoriesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __repositories,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListRepositoriesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "repositories" => Ok(__FieldTag::__repositories),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListRepositoriesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListRepositoriesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__repositories => {
                            if !fields.insert(__FieldTag::__repositories) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repositories",
                                ));
                            }
                            result.repositories = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Repository>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListRepositoriesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.repositories.is_empty() {
            state.serialize_entry("repositories", &self.repositories)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetRepository` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetRepositoryRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetRepositoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetRepositoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetRepositoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetRepositoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetRepositoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetRepositoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateRepository` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateRepositoryRequest {
    /// Required. The location in which to create the repository. Must be in the
    /// format `projects/*/locations/*`.
    pub parent: std::string::String,

    /// Required. The repository to create.
    pub repository: std::option::Option<crate::model::Repository>,

    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name.
    pub repository_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateRepositoryRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [repository][crate::model::CreateRepositoryRequest::repository].
    pub fn set_repository<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository][crate::model::CreateRepositoryRequest::repository].
    pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repository_id][crate::model::CreateRepositoryRequest::repository_id].
    pub fn set_repository_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.repository_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateRepositoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateRepositoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __repository,
            __repository_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateRepositoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "repository" => Ok(__FieldTag::__repository),
                            "repositoryId" => Ok(__FieldTag::__repository_id),
                            "repository_id" => Ok(__FieldTag::__repository_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateRepositoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateRepositoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository =
                                map.next_value::<std::option::Option<crate::model::Repository>>()?;
                        }
                        __FieldTag::__repository_id => {
                            if !fields.insert(__FieldTag::__repository_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository_id",
                                ));
                            }
                            result.repository_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateRepositoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.repository.is_some() {
            state.serialize_entry("repository", &self.repository)?;
        }
        if !self.repository_id.is_empty() {
            state.serialize_entry("repositoryId", &self.repository_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `UpdateRepository` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateRepositoryRequest {
    /// Optional. Specifies the fields to be updated in the repository. If left
    /// unset, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The repository to update.
    pub repository: std::option::Option<crate::model::Repository>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateRepositoryRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateRepositoryRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [repository][crate::model::UpdateRepositoryRequest::repository].
    pub fn set_repository<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [repository][crate::model::UpdateRepositoryRequest::repository].
    pub fn set_or_clear_repository<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Repository>,
    {
        self.repository = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.UpdateRepositoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateRepositoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __repository,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateRepositoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "repository" => Ok(__FieldTag::__repository),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateRepositoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateRepositoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__repository => {
                            if !fields.insert(__FieldTag::__repository) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for repository",
                                ));
                            }
                            result.repository =
                                map.next_value::<std::option::Option<crate::model::Repository>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateRepositoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.repository.is_some() {
            state.serialize_entry("repository", &self.repository)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `DeleteRepository` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteRepositoryRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    /// Optional. If set to true, any child resources of this repository will also
    /// be deleted. (Otherwise, the request will only succeed if the repository has
    /// no child resources.)
    pub force: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteRepositoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteRepositoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [force][crate::model::DeleteRepositoryRequest::force].
    pub fn set_force<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.force = v.into();
        self
    }
}

impl wkt::message::Message for DeleteRepositoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DeleteRepositoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteRepositoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __force,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteRepositoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "force" => Ok(__FieldTag::__force),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteRepositoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteRepositoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__force => {
                            if !fields.insert(__FieldTag::__force) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for force",
                                ));
                            }
                            result.force = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteRepositoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.force) {
            state.serialize_entry("force", &self.force)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CommitRepositoryChanges` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitRepositoryChangesRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    /// Required. The changes to commit to the repository.
    pub commit_metadata: std::option::Option<crate::model::CommitMetadata>,

    /// Optional. The commit SHA which must be the repository's current HEAD before
    /// applying this commit; otherwise this request will fail. If unset, no
    /// validation on the current HEAD commit SHA is performed.
    pub required_head_commit_sha: std::string::String,

    /// Optional. A map to the path of the file to the operation. The path is the
    /// full file path including filename, from repository root.
    pub file_operations: std::collections::HashMap<
        std::string::String,
        crate::model::commit_repository_changes_request::FileOperation,
    >,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitRepositoryChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitRepositoryChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_metadata][crate::model::CommitRepositoryChangesRequest::commit_metadata].
    pub fn set_commit_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommitMetadata>,
    {
        self.commit_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [commit_metadata][crate::model::CommitRepositoryChangesRequest::commit_metadata].
    pub fn set_or_clear_commit_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommitMetadata>,
    {
        self.commit_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [required_head_commit_sha][crate::model::CommitRepositoryChangesRequest::required_head_commit_sha].
    pub fn set_required_head_commit_sha<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.required_head_commit_sha = v.into();
        self
    }

    /// Sets the value of [file_operations][crate::model::CommitRepositoryChangesRequest::file_operations].
    pub fn set_file_operations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<crate::model::commit_repository_changes_request::FileOperation>,
    {
        use std::iter::Iterator;
        self.file_operations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for CommitRepositoryChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitRepositoryChangesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitRepositoryChangesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __commit_metadata,
            __required_head_commit_sha,
            __file_operations,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitRepositoryChangesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "commitMetadata" => Ok(__FieldTag::__commit_metadata),
                            "commit_metadata" => Ok(__FieldTag::__commit_metadata),
                            "requiredHeadCommitSha" => Ok(__FieldTag::__required_head_commit_sha),
                            "required_head_commit_sha" => {
                                Ok(__FieldTag::__required_head_commit_sha)
                            }
                            "fileOperations" => Ok(__FieldTag::__file_operations),
                            "file_operations" => Ok(__FieldTag::__file_operations),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitRepositoryChangesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitRepositoryChangesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_metadata => {
                            if !fields.insert(__FieldTag::__commit_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_metadata",
                                ));
                            }
                            result.commit_metadata = map
                                .next_value::<std::option::Option<crate::model::CommitMetadata>>(
                                )?;
                        }
                        __FieldTag::__required_head_commit_sha => {
                            if !fields.insert(__FieldTag::__required_head_commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for required_head_commit_sha",
                                ));
                            }
                            result.required_head_commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__file_operations => {
                            if !fields.insert(__FieldTag::__file_operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_operations",
                                ));
                            }
                            result.file_operations = map.next_value::<std::option::Option<std::collections::HashMap<std::string::String,crate::model::commit_repository_changes_request::FileOperation>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitRepositoryChangesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.commit_metadata.is_some() {
            state.serialize_entry("commitMetadata", &self.commit_metadata)?;
        }
        if !self.required_head_commit_sha.is_empty() {
            state.serialize_entry("requiredHeadCommitSha", &self.required_head_commit_sha)?;
        }
        if !self.file_operations.is_empty() {
            state.serialize_entry("fileOperations", &self.file_operations)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CommitRepositoryChangesRequest].
pub mod commit_repository_changes_request {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a single file operation to the repository.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct FileOperation {
        /// The operation to perform on the file.
        pub operation: std::option::Option<
            crate::model::commit_repository_changes_request::file_operation::Operation,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl FileOperation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [operation][crate::model::commit_repository_changes_request::FileOperation::operation].
        ///
        /// Note that all the setters affecting `operation` are mutually
        /// exclusive.
        pub fn set_operation<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::commit_repository_changes_request::file_operation::Operation,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operation = v.into();
            self
        }

        /// The value of [operation][crate::model::commit_repository_changes_request::FileOperation::operation]
        /// if it holds a `WriteFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn write_file(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::commit_repository_changes_request::file_operation::WriteFile,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.operation.as_ref().and_then(|v| match v {
                crate::model::commit_repository_changes_request::file_operation::Operation::WriteFile(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [operation][crate::model::commit_repository_changes_request::FileOperation::operation]
        /// to hold a `WriteFile`.
        ///
        /// Note that all the setters affecting `operation` are
        /// mutually exclusive.
        pub fn set_write_file<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::commit_repository_changes_request::file_operation::WriteFile,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operation = std::option::Option::Some(
                crate::model::commit_repository_changes_request::file_operation::Operation::WriteFile(
                    v.into()
                )
            );
            self
        }

        /// The value of [operation][crate::model::commit_repository_changes_request::FileOperation::operation]
        /// if it holds a `DeleteFile`, `None` if the field is not set or
        /// holds a different branch.
        pub fn delete_file(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::commit_repository_changes_request::file_operation::DeleteFile,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.operation.as_ref().and_then(|v| match v {
                crate::model::commit_repository_changes_request::file_operation::Operation::DeleteFile(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [operation][crate::model::commit_repository_changes_request::FileOperation::operation]
        /// to hold a `DeleteFile`.
        ///
        /// Note that all the setters affecting `operation` are
        /// mutually exclusive.
        pub fn set_delete_file<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::commit_repository_changes_request::file_operation::DeleteFile,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.operation = std::option::Option::Some(
                crate::model::commit_repository_changes_request::file_operation::Operation::DeleteFile(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for FileOperation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CommitRepositoryChangesRequest.FileOperation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for FileOperation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __write_file,
                __delete_file,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for FileOperation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "writeFile" => Ok(__FieldTag::__write_file),
                                "write_file" => Ok(__FieldTag::__write_file),
                                "deleteFile" => Ok(__FieldTag::__delete_file),
                                "delete_file" => Ok(__FieldTag::__delete_file),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = FileOperation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct FileOperation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__write_file => {
                                if !fields.insert(__FieldTag::__write_file) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for write_file",
                                    ));
                                }
                                if result.operation.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `operation`, a oneof with full ID .google.cloud.dataform.v1.CommitRepositoryChangesRequest.FileOperation.write_file, latest field was writeFile",
                                    ));
                                }
                                result.operation = std::option::Option::Some(
                                    crate::model::commit_repository_changes_request::file_operation::Operation::WriteFile(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::commit_repository_changes_request::file_operation::WriteFile>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__delete_file => {
                                if !fields.insert(__FieldTag::__delete_file) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for delete_file",
                                    ));
                                }
                                if result.operation.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `operation`, a oneof with full ID .google.cloud.dataform.v1.CommitRepositoryChangesRequest.FileOperation.delete_file, latest field was deleteFile",
                                    ));
                                }
                                result.operation = std::option::Option::Some(
                                    crate::model::commit_repository_changes_request::file_operation::Operation::DeleteFile(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::commit_repository_changes_request::file_operation::DeleteFile>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for FileOperation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.write_file() {
                state.serialize_entry("writeFile", value)?;
            }
            if let Some(value) = self.delete_file() {
                state.serialize_entry("deleteFile", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [FileOperation].
    pub mod file_operation {
        #[allow(unused_imports)]
        use super::*;

        /// Represents the write file operation (for files added or modified).
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct WriteFile {
            /// The file's contents.
            pub contents: ::bytes::Bytes,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl WriteFile {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [contents][crate::model::commit_repository_changes_request::file_operation::WriteFile::contents].
            pub fn set_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
                self.contents = v.into();
                self
            }
        }

        impl wkt::message::Message for WriteFile {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.CommitRepositoryChangesRequest.FileOperation.WriteFile"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for WriteFile {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __contents,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for WriteFile")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "contents" => Ok(__FieldTag::__contents),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = WriteFile;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct WriteFile")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__contents => {
                                    if !fields.insert(__FieldTag::__contents) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for contents",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<::bytes::Bytes>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::<
                                                std::option::Option<serde_with::base64::Base64>,
                                            >::deserialize(
                                                deserializer
                                            )
                                            .map(__With)
                                        }
                                    }
                                    result.contents =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for WriteFile {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.contents.is_empty() {
                    struct __With<'a>(&'a ::bytes::Bytes);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<serde_with::base64::Base64>::serialize(
                                self.0, serializer,
                            )
                        }
                    }
                    state.serialize_entry("contents", &__With(&self.contents))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Represents the delete file operation.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct DeleteFile {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl DeleteFile {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for DeleteFile {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.CommitRepositoryChangesRequest.FileOperation.DeleteFile"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for DeleteFile {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for DeleteFile")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = DeleteFile;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct DeleteFile")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for DeleteFile {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The operation to perform on the file.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Operation {
            /// Represents the write operation.
            WriteFile(
                std::boxed::Box<
                    crate::model::commit_repository_changes_request::file_operation::WriteFile,
                >,
            ),
            /// Represents the delete operation.
            DeleteFile(
                std::boxed::Box<
                    crate::model::commit_repository_changes_request::file_operation::DeleteFile,
                >,
            ),
        }
    }
}

/// `CommitRepositoryChanges` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitRepositoryChangesResponse {
    /// The commit SHA of the current commit.
    pub commit_sha: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitRepositoryChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commit_sha][crate::model::CommitRepositoryChangesResponse::commit_sha].
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_sha = v.into();
        self
    }
}

impl wkt::message::Message for CommitRepositoryChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitRepositoryChangesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitRepositoryChangesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commit_sha,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitRepositoryChangesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitRepositoryChangesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitRepositoryChangesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            result.commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitRepositoryChangesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.commit_sha.is_empty() {
            state.serialize_entry("commitSha", &self.commit_sha)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ReadRepositoryFile` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReadRepositoryFileRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    /// Optional. The commit SHA for the commit to read from. If unset, the file
    /// will be read from HEAD.
    pub commit_sha: std::string::String,

    /// Required. Full file path to read including filename, from repository root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadRepositoryFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReadRepositoryFileRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_sha][crate::model::ReadRepositoryFileRequest::commit_sha].
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_sha = v.into();
        self
    }

    /// Sets the value of [path][crate::model::ReadRepositoryFileRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for ReadRepositoryFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ReadRepositoryFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadRepositoryFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __commit_sha,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadRepositoryFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadRepositoryFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadRepositoryFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            result.commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadRepositoryFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.commit_sha.is_empty() {
            state.serialize_entry("commitSha", &self.commit_sha)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ReadRepositoryFile` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReadRepositoryFileResponse {
    /// The file's contents.
    pub contents: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadRepositoryFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [contents][crate::model::ReadRepositoryFileResponse::contents].
    pub fn set_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.contents = v.into();
        self
    }
}

impl wkt::message::Message for ReadRepositoryFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ReadRepositoryFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadRepositoryFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadRepositoryFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "contents" => Ok(__FieldTag::__contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadRepositoryFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadRepositoryFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.contents = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadRepositoryFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contents", &__With(&self.contents))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryRepositoryDirectoryContents` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryRepositoryDirectoryContentsRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    /// Optional. The Commit SHA for the commit to query from. If unset, the
    /// directory will be queried from HEAD.
    pub commit_sha: std::string::String,

    /// Optional. The directory's full path including directory name, relative to
    /// root. If left unset, the root is used.
    pub path: std::string::String,

    /// Optional. Maximum number of paths to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// Optional. Page token received from a previous
    /// `QueryRepositoryDirectoryContents` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryRepositoryDirectoryContents`, with the exception of `page_size`, must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryRepositoryDirectoryContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryRepositoryDirectoryContentsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [commit_sha][crate::model::QueryRepositoryDirectoryContentsRequest::commit_sha].
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_sha = v.into();
        self
    }

    /// Sets the value of [path][crate::model::QueryRepositoryDirectoryContentsRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryRepositoryDirectoryContentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryRepositoryDirectoryContentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryRepositoryDirectoryContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryRepositoryDirectoryContentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryRepositoryDirectoryContentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __commit_sha,
            __path,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for QueryRepositoryDirectoryContentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            "path" => Ok(__FieldTag::__path),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryRepositoryDirectoryContentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryRepositoryDirectoryContentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            result.commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryRepositoryDirectoryContentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.commit_sha.is_empty() {
            state.serialize_entry("commitSha", &self.commit_sha)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryRepositoryDirectoryContents` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryRepositoryDirectoryContentsResponse {
    /// List of entries in the directory.
    pub directory_entries: std::vec::Vec<crate::model::DirectoryEntry>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryRepositoryDirectoryContentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [directory_entries][crate::model::QueryRepositoryDirectoryContentsResponse::directory_entries].
    pub fn set_directory_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DirectoryEntry>,
    {
        use std::iter::Iterator;
        self.directory_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryRepositoryDirectoryContentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryRepositoryDirectoryContentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryRepositoryDirectoryContentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryRepositoryDirectoryContentsResponse {
    type PageItem = crate::model::DirectoryEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.directory_entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryRepositoryDirectoryContentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __directory_entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for QueryRepositoryDirectoryContentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "directoryEntries" => Ok(__FieldTag::__directory_entries),
                            "directory_entries" => Ok(__FieldTag::__directory_entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryRepositoryDirectoryContentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryRepositoryDirectoryContentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__directory_entries => {
                            if !fields.insert(__FieldTag::__directory_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directory_entries",
                                ));
                            }
                            result.directory_entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DirectoryEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryRepositoryDirectoryContentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.directory_entries.is_empty() {
            state.serialize_entry("directoryEntries", &self.directory_entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchRepositoryHistory` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchRepositoryHistoryRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    /// Optional. Maximum number of commits to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `FetchRepositoryHistory`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `FetchRepositoryHistory`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchRepositoryHistoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchRepositoryHistoryRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchRepositoryHistoryRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchRepositoryHistoryRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchRepositoryHistoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchRepositoryHistoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchRepositoryHistoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchRepositoryHistoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchRepositoryHistoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchRepositoryHistoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchRepositoryHistoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchRepositoryHistory` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchRepositoryHistoryResponse {
    /// A list of commit logs, ordered by 'git log' default order.
    pub commits: std::vec::Vec<crate::model::CommitLogEntry>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchRepositoryHistoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commits][crate::model::FetchRepositoryHistoryResponse::commits].
    pub fn set_commits<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CommitLogEntry>,
    {
        use std::iter::Iterator;
        self.commits = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchRepositoryHistoryResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchRepositoryHistoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchRepositoryHistoryResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchRepositoryHistoryResponse {
    type PageItem = crate::model::CommitLogEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.commits
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchRepositoryHistoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commits,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchRepositoryHistoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commits" => Ok(__FieldTag::__commits),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchRepositoryHistoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchRepositoryHistoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commits => {
                            if !fields.insert(__FieldTag::__commits) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commits",
                                ));
                            }
                            result.commits =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CommitLogEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchRepositoryHistoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.commits.is_empty() {
            state.serialize_entry("commits", &self.commits)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single commit log.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitLogEntry {
    /// Commit timestamp.
    pub commit_time: std::option::Option<wkt::Timestamp>,

    /// The commit SHA for this commit log entry.
    pub commit_sha: std::string::String,

    /// The commit author for this commit log entry.
    pub author: std::option::Option<crate::model::CommitAuthor>,

    /// The commit message for this commit log entry.
    pub commit_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitLogEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commit_time][crate::model::CommitLogEntry::commit_time].
    pub fn set_commit_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commit_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [commit_time][crate::model::CommitLogEntry::commit_time].
    pub fn set_or_clear_commit_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.commit_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commit_sha][crate::model::CommitLogEntry::commit_sha].
    pub fn set_commit_sha<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_sha = v.into();
        self
    }

    /// Sets the value of [author][crate::model::CommitLogEntry::author].
    pub fn set_author<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [author][crate::model::CommitLogEntry::author].
    pub fn set_or_clear_author<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commit_message][crate::model::CommitLogEntry::commit_message].
    pub fn set_commit_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_message = v.into();
        self
    }
}

impl wkt::message::Message for CommitLogEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitLogEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitLogEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commit_time,
            __commit_sha,
            __author,
            __commit_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitLogEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commitTime" => Ok(__FieldTag::__commit_time),
                            "commit_time" => Ok(__FieldTag::__commit_time),
                            "commitSha" => Ok(__FieldTag::__commit_sha),
                            "commit_sha" => Ok(__FieldTag::__commit_sha),
                            "author" => Ok(__FieldTag::__author),
                            "commitMessage" => Ok(__FieldTag::__commit_message),
                            "commit_message" => Ok(__FieldTag::__commit_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitLogEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitLogEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commit_time => {
                            if !fields.insert(__FieldTag::__commit_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_time",
                                ));
                            }
                            result.commit_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__commit_sha => {
                            if !fields.insert(__FieldTag::__commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_sha",
                                ));
                            }
                            result.commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__author => {
                            if !fields.insert(__FieldTag::__author) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for author",
                                ));
                            }
                            result.author = map
                                .next_value::<std::option::Option<crate::model::CommitAuthor>>()?;
                        }
                        __FieldTag::__commit_message => {
                            if !fields.insert(__FieldTag::__commit_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_message",
                                ));
                            }
                            result.commit_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitLogEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.commit_time.is_some() {
            state.serialize_entry("commitTime", &self.commit_time)?;
        }
        if !self.commit_sha.is_empty() {
            state.serialize_entry("commitSha", &self.commit_sha)?;
        }
        if self.author.is_some() {
            state.serialize_entry("author", &self.author)?;
        }
        if !self.commit_message.is_empty() {
            state.serialize_entry("commitMessage", &self.commit_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Dataform Git commit.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitMetadata {
    /// Required. The commit's author.
    pub author: std::option::Option<crate::model::CommitAuthor>,

    /// Optional. The commit's message.
    pub commit_message: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [author][crate::model::CommitMetadata::author].
    pub fn set_author<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [author][crate::model::CommitMetadata::author].
    pub fn set_or_clear_author<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commit_message][crate::model::CommitMetadata::commit_message].
    pub fn set_commit_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_message = v.into();
        self
    }
}

impl wkt::message::Message for CommitMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitMetadata"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitMetadata {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __author,
            __commit_message,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitMetadata")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "author" => Ok(__FieldTag::__author),
                            "commitMessage" => Ok(__FieldTag::__commit_message),
                            "commit_message" => Ok(__FieldTag::__commit_message),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitMetadata;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitMetadata")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__author => {
                            if !fields.insert(__FieldTag::__author) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for author",
                                ));
                            }
                            result.author = map
                                .next_value::<std::option::Option<crate::model::CommitAuthor>>()?;
                        }
                        __FieldTag::__commit_message => {
                            if !fields.insert(__FieldTag::__commit_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_message",
                                ));
                            }
                            result.commit_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitMetadata {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.author.is_some() {
            state.serialize_entry("author", &self.author)?;
        }
        if !self.commit_message.is_empty() {
            state.serialize_entry("commitMessage", &self.commit_message)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ComputeRepositoryAccessTokenStatus` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeRepositoryAccessTokenStatusRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeRepositoryAccessTokenStatusRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ComputeRepositoryAccessTokenStatusRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for ComputeRepositoryAccessTokenStatusRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ComputeRepositoryAccessTokenStatusRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeRepositoryAccessTokenStatusRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for ComputeRepositoryAccessTokenStatusRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeRepositoryAccessTokenStatusRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeRepositoryAccessTokenStatusRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeRepositoryAccessTokenStatusRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ComputeRepositoryAccessTokenStatus` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ComputeRepositoryAccessTokenStatusResponse {
    /// Indicates the status of the Git access token.
    pub token_status: crate::model::compute_repository_access_token_status_response::TokenStatus,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ComputeRepositoryAccessTokenStatusResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token_status][crate::model::ComputeRepositoryAccessTokenStatusResponse::token_status].
    pub fn set_token_status<
        T: std::convert::Into<
                crate::model::compute_repository_access_token_status_response::TokenStatus,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.token_status = v.into();
        self
    }
}

impl wkt::message::Message for ComputeRepositoryAccessTokenStatusResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ComputeRepositoryAccessTokenStatusResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ComputeRepositoryAccessTokenStatusResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __token_status,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str(
                            "a field name for ComputeRepositoryAccessTokenStatusResponse",
                        )
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "tokenStatus" => Ok(__FieldTag::__token_status),
                            "token_status" => Ok(__FieldTag::__token_status),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ComputeRepositoryAccessTokenStatusResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ComputeRepositoryAccessTokenStatusResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__token_status => {
                            if !fields.insert(__FieldTag::__token_status) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for token_status",
                                ));
                            }
                            result.token_status = map.next_value::<std::option::Option<crate::model::compute_repository_access_token_status_response::TokenStatus>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ComputeRepositoryAccessTokenStatusResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.token_status) {
            state.serialize_entry("tokenStatus", &self.token_status)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ComputeRepositoryAccessTokenStatusResponse].
pub mod compute_repository_access_token_status_response {
    #[allow(unused_imports)]
    use super::*;

    /// Indicates the status of a Git authentication token.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum TokenStatus {
        /// Default value. This value is unused.
        Unspecified,
        /// The token could not be found in Secret Manager (or the Dataform
        /// Service Account did not have permission to access it).
        NotFound,
        /// The token could not be used to authenticate against the Git remote.
        Invalid,
        /// The token was used successfully to authenticate against the Git remote.
        Valid,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [TokenStatus::value] or
        /// [TokenStatus::name].
        UnknownValue(token_status::UnknownValue),
    }

    #[doc(hidden)]
    pub mod token_status {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl TokenStatus {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::NotFound => std::option::Option::Some(1),
                Self::Invalid => std::option::Option::Some(2),
                Self::Valid => std::option::Option::Some(3),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("TOKEN_STATUS_UNSPECIFIED"),
                Self::NotFound => std::option::Option::Some("NOT_FOUND"),
                Self::Invalid => std::option::Option::Some("INVALID"),
                Self::Valid => std::option::Option::Some("VALID"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for TokenStatus {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for TokenStatus {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for TokenStatus {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::NotFound,
                2 => Self::Invalid,
                3 => Self::Valid,
                _ => Self::UnknownValue(token_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for TokenStatus {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "TOKEN_STATUS_UNSPECIFIED" => Self::Unspecified,
                "NOT_FOUND" => Self::NotFound,
                "INVALID" => Self::Invalid,
                "VALID" => Self::Valid,
                _ => Self::UnknownValue(token_status::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for TokenStatus {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::NotFound => serializer.serialize_i32(1),
                Self::Invalid => serializer.serialize_i32(2),
                Self::Valid => serializer.serialize_i32(3),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for TokenStatus {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<TokenStatus>::new(
                ".google.cloud.dataform.v1.ComputeRepositoryAccessTokenStatusResponse.TokenStatus",
            ))
        }
    }
}

/// `FetchRemoteBranches` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchRemoteBranchesRequest {
    /// Required. The repository's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchRemoteBranchesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchRemoteBranchesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FetchRemoteBranchesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchRemoteBranchesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchRemoteBranchesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchRemoteBranchesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchRemoteBranchesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchRemoteBranchesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchRemoteBranchesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchRemoteBranches` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchRemoteBranchesResponse {
    /// The remote repository's branch names.
    pub branches: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchRemoteBranchesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [branches][crate::model::FetchRemoteBranchesResponse::branches].
    pub fn set_branches<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.branches = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchRemoteBranchesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchRemoteBranchesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchRemoteBranchesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __branches,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchRemoteBranchesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "branches" => Ok(__FieldTag::__branches),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchRemoteBranchesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchRemoteBranchesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__branches => {
                            if !fields.insert(__FieldTag::__branches) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for branches",
                                ));
                            }
                            result.branches = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchRemoteBranchesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.branches.is_empty() {
            state.serialize_entry("branches", &self.branches)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Dataform Git workspace.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Workspace {
    /// Identifier. The workspace's name.
    pub name: std::string::String,

    /// Output only. The timestamp of when the workspace was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. A data encryption state of a Git repository if this Workspace
    /// is protected by a KMS key.
    pub data_encryption_state: std::option::Option<crate::model::DataEncryptionState>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Workspace {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Workspace::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Workspace::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Workspace::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [data_encryption_state][crate::model::Workspace::data_encryption_state].
    pub fn set_data_encryption_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_encryption_state][crate::model::Workspace::data_encryption_state].
    pub fn set_or_clear_data_encryption_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::Workspace::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::Workspace::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for Workspace {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.Workspace"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Workspace {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __create_time,
            __data_encryption_state,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Workspace")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "dataEncryptionState" => Ok(__FieldTag::__data_encryption_state),
                            "data_encryption_state" => Ok(__FieldTag::__data_encryption_state),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Workspace;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Workspace")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__data_encryption_state => {
                            if !fields.insert(__FieldTag::__data_encryption_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_encryption_state",
                                ));
                            }
                            result.data_encryption_state = map.next_value::<std::option::Option<crate::model::DataEncryptionState>>()?
                                ;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Workspace {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.data_encryption_state.is_some() {
            state.serialize_entry("dataEncryptionState", &self.data_encryption_state)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListWorkspaces` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkspacesRequest {
    /// Required. The repository in which to list workspaces. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of workspaces to return. The server may return
    /// fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListWorkspaces` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListWorkspaces`, with
    /// the exception of `page_size`, must match the call that provided the page
    /// token.
    pub page_token: std::string::String,

    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    pub order_by: std::string::String,

    /// Optional. Filter for the returned list.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkspacesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkspacesRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkspacesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkspacesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkspacesRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkspacesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkspacesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkspacesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkspacesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkspacesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkspacesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkspacesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkspacesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListWorkspaces` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkspacesResponse {
    /// List of workspaces.
    pub workspaces: std::vec::Vec<crate::model::Workspace>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkspacesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspaces][crate::model::ListWorkspacesResponse::workspaces].
    pub fn set_workspaces<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Workspace>,
    {
        use std::iter::Iterator;
        self.workspaces = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkspacesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkspacesResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkspacesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkspacesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkspacesResponse {
    type PageItem = crate::model::Workspace;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workspaces
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkspacesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspaces,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkspacesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspaces" => Ok(__FieldTag::__workspaces),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkspacesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkspacesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspaces => {
                            if !fields.insert(__FieldTag::__workspaces) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspaces",
                                ));
                            }
                            result.workspaces = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Workspace>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkspacesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspaces.is_empty() {
            state.serialize_entry("workspaces", &self.workspaces)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetWorkspace` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkspaceRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateWorkspace` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkspaceRequest {
    /// Required. The repository in which to create the workspace. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Required. The workspace to create.
    pub workspace: std::option::Option<crate::model::Workspace>,

    /// Required. The ID to use for the workspace, which will become the final
    /// component of the workspace's resource name.
    pub workspace_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkspaceRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workspace][crate::model::CreateWorkspaceRequest::workspace].
    pub fn set_workspace<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Workspace>,
    {
        self.workspace = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workspace][crate::model::CreateWorkspaceRequest::workspace].
    pub fn set_or_clear_workspace<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Workspace>,
    {
        self.workspace = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workspace_id][crate::model::CreateWorkspaceRequest::workspace_id].
    pub fn set_workspace_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workspace,
            __workspace_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workspace" => Ok(__FieldTag::__workspace),
                            "workspaceId" => Ok(__FieldTag::__workspace_id),
                            "workspace_id" => Ok(__FieldTag::__workspace_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace =
                                map.next_value::<std::option::Option<crate::model::Workspace>>()?;
                        }
                        __FieldTag::__workspace_id => {
                            if !fields.insert(__FieldTag::__workspace_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace_id",
                                ));
                            }
                            result.workspace_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.workspace.is_some() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.workspace_id.is_empty() {
            state.serialize_entry("workspaceId", &self.workspace_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `DeleteWorkspace` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkspaceRequest {
    /// Required. The workspace resource's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkspaceRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkspaceRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkspaceRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DeleteWorkspaceRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkspaceRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkspaceRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkspaceRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkspaceRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkspaceRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the author of a Git commit.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitAuthor {
    /// Required. The commit author's name.
    pub name: std::string::String,

    /// Required. The commit author's email address.
    pub email_address: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitAuthor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitAuthor::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [email_address][crate::model::CommitAuthor::email_address].
    pub fn set_email_address<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.email_address = v.into();
        self
    }
}

impl wkt::message::Message for CommitAuthor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitAuthor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitAuthor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __email_address,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitAuthor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "emailAddress" => Ok(__FieldTag::__email_address),
                            "email_address" => Ok(__FieldTag::__email_address),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitAuthor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitAuthor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__email_address => {
                            if !fields.insert(__FieldTag::__email_address) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for email_address",
                                ));
                            }
                            result.email_address = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitAuthor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.email_address.is_empty() {
            state.serialize_entry("emailAddress", &self.email_address)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `PullGitCommits` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PullGitCommitsRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    /// Optional. The name of the branch in the Git remote from which to pull
    /// commits. If left unset, the repository's default branch name will be used.
    pub remote_branch: std::string::String,

    /// Required. The author of any merge commit which may be created as a result
    /// of merging fetched Git commits into this workspace.
    pub author: std::option::Option<crate::model::CommitAuthor>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PullGitCommitsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PullGitCommitsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [remote_branch][crate::model::PullGitCommitsRequest::remote_branch].
    pub fn set_remote_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_branch = v.into();
        self
    }

    /// Sets the value of [author][crate::model::PullGitCommitsRequest::author].
    pub fn set_author<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [author][crate::model::PullGitCommitsRequest::author].
    pub fn set_or_clear_author<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for PullGitCommitsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.PullGitCommitsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PullGitCommitsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __remote_branch,
            __author,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PullGitCommitsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "remoteBranch" => Ok(__FieldTag::__remote_branch),
                            "remote_branch" => Ok(__FieldTag::__remote_branch),
                            "author" => Ok(__FieldTag::__author),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PullGitCommitsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PullGitCommitsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_branch => {
                            if !fields.insert(__FieldTag::__remote_branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_branch",
                                ));
                            }
                            result.remote_branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__author => {
                            if !fields.insert(__FieldTag::__author) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for author",
                                ));
                            }
                            result.author = map
                                .next_value::<std::option::Option<crate::model::CommitAuthor>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PullGitCommitsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.remote_branch.is_empty() {
            state.serialize_entry("remoteBranch", &self.remote_branch)?;
        }
        if self.author.is_some() {
            state.serialize_entry("author", &self.author)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `PullGitCommits` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PullGitCommitsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PullGitCommitsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PullGitCommitsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.PullGitCommitsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PullGitCommitsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PullGitCommitsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PullGitCommitsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PullGitCommitsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PullGitCommitsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `PushGitCommits` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PushGitCommitsRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    /// Optional. The name of the branch in the Git remote to which commits should
    /// be pushed. If left unset, the repository's default branch name will be
    /// used.
    pub remote_branch: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushGitCommitsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::PushGitCommitsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [remote_branch][crate::model::PushGitCommitsRequest::remote_branch].
    pub fn set_remote_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_branch = v.into();
        self
    }
}

impl wkt::message::Message for PushGitCommitsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.PushGitCommitsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PushGitCommitsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __remote_branch,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PushGitCommitsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "remoteBranch" => Ok(__FieldTag::__remote_branch),
                            "remote_branch" => Ok(__FieldTag::__remote_branch),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PushGitCommitsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PushGitCommitsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_branch => {
                            if !fields.insert(__FieldTag::__remote_branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_branch",
                                ));
                            }
                            result.remote_branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PushGitCommitsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.remote_branch.is_empty() {
            state.serialize_entry("remoteBranch", &self.remote_branch)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `PushGitCommits` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct PushGitCommitsResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl PushGitCommitsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for PushGitCommitsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.PushGitCommitsResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for PushGitCommitsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for PushGitCommitsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = PushGitCommitsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct PushGitCommitsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for PushGitCommitsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchFileGitStatuses` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchFileGitStatusesRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchFileGitStatusesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchFileGitStatusesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for FetchFileGitStatusesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchFileGitStatusesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchFileGitStatusesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchFileGitStatusesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchFileGitStatusesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchFileGitStatusesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchFileGitStatusesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchFileGitStatuses` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchFileGitStatusesResponse {
    /// A list of all files which have uncommitted Git changes. There will only be
    /// a single entry for any given file.
    pub uncommitted_file_changes:
        std::vec::Vec<crate::model::fetch_file_git_statuses_response::UncommittedFileChange>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchFileGitStatusesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [uncommitted_file_changes][crate::model::FetchFileGitStatusesResponse::uncommitted_file_changes].
    pub fn set_uncommitted_file_changes<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<
                crate::model::fetch_file_git_statuses_response::UncommittedFileChange,
            >,
    {
        use std::iter::Iterator;
        self.uncommitted_file_changes = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchFileGitStatusesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchFileGitStatusesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchFileGitStatusesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __uncommitted_file_changes,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchFileGitStatusesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "uncommittedFileChanges" => Ok(__FieldTag::__uncommitted_file_changes),
                            "uncommitted_file_changes" => {
                                Ok(__FieldTag::__uncommitted_file_changes)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchFileGitStatusesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchFileGitStatusesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__uncommitted_file_changes => {
                            if !fields.insert(__FieldTag::__uncommitted_file_changes) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for uncommitted_file_changes",
                                ));
                            }
                            result.uncommitted_file_changes = map.next_value::<std::option::Option<std::vec::Vec<crate::model::fetch_file_git_statuses_response::UncommittedFileChange>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchFileGitStatusesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.uncommitted_file_changes.is_empty() {
            state.serialize_entry("uncommittedFileChanges", &self.uncommitted_file_changes)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [FetchFileGitStatusesResponse].
pub mod fetch_file_git_statuses_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the Git state of a file with uncommitted changes.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct UncommittedFileChange {
        /// The file's full path including filename, relative to the workspace root.
        pub path: std::string::String,

        /// Output only. Indicates the status of the file.
        pub state: crate::model::fetch_file_git_statuses_response::uncommitted_file_change::State,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl UncommittedFileChange {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::fetch_file_git_statuses_response::UncommittedFileChange::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [state][crate::model::fetch_file_git_statuses_response::UncommittedFileChange::state].
        pub fn set_state<
            T: std::convert::Into<
                    crate::model::fetch_file_git_statuses_response::uncommitted_file_change::State,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.state = v.into();
            self
        }
    }

    impl wkt::message::Message for UncommittedFileChange {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.FetchFileGitStatusesResponse.UncommittedFileChange"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for UncommittedFileChange {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __path,
                __state,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for UncommittedFileChange")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "path" => Ok(__FieldTag::__path),
                                "state" => Ok(__FieldTag::__state),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = UncommittedFileChange;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct UncommittedFileChange")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__state => {
                                if !fields.insert(__FieldTag::__state) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for state",
                                    ));
                                }
                                result.state = map.next_value::<std::option::Option<crate::model::fetch_file_git_statuses_response::uncommitted_file_change::State>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for UncommittedFileChange {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !wkt::internal::is_default(&self.state) {
                state.serialize_entry("state", &self.state)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [UncommittedFileChange].
    pub mod uncommitted_file_change {
        #[allow(unused_imports)]
        use super::*;

        /// Indicates the status of an uncommitted file change.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum State {
            /// Default value. This value is unused.
            Unspecified,
            /// The file has been newly added.
            Added,
            /// The file has been deleted.
            Deleted,
            /// The file has been modified.
            Modified,
            /// The file contains merge conflicts.
            HasConflicts,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [State::value] or
            /// [State::name].
            UnknownValue(state::UnknownValue),
        }

        #[doc(hidden)]
        pub mod state {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl State {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Added => std::option::Option::Some(1),
                    Self::Deleted => std::option::Option::Some(2),
                    Self::Modified => std::option::Option::Some(3),
                    Self::HasConflicts => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                    Self::Added => std::option::Option::Some("ADDED"),
                    Self::Deleted => std::option::Option::Some("DELETED"),
                    Self::Modified => std::option::Option::Some("MODIFIED"),
                    Self::HasConflicts => std::option::Option::Some("HAS_CONFLICTS"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for State {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for State {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for State {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Added,
                    2 => Self::Deleted,
                    3 => Self::Modified,
                    4 => Self::HasConflicts,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for State {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "STATE_UNSPECIFIED" => Self::Unspecified,
                    "ADDED" => Self::Added,
                    "DELETED" => Self::Deleted,
                    "MODIFIED" => Self::Modified,
                    "HAS_CONFLICTS" => Self::HasConflicts,
                    _ => Self::UnknownValue(state::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for State {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Added => serializer.serialize_i32(1),
                    Self::Deleted => serializer.serialize_i32(2),
                    Self::Modified => serializer.serialize_i32(3),
                    Self::HasConflicts => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for State {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                    ".google.cloud.dataform.v1.FetchFileGitStatusesResponse.UncommittedFileChange.State"))
            }
        }
    }
}

/// `FetchGitAheadBehind` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitAheadBehindRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    /// Optional. The name of the branch in the Git remote against which this
    /// workspace should be compared. If left unset, the repository's default
    /// branch name will be used.
    pub remote_branch: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitAheadBehindRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::FetchGitAheadBehindRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [remote_branch][crate::model::FetchGitAheadBehindRequest::remote_branch].
    pub fn set_remote_branch<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.remote_branch = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitAheadBehindRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchGitAheadBehindRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitAheadBehindRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __remote_branch,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitAheadBehindRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "remoteBranch" => Ok(__FieldTag::__remote_branch),
                            "remote_branch" => Ok(__FieldTag::__remote_branch),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitAheadBehindRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitAheadBehindRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__remote_branch => {
                            if !fields.insert(__FieldTag::__remote_branch) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for remote_branch",
                                ));
                            }
                            result.remote_branch = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitAheadBehindRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.remote_branch.is_empty() {
            state.serialize_entry("remoteBranch", &self.remote_branch)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchGitAheadBehind` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchGitAheadBehindResponse {
    /// The number of commits in the remote branch that are not in the workspace.
    pub commits_ahead: i32,

    /// The number of commits in the workspace that are not in the remote branch.
    pub commits_behind: i32,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitAheadBehindResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [commits_ahead][crate::model::FetchGitAheadBehindResponse::commits_ahead].
    pub fn set_commits_ahead<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.commits_ahead = v.into();
        self
    }

    /// Sets the value of [commits_behind][crate::model::FetchGitAheadBehindResponse::commits_behind].
    pub fn set_commits_behind<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.commits_behind = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitAheadBehindResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchGitAheadBehindResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchGitAheadBehindResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __commits_ahead,
            __commits_behind,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchGitAheadBehindResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "commitsAhead" => Ok(__FieldTag::__commits_ahead),
                            "commits_ahead" => Ok(__FieldTag::__commits_ahead),
                            "commitsBehind" => Ok(__FieldTag::__commits_behind),
                            "commits_behind" => Ok(__FieldTag::__commits_behind),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchGitAheadBehindResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchGitAheadBehindResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__commits_ahead => {
                            if !fields.insert(__FieldTag::__commits_ahead) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commits_ahead",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.commits_ahead =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__commits_behind => {
                            if !fields.insert(__FieldTag::__commits_behind) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commits_behind",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.commits_behind =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchGitAheadBehindResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !wkt::internal::is_default(&self.commits_ahead) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("commitsAhead", &__With(&self.commits_ahead))?;
        }
        if !wkt::internal::is_default(&self.commits_behind) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("commitsBehind", &__With(&self.commits_behind))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CommitWorkspaceChanges` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitWorkspaceChangesRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    /// Required. The commit's author.
    pub author: std::option::Option<crate::model::CommitAuthor>,

    /// Optional. The commit's message.
    pub commit_message: std::string::String,

    /// Optional. Full file paths to commit including filename, rooted at workspace
    /// root. If left empty, all files will be committed.
    pub paths: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitWorkspaceChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CommitWorkspaceChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [author][crate::model::CommitWorkspaceChangesRequest::author].
    pub fn set_author<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [author][crate::model::CommitWorkspaceChangesRequest::author].
    pub fn set_or_clear_author<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CommitAuthor>,
    {
        self.author = v.map(|x| x.into());
        self
    }

    /// Sets the value of [commit_message][crate::model::CommitWorkspaceChangesRequest::commit_message].
    pub fn set_commit_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.commit_message = v.into();
        self
    }

    /// Sets the value of [paths][crate::model::CommitWorkspaceChangesRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for CommitWorkspaceChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitWorkspaceChangesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitWorkspaceChangesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __author,
            __commit_message,
            __paths,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitWorkspaceChangesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "author" => Ok(__FieldTag::__author),
                            "commitMessage" => Ok(__FieldTag::__commit_message),
                            "commit_message" => Ok(__FieldTag::__commit_message),
                            "paths" => Ok(__FieldTag::__paths),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitWorkspaceChangesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitWorkspaceChangesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__author => {
                            if !fields.insert(__FieldTag::__author) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for author",
                                ));
                            }
                            result.author = map
                                .next_value::<std::option::Option<crate::model::CommitAuthor>>()?;
                        }
                        __FieldTag::__commit_message => {
                            if !fields.insert(__FieldTag::__commit_message) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for commit_message",
                                ));
                            }
                            result.commit_message = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitWorkspaceChangesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.author.is_some() {
            state.serialize_entry("author", &self.author)?;
        }
        if !self.commit_message.is_empty() {
            state.serialize_entry("commitMessage", &self.commit_message)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CommitWorkspaceChanges` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CommitWorkspaceChangesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CommitWorkspaceChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CommitWorkspaceChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CommitWorkspaceChangesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CommitWorkspaceChangesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CommitWorkspaceChangesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CommitWorkspaceChangesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CommitWorkspaceChangesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CommitWorkspaceChangesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ResetWorkspaceChanges` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetWorkspaceChangesRequest {
    /// Required. The workspace's name.
    pub name: std::string::String,

    /// Optional. Full file paths to reset back to their committed state including
    /// filename, rooted at workspace root. If left empty, all files will be reset.
    pub paths: std::vec::Vec<std::string::String>,

    /// Optional. If set to true, untracked files will be deleted.
    pub clean: bool,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetWorkspaceChangesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ResetWorkspaceChangesRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [paths][crate::model::ResetWorkspaceChangesRequest::paths].
    pub fn set_paths<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.paths = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [clean][crate::model::ResetWorkspaceChangesRequest::clean].
    pub fn set_clean<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.clean = v.into();
        self
    }
}

impl wkt::message::Message for ResetWorkspaceChangesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ResetWorkspaceChangesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetWorkspaceChangesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __paths,
            __clean,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetWorkspaceChangesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "paths" => Ok(__FieldTag::__paths),
                            "clean" => Ok(__FieldTag::__clean),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetWorkspaceChangesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetWorkspaceChangesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__paths => {
                            if !fields.insert(__FieldTag::__paths) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for paths",
                                ));
                            }
                            result.paths = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__clean => {
                            if !fields.insert(__FieldTag::__clean) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for clean",
                                ));
                            }
                            result.clean = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetWorkspaceChangesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.paths.is_empty() {
            state.serialize_entry("paths", &self.paths)?;
        }
        if !wkt::internal::is_default(&self.clean) {
            state.serialize_entry("clean", &self.clean)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ResetWorkspaceChanges` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ResetWorkspaceChangesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ResetWorkspaceChangesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for ResetWorkspaceChangesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ResetWorkspaceChangesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ResetWorkspaceChangesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ResetWorkspaceChangesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ResetWorkspaceChangesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ResetWorkspaceChangesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ResetWorkspaceChangesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchFileDiff` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchFileDiffRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchFileDiffRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::FetchFileDiffRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::FetchFileDiffRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for FetchFileDiffRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchFileDiffRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchFileDiffRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchFileDiffRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchFileDiffRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchFileDiffRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchFileDiffRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `FetchFileDiff` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FetchFileDiffResponse {
    /// The raw formatted Git diff for the file.
    pub formatted_diff: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchFileDiffResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [formatted_diff][crate::model::FetchFileDiffResponse::formatted_diff].
    pub fn set_formatted_diff<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.formatted_diff = v.into();
        self
    }
}

impl wkt::message::Message for FetchFileDiffResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FetchFileDiffResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FetchFileDiffResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __formatted_diff,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FetchFileDiffResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "formattedDiff" => Ok(__FieldTag::__formatted_diff),
                            "formatted_diff" => Ok(__FieldTag::__formatted_diff),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FetchFileDiffResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FetchFileDiffResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__formatted_diff => {
                            if !fields.insert(__FieldTag::__formatted_diff) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for formatted_diff",
                                ));
                            }
                            result.formatted_diff = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FetchFileDiffResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.formatted_diff.is_empty() {
            state.serialize_entry("formattedDiff", &self.formatted_diff)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryDirectoryContents` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDirectoryContentsRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Optional. The directory's full path including directory name, relative to
    /// the workspace root. If left unset, the workspace root is used.
    pub path: std::string::String,

    /// Optional. Maximum number of paths to return. The server may return fewer
    /// items than requested. If unspecified, the server will pick an appropriate
    /// default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `QueryDirectoryContents`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryDirectoryContents`, with the exception of `page_size`, must match the
    /// call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDirectoryContentsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::QueryDirectoryContentsRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::QueryDirectoryContentsRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryDirectoryContentsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryDirectoryContentsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryDirectoryContentsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryDirectoryContentsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryDirectoryContentsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryDirectoryContentsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryDirectoryContentsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryDirectoryContentsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryDirectoryContentsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryDirectoryContents` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryDirectoryContentsResponse {
    /// List of entries in the directory.
    pub directory_entries: std::vec::Vec<crate::model::DirectoryEntry>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryDirectoryContentsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [directory_entries][crate::model::QueryDirectoryContentsResponse::directory_entries].
    pub fn set_directory_entries<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::DirectoryEntry>,
    {
        use std::iter::Iterator;
        self.directory_entries = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryDirectoryContentsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryDirectoryContentsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryDirectoryContentsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryDirectoryContentsResponse {
    type PageItem = crate::model::DirectoryEntry;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.directory_entries
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryDirectoryContentsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __directory_entries,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryDirectoryContentsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "directoryEntries" => Ok(__FieldTag::__directory_entries),
                            "directory_entries" => Ok(__FieldTag::__directory_entries),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryDirectoryContentsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryDirectoryContentsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__directory_entries => {
                            if !fields.insert(__FieldTag::__directory_entries) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directory_entries",
                                ));
                            }
                            result.directory_entries =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::DirectoryEntry>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryDirectoryContentsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.directory_entries.is_empty() {
            state.serialize_entry("directoryEntries", &self.directory_entries)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single entry in a directory.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DirectoryEntry {
    /// The entry's contents.
    pub entry: std::option::Option<crate::model::directory_entry::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DirectoryEntry {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::DirectoryEntry::entry].
    ///
    /// Note that all the setters affecting `entry` are mutually
    /// exclusive.
    pub fn set_entry<
        T: std::convert::Into<std::option::Option<crate::model::directory_entry::Entry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// The value of [entry][crate::model::DirectoryEntry::entry]
    /// if it holds a `File`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::directory_entry::Entry::File(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::DirectoryEntry::entry]
    /// to hold a `File`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_file<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry =
            std::option::Option::Some(crate::model::directory_entry::Entry::File(v.into()));
        self
    }

    /// The value of [entry][crate::model::DirectoryEntry::entry]
    /// if it holds a `Directory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn directory(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::directory_entry::Entry::Directory(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::DirectoryEntry::entry]
    /// to hold a `Directory`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_directory<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.entry =
            std::option::Option::Some(crate::model::directory_entry::Entry::Directory(v.into()));
        self
    }
}

impl wkt::message::Message for DirectoryEntry {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DirectoryEntry"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DirectoryEntry {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __directory,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DirectoryEntry")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "directory" => Ok(__FieldTag::__directory),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DirectoryEntry;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DirectoryEntry")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            if result.entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry`, a oneof with full ID .google.cloud.dataform.v1.DirectoryEntry.file, latest field was file",
                                ));
                            }
                            result.entry = std::option::Option::Some(
                                crate::model::directory_entry::Entry::File(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__directory => {
                            if !fields.insert(__FieldTag::__directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directory",
                                ));
                            }
                            if result.entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry`, a oneof with full ID .google.cloud.dataform.v1.DirectoryEntry.directory, latest field was directory",
                                ));
                            }
                            result.entry = std::option::Option::Some(
                                crate::model::directory_entry::Entry::Directory(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DirectoryEntry {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.file() {
            state.serialize_entry("file", value)?;
        }
        if let Some(value) = self.directory() {
            state.serialize_entry("directory", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [DirectoryEntry].
pub mod directory_entry {
    #[allow(unused_imports)]
    use super::*;

    /// The entry's contents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Entry {
        /// A file in the directory.
        File(std::string::String),
        /// A child directory in the directory.
        Directory(std::string::String),
    }
}

/// Configuration containing file search request parameters.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchFilesRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Optional. Maximum number of search results to return. The server may return
    /// fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `SearchFilesRequest`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `SearchFilesRequest`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    /// Optional. Optional filter for the returned list in filtering format.
    /// Filtering is only currently supported on the `path` field.
    /// See <https://google.aip.dev/160> for details.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchFilesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::SearchFilesRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::SearchFilesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::SearchFilesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::SearchFilesRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for SearchFilesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.SearchFilesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchFilesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchFilesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchFilesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchFilesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchFilesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Client-facing representation of a file search response.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchFilesResponse {
    /// List of matched results.
    pub search_results: std::vec::Vec<crate::model::SearchResult>,

    /// Optional. A token, which can be sent as `page_token` to retrieve the next
    /// page. If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchFilesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [search_results][crate::model::SearchFilesResponse::search_results].
    pub fn set_search_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::SearchResult>,
    {
        use std::iter::Iterator;
        self.search_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::SearchFilesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for SearchFilesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.SearchFilesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for SearchFilesResponse {
    type PageItem = crate::model::SearchResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.search_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchFilesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __search_results,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchFilesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "searchResults" => Ok(__FieldTag::__search_results),
                            "search_results" => Ok(__FieldTag::__search_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchFilesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchFilesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__search_results => {
                            if !fields.insert(__FieldTag::__search_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for search_results",
                                ));
                            }
                            result.search_results = map.next_value::<std::option::Option<std::vec::Vec<crate::model::SearchResult>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchFilesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.search_results.is_empty() {
            state.serialize_entry("searchResults", &self.search_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Client-facing representation of a search result entry.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct SearchResult {
    /// The entry's contents.
    pub entry: std::option::Option<crate::model::search_result::Entry>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl SearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [entry][crate::model::SearchResult::entry].
    ///
    /// Note that all the setters affecting `entry` are mutually
    /// exclusive.
    pub fn set_entry<
        T: std::convert::Into<std::option::Option<crate::model::search_result::Entry>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry = v.into();
        self
    }

    /// The value of [entry][crate::model::SearchResult::entry]
    /// if it holds a `File`, `None` if the field is not set or
    /// holds a different branch.
    pub fn file(&self) -> std::option::Option<&std::boxed::Box<crate::model::FileSearchResult>> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::search_result::Entry::File(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::SearchResult::entry]
    /// to hold a `File`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_file<T: std::convert::Into<std::boxed::Box<crate::model::FileSearchResult>>>(
        mut self,
        v: T,
    ) -> Self {
        self.entry = std::option::Option::Some(crate::model::search_result::Entry::File(v.into()));
        self
    }

    /// The value of [entry][crate::model::SearchResult::entry]
    /// if it holds a `Directory`, `None` if the field is not set or
    /// holds a different branch.
    pub fn directory(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::DirectorySearchResult>> {
        #[allow(unreachable_patterns)]
        self.entry.as_ref().and_then(|v| match v {
            crate::model::search_result::Entry::Directory(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [entry][crate::model::SearchResult::entry]
    /// to hold a `Directory`.
    ///
    /// Note that all the setters affecting `entry` are
    /// mutually exclusive.
    pub fn set_directory<
        T: std::convert::Into<std::boxed::Box<crate::model::DirectorySearchResult>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.entry =
            std::option::Option::Some(crate::model::search_result::Entry::Directory(v.into()));
        self
    }
}

impl wkt::message::Message for SearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.SearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for SearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file,
            __directory,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for SearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "file" => Ok(__FieldTag::__file),
                            "directory" => Ok(__FieldTag::__directory),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = SearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct SearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file => {
                            if !fields.insert(__FieldTag::__file) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file",
                                ));
                            }
                            if result.entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry`, a oneof with full ID .google.cloud.dataform.v1.SearchResult.file, latest field was file",
                                ));
                            }
                            result.entry = std::option::Option::Some(
                                crate::model::search_result::Entry::File(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::FileSearchResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__directory => {
                            if !fields.insert(__FieldTag::__directory) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for directory",
                                ));
                            }
                            if result.entry.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `entry`, a oneof with full ID .google.cloud.dataform.v1.SearchResult.directory, latest field was directory",
                                ));
                            }
                            result.entry = std::option::Option::Some(
                                crate::model::search_result::Entry::Directory(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<crate::model::DirectorySearchResult>,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for SearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.file() {
            state.serialize_entry("file", value)?;
        }
        if let Some(value) = self.directory() {
            state.serialize_entry("directory", value)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [SearchResult].
pub mod search_result {
    #[allow(unused_imports)]
    use super::*;

    /// The entry's contents.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Entry {
        /// Details when search result is a file.
        File(std::boxed::Box<crate::model::FileSearchResult>),
        /// Details when search result is a directory.
        Directory(std::boxed::Box<crate::model::DirectorySearchResult>),
    }
}

/// Client-facing representation of a file entry in search results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct FileSearchResult {
    /// File system path relative to the workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FileSearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::FileSearchResult::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for FileSearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.FileSearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for FileSearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for FileSearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = FileSearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct FileSearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for FileSearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Client-facing representation of a directory entry in search results.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DirectorySearchResult {
    /// File system path relative to the workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DirectorySearchResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [path][crate::model::DirectorySearchResult::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for DirectorySearchResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DirectorySearchResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DirectorySearchResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DirectorySearchResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DirectorySearchResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DirectorySearchResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DirectorySearchResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MakeDirectory` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MakeDirectoryRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MakeDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::MakeDirectoryRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::MakeDirectoryRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for MakeDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MakeDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MakeDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MakeDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MakeDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MakeDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MakeDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MakeDirectory` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MakeDirectoryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MakeDirectoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MakeDirectoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MakeDirectoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MakeDirectoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MakeDirectoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MakeDirectoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MakeDirectoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MakeDirectoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `RemoveDirectory` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveDirectoryRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::RemoveDirectoryRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::RemoveDirectoryRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for RemoveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.RemoveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `RemoveDirectory` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveDirectoryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveDirectoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveDirectoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.RemoveDirectoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveDirectoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveDirectoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveDirectoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveDirectoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveDirectoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MoveDirectory` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveDirectoryRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The directory's full path including directory name, relative to
    /// the workspace root.
    pub path: std::string::String,

    /// Required. The new path for the directory including directory name, rooted
    /// at workspace root.
    pub new_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveDirectoryRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::MoveDirectoryRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::MoveDirectoryRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [new_path][crate::model::MoveDirectoryRequest::new_path].
    pub fn set_new_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_path = v.into();
        self
    }
}

impl wkt::message::Message for MoveDirectoryRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MoveDirectoryRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveDirectoryRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            __new_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveDirectoryRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            "newPath" => Ok(__FieldTag::__new_path),
                            "new_path" => Ok(__FieldTag::__new_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveDirectoryRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveDirectoryRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_path => {
                            if !fields.insert(__FieldTag::__new_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_path",
                                ));
                            }
                            result.new_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveDirectoryRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.new_path.is_empty() {
            state.serialize_entry("newPath", &self.new_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MoveDirectory` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveDirectoryResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveDirectoryResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MoveDirectoryResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MoveDirectoryResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveDirectoryResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveDirectoryResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveDirectoryResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveDirectoryResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveDirectoryResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ReadFile` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReadFileRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    pub path: std::string::String,

    /// Optional. The Git revision of the file to return. If left empty, the
    /// current contents of `path` will be returned.
    pub revision: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::ReadFileRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::ReadFileRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [revision][crate::model::ReadFileRequest::revision].
    pub fn set_revision<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.revision = v.into();
        self
    }
}

impl wkt::message::Message for ReadFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ReadFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            __revision,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            "revision" => Ok(__FieldTag::__revision),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__revision => {
                            if !fields.insert(__FieldTag::__revision) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for revision",
                                ));
                            }
                            result.revision = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.revision.is_empty() {
            state.serialize_entry("revision", &self.revision)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ReadFile` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReadFileResponse {
    /// The file's contents.
    pub file_contents: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReadFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [file_contents][crate::model::ReadFileResponse::file_contents].
    pub fn set_file_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.file_contents = v.into();
        self
    }
}

impl wkt::message::Message for ReadFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ReadFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReadFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __file_contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReadFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "fileContents" => Ok(__FieldTag::__file_contents),
                            "file_contents" => Ok(__FieldTag::__file_contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReadFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReadFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__file_contents => {
                            if !fields.insert(__FieldTag::__file_contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.file_contents =
                                map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReadFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.file_contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("fileContents", &__With(&self.file_contents))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `RemoveFile` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveFileRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    pub path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::RemoveFileRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::RemoveFileRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }
}

impl wkt::message::Message for RemoveFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.RemoveFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `RemoveFile` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RemoveFileResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RemoveFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for RemoveFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.RemoveFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RemoveFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RemoveFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RemoveFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RemoveFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RemoveFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MoveFile` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveFileRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The file's full path including filename, relative to the
    /// workspace root.
    pub path: std::string::String,

    /// Required. The file's new path including filename, relative to the workspace
    /// root.
    pub new_path: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::MoveFileRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::MoveFileRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [new_path][crate::model::MoveFileRequest::new_path].
    pub fn set_new_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.new_path = v.into();
        self
    }
}

impl wkt::message::Message for MoveFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MoveFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            __new_path,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            "newPath" => Ok(__FieldTag::__new_path),
                            "new_path" => Ok(__FieldTag::__new_path),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__new_path => {
                            if !fields.insert(__FieldTag::__new_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for new_path",
                                ));
                            }
                            result.new_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.new_path.is_empty() {
            state.serialize_entry("newPath", &self.new_path)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `MoveFile` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct MoveFileResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl MoveFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for MoveFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.MoveFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for MoveFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for MoveFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = MoveFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct MoveFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for MoveFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `WriteFile` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteFileRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    /// Required. The file.
    pub path: std::string::String,

    /// Required. The file's contents.
    pub contents: ::bytes::Bytes,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteFileRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::WriteFileRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }

    /// Sets the value of [path][crate::model::WriteFileRequest::path].
    pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.path = v.into();
        self
    }

    /// Sets the value of [contents][crate::model::WriteFileRequest::contents].
    pub fn set_contents<T: std::convert::Into<::bytes::Bytes>>(mut self, v: T) -> Self {
        self.contents = v.into();
        self
    }
}

impl wkt::message::Message for WriteFileRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.WriteFileRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteFileRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            __path,
            __contents,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteFileRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            "path" => Ok(__FieldTag::__path),
                            "contents" => Ok(__FieldTag::__contents),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteFileRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteFileRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__path => {
                            if !fields.insert(__FieldTag::__path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for path",
                                ));
                            }
                            result.path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__contents => {
                            if !fields.insert(__FieldTag::__contents) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for contents",
                                ));
                            }
                            struct __With(std::option::Option<::bytes::Bytes>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<serde_with::base64::Base64> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.contents = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteFileRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self.path.is_empty() {
            state.serialize_entry("path", &self.path)?;
        }
        if !self.contents.is_empty() {
            struct __With<'a>(&'a ::bytes::Bytes);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<serde_with::base64::Base64>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("contents", &__With(&self.contents))?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `WriteFile` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WriteFileResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WriteFileResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for WriteFileResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.WriteFileResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WriteFileResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WriteFileResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WriteFileResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WriteFileResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WriteFileResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `InstallNpmPackages` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstallNpmPackagesRequest {
    /// Required. The workspace's name.
    pub workspace: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallNpmPackagesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workspace][crate::model::InstallNpmPackagesRequest::workspace].
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.workspace = v.into();
        self
    }
}

impl wkt::message::Message for InstallNpmPackagesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.InstallNpmPackagesRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstallNpmPackagesRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workspace,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstallNpmPackagesRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workspace" => Ok(__FieldTag::__workspace),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstallNpmPackagesRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstallNpmPackagesRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            result.workspace = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstallNpmPackagesRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workspace.is_empty() {
            state.serialize_entry("workspace", &self.workspace)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `InstallNpmPackages` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InstallNpmPackagesResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallNpmPackagesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for InstallNpmPackagesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.InstallNpmPackagesResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InstallNpmPackagesResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InstallNpmPackagesResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InstallNpmPackagesResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InstallNpmPackagesResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InstallNpmPackagesResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Dataform release configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ReleaseConfig {
    /// Identifier. The release config's name.
    pub name: std::string::String,

    /// Required. Git commit/tag/branch name at which the repository should be
    /// compiled. Must exist in the remote repository. Examples:
    ///
    /// - a commit SHA: `12ade345`
    /// - a tag: `tag1`
    /// - a branch name: `branch1`
    pub git_commitish: std::string::String,

    /// Optional. If set, fields of `code_compilation_config` override the default
    /// compilation settings that are specified in dataform.json.
    pub code_compilation_config: std::option::Option<crate::model::CodeCompilationConfig>,

    /// Optional. Optional schedule (in cron format) for automatic creation of
    /// compilation results.
    pub cron_schedule: std::string::String,

    /// Optional. Specifies the time zone to be used when interpreting
    /// cron_schedule. Must be a time zone name from the time zone database
    /// (<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>). If left
    /// unspecified, the default is UTC.
    pub time_zone: std::string::String,

    /// Output only. Records of the 10 most recent scheduled release attempts,
    /// ordered in descending order of `release_time`. Updated whenever automatic
    /// creation of a compilation result is triggered by cron_schedule.
    pub recent_scheduled_release_records:
        std::vec::Vec<crate::model::release_config::ScheduledReleaseRecord>,

    /// Optional. The name of the currently released compilation result for this
    /// release config. This value is updated when a compilation result is
    /// automatically created from this release config (using cron_schedule), or
    /// when this resource is updated by API call (perhaps to roll back to an
    /// earlier release). The compilation result must have been created using this
    /// release config. Must be in the format
    /// `projects/*/locations/*/repositories/*/compilationResults/*`.
    pub release_compilation_result: std::string::String,

    /// Optional. Disables automatic creation of compilation results.
    pub disabled: bool,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ReleaseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::ReleaseConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [git_commitish][crate::model::ReleaseConfig::git_commitish].
    pub fn set_git_commitish<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_commitish = v.into();
        self
    }

    /// Sets the value of [code_compilation_config][crate::model::ReleaseConfig::code_compilation_config].
    pub fn set_code_compilation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CodeCompilationConfig>,
    {
        self.code_compilation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [code_compilation_config][crate::model::ReleaseConfig::code_compilation_config].
    pub fn set_or_clear_code_compilation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CodeCompilationConfig>,
    {
        self.code_compilation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cron_schedule][crate::model::ReleaseConfig::cron_schedule].
    pub fn set_cron_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cron_schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::ReleaseConfig::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [recent_scheduled_release_records][crate::model::ReleaseConfig::recent_scheduled_release_records].
    pub fn set_recent_scheduled_release_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::release_config::ScheduledReleaseRecord>,
    {
        use std::iter::Iterator;
        self.recent_scheduled_release_records = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [release_compilation_result][crate::model::ReleaseConfig::release_compilation_result].
    pub fn set_release_compilation_result<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_compilation_result = v.into();
        self
    }

    /// Sets the value of [disabled][crate::model::ReleaseConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [internal_metadata][crate::model::ReleaseConfig::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::ReleaseConfig::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for ReleaseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ReleaseConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ReleaseConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __git_commitish,
            __code_compilation_config,
            __cron_schedule,
            __time_zone,
            __recent_scheduled_release_records,
            __release_compilation_result,
            __disabled,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ReleaseConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "gitCommitish" => Ok(__FieldTag::__git_commitish),
                            "git_commitish" => Ok(__FieldTag::__git_commitish),
                            "codeCompilationConfig" => Ok(__FieldTag::__code_compilation_config),
                            "code_compilation_config" => Ok(__FieldTag::__code_compilation_config),
                            "cronSchedule" => Ok(__FieldTag::__cron_schedule),
                            "cron_schedule" => Ok(__FieldTag::__cron_schedule),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "recentScheduledReleaseRecords" => {
                                Ok(__FieldTag::__recent_scheduled_release_records)
                            }
                            "recent_scheduled_release_records" => {
                                Ok(__FieldTag::__recent_scheduled_release_records)
                            }
                            "releaseCompilationResult" => {
                                Ok(__FieldTag::__release_compilation_result)
                            }
                            "release_compilation_result" => {
                                Ok(__FieldTag::__release_compilation_result)
                            }
                            "disabled" => Ok(__FieldTag::__disabled),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ReleaseConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ReleaseConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__git_commitish => {
                            if !fields.insert(__FieldTag::__git_commitish) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_commitish",
                                ));
                            }
                            result.git_commitish = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code_compilation_config => {
                            if !fields.insert(__FieldTag::__code_compilation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code_compilation_config",
                                ));
                            }
                            result.code_compilation_config = map.next_value::<std::option::Option<crate::model::CodeCompilationConfig>>()?
                                ;
                        }
                        __FieldTag::__cron_schedule => {
                            if !fields.insert(__FieldTag::__cron_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cron_schedule",
                                ));
                            }
                            result.cron_schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recent_scheduled_release_records => {
                            if !fields.insert(__FieldTag::__recent_scheduled_release_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_scheduled_release_records",
                                ));
                            }
                            result.recent_scheduled_release_records = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::release_config::ScheduledReleaseRecord,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_compilation_result => {
                            if !fields.insert(__FieldTag::__release_compilation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_compilation_result",
                                ));
                            }
                            result.release_compilation_result = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ReleaseConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.git_commitish.is_empty() {
            state.serialize_entry("gitCommitish", &self.git_commitish)?;
        }
        if self.code_compilation_config.is_some() {
            state.serialize_entry("codeCompilationConfig", &self.code_compilation_config)?;
        }
        if !self.cron_schedule.is_empty() {
            state.serialize_entry("cronSchedule", &self.cron_schedule)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.recent_scheduled_release_records.is_empty() {
            state.serialize_entry(
                "recentScheduledReleaseRecords",
                &self.recent_scheduled_release_records,
            )?;
        }
        if !self.release_compilation_result.is_empty() {
            state.serialize_entry("releaseCompilationResult", &self.release_compilation_result)?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [ReleaseConfig].
pub mod release_config {
    #[allow(unused_imports)]
    use super::*;

    /// A record of an attempt to create a compilation result for this release
    /// config.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ScheduledReleaseRecord {
        /// Output only. The timestamp of this release attempt.
        pub release_time: std::option::Option<wkt::Timestamp>,

        /// The result of this release attempt.
        pub result:
            std::option::Option<crate::model::release_config::scheduled_release_record::Result>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScheduledReleaseRecord {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [release_time][crate::model::release_config::ScheduledReleaseRecord::release_time].
        pub fn set_release_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.release_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [release_time][crate::model::release_config::ScheduledReleaseRecord::release_time].
        pub fn set_or_clear_release_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.release_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [result][crate::model::release_config::ScheduledReleaseRecord::result].
        ///
        /// Note that all the setters affecting `result` are mutually
        /// exclusive.
        pub fn set_result<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::release_config::scheduled_release_record::Result,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.result = v.into();
            self
        }

        /// The value of [result][crate::model::release_config::ScheduledReleaseRecord::result]
        /// if it holds a `CompilationResult`, `None` if the field is not set or
        /// holds a different branch.
        pub fn compilation_result(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::release_config::scheduled_release_record::Result::CompilationResult(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::release_config::ScheduledReleaseRecord::result]
        /// to hold a `CompilationResult`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_compilation_result<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::release_config::scheduled_release_record::Result::CompilationResult(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [result][crate::model::release_config::ScheduledReleaseRecord::result]
        /// if it holds a `ErrorStatus`, `None` if the field is not set or
        /// holds a different branch.
        pub fn error_status(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::release_config::scheduled_release_record::Result::ErrorStatus(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::release_config::ScheduledReleaseRecord::result]
        /// to hold a `ErrorStatus`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_error_status<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::release_config::scheduled_release_record::Result::ErrorStatus(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ScheduledReleaseRecord {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.ReleaseConfig.ScheduledReleaseRecord"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ScheduledReleaseRecord {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __compilation_result,
                __error_status,
                __release_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ScheduledReleaseRecord")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "compilationResult" => Ok(__FieldTag::__compilation_result),
                                "compilation_result" => Ok(__FieldTag::__compilation_result),
                                "errorStatus" => Ok(__FieldTag::__error_status),
                                "error_status" => Ok(__FieldTag::__error_status),
                                "releaseTime" => Ok(__FieldTag::__release_time),
                                "release_time" => Ok(__FieldTag::__release_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ScheduledReleaseRecord;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ScheduledReleaseRecord")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__compilation_result => {
                                if !fields.insert(__FieldTag::__compilation_result) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for compilation_result",
                                    ));
                                }
                                if result.result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `result`, a oneof with full ID .google.cloud.dataform.v1.ReleaseConfig.ScheduledReleaseRecord.compilation_result, latest field was compilationResult",
                                    ));
                                }
                                result.result = std::option::Option::Some(
                                    crate::model::release_config::scheduled_release_record::Result::CompilationResult(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__error_status => {
                                if !fields.insert(__FieldTag::__error_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_status",
                                    ));
                                }
                                if result.result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `result`, a oneof with full ID .google.cloud.dataform.v1.ReleaseConfig.ScheduledReleaseRecord.error_status, latest field was errorStatus",
                                    ));
                                }
                                result.result = std::option::Option::Some(
                                    crate::model::release_config::scheduled_release_record::Result::ErrorStatus(
                                        map.next_value::<std::option::Option<std::boxed::Box<rpc::model::Status>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__release_time => {
                                if !fields.insert(__FieldTag::__release_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for release_time",
                                    ));
                                }
                                result.release_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ScheduledReleaseRecord {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.compilation_result() {
                state.serialize_entry("compilationResult", value)?;
            }
            if let Some(value) = self.error_status() {
                state.serialize_entry("errorStatus", value)?;
            }
            if self.release_time.is_some() {
                state.serialize_entry("releaseTime", &self.release_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ScheduledReleaseRecord].
    pub mod scheduled_release_record {
        #[allow(unused_imports)]
        use super::*;

        /// The result of this release attempt.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Result {
            /// The name of the created compilation result, if one was successfully
            /// created. Must be in the format
            /// `projects/*/locations/*/repositories/*/compilationResults/*`.
            CompilationResult(std::string::String),
            /// The error status encountered upon this attempt to create the
            /// compilation result, if the attempt was unsuccessful.
            ErrorStatus(std::boxed::Box<rpc::model::Status>),
        }
    }
}

/// `ListReleaseConfigs` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReleaseConfigsRequest {
    /// Required. The repository in which to list release configs. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of release configs to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListReleaseConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListReleaseConfigs`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleaseConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListReleaseConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListReleaseConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListReleaseConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListReleaseConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListReleaseConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReleaseConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReleaseConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReleaseConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReleaseConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReleaseConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListReleaseConfigs` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListReleaseConfigsResponse {
    /// List of release configs.
    pub release_configs: std::vec::Vec<crate::model::ReleaseConfig>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListReleaseConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [release_configs][crate::model::ListReleaseConfigsResponse::release_configs].
    pub fn set_release_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::ReleaseConfig>,
    {
        use std::iter::Iterator;
        self.release_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListReleaseConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListReleaseConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListReleaseConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListReleaseConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListReleaseConfigsResponse {
    type PageItem = crate::model::ReleaseConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.release_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListReleaseConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __release_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListReleaseConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "releaseConfigs" => Ok(__FieldTag::__release_configs),
                            "release_configs" => Ok(__FieldTag::__release_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListReleaseConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListReleaseConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__release_configs => {
                            if !fields.insert(__FieldTag::__release_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_configs",
                                ));
                            }
                            result.release_configs = map.next_value::<std::option::Option<std::vec::Vec<crate::model::ReleaseConfig>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListReleaseConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.release_configs.is_empty() {
            state.serialize_entry("releaseConfigs", &self.release_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetReleaseConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetReleaseConfigRequest {
    /// Required. The release config's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetReleaseConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetReleaseConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetReleaseConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetReleaseConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetReleaseConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetReleaseConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetReleaseConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetReleaseConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetReleaseConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateReleaseConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateReleaseConfigRequest {
    /// Required. The repository in which to create the release config. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Required. The release config to create.
    pub release_config: std::option::Option<crate::model::ReleaseConfig>,

    /// Required. The ID to use for the release config, which will become the final
    /// component of the release config's resource name.
    pub release_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateReleaseConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateReleaseConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [release_config][crate::model::CreateReleaseConfigRequest::release_config].
    pub fn set_release_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseConfig>,
    {
        self.release_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_config][crate::model::CreateReleaseConfigRequest::release_config].
    pub fn set_or_clear_release_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseConfig>,
    {
        self.release_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [release_config_id][crate::model::CreateReleaseConfigRequest::release_config_id].
    pub fn set_release_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.release_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateReleaseConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateReleaseConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateReleaseConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __release_config,
            __release_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateReleaseConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "releaseConfig" => Ok(__FieldTag::__release_config),
                            "release_config" => Ok(__FieldTag::__release_config),
                            "releaseConfigId" => Ok(__FieldTag::__release_config_id),
                            "release_config_id" => Ok(__FieldTag::__release_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateReleaseConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateReleaseConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_config => {
                            if !fields.insert(__FieldTag::__release_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_config",
                                ));
                            }
                            result.release_config = map
                                .next_value::<std::option::Option<crate::model::ReleaseConfig>>()?;
                        }
                        __FieldTag::__release_config_id => {
                            if !fields.insert(__FieldTag::__release_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_config_id",
                                ));
                            }
                            result.release_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateReleaseConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.release_config.is_some() {
            state.serialize_entry("releaseConfig", &self.release_config)?;
        }
        if !self.release_config_id.is_empty() {
            state.serialize_entry("releaseConfigId", &self.release_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `UpdateReleaseConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateReleaseConfigRequest {
    /// Optional. Specifies the fields to be updated in the release config. If left
    /// unset, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The release config to update.
    pub release_config: std::option::Option<crate::model::ReleaseConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateReleaseConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateReleaseConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateReleaseConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [release_config][crate::model::UpdateReleaseConfigRequest::release_config].
    pub fn set_release_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseConfig>,
    {
        self.release_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [release_config][crate::model::UpdateReleaseConfigRequest::release_config].
    pub fn set_or_clear_release_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ReleaseConfig>,
    {
        self.release_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateReleaseConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.UpdateReleaseConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateReleaseConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __release_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateReleaseConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "releaseConfig" => Ok(__FieldTag::__release_config),
                            "release_config" => Ok(__FieldTag::__release_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateReleaseConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateReleaseConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__release_config => {
                            if !fields.insert(__FieldTag::__release_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_config",
                                ));
                            }
                            result.release_config = map
                                .next_value::<std::option::Option<crate::model::ReleaseConfig>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateReleaseConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.release_config.is_some() {
            state.serialize_entry("releaseConfig", &self.release_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `DeleteReleaseConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteReleaseConfigRequest {
    /// Required. The release config's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteReleaseConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteReleaseConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteReleaseConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DeleteReleaseConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteReleaseConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteReleaseConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteReleaseConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteReleaseConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteReleaseConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents the result of compiling a Dataform project.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompilationResult {
    /// Output only. The compilation result's name.
    pub name: std::string::String,

    /// Immutable. If set, fields of `code_compilation_config` override the default
    /// compilation settings that are specified in dataform.json.
    pub code_compilation_config: std::option::Option<crate::model::CodeCompilationConfig>,

    /// Output only. The fully resolved Git commit SHA of the code that was
    /// compiled. Not set for compilation results whose source is a workspace.
    pub resolved_git_commit_sha: std::string::String,

    /// Output only. The version of `@dataform/core` that was used for compilation.
    pub dataform_core_version: std::string::String,

    /// Output only. Errors encountered during project compilation.
    pub compilation_errors: std::vec::Vec<crate::model::compilation_result::CompilationError>,

    /// Output only. Only set if the repository has a KMS Key.
    pub data_encryption_state: std::option::Option<crate::model::DataEncryptionState>,

    /// Output only. The timestamp of when the compilation result was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    /// The source of the compilation result.
    pub source: std::option::Option<crate::model::compilation_result::Source>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompilationResult {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CompilationResult::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [code_compilation_config][crate::model::CompilationResult::code_compilation_config].
    pub fn set_code_compilation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CodeCompilationConfig>,
    {
        self.code_compilation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [code_compilation_config][crate::model::CompilationResult::code_compilation_config].
    pub fn set_or_clear_code_compilation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CodeCompilationConfig>,
    {
        self.code_compilation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_git_commit_sha][crate::model::CompilationResult::resolved_git_commit_sha].
    pub fn set_resolved_git_commit_sha<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_git_commit_sha = v.into();
        self
    }

    /// Sets the value of [dataform_core_version][crate::model::CompilationResult::dataform_core_version].
    pub fn set_dataform_core_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.dataform_core_version = v.into();
        self
    }

    /// Sets the value of [compilation_errors][crate::model::CompilationResult::compilation_errors].
    pub fn set_compilation_errors<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::compilation_result::CompilationError>,
    {
        use std::iter::Iterator;
        self.compilation_errors = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [data_encryption_state][crate::model::CompilationResult::data_encryption_state].
    pub fn set_data_encryption_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_encryption_state][crate::model::CompilationResult::data_encryption_state].
    pub fn set_or_clear_data_encryption_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [create_time][crate::model::CompilationResult::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::CompilationResult::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::CompilationResult::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::CompilationResult::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [source][crate::model::CompilationResult::source].
    ///
    /// Note that all the setters affecting `source` are mutually
    /// exclusive.
    pub fn set_source<
        T: std::convert::Into<std::option::Option<crate::model::compilation_result::Source>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.source = v.into();
        self
    }

    /// The value of [source][crate::model::CompilationResult::source]
    /// if it holds a `GitCommitish`, `None` if the field is not set or
    /// holds a different branch.
    pub fn git_commitish(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::compilation_result::Source::GitCommitish(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CompilationResult::source]
    /// to hold a `GitCommitish`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_git_commitish<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::compilation_result::Source::GitCommitish(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::CompilationResult::source]
    /// if it holds a `Workspace`, `None` if the field is not set or
    /// holds a different branch.
    pub fn workspace(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::compilation_result::Source::Workspace(v) => std::option::Option::Some(v),
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CompilationResult::source]
    /// to hold a `Workspace`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_workspace<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::compilation_result::Source::Workspace(v.into()),
        );
        self
    }

    /// The value of [source][crate::model::CompilationResult::source]
    /// if it holds a `ReleaseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn release_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.source.as_ref().and_then(|v| match v {
            crate::model::compilation_result::Source::ReleaseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [source][crate::model::CompilationResult::source]
    /// to hold a `ReleaseConfig`.
    ///
    /// Note that all the setters affecting `source` are
    /// mutually exclusive.
    pub fn set_release_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.source = std::option::Option::Some(
            crate::model::compilation_result::Source::ReleaseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CompilationResult {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CompilationResult"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompilationResult {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __git_commitish,
            __workspace,
            __release_config,
            __name,
            __code_compilation_config,
            __resolved_git_commit_sha,
            __dataform_core_version,
            __compilation_errors,
            __data_encryption_state,
            __create_time,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompilationResult")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gitCommitish" => Ok(__FieldTag::__git_commitish),
                            "git_commitish" => Ok(__FieldTag::__git_commitish),
                            "workspace" => Ok(__FieldTag::__workspace),
                            "releaseConfig" => Ok(__FieldTag::__release_config),
                            "release_config" => Ok(__FieldTag::__release_config),
                            "name" => Ok(__FieldTag::__name),
                            "codeCompilationConfig" => Ok(__FieldTag::__code_compilation_config),
                            "code_compilation_config" => Ok(__FieldTag::__code_compilation_config),
                            "resolvedGitCommitSha" => Ok(__FieldTag::__resolved_git_commit_sha),
                            "resolved_git_commit_sha" => Ok(__FieldTag::__resolved_git_commit_sha),
                            "dataformCoreVersion" => Ok(__FieldTag::__dataform_core_version),
                            "dataform_core_version" => Ok(__FieldTag::__dataform_core_version),
                            "compilationErrors" => Ok(__FieldTag::__compilation_errors),
                            "compilation_errors" => Ok(__FieldTag::__compilation_errors),
                            "dataEncryptionState" => Ok(__FieldTag::__data_encryption_state),
                            "data_encryption_state" => Ok(__FieldTag::__data_encryption_state),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompilationResult;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompilationResult")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__git_commitish => {
                            if !fields.insert(__FieldTag::__git_commitish) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for git_commitish",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dataform.v1.CompilationResult.git_commitish, latest field was gitCommitish",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::compilation_result::Source::GitCommitish(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__workspace => {
                            if !fields.insert(__FieldTag::__workspace) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workspace",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dataform.v1.CompilationResult.workspace, latest field was workspace",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::compilation_result::Source::Workspace(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__release_config => {
                            if !fields.insert(__FieldTag::__release_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_config",
                                ));
                            }
                            if result.source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `source`, a oneof with full ID .google.cloud.dataform.v1.CompilationResult.release_config, latest field was releaseConfig",
                                ));
                            }
                            result.source = std::option::Option::Some(
                                crate::model::compilation_result::Source::ReleaseConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__code_compilation_config => {
                            if !fields.insert(__FieldTag::__code_compilation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for code_compilation_config",
                                ));
                            }
                            result.code_compilation_config = map.next_value::<std::option::Option<crate::model::CodeCompilationConfig>>()?
                                ;
                        }
                        __FieldTag::__resolved_git_commit_sha => {
                            if !fields.insert(__FieldTag::__resolved_git_commit_sha) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_git_commit_sha",
                                ));
                            }
                            result.resolved_git_commit_sha = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__dataform_core_version => {
                            if !fields.insert(__FieldTag::__dataform_core_version) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for dataform_core_version",
                                ));
                            }
                            result.dataform_core_version = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compilation_errors => {
                            if !fields.insert(__FieldTag::__compilation_errors) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compilation_errors",
                                ));
                            }
                            result.compilation_errors = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::compilation_result::CompilationError,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_encryption_state => {
                            if !fields.insert(__FieldTag::__data_encryption_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_encryption_state",
                                ));
                            }
                            result.data_encryption_state = map.next_value::<std::option::Option<crate::model::DataEncryptionState>>()?
                                ;
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompilationResult {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.git_commitish() {
            state.serialize_entry("gitCommitish", value)?;
        }
        if let Some(value) = self.workspace() {
            state.serialize_entry("workspace", value)?;
        }
        if let Some(value) = self.release_config() {
            state.serialize_entry("releaseConfig", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.code_compilation_config.is_some() {
            state.serialize_entry("codeCompilationConfig", &self.code_compilation_config)?;
        }
        if !self.resolved_git_commit_sha.is_empty() {
            state.serialize_entry("resolvedGitCommitSha", &self.resolved_git_commit_sha)?;
        }
        if !self.dataform_core_version.is_empty() {
            state.serialize_entry("dataformCoreVersion", &self.dataform_core_version)?;
        }
        if !self.compilation_errors.is_empty() {
            state.serialize_entry("compilationErrors", &self.compilation_errors)?;
        }
        if self.data_encryption_state.is_some() {
            state.serialize_entry("dataEncryptionState", &self.data_encryption_state)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CompilationResult].
pub mod compilation_result {
    #[allow(unused_imports)]
    use super::*;

    /// An error encountered when attempting to compile a Dataform project.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct CompilationError {
        /// Output only. The error's top level message.
        pub message: std::string::String,

        /// Output only. The error's full stack trace.
        pub stack: std::string::String,

        /// Output only. The path of the file where this error occurred, if
        /// available, relative to the project root.
        pub path: std::string::String,

        /// Output only. The identifier of the action where this error occurred, if
        /// available.
        pub action_target: std::option::Option<crate::model::Target>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl CompilationError {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [message][crate::model::compilation_result::CompilationError::message].
        pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.message = v.into();
            self
        }

        /// Sets the value of [stack][crate::model::compilation_result::CompilationError::stack].
        pub fn set_stack<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.stack = v.into();
            self
        }

        /// Sets the value of [path][crate::model::compilation_result::CompilationError::path].
        pub fn set_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.path = v.into();
            self
        }

        /// Sets the value of [action_target][crate::model::compilation_result::CompilationError::action_target].
        pub fn set_action_target<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Target>,
        {
            self.action_target = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [action_target][crate::model::compilation_result::CompilationError::action_target].
        pub fn set_or_clear_action_target<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Target>,
        {
            self.action_target = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for CompilationError {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResult.CompilationError"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for CompilationError {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __message,
                __stack,
                __path,
                __action_target,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for CompilationError")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "message" => Ok(__FieldTag::__message),
                                "stack" => Ok(__FieldTag::__stack),
                                "path" => Ok(__FieldTag::__path),
                                "actionTarget" => Ok(__FieldTag::__action_target),
                                "action_target" => Ok(__FieldTag::__action_target),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = CompilationError;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct CompilationError")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__message => {
                                if !fields.insert(__FieldTag::__message) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for message",
                                    ));
                                }
                                result.message = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__stack => {
                                if !fields.insert(__FieldTag::__stack) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for stack",
                                    ));
                                }
                                result.stack = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__action_target => {
                                if !fields.insert(__FieldTag::__action_target) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for action_target",
                                    ));
                                }
                                result.action_target =
                                    map.next_value::<std::option::Option<crate::model::Target>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for CompilationError {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.message.is_empty() {
                state.serialize_entry("message", &self.message)?;
            }
            if !self.stack.is_empty() {
                state.serialize_entry("stack", &self.stack)?;
            }
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if self.action_target.is_some() {
                state.serialize_entry("actionTarget", &self.action_target)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The source of the compilation result.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Source {
        /// Immutable. Git commit/tag/branch name at which the repository should be
        /// compiled. Must exist in the remote repository. Examples:
        ///
        /// - a commit SHA: `12ade345`
        /// - a tag: `tag1`
        /// - a branch name: `branch1`
        GitCommitish(std::string::String),
        /// Immutable. The name of the workspace to compile. Must be in the format
        /// `projects/*/locations/*/repositories/*/workspaces/*`.
        Workspace(std::string::String),
        /// Immutable. The name of the release config to compile. Must be in the
        /// format `projects/*/locations/*/repositories/*/releaseConfigs/*`.
        ReleaseConfig(std::string::String),
    }
}

/// Configures various aspects of Dataform code compilation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CodeCompilationConfig {
    /// Optional. The default database (Google Cloud project ID).
    pub default_database: std::string::String,

    /// Optional. The default schema (BigQuery dataset ID).
    pub default_schema: std::string::String,

    /// Optional. The default BigQuery location to use. Defaults to "US".
    /// See the BigQuery docs for a full list of locations:
    /// <https://cloud.google.com/bigquery/docs/locations>.
    pub default_location: std::string::String,

    /// Optional. The default schema (BigQuery dataset ID) for assertions.
    pub assertion_schema: std::string::String,

    /// Optional. User-defined variables that are made available to project code
    /// during compilation.
    pub vars: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. The suffix that should be appended to all database (Google Cloud
    /// project ID) names.
    pub database_suffix: std::string::String,

    /// Optional. The suffix that should be appended to all schema (BigQuery
    /// dataset ID) names.
    pub schema_suffix: std::string::String,

    /// Optional. The prefix that should be prepended to all table names.
    pub table_prefix: std::string::String,

    /// Optional. The prefix to prepend to built-in assertion names.
    pub builtin_assertion_name_prefix: std::string::String,

    /// Optional. The default notebook runtime options.
    pub default_notebook_runtime_options: std::option::Option<crate::model::NotebookRuntimeOptions>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CodeCompilationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [default_database][crate::model::CodeCompilationConfig::default_database].
    pub fn set_default_database<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_database = v.into();
        self
    }

    /// Sets the value of [default_schema][crate::model::CodeCompilationConfig::default_schema].
    pub fn set_default_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.default_schema = v.into();
        self
    }

    /// Sets the value of [default_location][crate::model::CodeCompilationConfig::default_location].
    pub fn set_default_location<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_location = v.into();
        self
    }

    /// Sets the value of [assertion_schema][crate::model::CodeCompilationConfig::assertion_schema].
    pub fn set_assertion_schema<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.assertion_schema = v.into();
        self
    }

    /// Sets the value of [vars][crate::model::CodeCompilationConfig::vars].
    pub fn set_vars<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.vars = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [database_suffix][crate::model::CodeCompilationConfig::database_suffix].
    pub fn set_database_suffix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database_suffix = v.into();
        self
    }

    /// Sets the value of [schema_suffix][crate::model::CodeCompilationConfig::schema_suffix].
    pub fn set_schema_suffix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema_suffix = v.into();
        self
    }

    /// Sets the value of [table_prefix][crate::model::CodeCompilationConfig::table_prefix].
    pub fn set_table_prefix<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.table_prefix = v.into();
        self
    }

    /// Sets the value of [builtin_assertion_name_prefix][crate::model::CodeCompilationConfig::builtin_assertion_name_prefix].
    pub fn set_builtin_assertion_name_prefix<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.builtin_assertion_name_prefix = v.into();
        self
    }

    /// Sets the value of [default_notebook_runtime_options][crate::model::CodeCompilationConfig::default_notebook_runtime_options].
    pub fn set_default_notebook_runtime_options<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::NotebookRuntimeOptions>,
    {
        self.default_notebook_runtime_options = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [default_notebook_runtime_options][crate::model::CodeCompilationConfig::default_notebook_runtime_options].
    pub fn set_or_clear_default_notebook_runtime_options<T>(
        mut self,
        v: std::option::Option<T>,
    ) -> Self
    where
        T: std::convert::Into<crate::model::NotebookRuntimeOptions>,
    {
        self.default_notebook_runtime_options = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CodeCompilationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CodeCompilationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CodeCompilationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __default_database,
            __default_schema,
            __default_location,
            __assertion_schema,
            __vars,
            __database_suffix,
            __schema_suffix,
            __table_prefix,
            __builtin_assertion_name_prefix,
            __default_notebook_runtime_options,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CodeCompilationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "defaultDatabase" => Ok(__FieldTag::__default_database),
                            "default_database" => Ok(__FieldTag::__default_database),
                            "defaultSchema" => Ok(__FieldTag::__default_schema),
                            "default_schema" => Ok(__FieldTag::__default_schema),
                            "defaultLocation" => Ok(__FieldTag::__default_location),
                            "default_location" => Ok(__FieldTag::__default_location),
                            "assertionSchema" => Ok(__FieldTag::__assertion_schema),
                            "assertion_schema" => Ok(__FieldTag::__assertion_schema),
                            "vars" => Ok(__FieldTag::__vars),
                            "databaseSuffix" => Ok(__FieldTag::__database_suffix),
                            "database_suffix" => Ok(__FieldTag::__database_suffix),
                            "schemaSuffix" => Ok(__FieldTag::__schema_suffix),
                            "schema_suffix" => Ok(__FieldTag::__schema_suffix),
                            "tablePrefix" => Ok(__FieldTag::__table_prefix),
                            "table_prefix" => Ok(__FieldTag::__table_prefix),
                            "builtinAssertionNamePrefix" => {
                                Ok(__FieldTag::__builtin_assertion_name_prefix)
                            }
                            "builtin_assertion_name_prefix" => {
                                Ok(__FieldTag::__builtin_assertion_name_prefix)
                            }
                            "defaultNotebookRuntimeOptions" => {
                                Ok(__FieldTag::__default_notebook_runtime_options)
                            }
                            "default_notebook_runtime_options" => {
                                Ok(__FieldTag::__default_notebook_runtime_options)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CodeCompilationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CodeCompilationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__default_database => {
                            if !fields.insert(__FieldTag::__default_database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_database",
                                ));
                            }
                            result.default_database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_schema => {
                            if !fields.insert(__FieldTag::__default_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_schema",
                                ));
                            }
                            result.default_schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_location => {
                            if !fields.insert(__FieldTag::__default_location) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_location",
                                ));
                            }
                            result.default_location = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__assertion_schema => {
                            if !fields.insert(__FieldTag::__assertion_schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assertion_schema",
                                ));
                            }
                            result.assertion_schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__vars => {
                            if !fields.insert(__FieldTag::__vars) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for vars",
                                ));
                            }
                            result.vars = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__database_suffix => {
                            if !fields.insert(__FieldTag::__database_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database_suffix",
                                ));
                            }
                            result.database_suffix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema_suffix => {
                            if !fields.insert(__FieldTag::__schema_suffix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema_suffix",
                                ));
                            }
                            result.schema_suffix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__table_prefix => {
                            if !fields.insert(__FieldTag::__table_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for table_prefix",
                                ));
                            }
                            result.table_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__builtin_assertion_name_prefix => {
                            if !fields.insert(__FieldTag::__builtin_assertion_name_prefix) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for builtin_assertion_name_prefix",
                                ));
                            }
                            result.builtin_assertion_name_prefix = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_notebook_runtime_options => {
                            if !fields.insert(__FieldTag::__default_notebook_runtime_options) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_notebook_runtime_options",
                                ));
                            }
                            result.default_notebook_runtime_options = map.next_value::<std::option::Option<crate::model::NotebookRuntimeOptions>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CodeCompilationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.default_database.is_empty() {
            state.serialize_entry("defaultDatabase", &self.default_database)?;
        }
        if !self.default_schema.is_empty() {
            state.serialize_entry("defaultSchema", &self.default_schema)?;
        }
        if !self.default_location.is_empty() {
            state.serialize_entry("defaultLocation", &self.default_location)?;
        }
        if !self.assertion_schema.is_empty() {
            state.serialize_entry("assertionSchema", &self.assertion_schema)?;
        }
        if !self.vars.is_empty() {
            state.serialize_entry("vars", &self.vars)?;
        }
        if !self.database_suffix.is_empty() {
            state.serialize_entry("databaseSuffix", &self.database_suffix)?;
        }
        if !self.schema_suffix.is_empty() {
            state.serialize_entry("schemaSuffix", &self.schema_suffix)?;
        }
        if !self.table_prefix.is_empty() {
            state.serialize_entry("tablePrefix", &self.table_prefix)?;
        }
        if !self.builtin_assertion_name_prefix.is_empty() {
            state.serialize_entry(
                "builtinAssertionNamePrefix",
                &self.builtin_assertion_name_prefix,
            )?;
        }
        if self.default_notebook_runtime_options.is_some() {
            state.serialize_entry(
                "defaultNotebookRuntimeOptions",
                &self.default_notebook_runtime_options,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Configures various aspects of Dataform notebook runtime.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct NotebookRuntimeOptions {
    /// Optional. The resource name of the [Colab runtime template]
    /// (<https://cloud.google.com/colab/docs/runtimes>), from which a runtime is
    /// created for notebook executions. If not specified, a runtime is created
    /// with Colab's default specifications.
    pub ai_platform_notebook_runtime_template: std::string::String,

    /// The location to store the notebook execution result.
    pub execution_sink: std::option::Option<crate::model::notebook_runtime_options::ExecutionSink>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl NotebookRuntimeOptions {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ai_platform_notebook_runtime_template][crate::model::NotebookRuntimeOptions::ai_platform_notebook_runtime_template].
    pub fn set_ai_platform_notebook_runtime_template<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ai_platform_notebook_runtime_template = v.into();
        self
    }

    /// Sets the value of [execution_sink][crate::model::NotebookRuntimeOptions::execution_sink].
    ///
    /// Note that all the setters affecting `execution_sink` are mutually
    /// exclusive.
    pub fn set_execution_sink<
        T: std::convert::Into<
                std::option::Option<crate::model::notebook_runtime_options::ExecutionSink>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.execution_sink = v.into();
        self
    }

    /// The value of [execution_sink][crate::model::NotebookRuntimeOptions::execution_sink]
    /// if it holds a `GcsOutputBucket`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gcs_output_bucket(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.execution_sink.as_ref().and_then(|v| match v {
            crate::model::notebook_runtime_options::ExecutionSink::GcsOutputBucket(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [execution_sink][crate::model::NotebookRuntimeOptions::execution_sink]
    /// to hold a `GcsOutputBucket`.
    ///
    /// Note that all the setters affecting `execution_sink` are
    /// mutually exclusive.
    pub fn set_gcs_output_bucket<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.execution_sink = std::option::Option::Some(
            crate::model::notebook_runtime_options::ExecutionSink::GcsOutputBucket(v.into()),
        );
        self
    }
}

impl wkt::message::Message for NotebookRuntimeOptions {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.NotebookRuntimeOptions"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for NotebookRuntimeOptions {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __gcs_output_bucket,
            __ai_platform_notebook_runtime_template,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for NotebookRuntimeOptions")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "gcsOutputBucket" => Ok(__FieldTag::__gcs_output_bucket),
                            "gcs_output_bucket" => Ok(__FieldTag::__gcs_output_bucket),
                            "aiPlatformNotebookRuntimeTemplate" => {
                                Ok(__FieldTag::__ai_platform_notebook_runtime_template)
                            }
                            "ai_platform_notebook_runtime_template" => {
                                Ok(__FieldTag::__ai_platform_notebook_runtime_template)
                            }
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = NotebookRuntimeOptions;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct NotebookRuntimeOptions")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__gcs_output_bucket => {
                            if !fields.insert(__FieldTag::__gcs_output_bucket) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for gcs_output_bucket",
                                ));
                            }
                            if result.execution_sink.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `execution_sink`, a oneof with full ID .google.cloud.dataform.v1.NotebookRuntimeOptions.gcs_output_bucket, latest field was gcsOutputBucket",
                                ));
                            }
                            result.execution_sink = std::option::Option::Some(
                                crate::model::notebook_runtime_options::ExecutionSink::GcsOutputBucket(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__ai_platform_notebook_runtime_template => {
                            if !fields.insert(__FieldTag::__ai_platform_notebook_runtime_template) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for ai_platform_notebook_runtime_template",
                                ));
                            }
                            result.ai_platform_notebook_runtime_template = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for NotebookRuntimeOptions {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.gcs_output_bucket() {
            state.serialize_entry("gcsOutputBucket", value)?;
        }
        if !self.ai_platform_notebook_runtime_template.is_empty() {
            state.serialize_entry(
                "aiPlatformNotebookRuntimeTemplate",
                &self.ai_platform_notebook_runtime_template,
            )?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [NotebookRuntimeOptions].
pub mod notebook_runtime_options {
    #[allow(unused_imports)]
    use super::*;

    /// The location to store the notebook execution result.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum ExecutionSink {
        /// Optional. The Google Cloud Storage location to upload the result to.
        /// Format: `gs://bucket-name`.
        GcsOutputBucket(std::string::String),
    }
}

/// `ListCompilationResults` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCompilationResultsRequest {
    /// Required. The repository in which to list compilation results. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of compilation results to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListCompilationResults`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListCompilationResults`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    /// Optional. This field only supports ordering by `name` and `create_time`.
    /// If unspecified, the server will choose the ordering.
    /// If specified, the default order is ascending for the `name` field.
    pub order_by: std::string::String,

    /// Optional. Filter for the returned list.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCompilationResultsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListCompilationResultsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListCompilationResultsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListCompilationResultsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListCompilationResultsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListCompilationResultsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListCompilationResultsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListCompilationResultsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCompilationResultsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCompilationResultsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCompilationResultsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCompilationResultsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCompilationResultsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListCompilationResults` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListCompilationResultsResponse {
    /// List of compilation results.
    pub compilation_results: std::vec::Vec<crate::model::CompilationResult>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListCompilationResultsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compilation_results][crate::model::ListCompilationResultsResponse::compilation_results].
    pub fn set_compilation_results<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CompilationResult>,
    {
        use std::iter::Iterator;
        self.compilation_results = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListCompilationResultsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListCompilationResultsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListCompilationResultsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListCompilationResultsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListCompilationResultsResponse {
    type PageItem = crate::model::CompilationResult;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.compilation_results
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListCompilationResultsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compilation_results,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListCompilationResultsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compilationResults" => Ok(__FieldTag::__compilation_results),
                            "compilation_results" => Ok(__FieldTag::__compilation_results),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListCompilationResultsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListCompilationResultsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compilation_results => {
                            if !fields.insert(__FieldTag::__compilation_results) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compilation_results",
                                ));
                            }
                            result.compilation_results =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CompilationResult>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListCompilationResultsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.compilation_results.is_empty() {
            state.serialize_entry("compilationResults", &self.compilation_results)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetCompilationResult` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetCompilationResultRequest {
    /// Required. The compilation result's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetCompilationResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetCompilationResultRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetCompilationResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetCompilationResultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetCompilationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetCompilationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetCompilationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetCompilationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetCompilationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateCompilationResult` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateCompilationResultRequest {
    /// Required. The repository in which to create the compilation result. Must be
    /// in the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Required. The compilation result to create.
    pub compilation_result: std::option::Option<crate::model::CompilationResult>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateCompilationResultRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateCompilationResultRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [compilation_result][crate::model::CreateCompilationResultRequest::compilation_result].
    pub fn set_compilation_result<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CompilationResult>,
    {
        self.compilation_result = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [compilation_result][crate::model::CreateCompilationResultRequest::compilation_result].
    pub fn set_or_clear_compilation_result<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CompilationResult>,
    {
        self.compilation_result = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateCompilationResultRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateCompilationResultRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateCompilationResultRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __compilation_result,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateCompilationResultRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "compilationResult" => Ok(__FieldTag::__compilation_result),
                            "compilation_result" => Ok(__FieldTag::__compilation_result),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateCompilationResultRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateCompilationResultRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__compilation_result => {
                            if !fields.insert(__FieldTag::__compilation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compilation_result",
                                ));
                            }
                            result.compilation_result = map
                                .next_value::<std::option::Option<crate::model::CompilationResult>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateCompilationResultRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.compilation_result.is_some() {
            state.serialize_entry("compilationResult", &self.compilation_result)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents an action identifier. If the action writes output, the output
/// will be written to the referenced database object.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Target {
    /// Optional. The action's database (Google Cloud project ID) .
    pub database: std::string::String,

    /// Optional. The action's schema (BigQuery dataset ID), within `database`.
    pub schema: std::string::String,

    /// Optional. The action's name, within `database` and `schema`.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Target {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [database][crate::model::Target::database].
    pub fn set_database<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.database = v.into();
        self
    }

    /// Sets the value of [schema][crate::model::Target::schema].
    pub fn set_schema<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.schema = v.into();
        self
    }

    /// Sets the value of [name][crate::model::Target::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for Target {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.Target"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Target {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __database,
            __schema,
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Target")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "database" => Ok(__FieldTag::__database),
                            "schema" => Ok(__FieldTag::__schema),
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Target;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Target")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__database => {
                            if !fields.insert(__FieldTag::__database) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for database",
                                ));
                            }
                            result.database = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__schema => {
                            if !fields.insert(__FieldTag::__schema) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for schema",
                                ));
                            }
                            result.schema = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Target {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.database.is_empty() {
            state.serialize_entry("database", &self.database)?;
        }
        if !self.schema.is_empty() {
            state.serialize_entry("schema", &self.schema)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Describes a relation and its columns.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct RelationDescriptor {
    /// A text description of the relation.
    pub description: std::string::String,

    /// A list of descriptions of columns within the relation.
    pub columns: std::vec::Vec<crate::model::relation_descriptor::ColumnDescriptor>,

    /// A set of BigQuery labels that should be applied to the relation.
    pub bigquery_labels: std::collections::HashMap<std::string::String, std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl RelationDescriptor {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [description][crate::model::RelationDescriptor::description].
    pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.description = v.into();
        self
    }

    /// Sets the value of [columns][crate::model::RelationDescriptor::columns].
    pub fn set_columns<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::relation_descriptor::ColumnDescriptor>,
    {
        use std::iter::Iterator;
        self.columns = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [bigquery_labels][crate::model::RelationDescriptor::bigquery_labels].
    pub fn set_bigquery_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.bigquery_labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }
}

impl wkt::message::Message for RelationDescriptor {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.RelationDescriptor"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for RelationDescriptor {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __description,
            __columns,
            __bigquery_labels,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for RelationDescriptor")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "description" => Ok(__FieldTag::__description),
                            "columns" => Ok(__FieldTag::__columns),
                            "bigqueryLabels" => Ok(__FieldTag::__bigquery_labels),
                            "bigquery_labels" => Ok(__FieldTag::__bigquery_labels),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = RelationDescriptor;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct RelationDescriptor")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__description => {
                            if !fields.insert(__FieldTag::__description) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for description",
                                ));
                            }
                            result.description = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__columns => {
                            if !fields.insert(__FieldTag::__columns) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for columns",
                                ));
                            }
                            result.columns = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::relation_descriptor::ColumnDescriptor,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__bigquery_labels => {
                            if !fields.insert(__FieldTag::__bigquery_labels) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_labels",
                                ));
                            }
                            result.bigquery_labels = map
                                .next_value::<std::option::Option<
                                    std::collections::HashMap<
                                        std::string::String,
                                        std::string::String,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for RelationDescriptor {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.description.is_empty() {
            state.serialize_entry("description", &self.description)?;
        }
        if !self.columns.is_empty() {
            state.serialize_entry("columns", &self.columns)?;
        }
        if !self.bigquery_labels.is_empty() {
            state.serialize_entry("bigqueryLabels", &self.bigquery_labels)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [RelationDescriptor].
pub mod relation_descriptor {
    #[allow(unused_imports)]
    use super::*;

    /// Describes a column.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ColumnDescriptor {
        /// The identifier for the column. Each entry in `path` represents one level
        /// of nesting.
        pub path: std::vec::Vec<std::string::String>,

        /// A textual description of the column.
        pub description: std::string::String,

        /// A list of BigQuery policy tags that will be applied to the column.
        pub bigquery_policy_tags: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ColumnDescriptor {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [path][crate::model::relation_descriptor::ColumnDescriptor::path].
        pub fn set_path<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.path = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [description][crate::model::relation_descriptor::ColumnDescriptor::description].
        pub fn set_description<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.description = v.into();
            self
        }

        /// Sets the value of [bigquery_policy_tags][crate::model::relation_descriptor::ColumnDescriptor::bigquery_policy_tags].
        pub fn set_bigquery_policy_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.bigquery_policy_tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for ColumnDescriptor {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.RelationDescriptor.ColumnDescriptor"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ColumnDescriptor {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __path,
                __description,
                __bigquery_policy_tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ColumnDescriptor")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "path" => Ok(__FieldTag::__path),
                                "description" => Ok(__FieldTag::__description),
                                "bigqueryPolicyTags" => Ok(__FieldTag::__bigquery_policy_tags),
                                "bigquery_policy_tags" => Ok(__FieldTag::__bigquery_policy_tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ColumnDescriptor;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ColumnDescriptor")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__path => {
                                if !fields.insert(__FieldTag::__path) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for path",
                                    ));
                                }
                                result.path = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__description => {
                                if !fields.insert(__FieldTag::__description) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for description",
                                    ));
                                }
                                result.description = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__bigquery_policy_tags => {
                                if !fields.insert(__FieldTag::__bigquery_policy_tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for bigquery_policy_tags",
                                    ));
                                }
                                result.bigquery_policy_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ColumnDescriptor {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.path.is_empty() {
                state.serialize_entry("path", &self.path)?;
            }
            if !self.description.is_empty() {
                state.serialize_entry("description", &self.description)?;
            }
            if !self.bigquery_policy_tags.is_empty() {
                state.serialize_entry("bigqueryPolicyTags", &self.bigquery_policy_tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }
}

/// Represents a single Dataform action in a compilation result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CompilationResultAction {
    /// This action's identifier. Unique within the compilation result.
    pub target: std::option::Option<crate::model::Target>,

    /// The action's identifier if the project had been compiled without any
    /// overrides configured. Unique within the compilation result.
    pub canonical_target: std::option::Option<crate::model::Target>,

    /// The full path including filename in which this action is located, relative
    /// to the workspace root.
    pub file_path: std::string::String,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    /// The compiled object.
    pub compiled_object:
        std::option::Option<crate::model::compilation_result_action::CompiledObject>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CompilationResultAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::CompilationResultAction::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::CompilationResultAction::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [canonical_target][crate::model::CompilationResultAction::canonical_target].
    pub fn set_canonical_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.canonical_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [canonical_target][crate::model::CompilationResultAction::canonical_target].
    pub fn set_or_clear_canonical_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.canonical_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [file_path][crate::model::CompilationResultAction::file_path].
    pub fn set_file_path<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.file_path = v.into();
        self
    }

    /// Sets the value of [internal_metadata][crate::model::CompilationResultAction::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::CompilationResultAction::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object].
    ///
    /// Note that all the setters affecting `compiled_object` are mutually
    /// exclusive.
    pub fn set_compiled_object<
        T: std::convert::Into<
                std::option::Option<crate::model::compilation_result_action::CompiledObject>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = v.into();
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `Relation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn relation(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compilation_result_action::Relation>>
    {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::Relation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `Relation`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_relation<
        T: std::convert::Into<std::boxed::Box<crate::model::compilation_result_action::Relation>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::Relation(v.into()),
        );
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `Operations`, `None` if the field is not set or
    /// holds a different branch.
    pub fn operations(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compilation_result_action::Operations>>
    {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::Operations(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `Operations`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_operations<
        T: std::convert::Into<std::boxed::Box<crate::model::compilation_result_action::Operations>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::Operations(v.into()),
        );
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `Assertion`, `None` if the field is not set or
    /// holds a different branch.
    pub fn assertion(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compilation_result_action::Assertion>>
    {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::Assertion(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `Assertion`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_assertion<
        T: std::convert::Into<std::boxed::Box<crate::model::compilation_result_action::Assertion>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::Assertion(v.into()),
        );
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `Declaration`, `None` if the field is not set or
    /// holds a different branch.
    pub fn declaration(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compilation_result_action::Declaration>>
    {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::Declaration(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `Declaration`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_declaration<
        T: std::convert::Into<std::boxed::Box<crate::model::compilation_result_action::Declaration>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::Declaration(v.into()),
        );
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `Notebook`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::compilation_result_action::Notebook>>
    {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::Notebook(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `Notebook`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_notebook<
        T: std::convert::Into<std::boxed::Box<crate::model::compilation_result_action::Notebook>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::Notebook(v.into()),
        );
        self
    }

    /// The value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// if it holds a `DataPreparation`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_preparation(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::compilation_result_action::DataPreparation>,
    > {
        #[allow(unreachable_patterns)]
        self.compiled_object.as_ref().and_then(|v| match v {
            crate::model::compilation_result_action::CompiledObject::DataPreparation(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compiled_object][crate::model::CompilationResultAction::compiled_object]
    /// to hold a `DataPreparation`.
    ///
    /// Note that all the setters affecting `compiled_object` are
    /// mutually exclusive.
    pub fn set_data_preparation<
        T: std::convert::Into<
                std::boxed::Box<crate::model::compilation_result_action::DataPreparation>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compiled_object = std::option::Option::Some(
            crate::model::compilation_result_action::CompiledObject::DataPreparation(v.into()),
        );
        self
    }
}

impl wkt::message::Message for CompilationResultAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CompilationResultAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __relation,
            __operations,
            __assertion,
            __declaration,
            __notebook,
            __data_preparation,
            __target,
            __canonical_target,
            __file_path,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CompilationResultAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "relation" => Ok(__FieldTag::__relation),
                            "operations" => Ok(__FieldTag::__operations),
                            "assertion" => Ok(__FieldTag::__assertion),
                            "declaration" => Ok(__FieldTag::__declaration),
                            "notebook" => Ok(__FieldTag::__notebook),
                            "dataPreparation" => Ok(__FieldTag::__data_preparation),
                            "data_preparation" => Ok(__FieldTag::__data_preparation),
                            "target" => Ok(__FieldTag::__target),
                            "canonicalTarget" => Ok(__FieldTag::__canonical_target),
                            "canonical_target" => Ok(__FieldTag::__canonical_target),
                            "filePath" => Ok(__FieldTag::__file_path),
                            "file_path" => Ok(__FieldTag::__file_path),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CompilationResultAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CompilationResultAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__relation => {
                            if !fields.insert(__FieldTag::__relation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for relation",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.relation, latest field was relation",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::Relation(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compilation_result_action::Relation,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__operations => {
                            if !fields.insert(__FieldTag::__operations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for operations",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.operations, latest field was operations",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::Operations(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compilation_result_action::Operations,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__assertion => {
                            if !fields.insert(__FieldTag::__assertion) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for assertion",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.assertion, latest field was assertion",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::Assertion(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compilation_result_action::Assertion,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__declaration => {
                            if !fields.insert(__FieldTag::__declaration) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for declaration",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.declaration, latest field was declaration",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::Declaration(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::Declaration>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__notebook => {
                            if !fields.insert(__FieldTag::__notebook) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.notebook, latest field was notebook",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::Notebook(
                                    map.next_value::<std::option::Option<
                                        std::boxed::Box<
                                            crate::model::compilation_result_action::Notebook,
                                        >,
                                    >>()?
                                    .unwrap_or_default(),
                                ),
                            );
                        }
                        __FieldTag::__data_preparation => {
                            if !fields.insert(__FieldTag::__data_preparation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_preparation",
                                ));
                            }
                            if result.compiled_object.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compiled_object`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.data_preparation, latest field was dataPreparation",
                                ));
                            }
                            result.compiled_object = std::option::Option::Some(
                                crate::model::compilation_result_action::CompiledObject::DataPreparation(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::DataPreparation>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__canonical_target => {
                            if !fields.insert(__FieldTag::__canonical_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_target",
                                ));
                            }
                            result.canonical_target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__file_path => {
                            if !fields.insert(__FieldTag::__file_path) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for file_path",
                                ));
                            }
                            result.file_path = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CompilationResultAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.relation() {
            state.serialize_entry("relation", value)?;
        }
        if let Some(value) = self.operations() {
            state.serialize_entry("operations", value)?;
        }
        if let Some(value) = self.assertion() {
            state.serialize_entry("assertion", value)?;
        }
        if let Some(value) = self.declaration() {
            state.serialize_entry("declaration", value)?;
        }
        if let Some(value) = self.notebook() {
            state.serialize_entry("notebook", value)?;
        }
        if let Some(value) = self.data_preparation() {
            state.serialize_entry("dataPreparation", value)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if self.canonical_target.is_some() {
            state.serialize_entry("canonicalTarget", &self.canonical_target)?;
        }
        if !self.file_path.is_empty() {
            state.serialize_entry("filePath", &self.file_path)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [CompilationResultAction].
pub mod compilation_result_action {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a database relation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Relation {
        /// A list of actions that this action depends on.
        pub dependency_targets: std::vec::Vec<crate::model::Target>,

        /// Whether this action is disabled (i.e. should not be run).
        pub disabled: bool,

        /// Arbitrary, user-defined tags on this action.
        pub tags: std::vec::Vec<std::string::String>,

        /// Descriptor for the relation and its columns.
        pub relation_descriptor: std::option::Option<crate::model::RelationDescriptor>,

        /// The type of this relation.
        pub relation_type: crate::model::compilation_result_action::relation::RelationType,

        /// The SELECT query which returns rows which this relation should contain.
        pub select_query: std::string::String,

        /// SQL statements to be executed before creating the relation.
        pub pre_operations: std::vec::Vec<std::string::String>,

        /// SQL statements to be executed after creating the relation.
        pub post_operations: std::vec::Vec<std::string::String>,

        /// Configures `INCREMENTAL_TABLE` settings for this relation. Only set if
        /// `relation_type` is `INCREMENTAL_TABLE`.
        pub incremental_table_config: std::option::Option<
            crate::model::compilation_result_action::relation::IncrementalTableConfig,
        >,

        /// The SQL expression used to partition the relation.
        pub partition_expression: std::string::String,

        /// A list of columns or SQL expressions used to cluster the table.
        pub cluster_expressions: std::vec::Vec<std::string::String>,

        /// Sets the partition expiration in days.
        pub partition_expiration_days: i32,

        /// Specifies whether queries on this table must include a predicate filter
        /// that filters on the partitioning column.
        pub require_partition_filter: bool,

        /// Additional options that will be provided as key/value pairs into the
        /// options clause of a create table/view statement. See
        /// <https://cloud.google.com/bigquery/docs/reference/standard-sql/data-definition-language>
        /// for more information on which options are supported.
        pub additional_options: std::collections::HashMap<std::string::String, std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Relation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dependency_targets][crate::model::compilation_result_action::Relation::dependency_targets].
        pub fn set_dependency_targets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Target>,
        {
            use std::iter::Iterator;
            self.dependency_targets = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [disabled][crate::model::compilation_result_action::Relation::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::compilation_result_action::Relation::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [relation_descriptor][crate::model::compilation_result_action::Relation::relation_descriptor].
        pub fn set_relation_descriptor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [relation_descriptor][crate::model::compilation_result_action::Relation::relation_descriptor].
        pub fn set_or_clear_relation_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [relation_type][crate::model::compilation_result_action::Relation::relation_type].
        pub fn set_relation_type<
            T: std::convert::Into<crate::model::compilation_result_action::relation::RelationType>,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.relation_type = v.into();
            self
        }

        /// Sets the value of [select_query][crate::model::compilation_result_action::Relation::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [pre_operations][crate::model::compilation_result_action::Relation::pre_operations].
        pub fn set_pre_operations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.pre_operations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [post_operations][crate::model::compilation_result_action::Relation::post_operations].
        pub fn set_post_operations<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.post_operations = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [incremental_table_config][crate::model::compilation_result_action::Relation::incremental_table_config].
        pub fn set_incremental_table_config<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<
                    crate::model::compilation_result_action::relation::IncrementalTableConfig,
                >,
        {
            self.incremental_table_config = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [incremental_table_config][crate::model::compilation_result_action::Relation::incremental_table_config].
        pub fn set_or_clear_incremental_table_config<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<
                    crate::model::compilation_result_action::relation::IncrementalTableConfig,
                >,
        {
            self.incremental_table_config = v.map(|x| x.into());
            self
        }

        /// Sets the value of [partition_expression][crate::model::compilation_result_action::Relation::partition_expression].
        pub fn set_partition_expression<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.partition_expression = v.into();
            self
        }

        /// Sets the value of [cluster_expressions][crate::model::compilation_result_action::Relation::cluster_expressions].
        pub fn set_cluster_expressions<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.cluster_expressions = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [partition_expiration_days][crate::model::compilation_result_action::Relation::partition_expiration_days].
        pub fn set_partition_expiration_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
            self.partition_expiration_days = v.into();
            self
        }

        /// Sets the value of [require_partition_filter][crate::model::compilation_result_action::Relation::require_partition_filter].
        pub fn set_require_partition_filter<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.require_partition_filter = v.into();
            self
        }

        /// Sets the value of [additional_options][crate::model::compilation_result_action::Relation::additional_options].
        pub fn set_additional_options<T, K, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = (K, V)>,
            K: std::convert::Into<std::string::String>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.additional_options = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
            self
        }
    }

    impl wkt::message::Message for Relation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Relation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Relation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dependency_targets,
                __disabled,
                __tags,
                __relation_descriptor,
                __relation_type,
                __select_query,
                __pre_operations,
                __post_operations,
                __incremental_table_config,
                __partition_expression,
                __cluster_expressions,
                __partition_expiration_days,
                __require_partition_filter,
                __additional_options,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Relation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dependencyTargets" => Ok(__FieldTag::__dependency_targets),
                                "dependency_targets" => Ok(__FieldTag::__dependency_targets),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "tags" => Ok(__FieldTag::__tags),
                                "relationDescriptor" => Ok(__FieldTag::__relation_descriptor),
                                "relation_descriptor" => Ok(__FieldTag::__relation_descriptor),
                                "relationType" => Ok(__FieldTag::__relation_type),
                                "relation_type" => Ok(__FieldTag::__relation_type),
                                "selectQuery" => Ok(__FieldTag::__select_query),
                                "select_query" => Ok(__FieldTag::__select_query),
                                "preOperations" => Ok(__FieldTag::__pre_operations),
                                "pre_operations" => Ok(__FieldTag::__pre_operations),
                                "postOperations" => Ok(__FieldTag::__post_operations),
                                "post_operations" => Ok(__FieldTag::__post_operations),
                                "incrementalTableConfig" => {
                                    Ok(__FieldTag::__incremental_table_config)
                                }
                                "incremental_table_config" => {
                                    Ok(__FieldTag::__incremental_table_config)
                                }
                                "partitionExpression" => Ok(__FieldTag::__partition_expression),
                                "partition_expression" => Ok(__FieldTag::__partition_expression),
                                "clusterExpressions" => Ok(__FieldTag::__cluster_expressions),
                                "cluster_expressions" => Ok(__FieldTag::__cluster_expressions),
                                "partitionExpirationDays" => {
                                    Ok(__FieldTag::__partition_expiration_days)
                                }
                                "partition_expiration_days" => {
                                    Ok(__FieldTag::__partition_expiration_days)
                                }
                                "requirePartitionFilter" => {
                                    Ok(__FieldTag::__require_partition_filter)
                                }
                                "require_partition_filter" => {
                                    Ok(__FieldTag::__require_partition_filter)
                                }
                                "additionalOptions" => Ok(__FieldTag::__additional_options),
                                "additional_options" => Ok(__FieldTag::__additional_options),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Relation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Relation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dependency_targets => {
                                if !fields.insert(__FieldTag::__dependency_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dependency_targets",
                                    ));
                                }
                                result.dependency_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__relation_descriptor => {
                                if !fields.insert(__FieldTag::__relation_descriptor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation_descriptor",
                                    ));
                                }
                                result.relation_descriptor = map.next_value::<std::option::Option<crate::model::RelationDescriptor>>()?
                                    ;
                            }
                            __FieldTag::__relation_type => {
                                if !fields.insert(__FieldTag::__relation_type) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation_type",
                                    ));
                                }
                                result.relation_type = map.next_value::<std::option::Option<crate::model::compilation_result_action::relation::RelationType>>()?.unwrap_or_default();
                            }
                            __FieldTag::__select_query => {
                                if !fields.insert(__FieldTag::__select_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for select_query",
                                    ));
                                }
                                result.select_query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__pre_operations => {
                                if !fields.insert(__FieldTag::__pre_operations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for pre_operations",
                                    ));
                                }
                                result.pre_operations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__post_operations => {
                                if !fields.insert(__FieldTag::__post_operations) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for post_operations",
                                    ));
                                }
                                result.post_operations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__incremental_table_config => {
                                if !fields.insert(__FieldTag::__incremental_table_config) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for incremental_table_config",
                                    ));
                                }
                                result.incremental_table_config = map.next_value::<std::option::Option<crate::model::compilation_result_action::relation::IncrementalTableConfig>>()?
                                    ;
                            }
                            __FieldTag::__partition_expression => {
                                if !fields.insert(__FieldTag::__partition_expression) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partition_expression",
                                    ));
                                }
                                result.partition_expression = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__cluster_expressions => {
                                if !fields.insert(__FieldTag::__cluster_expressions) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for cluster_expressions",
                                    ));
                                }
                                result.cluster_expressions = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__partition_expiration_days => {
                                if !fields.insert(__FieldTag::__partition_expiration_days) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for partition_expiration_days",
                                    ));
                                }
                                struct __With(std::option::Option<i32>);
                                impl<'de> serde::de::Deserialize<'de> for __With {
                                    fn deserialize<D>(
                                        deserializer: D,
                                    ) -> std::result::Result<Self, D::Error>
                                    where
                                        D: serde::de::Deserializer<'de>,
                                    {
                                        serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                    }
                                }
                                result.partition_expiration_days =
                                    map.next_value::<__With>()?.0.unwrap_or_default();
                            }
                            __FieldTag::__require_partition_filter => {
                                if !fields.insert(__FieldTag::__require_partition_filter) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for require_partition_filter",
                                    ));
                                }
                                result.require_partition_filter = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__additional_options => {
                                if !fields.insert(__FieldTag::__additional_options) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for additional_options",
                                    ));
                                }
                                result.additional_options = map
                                    .next_value::<std::option::Option<
                                        std::collections::HashMap<
                                            std::string::String,
                                            std::string::String,
                                        >,
                                    >>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Relation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dependency_targets.is_empty() {
                state.serialize_entry("dependencyTargets", &self.dependency_targets)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if self.relation_descriptor.is_some() {
                state.serialize_entry("relationDescriptor", &self.relation_descriptor)?;
            }
            if !wkt::internal::is_default(&self.relation_type) {
                state.serialize_entry("relationType", &self.relation_type)?;
            }
            if !self.select_query.is_empty() {
                state.serialize_entry("selectQuery", &self.select_query)?;
            }
            if !self.pre_operations.is_empty() {
                state.serialize_entry("preOperations", &self.pre_operations)?;
            }
            if !self.post_operations.is_empty() {
                state.serialize_entry("postOperations", &self.post_operations)?;
            }
            if self.incremental_table_config.is_some() {
                state.serialize_entry("incrementalTableConfig", &self.incremental_table_config)?;
            }
            if !self.partition_expression.is_empty() {
                state.serialize_entry("partitionExpression", &self.partition_expression)?;
            }
            if !self.cluster_expressions.is_empty() {
                state.serialize_entry("clusterExpressions", &self.cluster_expressions)?;
            }
            if !wkt::internal::is_default(&self.partition_expiration_days) {
                struct __With<'a>(&'a i32);
                impl<'a> serde::ser::Serialize for __With<'a> {
                    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                    where
                        S: serde::ser::Serializer,
                    {
                        serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                    }
                }
                state.serialize_entry(
                    "partitionExpirationDays",
                    &__With(&self.partition_expiration_days),
                )?;
            }
            if !wkt::internal::is_default(&self.require_partition_filter) {
                state.serialize_entry("requirePartitionFilter", &self.require_partition_filter)?;
            }
            if !self.additional_options.is_empty() {
                state.serialize_entry("additionalOptions", &self.additional_options)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [Relation].
    pub mod relation {
        #[allow(unused_imports)]
        use super::*;

        /// Contains settings for relations of type `INCREMENTAL_TABLE`.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct IncrementalTableConfig {
            /// The SELECT query which returns rows which should be inserted into the
            /// relation if it already exists and is not being refreshed.
            pub incremental_select_query: std::string::String,

            /// Whether this table should be protected from being refreshed.
            pub refresh_disabled: bool,

            /// A set of columns or SQL expressions used to define row uniqueness.
            /// If any duplicates are discovered (as defined by `unique_key_parts`),
            /// only the newly selected rows (as defined by `incremental_select_query`)
            /// will be included in the relation.
            pub unique_key_parts: std::vec::Vec<std::string::String>,

            /// A SQL expression conditional used to limit the set of existing rows
            /// considered for a merge operation (see `unique_key_parts` for more
            /// information).
            pub update_partition_filter: std::string::String,

            /// SQL statements to be executed before inserting new rows into the
            /// relation.
            pub incremental_pre_operations: std::vec::Vec<std::string::String>,

            /// SQL statements to be executed after inserting new rows into the
            /// relation.
            pub incremental_post_operations: std::vec::Vec<std::string::String>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl IncrementalTableConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [incremental_select_query][crate::model::compilation_result_action::relation::IncrementalTableConfig::incremental_select_query].
            pub fn set_incremental_select_query<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.incremental_select_query = v.into();
                self
            }

            /// Sets the value of [refresh_disabled][crate::model::compilation_result_action::relation::IncrementalTableConfig::refresh_disabled].
            pub fn set_refresh_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
                self.refresh_disabled = v.into();
                self
            }

            /// Sets the value of [unique_key_parts][crate::model::compilation_result_action::relation::IncrementalTableConfig::unique_key_parts].
            pub fn set_unique_key_parts<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.unique_key_parts = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [update_partition_filter][crate::model::compilation_result_action::relation::IncrementalTableConfig::update_partition_filter].
            pub fn set_update_partition_filter<T: std::convert::Into<std::string::String>>(
                mut self,
                v: T,
            ) -> Self {
                self.update_partition_filter = v.into();
                self
            }

            /// Sets the value of [incremental_pre_operations][crate::model::compilation_result_action::relation::IncrementalTableConfig::incremental_pre_operations].
            pub fn set_incremental_pre_operations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.incremental_pre_operations = v.into_iter().map(|i| i.into()).collect();
                self
            }

            /// Sets the value of [incremental_post_operations][crate::model::compilation_result_action::relation::IncrementalTableConfig::incremental_post_operations].
            pub fn set_incremental_post_operations<T, V>(mut self, v: T) -> Self
            where
                T: std::iter::IntoIterator<Item = V>,
                V: std::convert::Into<std::string::String>,
            {
                use std::iter::Iterator;
                self.incremental_post_operations = v.into_iter().map(|i| i.into()).collect();
                self
            }
        }

        impl wkt::message::Message for IncrementalTableConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Relation.IncrementalTableConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for IncrementalTableConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __incremental_select_query,
                    __refresh_disabled,
                    __unique_key_parts,
                    __update_partition_filter,
                    __incremental_pre_operations,
                    __incremental_post_operations,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for IncrementalTableConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "incrementalSelectQuery" => {
                                        Ok(__FieldTag::__incremental_select_query)
                                    }
                                    "incremental_select_query" => {
                                        Ok(__FieldTag::__incremental_select_query)
                                    }
                                    "refreshDisabled" => Ok(__FieldTag::__refresh_disabled),
                                    "refresh_disabled" => Ok(__FieldTag::__refresh_disabled),
                                    "uniqueKeyParts" => Ok(__FieldTag::__unique_key_parts),
                                    "unique_key_parts" => Ok(__FieldTag::__unique_key_parts),
                                    "updatePartitionFilter" => {
                                        Ok(__FieldTag::__update_partition_filter)
                                    }
                                    "update_partition_filter" => {
                                        Ok(__FieldTag::__update_partition_filter)
                                    }
                                    "incrementalPreOperations" => {
                                        Ok(__FieldTag::__incremental_pre_operations)
                                    }
                                    "incremental_pre_operations" => {
                                        Ok(__FieldTag::__incremental_pre_operations)
                                    }
                                    "incrementalPostOperations" => {
                                        Ok(__FieldTag::__incremental_post_operations)
                                    }
                                    "incremental_post_operations" => {
                                        Ok(__FieldTag::__incremental_post_operations)
                                    }
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = IncrementalTableConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct IncrementalTableConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__incremental_select_query => {
                                    if !fields.insert(__FieldTag::__incremental_select_query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for incremental_select_query",
                                            ),
                                        );
                                    }
                                    result.incremental_select_query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__refresh_disabled => {
                                    if !fields.insert(__FieldTag::__refresh_disabled) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for refresh_disabled",
                                            ),
                                        );
                                    }
                                    result.refresh_disabled = map
                                        .next_value::<std::option::Option<bool>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__unique_key_parts => {
                                    if !fields.insert(__FieldTag::__unique_key_parts) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for unique_key_parts",
                                            ),
                                        );
                                    }
                                    result.unique_key_parts = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__update_partition_filter => {
                                    if !fields.insert(__FieldTag::__update_partition_filter) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for update_partition_filter",
                                            ),
                                        );
                                    }
                                    result.update_partition_filter = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__incremental_pre_operations => {
                                    if !fields.insert(__FieldTag::__incremental_pre_operations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for incremental_pre_operations",
                                            ),
                                        );
                                    }
                                    result.incremental_pre_operations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::__incremental_post_operations => {
                                    if !fields.insert(__FieldTag::__incremental_post_operations) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for incremental_post_operations",
                                            ),
                                        );
                                    }
                                    result.incremental_post_operations = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for IncrementalTableConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.incremental_select_query.is_empty() {
                    state.serialize_entry(
                        "incrementalSelectQuery",
                        &self.incremental_select_query,
                    )?;
                }
                if !wkt::internal::is_default(&self.refresh_disabled) {
                    state.serialize_entry("refreshDisabled", &self.refresh_disabled)?;
                }
                if !self.unique_key_parts.is_empty() {
                    state.serialize_entry("uniqueKeyParts", &self.unique_key_parts)?;
                }
                if !self.update_partition_filter.is_empty() {
                    state
                        .serialize_entry("updatePartitionFilter", &self.update_partition_filter)?;
                }
                if !self.incremental_pre_operations.is_empty() {
                    state.serialize_entry(
                        "incrementalPreOperations",
                        &self.incremental_pre_operations,
                    )?;
                }
                if !self.incremental_post_operations.is_empty() {
                    state.serialize_entry(
                        "incrementalPostOperations",
                        &self.incremental_post_operations,
                    )?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Indicates the type of this relation.
        ///
        /// # Working with unknown values
        ///
        /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
        /// additional enum variants at any time. Adding new variants is not considered
        /// a breaking change. Applications should write their code in anticipation of:
        ///
        /// - New values appearing in future releases of the client library, **and**
        /// - New values received dynamically, without application changes.
        ///
        /// Please consult the [Working with enums] section in the user guide for some
        /// guidelines.
        ///
        /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum RelationType {
            /// Default value. This value is unused.
            Unspecified,
            /// The relation is a table.
            Table,
            /// The relation is a view.
            View,
            /// The relation is an incrementalized table.
            IncrementalTable,
            /// The relation is a materialized view.
            MaterializedView,
            /// If set, the enum was initialized with an unknown value.
            ///
            /// Applications can examine the value using [RelationType::value] or
            /// [RelationType::name].
            UnknownValue(relation_type::UnknownValue),
        }

        #[doc(hidden)]
        pub mod relation_type {
            #[allow(unused_imports)]
            use super::*;
            #[derive(Clone, Debug, PartialEq)]
            pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
        }

        impl RelationType {
            /// Gets the enum value.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the string representation of enums.
            pub fn value(&self) -> std::option::Option<i32> {
                match self {
                    Self::Unspecified => std::option::Option::Some(0),
                    Self::Table => std::option::Option::Some(1),
                    Self::View => std::option::Option::Some(2),
                    Self::IncrementalTable => std::option::Option::Some(3),
                    Self::MaterializedView => std::option::Option::Some(4),
                    Self::UnknownValue(u) => u.0.value(),
                }
            }

            /// Gets the enum value as a string.
            ///
            /// Returns `None` if the enum contains an unknown value deserialized from
            /// the integer representation of enums.
            pub fn name(&self) -> std::option::Option<&str> {
                match self {
                    Self::Unspecified => std::option::Option::Some("RELATION_TYPE_UNSPECIFIED"),
                    Self::Table => std::option::Option::Some("TABLE"),
                    Self::View => std::option::Option::Some("VIEW"),
                    Self::IncrementalTable => std::option::Option::Some("INCREMENTAL_TABLE"),
                    Self::MaterializedView => std::option::Option::Some("MATERIALIZED_VIEW"),
                    Self::UnknownValue(u) => u.0.name(),
                }
            }
        }

        impl std::default::Default for RelationType {
            fn default() -> Self {
                use std::convert::From;
                Self::from(0)
            }
        }

        impl std::fmt::Display for RelationType {
            fn fmt(
                &self,
                f: &mut std::fmt::Formatter<'_>,
            ) -> std::result::Result<(), std::fmt::Error> {
                wkt::internal::display_enum(f, self.name(), self.value())
            }
        }

        impl std::convert::From<i32> for RelationType {
            fn from(value: i32) -> Self {
                match value {
                    0 => Self::Unspecified,
                    1 => Self::Table,
                    2 => Self::View,
                    3 => Self::IncrementalTable,
                    4 => Self::MaterializedView,
                    _ => Self::UnknownValue(relation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::Integer(value),
                    )),
                }
            }
        }

        impl std::convert::From<&str> for RelationType {
            fn from(value: &str) -> Self {
                use std::string::ToString;
                match value {
                    "RELATION_TYPE_UNSPECIFIED" => Self::Unspecified,
                    "TABLE" => Self::Table,
                    "VIEW" => Self::View,
                    "INCREMENTAL_TABLE" => Self::IncrementalTable,
                    "MATERIALIZED_VIEW" => Self::MaterializedView,
                    _ => Self::UnknownValue(relation_type::UnknownValue(
                        wkt::internal::UnknownEnumValue::String(value.to_string()),
                    )),
                }
            }
        }

        impl serde::ser::Serialize for RelationType {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::Serializer,
            {
                match self {
                    Self::Unspecified => serializer.serialize_i32(0),
                    Self::Table => serializer.serialize_i32(1),
                    Self::View => serializer.serialize_i32(2),
                    Self::IncrementalTable => serializer.serialize_i32(3),
                    Self::MaterializedView => serializer.serialize_i32(4),
                    Self::UnknownValue(u) => u.0.serialize(serializer),
                }
            }
        }

        impl<'de> serde::de::Deserialize<'de> for RelationType {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                deserializer.deserialize_any(wkt::internal::EnumVisitor::<RelationType>::new(
                    ".google.cloud.dataform.v1.CompilationResultAction.Relation.RelationType",
                ))
            }
        }
    }

    /// Represents a list of arbitrary database operations.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Operations {
        /// A list of actions that this action depends on.
        pub dependency_targets: std::vec::Vec<crate::model::Target>,

        /// Whether this action is disabled (i.e. should not be run).
        pub disabled: bool,

        /// Arbitrary, user-defined tags on this action.
        pub tags: std::vec::Vec<std::string::String>,

        /// Descriptor for any output relation and its columns. Only set if
        /// `has_output` is true.
        pub relation_descriptor: std::option::Option<crate::model::RelationDescriptor>,

        /// A list of arbitrary SQL statements that will be executed without
        /// alteration.
        pub queries: std::vec::Vec<std::string::String>,

        /// Whether these operations produce an output relation.
        pub has_output: bool,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Operations {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dependency_targets][crate::model::compilation_result_action::Operations::dependency_targets].
        pub fn set_dependency_targets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Target>,
        {
            use std::iter::Iterator;
            self.dependency_targets = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [disabled][crate::model::compilation_result_action::Operations::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::compilation_result_action::Operations::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [relation_descriptor][crate::model::compilation_result_action::Operations::relation_descriptor].
        pub fn set_relation_descriptor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [relation_descriptor][crate::model::compilation_result_action::Operations::relation_descriptor].
        pub fn set_or_clear_relation_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = v.map(|x| x.into());
            self
        }

        /// Sets the value of [queries][crate::model::compilation_result_action::Operations::queries].
        pub fn set_queries<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.queries = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [has_output][crate::model::compilation_result_action::Operations::has_output].
        pub fn set_has_output<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.has_output = v.into();
            self
        }
    }

    impl wkt::message::Message for Operations {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Operations"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Operations {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dependency_targets,
                __disabled,
                __tags,
                __relation_descriptor,
                __queries,
                __has_output,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Operations")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dependencyTargets" => Ok(__FieldTag::__dependency_targets),
                                "dependency_targets" => Ok(__FieldTag::__dependency_targets),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "tags" => Ok(__FieldTag::__tags),
                                "relationDescriptor" => Ok(__FieldTag::__relation_descriptor),
                                "relation_descriptor" => Ok(__FieldTag::__relation_descriptor),
                                "queries" => Ok(__FieldTag::__queries),
                                "hasOutput" => Ok(__FieldTag::__has_output),
                                "has_output" => Ok(__FieldTag::__has_output),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Operations;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Operations")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dependency_targets => {
                                if !fields.insert(__FieldTag::__dependency_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dependency_targets",
                                    ));
                                }
                                result.dependency_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__relation_descriptor => {
                                if !fields.insert(__FieldTag::__relation_descriptor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation_descriptor",
                                    ));
                                }
                                result.relation_descriptor = map.next_value::<std::option::Option<crate::model::RelationDescriptor>>()?
                                    ;
                            }
                            __FieldTag::__queries => {
                                if !fields.insert(__FieldTag::__queries) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for queries",
                                    ));
                                }
                                result.queries = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__has_output => {
                                if !fields.insert(__FieldTag::__has_output) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for has_output",
                                    ));
                                }
                                result.has_output = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Operations {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dependency_targets.is_empty() {
                state.serialize_entry("dependencyTargets", &self.dependency_targets)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if self.relation_descriptor.is_some() {
                state.serialize_entry("relationDescriptor", &self.relation_descriptor)?;
            }
            if !self.queries.is_empty() {
                state.serialize_entry("queries", &self.queries)?;
            }
            if !wkt::internal::is_default(&self.has_output) {
                state.serialize_entry("hasOutput", &self.has_output)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents an assertion upon a SQL query which is required return zero
    /// rows.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Assertion {
        /// A list of actions that this action depends on.
        pub dependency_targets: std::vec::Vec<crate::model::Target>,

        /// The parent action of this assertion. Only set if this assertion was
        /// automatically generated.
        pub parent_action: std::option::Option<crate::model::Target>,

        /// Whether this action is disabled (i.e. should not be run).
        pub disabled: bool,

        /// Arbitrary, user-defined tags on this action.
        pub tags: std::vec::Vec<std::string::String>,

        /// The SELECT query which must return zero rows in order for this assertion
        /// to succeed.
        pub select_query: std::string::String,

        /// Descriptor for the assertion's automatically-generated view and its
        /// columns.
        pub relation_descriptor: std::option::Option<crate::model::RelationDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Assertion {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dependency_targets][crate::model::compilation_result_action::Assertion::dependency_targets].
        pub fn set_dependency_targets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Target>,
        {
            use std::iter::Iterator;
            self.dependency_targets = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [parent_action][crate::model::compilation_result_action::Assertion::parent_action].
        pub fn set_parent_action<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::Target>,
        {
            self.parent_action = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [parent_action][crate::model::compilation_result_action::Assertion::parent_action].
        pub fn set_or_clear_parent_action<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::Target>,
        {
            self.parent_action = v.map(|x| x.into());
            self
        }

        /// Sets the value of [disabled][crate::model::compilation_result_action::Assertion::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::compilation_result_action::Assertion::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [select_query][crate::model::compilation_result_action::Assertion::select_query].
        pub fn set_select_query<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.select_query = v.into();
            self
        }

        /// Sets the value of [relation_descriptor][crate::model::compilation_result_action::Assertion::relation_descriptor].
        pub fn set_relation_descriptor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [relation_descriptor][crate::model::compilation_result_action::Assertion::relation_descriptor].
        pub fn set_or_clear_relation_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Assertion {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Assertion"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Assertion {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dependency_targets,
                __parent_action,
                __disabled,
                __tags,
                __select_query,
                __relation_descriptor,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Assertion")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dependencyTargets" => Ok(__FieldTag::__dependency_targets),
                                "dependency_targets" => Ok(__FieldTag::__dependency_targets),
                                "parentAction" => Ok(__FieldTag::__parent_action),
                                "parent_action" => Ok(__FieldTag::__parent_action),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "tags" => Ok(__FieldTag::__tags),
                                "selectQuery" => Ok(__FieldTag::__select_query),
                                "select_query" => Ok(__FieldTag::__select_query),
                                "relationDescriptor" => Ok(__FieldTag::__relation_descriptor),
                                "relation_descriptor" => Ok(__FieldTag::__relation_descriptor),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Assertion;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Assertion")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dependency_targets => {
                                if !fields.insert(__FieldTag::__dependency_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dependency_targets",
                                    ));
                                }
                                result.dependency_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__parent_action => {
                                if !fields.insert(__FieldTag::__parent_action) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for parent_action",
                                    ));
                                }
                                result.parent_action =
                                    map.next_value::<std::option::Option<crate::model::Target>>()?;
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__select_query => {
                                if !fields.insert(__FieldTag::__select_query) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for select_query",
                                    ));
                                }
                                result.select_query = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__relation_descriptor => {
                                if !fields.insert(__FieldTag::__relation_descriptor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation_descriptor",
                                    ));
                                }
                                result.relation_descriptor = map.next_value::<std::option::Option<crate::model::RelationDescriptor>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Assertion {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dependency_targets.is_empty() {
                state.serialize_entry("dependencyTargets", &self.dependency_targets)?;
            }
            if self.parent_action.is_some() {
                state.serialize_entry("parentAction", &self.parent_action)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if !self.select_query.is_empty() {
                state.serialize_entry("selectQuery", &self.select_query)?;
            }
            if self.relation_descriptor.is_some() {
                state.serialize_entry("relationDescriptor", &self.relation_descriptor)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a relation which is not managed by Dataform but which may be
    /// referenced by Dataform actions.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Declaration {
        /// Descriptor for the relation and its columns. Used as documentation only,
        /// i.e. values here will result in no changes to the relation's metadata.
        pub relation_descriptor: std::option::Option<crate::model::RelationDescriptor>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Declaration {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [relation_descriptor][crate::model::compilation_result_action::Declaration::relation_descriptor].
        pub fn set_relation_descriptor<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [relation_descriptor][crate::model::compilation_result_action::Declaration::relation_descriptor].
        pub fn set_or_clear_relation_descriptor<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<crate::model::RelationDescriptor>,
        {
            self.relation_descriptor = v.map(|x| x.into());
            self
        }
    }

    impl wkt::message::Message for Declaration {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Declaration"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Declaration {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __relation_descriptor,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Declaration")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "relationDescriptor" => Ok(__FieldTag::__relation_descriptor),
                                "relation_descriptor" => Ok(__FieldTag::__relation_descriptor),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Declaration;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Declaration")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__relation_descriptor => {
                                if !fields.insert(__FieldTag::__relation_descriptor) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for relation_descriptor",
                                    ));
                                }
                                result.relation_descriptor = map.next_value::<std::option::Option<crate::model::RelationDescriptor>>()?
                                    ;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Declaration {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if self.relation_descriptor.is_some() {
                state.serialize_entry("relationDescriptor", &self.relation_descriptor)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a notebook.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct Notebook {
        /// A list of actions that this action depends on.
        pub dependency_targets: std::vec::Vec<crate::model::Target>,

        /// Whether this action is disabled (i.e. should not be run).
        pub disabled: bool,

        /// The contents of the notebook.
        pub contents: std::string::String,

        /// Arbitrary, user-defined tags on this action.
        pub tags: std::vec::Vec<std::string::String>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Notebook {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dependency_targets][crate::model::compilation_result_action::Notebook::dependency_targets].
        pub fn set_dependency_targets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Target>,
        {
            use std::iter::Iterator;
            self.dependency_targets = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [disabled][crate::model::compilation_result_action::Notebook::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [contents][crate::model::compilation_result_action::Notebook::contents].
        pub fn set_contents<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.contents = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::compilation_result_action::Notebook::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }
    }

    impl wkt::message::Message for Notebook {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.Notebook"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for Notebook {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __dependency_targets,
                __disabled,
                __contents,
                __tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for Notebook")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "dependencyTargets" => Ok(__FieldTag::__dependency_targets),
                                "dependency_targets" => Ok(__FieldTag::__dependency_targets),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "contents" => Ok(__FieldTag::__contents),
                                "tags" => Ok(__FieldTag::__tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = Notebook;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct Notebook")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__dependency_targets => {
                                if !fields.insert(__FieldTag::__dependency_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dependency_targets",
                                    ));
                                }
                                result.dependency_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__contents => {
                                if !fields.insert(__FieldTag::__contents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents",
                                    ));
                                }
                                result.contents = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for Notebook {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.dependency_targets.is_empty() {
                state.serialize_entry("dependencyTargets", &self.dependency_targets)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !self.contents.is_empty() {
                state.serialize_entry("contents", &self.contents)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines a compiled Data Preparation entity
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataPreparation {
        /// A list of actions that this action depends on.
        pub dependency_targets: std::vec::Vec<crate::model::Target>,

        /// Whether this action is disabled (i.e. should not be run).
        pub disabled: bool,

        /// Arbitrary, user-defined tags on this action.
        pub tags: std::vec::Vec<std::string::String>,

        /// The definition for the data preparation.
        pub definition: std::option::Option<
            crate::model::compilation_result_action::data_preparation::Definition,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataPreparation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [dependency_targets][crate::model::compilation_result_action::DataPreparation::dependency_targets].
        pub fn set_dependency_targets<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<crate::model::Target>,
        {
            use std::iter::Iterator;
            self.dependency_targets = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [disabled][crate::model::compilation_result_action::DataPreparation::disabled].
        pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
            self.disabled = v.into();
            self
        }

        /// Sets the value of [tags][crate::model::compilation_result_action::DataPreparation::tags].
        pub fn set_tags<T, V>(mut self, v: T) -> Self
        where
            T: std::iter::IntoIterator<Item = V>,
            V: std::convert::Into<std::string::String>,
        {
            use std::iter::Iterator;
            self.tags = v.into_iter().map(|i| i.into()).collect();
            self
        }

        /// Sets the value of [definition][crate::model::compilation_result_action::DataPreparation::definition].
        ///
        /// Note that all the setters affecting `definition` are mutually
        /// exclusive.
        pub fn set_definition<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::compilation_result_action::data_preparation::Definition,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.definition = v.into();
            self
        }

        /// The value of [definition][crate::model::compilation_result_action::DataPreparation::definition]
        /// if it holds a `ContentsYaml`, `None` if the field is not set or
        /// holds a different branch.
        pub fn contents_yaml(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.definition.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::data_preparation::Definition::ContentsYaml(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [definition][crate::model::compilation_result_action::DataPreparation::definition]
        /// to hold a `ContentsYaml`.
        ///
        /// Note that all the setters affecting `definition` are
        /// mutually exclusive.
        pub fn set_contents_yaml<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.definition = std::option::Option::Some(
                crate::model::compilation_result_action::data_preparation::Definition::ContentsYaml(
                    v.into(),
                ),
            );
            self
        }

        /// The value of [definition][crate::model::compilation_result_action::DataPreparation::definition]
        /// if it holds a `ContentsSql`, `None` if the field is not set or
        /// holds a different branch.
        pub fn contents_sql(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<
                crate::model::compilation_result_action::data_preparation::SqlDefinition,
            >,
        > {
            #[allow(unreachable_patterns)]
            self.definition.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::data_preparation::Definition::ContentsSql(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [definition][crate::model::compilation_result_action::DataPreparation::definition]
        /// to hold a `ContentsSql`.
        ///
        /// Note that all the setters affecting `definition` are
        /// mutually exclusive.
        pub fn set_contents_sql<
            T: std::convert::Into<
                    std::boxed::Box<
                        crate::model::compilation_result_action::data_preparation::SqlDefinition,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.definition = std::option::Option::Some(
                crate::model::compilation_result_action::data_preparation::Definition::ContentsSql(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for DataPreparation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.DataPreparation"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataPreparation {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __contents_yaml,
                __contents_sql,
                __dependency_targets,
                __disabled,
                __tags,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataPreparation")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "contentsYaml" => Ok(__FieldTag::__contents_yaml),
                                "contents_yaml" => Ok(__FieldTag::__contents_yaml),
                                "contentsSql" => Ok(__FieldTag::__contents_sql),
                                "contents_sql" => Ok(__FieldTag::__contents_sql),
                                "dependencyTargets" => Ok(__FieldTag::__dependency_targets),
                                "dependency_targets" => Ok(__FieldTag::__dependency_targets),
                                "disabled" => Ok(__FieldTag::__disabled),
                                "tags" => Ok(__FieldTag::__tags),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataPreparation;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataPreparation")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__contents_yaml => {
                                if !fields.insert(__FieldTag::__contents_yaml) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents_yaml",
                                    ));
                                }
                                if result.definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `definition`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.DataPreparation.contents_yaml, latest field was contentsYaml",
                                    ));
                                }
                                result.definition = std::option::Option::Some(
                                    crate::model::compilation_result_action::data_preparation::Definition::ContentsYaml(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__contents_sql => {
                                if !fields.insert(__FieldTag::__contents_sql) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents_sql",
                                    ));
                                }
                                if result.definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `definition`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.DataPreparation.contents_sql, latest field was contentsSql",
                                    ));
                                }
                                result.definition = std::option::Option::Some(
                                    crate::model::compilation_result_action::data_preparation::Definition::ContentsSql(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::data_preparation::SqlDefinition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__dependency_targets => {
                                if !fields.insert(__FieldTag::__dependency_targets) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for dependency_targets",
                                    ));
                                }
                                result.dependency_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                            }
                            __FieldTag::__disabled => {
                                if !fields.insert(__FieldTag::__disabled) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for disabled",
                                    ));
                                }
                                result.disabled = map
                                    .next_value::<std::option::Option<bool>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__tags => {
                                if !fields.insert(__FieldTag::__tags) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for tags",
                                    ));
                                }
                                result.tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataPreparation {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.contents_yaml() {
                state.serialize_entry("contentsYaml", value)?;
            }
            if let Some(value) = self.contents_sql() {
                state.serialize_entry("contentsSql", value)?;
            }
            if !self.dependency_targets.is_empty() {
                state.serialize_entry("dependencyTargets", &self.dependency_targets)?;
            }
            if !wkt::internal::is_default(&self.disabled) {
                state.serialize_entry("disabled", &self.disabled)?;
            }
            if !self.tags.is_empty() {
                state.serialize_entry("tags", &self.tags)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DataPreparation].
    pub mod data_preparation {
        #[allow(unused_imports)]
        use super::*;

        /// Definition of a SQL Data Preparation
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct SqlDefinition {
            /// The SQL query representing the data preparation steps. Formatted as a
            /// Pipe SQL query statement.
            pub query: std::string::String,

            /// Error table configuration,
            pub error_table: std::option::Option<
                crate::model::compilation_result_action::data_preparation::ErrorTable,
            >,

            /// Load configuration.
            pub load: std::option::Option<crate::model::compilation_result_action::LoadConfig>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl SqlDefinition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [query][crate::model::compilation_result_action::data_preparation::SqlDefinition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [error_table][crate::model::compilation_result_action::data_preparation::SqlDefinition::error_table].
            pub fn set_error_table<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<
                        crate::model::compilation_result_action::data_preparation::ErrorTable,
                    >,
            {
                self.error_table = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [error_table][crate::model::compilation_result_action::data_preparation::SqlDefinition::error_table].
            pub fn set_or_clear_error_table<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<
                        crate::model::compilation_result_action::data_preparation::ErrorTable,
                    >,
            {
                self.error_table = v.map(|x| x.into());
                self
            }

            /// Sets the value of [load][crate::model::compilation_result_action::data_preparation::SqlDefinition::load].
            pub fn set_load<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::compilation_result_action::LoadConfig>,
            {
                self.load = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [load][crate::model::compilation_result_action::data_preparation::SqlDefinition::load].
            pub fn set_or_clear_load<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::compilation_result_action::LoadConfig>,
            {
                self.load = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for SqlDefinition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.DataPreparation.SqlDefinition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for SqlDefinition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __query,
                    __error_table,
                    __load,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for SqlDefinition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "query" => Ok(__FieldTag::__query),
                                    "errorTable" => Ok(__FieldTag::__error_table),
                                    "error_table" => Ok(__FieldTag::__error_table),
                                    "load" => Ok(__FieldTag::__load),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = SqlDefinition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct SqlDefinition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__error_table => {
                                    if !fields.insert(__FieldTag::__error_table) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for error_table",
                                            ),
                                        );
                                    }
                                    result.error_table = map.next_value::<std::option::Option<crate::model::compilation_result_action::data_preparation::ErrorTable>>()?
                                        ;
                                }
                                __FieldTag::__load => {
                                    if !fields.insert(__FieldTag::__load) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for load"),
                                        );
                                    }
                                    result.load = map.next_value::<std::option::Option<
                                        crate::model::compilation_result_action::LoadConfig,
                                    >>()?;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for SqlDefinition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if self.error_table.is_some() {
                    state.serialize_entry("errorTable", &self.error_table)?;
                }
                if self.load.is_some() {
                    state.serialize_entry("load", &self.load)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Error table information, used to write error data into a BigQuery
        /// table.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ErrorTable {
            /// Error Table target.
            pub target: std::option::Option<crate::model::Target>,

            /// Error table partition expiration in days. Only positive values are
            /// allowed.
            pub retention_days: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ErrorTable {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target][crate::model::compilation_result_action::data_preparation::ErrorTable::target].
            pub fn set_target<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::Target>,
            {
                self.target = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target][crate::model::compilation_result_action::data_preparation::ErrorTable::target].
            pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::Target>,
            {
                self.target = v.map(|x| x.into());
                self
            }

            /// Sets the value of [retention_days][crate::model::compilation_result_action::data_preparation::ErrorTable::retention_days].
            pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.retention_days = v.into();
                self
            }
        }

        impl wkt::message::Message for ErrorTable {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.DataPreparation.ErrorTable"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ErrorTable {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __target,
                    __retention_days,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ErrorTable")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "target" => Ok(__FieldTag::__target),
                                    "retentionDays" => Ok(__FieldTag::__retention_days),
                                    "retention_days" => Ok(__FieldTag::__retention_days),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ErrorTable;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ErrorTable")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__target => {
                                    if !fields.insert(__FieldTag::__target) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for target"),
                                        );
                                    }
                                    result.target = map
                                        .next_value::<std::option::Option<crate::model::Target>>(
                                        )?;
                                }
                                __FieldTag::__retention_days => {
                                    if !fields.insert(__FieldTag::__retention_days) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for retention_days",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.retention_days =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ErrorTable {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.target.is_some() {
                    state.serialize_entry("target", &self.target)?;
                }
                if !wkt::internal::is_default(&self.retention_days) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("retentionDays", &__With(&self.retention_days))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The definition for the data preparation.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Definition {
            /// The data preparation definition, stored as a YAML string.
            ContentsYaml(std::string::String),
            /// SQL definition for a Data Preparation. Contains a SQL query and
            /// additional context information.
            ContentsSql(
                std::boxed::Box<
                    crate::model::compilation_result_action::data_preparation::SqlDefinition,
                >,
            ),
        }
    }

    /// Simplified load configuration for actions
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct LoadConfig {
        /// Load mode
        pub mode: std::option::Option<crate::model::compilation_result_action::load_config::Mode>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl LoadConfig {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [mode][crate::model::compilation_result_action::LoadConfig::mode].
        ///
        /// Note that all the setters affecting `mode` are mutually
        /// exclusive.
        pub fn set_mode<
            T: std::convert::Into<
                    std::option::Option<crate::model::compilation_result_action::load_config::Mode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = v.into();
            self
        }

        /// The value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// if it holds a `Replace`, `None` if the field is not set or
        /// holds a different branch.
        pub fn replace(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>,
        > {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::load_config::Mode::Replace(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// to hold a `Replace`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_replace<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::compilation_result_action::load_config::Mode::Replace(v.into()),
            );
            self
        }

        /// The value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// if it holds a `Append`, `None` if the field is not set or
        /// holds a different branch.
        pub fn append(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>,
        > {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::load_config::Mode::Append(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// to hold a `Append`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_append<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::compilation_result_action::load_config::Mode::Append(v.into()),
            );
            self
        }

        /// The value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// if it holds a `Maximum`, `None` if the field is not set or
        /// holds a different branch.
        pub fn maximum(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>,
        > {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::load_config::Mode::Maximum(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// to hold a `Maximum`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_maximum<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::compilation_result_action::load_config::Mode::Maximum(v.into()),
            );
            self
        }

        /// The value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// if it holds a `Unique`, `None` if the field is not set or
        /// holds a different branch.
        pub fn unique(
            &self,
        ) -> std::option::Option<
            &std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>,
        > {
            #[allow(unreachable_patterns)]
            self.mode.as_ref().and_then(|v| match v {
                crate::model::compilation_result_action::load_config::Mode::Unique(v) => {
                    std::option::Option::Some(v)
                }
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [mode][crate::model::compilation_result_action::LoadConfig::mode]
        /// to hold a `Unique`.
        ///
        /// Note that all the setters affecting `mode` are
        /// mutually exclusive.
        pub fn set_unique<
            T: std::convert::Into<
                    std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.mode = std::option::Option::Some(
                crate::model::compilation_result_action::load_config::Mode::Unique(v.into()),
            );
            self
        }
    }

    impl wkt::message::Message for LoadConfig {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.LoadConfig"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for LoadConfig {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __replace,
                __append,
                __maximum,
                __unique,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for LoadConfig")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "replace" => Ok(__FieldTag::__replace),
                                "append" => Ok(__FieldTag::__append),
                                "maximum" => Ok(__FieldTag::__maximum),
                                "unique" => Ok(__FieldTag::__unique),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = LoadConfig;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct LoadConfig")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__replace => {
                                if !fields.insert(__FieldTag::__replace) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for replace",
                                    ));
                                }
                                if result.mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.LoadConfig.replace, latest field was replace",
                                    ));
                                }
                                result.mode = std::option::Option::Some(
                                    crate::model::compilation_result_action::load_config::Mode::Replace(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__append => {
                                if !fields.insert(__FieldTag::__append) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for append",
                                    ));
                                }
                                if result.mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.LoadConfig.append, latest field was append",
                                    ));
                                }
                                result.mode = std::option::Option::Some(
                                    crate::model::compilation_result_action::load_config::Mode::Append(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__maximum => {
                                if !fields.insert(__FieldTag::__maximum) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for maximum",
                                    ));
                                }
                                if result.mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.LoadConfig.maximum, latest field was maximum",
                                    ));
                                }
                                result.mode = std::option::Option::Some(
                                    crate::model::compilation_result_action::load_config::Mode::Maximum(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__unique => {
                                if !fields.insert(__FieldTag::__unique) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for unique",
                                    ));
                                }
                                if result.mode.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.CompilationResultAction.LoadConfig.unique, latest field was unique",
                                    ));
                                }
                                result.mode = std::option::Option::Some(
                                    crate::model::compilation_result_action::load_config::Mode::Unique(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for LoadConfig {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.replace() {
                state.serialize_entry("replace", value)?;
            }
            if let Some(value) = self.append() {
                state.serialize_entry("append", value)?;
            }
            if let Some(value) = self.maximum() {
                state.serialize_entry("maximum", value)?;
            }
            if let Some(value) = self.unique() {
                state.serialize_entry("unique", value)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [LoadConfig].
    pub mod load_config {
        #[allow(unused_imports)]
        use super::*;

        /// Load mode
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Mode {
            /// Replace destination table
            Replace(std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>),
            /// Append into destination table
            Append(std::boxed::Box<crate::model::compilation_result_action::SimpleLoadMode>),
            /// Insert records where the value exceeds the previous maximum value for a
            /// column in the destination table
            Maximum(std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>),
            /// Insert records where the value of a column is not already present in
            /// the destination table
            Unique(std::boxed::Box<crate::model::compilation_result_action::IncrementalLoadMode>),
        }
    }

    /// Simple load definition
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct SimpleLoadMode {
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl SimpleLoadMode {
        pub fn new() -> Self {
            std::default::Default::default()
        }
    }

    impl wkt::message::Message for SimpleLoadMode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.SimpleLoadMode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for SimpleLoadMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for SimpleLoadMode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            Ok(__FieldTag::Unknown(value.to_string()))
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = SimpleLoadMode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct SimpleLoadMode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for SimpleLoadMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Load definition for incremental load modes
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct IncrementalLoadMode {
        /// Column name for incremental load modes
        pub column: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl IncrementalLoadMode {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [column][crate::model::compilation_result_action::IncrementalLoadMode::column].
        pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.column = v.into();
            self
        }
    }

    impl wkt::message::Message for IncrementalLoadMode {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.CompilationResultAction.IncrementalLoadMode"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for IncrementalLoadMode {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __column,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for IncrementalLoadMode")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "column" => Ok(__FieldTag::__column),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = IncrementalLoadMode;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct IncrementalLoadMode")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__column => {
                                if !fields.insert(__FieldTag::__column) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for column",
                                    ));
                                }
                                result.column = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for IncrementalLoadMode {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.column.is_empty() {
                state.serialize_entry("column", &self.column)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// The compiled object.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompiledObject {
        /// The database relation created/updated by this action.
        Relation(std::boxed::Box<crate::model::compilation_result_action::Relation>),
        /// The database operations executed by this action.
        Operations(std::boxed::Box<crate::model::compilation_result_action::Operations>),
        /// The assertion executed by this action.
        Assertion(std::boxed::Box<crate::model::compilation_result_action::Assertion>),
        /// The declaration declared by this action.
        Declaration(std::boxed::Box<crate::model::compilation_result_action::Declaration>),
        /// The notebook executed by this action.
        Notebook(std::boxed::Box<crate::model::compilation_result_action::Notebook>),
        /// The data preparation executed by this action.
        DataPreparation(std::boxed::Box<crate::model::compilation_result_action::DataPreparation>),
    }
}

/// `QueryCompilationResultActions` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryCompilationResultActionsRequest {
    /// Required. The compilation result's name.
    pub name: std::string::String,

    /// Optional. Maximum number of compilation results to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous
    /// `QueryCompilationResultActions` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryCompilationResultActions`, with the exception of `page_size`, must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. Optional filter for the returned list. Filtering is only
    /// currently supported on the `file_path` field.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryCompilationResultActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryCompilationResultActionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryCompilationResultActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryCompilationResultActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::QueryCompilationResultActionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for QueryCompilationResultActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryCompilationResultActionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryCompilationResultActionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for QueryCompilationResultActionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryCompilationResultActionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryCompilationResultActionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryCompilationResultActionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryCompilationResultActions` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryCompilationResultActionsResponse {
    /// List of compilation result actions.
    pub compilation_result_actions: std::vec::Vec<crate::model::CompilationResultAction>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryCompilationResultActionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [compilation_result_actions][crate::model::QueryCompilationResultActionsResponse::compilation_result_actions].
    pub fn set_compilation_result_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::CompilationResultAction>,
    {
        use std::iter::Iterator;
        self.compilation_result_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryCompilationResultActionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryCompilationResultActionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryCompilationResultActionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryCompilationResultActionsResponse {
    type PageItem = crate::model::CompilationResultAction;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.compilation_result_actions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryCompilationResultActionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compilation_result_actions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for QueryCompilationResultActionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compilationResultActions" => {
                                Ok(__FieldTag::__compilation_result_actions)
                            }
                            "compilation_result_actions" => {
                                Ok(__FieldTag::__compilation_result_actions)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryCompilationResultActionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryCompilationResultActionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compilation_result_actions => {
                            if !fields.insert(__FieldTag::__compilation_result_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compilation_result_actions",
                                ));
                            }
                            result.compilation_result_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::CompilationResultAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryCompilationResultActionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.compilation_result_actions.is_empty() {
            state.serialize_entry("compilationResultActions", &self.compilation_result_actions)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a Dataform workflow configuration.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowConfig {
    /// Identifier. The workflow config's name.
    pub name: std::string::String,

    /// Required. The name of the release config whose release_compilation_result
    /// should be executed. Must be in the format
    /// `projects/*/locations/*/repositories/*/releaseConfigs/*`.
    pub release_config: std::string::String,

    /// Optional. If left unset, a default InvocationConfig will be used.
    pub invocation_config: std::option::Option<crate::model::InvocationConfig>,

    /// Optional. Optional schedule (in cron format) for automatic execution of
    /// this workflow config.
    pub cron_schedule: std::string::String,

    /// Optional. Specifies the time zone to be used when interpreting
    /// cron_schedule. Must be a time zone name from the time zone database
    /// (<https://en.wikipedia.org/wiki/List_of_tz_database_time_zones>). If left
    /// unspecified, the default is UTC.
    pub time_zone: std::string::String,

    /// Output only. Records of the 10 most recent scheduled execution attempts,
    /// ordered in descending order of `execution_time`. Updated whenever automatic
    /// creation of a workflow invocation is triggered by cron_schedule.
    pub recent_scheduled_execution_records:
        std::vec::Vec<crate::model::workflow_config::ScheduledExecutionRecord>,

    /// Optional. Disables automatic creation of workflow invocations.
    pub disabled: bool,

    /// Output only. The timestamp of when the WorkflowConfig was created.
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The timestamp of when the WorkflowConfig was last updated.
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkflowConfig::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [release_config][crate::model::WorkflowConfig::release_config].
    pub fn set_release_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.release_config = v.into();
        self
    }

    /// Sets the value of [invocation_config][crate::model::WorkflowConfig::invocation_config].
    pub fn set_invocation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InvocationConfig>,
    {
        self.invocation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation_config][crate::model::WorkflowConfig::invocation_config].
    pub fn set_or_clear_invocation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InvocationConfig>,
    {
        self.invocation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [cron_schedule][crate::model::WorkflowConfig::cron_schedule].
    pub fn set_cron_schedule<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.cron_schedule = v.into();
        self
    }

    /// Sets the value of [time_zone][crate::model::WorkflowConfig::time_zone].
    pub fn set_time_zone<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.time_zone = v.into();
        self
    }

    /// Sets the value of [recent_scheduled_execution_records][crate::model::WorkflowConfig::recent_scheduled_execution_records].
    pub fn set_recent_scheduled_execution_records<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::workflow_config::ScheduledExecutionRecord>,
    {
        use std::iter::Iterator;
        self.recent_scheduled_execution_records = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [disabled][crate::model::WorkflowConfig::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::WorkflowConfig::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::WorkflowConfig::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::WorkflowConfig::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::WorkflowConfig::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::WorkflowConfig::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::WorkflowConfig::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for WorkflowConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.WorkflowConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __release_config,
            __invocation_config,
            __cron_schedule,
            __time_zone,
            __recent_scheduled_execution_records,
            __disabled,
            __create_time,
            __update_time,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "releaseConfig" => Ok(__FieldTag::__release_config),
                            "release_config" => Ok(__FieldTag::__release_config),
                            "invocationConfig" => Ok(__FieldTag::__invocation_config),
                            "invocation_config" => Ok(__FieldTag::__invocation_config),
                            "cronSchedule" => Ok(__FieldTag::__cron_schedule),
                            "cron_schedule" => Ok(__FieldTag::__cron_schedule),
                            "timeZone" => Ok(__FieldTag::__time_zone),
                            "time_zone" => Ok(__FieldTag::__time_zone),
                            "recentScheduledExecutionRecords" => {
                                Ok(__FieldTag::__recent_scheduled_execution_records)
                            }
                            "recent_scheduled_execution_records" => {
                                Ok(__FieldTag::__recent_scheduled_execution_records)
                            }
                            "disabled" => Ok(__FieldTag::__disabled),
                            "createTime" => Ok(__FieldTag::__create_time),
                            "create_time" => Ok(__FieldTag::__create_time),
                            "updateTime" => Ok(__FieldTag::__update_time),
                            "update_time" => Ok(__FieldTag::__update_time),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__release_config => {
                            if !fields.insert(__FieldTag::__release_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for release_config",
                                ));
                            }
                            result.release_config = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation_config => {
                            if !fields.insert(__FieldTag::__invocation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_config",
                                ));
                            }
                            result.invocation_config = map
                                .next_value::<std::option::Option<crate::model::InvocationConfig>>(
                                )?;
                        }
                        __FieldTag::__cron_schedule => {
                            if !fields.insert(__FieldTag::__cron_schedule) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for cron_schedule",
                                ));
                            }
                            result.cron_schedule = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__time_zone => {
                            if !fields.insert(__FieldTag::__time_zone) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for time_zone",
                                ));
                            }
                            result.time_zone = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__recent_scheduled_execution_records => {
                            if !fields.insert(__FieldTag::__recent_scheduled_execution_records) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for recent_scheduled_execution_records",
                                ));
                            }
                            result.recent_scheduled_execution_records = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<
                                        crate::model::workflow_config::ScheduledExecutionRecord,
                                    >,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__disabled => {
                            if !fields.insert(__FieldTag::__disabled) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for disabled",
                                ));
                            }
                            result.disabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__create_time => {
                            if !fields.insert(__FieldTag::__create_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for create_time",
                                ));
                            }
                            result.create_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__update_time => {
                            if !fields.insert(__FieldTag::__update_time) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_time",
                                ));
                            }
                            result.update_time =
                                map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.release_config.is_empty() {
            state.serialize_entry("releaseConfig", &self.release_config)?;
        }
        if self.invocation_config.is_some() {
            state.serialize_entry("invocationConfig", &self.invocation_config)?;
        }
        if !self.cron_schedule.is_empty() {
            state.serialize_entry("cronSchedule", &self.cron_schedule)?;
        }
        if !self.time_zone.is_empty() {
            state.serialize_entry("timeZone", &self.time_zone)?;
        }
        if !self.recent_scheduled_execution_records.is_empty() {
            state.serialize_entry(
                "recentScheduledExecutionRecords",
                &self.recent_scheduled_execution_records,
            )?;
        }
        if !wkt::internal::is_default(&self.disabled) {
            state.serialize_entry("disabled", &self.disabled)?;
        }
        if self.create_time.is_some() {
            state.serialize_entry("createTime", &self.create_time)?;
        }
        if self.update_time.is_some() {
            state.serialize_entry("updateTime", &self.update_time)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowConfig].
pub mod workflow_config {
    #[allow(unused_imports)]
    use super::*;

    /// A record of an attempt to create a workflow invocation for this workflow
    /// config.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct ScheduledExecutionRecord {
        /// Output only. The timestamp of this execution attempt.
        pub execution_time: std::option::Option<wkt::Timestamp>,

        /// The result of this execution attempt.
        pub result:
            std::option::Option<crate::model::workflow_config::scheduled_execution_record::Result>,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl ScheduledExecutionRecord {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [execution_time][crate::model::workflow_config::ScheduledExecutionRecord::execution_time].
        pub fn set_execution_time<T>(mut self, v: T) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.execution_time = std::option::Option::Some(v.into());
            self
        }

        /// Sets or clears the value of [execution_time][crate::model::workflow_config::ScheduledExecutionRecord::execution_time].
        pub fn set_or_clear_execution_time<T>(mut self, v: std::option::Option<T>) -> Self
        where
            T: std::convert::Into<wkt::Timestamp>,
        {
            self.execution_time = v.map(|x| x.into());
            self
        }

        /// Sets the value of [result][crate::model::workflow_config::ScheduledExecutionRecord::result].
        ///
        /// Note that all the setters affecting `result` are mutually
        /// exclusive.
        pub fn set_result<
            T: std::convert::Into<
                    std::option::Option<
                        crate::model::workflow_config::scheduled_execution_record::Result,
                    >,
                >,
        >(
            mut self,
            v: T,
        ) -> Self {
            self.result = v.into();
            self
        }

        /// The value of [result][crate::model::workflow_config::ScheduledExecutionRecord::result]
        /// if it holds a `WorkflowInvocation`, `None` if the field is not set or
        /// holds a different branch.
        pub fn workflow_invocation(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::workflow_config::scheduled_execution_record::Result::WorkflowInvocation(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::workflow_config::ScheduledExecutionRecord::result]
        /// to hold a `WorkflowInvocation`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_workflow_invocation<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::workflow_config::scheduled_execution_record::Result::WorkflowInvocation(
                    v.into()
                )
            );
            self
        }

        /// The value of [result][crate::model::workflow_config::ScheduledExecutionRecord::result]
        /// if it holds a `ErrorStatus`, `None` if the field is not set or
        /// holds a different branch.
        pub fn error_status(&self) -> std::option::Option<&std::boxed::Box<rpc::model::Status>> {
            #[allow(unreachable_patterns)]
            self.result.as_ref().and_then(|v| match v {
                crate::model::workflow_config::scheduled_execution_record::Result::ErrorStatus(
                    v,
                ) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [result][crate::model::workflow_config::ScheduledExecutionRecord::result]
        /// to hold a `ErrorStatus`.
        ///
        /// Note that all the setters affecting `result` are
        /// mutually exclusive.
        pub fn set_error_status<T: std::convert::Into<std::boxed::Box<rpc::model::Status>>>(
            mut self,
            v: T,
        ) -> Self {
            self.result = std::option::Option::Some(
                crate::model::workflow_config::scheduled_execution_record::Result::ErrorStatus(
                    v.into(),
                ),
            );
            self
        }
    }

    impl wkt::message::Message for ScheduledExecutionRecord {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.WorkflowConfig.ScheduledExecutionRecord"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for ScheduledExecutionRecord {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __workflow_invocation,
                __error_status,
                __execution_time,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for ScheduledExecutionRecord")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "workflowInvocation" => Ok(__FieldTag::__workflow_invocation),
                                "workflow_invocation" => Ok(__FieldTag::__workflow_invocation),
                                "errorStatus" => Ok(__FieldTag::__error_status),
                                "error_status" => Ok(__FieldTag::__error_status),
                                "executionTime" => Ok(__FieldTag::__execution_time),
                                "execution_time" => Ok(__FieldTag::__execution_time),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = ScheduledExecutionRecord;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct ScheduledExecutionRecord")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__workflow_invocation => {
                                if !fields.insert(__FieldTag::__workflow_invocation) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for workflow_invocation",
                                    ));
                                }
                                if result.result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `result`, a oneof with full ID .google.cloud.dataform.v1.WorkflowConfig.ScheduledExecutionRecord.workflow_invocation, latest field was workflowInvocation",
                                    ));
                                }
                                result.result = std::option::Option::Some(
                                    crate::model::workflow_config::scheduled_execution_record::Result::WorkflowInvocation(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__error_status => {
                                if !fields.insert(__FieldTag::__error_status) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for error_status",
                                    ));
                                }
                                if result.result.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `result`, a oneof with full ID .google.cloud.dataform.v1.WorkflowConfig.ScheduledExecutionRecord.error_status, latest field was errorStatus",
                                    ));
                                }
                                result.result = std::option::Option::Some(
                                    crate::model::workflow_config::scheduled_execution_record::Result::ErrorStatus(
                                        map.next_value::<std::option::Option<std::boxed::Box<rpc::model::Status>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__execution_time => {
                                if !fields.insert(__FieldTag::__execution_time) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for execution_time",
                                    ));
                                }
                                result.execution_time =
                                    map.next_value::<std::option::Option<wkt::Timestamp>>()?;
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for ScheduledExecutionRecord {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.workflow_invocation() {
                state.serialize_entry("workflowInvocation", value)?;
            }
            if let Some(value) = self.error_status() {
                state.serialize_entry("errorStatus", value)?;
            }
            if self.execution_time.is_some() {
                state.serialize_entry("executionTime", &self.execution_time)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [ScheduledExecutionRecord].
    pub mod scheduled_execution_record {
        #[allow(unused_imports)]
        use super::*;

        /// The result of this execution attempt.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Result {
            /// The name of the created workflow invocation, if one was successfully
            /// created. Must be in the format
            /// `projects/*/locations/*/repositories/*/workflowInvocations/*`.
            WorkflowInvocation(std::string::String),
            /// The error status encountered upon this attempt to create the
            /// workflow invocation, if the attempt was unsuccessful.
            ErrorStatus(std::boxed::Box<rpc::model::Status>),
        }
    }
}

/// Includes various configuration options for a workflow invocation.
/// If both `included_targets` and `included_tags` are unset, all actions
/// will be included.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct InvocationConfig {
    /// Optional. The set of action identifiers to include.
    pub included_targets: std::vec::Vec<crate::model::Target>,

    /// Optional. The set of tags to include.
    pub included_tags: std::vec::Vec<std::string::String>,

    /// Optional. When set to true, transitive dependencies of included actions
    /// will be executed.
    pub transitive_dependencies_included: bool,

    /// Optional. When set to true, transitive dependents of included actions will
    /// be executed.
    pub transitive_dependents_included: bool,

    /// Optional. When set to true, any incremental tables will be fully refreshed.
    pub fully_refresh_incremental_tables_enabled: bool,

    /// Optional. The service account to run workflow invocations under.
    pub service_account: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InvocationConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [included_targets][crate::model::InvocationConfig::included_targets].
    pub fn set_included_targets<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Target>,
    {
        use std::iter::Iterator;
        self.included_targets = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [included_tags][crate::model::InvocationConfig::included_tags].
    pub fn set_included_tags<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.included_tags = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [transitive_dependencies_included][crate::model::InvocationConfig::transitive_dependencies_included].
    pub fn set_transitive_dependencies_included<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.transitive_dependencies_included = v.into();
        self
    }

    /// Sets the value of [transitive_dependents_included][crate::model::InvocationConfig::transitive_dependents_included].
    pub fn set_transitive_dependents_included<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.transitive_dependents_included = v.into();
        self
    }

    /// Sets the value of [fully_refresh_incremental_tables_enabled][crate::model::InvocationConfig::fully_refresh_incremental_tables_enabled].
    pub fn set_fully_refresh_incremental_tables_enabled<T: std::convert::Into<bool>>(
        mut self,
        v: T,
    ) -> Self {
        self.fully_refresh_incremental_tables_enabled = v.into();
        self
    }

    /// Sets the value of [service_account][crate::model::InvocationConfig::service_account].
    pub fn set_service_account<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service_account = v.into();
        self
    }
}

impl wkt::message::Message for InvocationConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.InvocationConfig"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for InvocationConfig {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __included_targets,
            __included_tags,
            __transitive_dependencies_included,
            __transitive_dependents_included,
            __fully_refresh_incremental_tables_enabled,
            __service_account,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for InvocationConfig")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "includedTargets" => Ok(__FieldTag::__included_targets),
                            "included_targets" => Ok(__FieldTag::__included_targets),
                            "includedTags" => Ok(__FieldTag::__included_tags),
                            "included_tags" => Ok(__FieldTag::__included_tags),
                            "transitiveDependenciesIncluded" => {
                                Ok(__FieldTag::__transitive_dependencies_included)
                            }
                            "transitive_dependencies_included" => {
                                Ok(__FieldTag::__transitive_dependencies_included)
                            }
                            "transitiveDependentsIncluded" => {
                                Ok(__FieldTag::__transitive_dependents_included)
                            }
                            "transitive_dependents_included" => {
                                Ok(__FieldTag::__transitive_dependents_included)
                            }
                            "fullyRefreshIncrementalTablesEnabled" => {
                                Ok(__FieldTag::__fully_refresh_incremental_tables_enabled)
                            }
                            "fully_refresh_incremental_tables_enabled" => {
                                Ok(__FieldTag::__fully_refresh_incremental_tables_enabled)
                            }
                            "serviceAccount" => Ok(__FieldTag::__service_account),
                            "service_account" => Ok(__FieldTag::__service_account),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = InvocationConfig;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct InvocationConfig")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__included_targets => {
                            if !fields.insert(__FieldTag::__included_targets) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_targets",
                                ));
                            }
                            result.included_targets = map.next_value::<std::option::Option<std::vec::Vec<crate::model::Target>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__included_tags => {
                            if !fields.insert(__FieldTag::__included_tags) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for included_tags",
                                ));
                            }
                            result.included_tags = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::__transitive_dependencies_included => {
                            if !fields.insert(__FieldTag::__transitive_dependencies_included) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transitive_dependencies_included",
                                ));
                            }
                            result.transitive_dependencies_included = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__transitive_dependents_included => {
                            if !fields.insert(__FieldTag::__transitive_dependents_included) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for transitive_dependents_included",
                                ));
                            }
                            result.transitive_dependents_included = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__fully_refresh_incremental_tables_enabled => {
                            if !fields
                                .insert(__FieldTag::__fully_refresh_incremental_tables_enabled)
                            {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for fully_refresh_incremental_tables_enabled",
                                ));
                            }
                            result.fully_refresh_incremental_tables_enabled = map
                                .next_value::<std::option::Option<bool>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__service_account => {
                            if !fields.insert(__FieldTag::__service_account) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for service_account",
                                ));
                            }
                            result.service_account = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for InvocationConfig {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.included_targets.is_empty() {
            state.serialize_entry("includedTargets", &self.included_targets)?;
        }
        if !self.included_tags.is_empty() {
            state.serialize_entry("includedTags", &self.included_tags)?;
        }
        if !wkt::internal::is_default(&self.transitive_dependencies_included) {
            state.serialize_entry(
                "transitiveDependenciesIncluded",
                &self.transitive_dependencies_included,
            )?;
        }
        if !wkt::internal::is_default(&self.transitive_dependents_included) {
            state.serialize_entry(
                "transitiveDependentsIncluded",
                &self.transitive_dependents_included,
            )?;
        }
        if !wkt::internal::is_default(&self.fully_refresh_incremental_tables_enabled) {
            state.serialize_entry(
                "fullyRefreshIncrementalTablesEnabled",
                &self.fully_refresh_incremental_tables_enabled,
            )?;
        }
        if !self.service_account.is_empty() {
            state.serialize_entry("serviceAccount", &self.service_account)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListWorkflowConfigs` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowConfigsRequest {
    /// Required. The repository in which to list workflow configs. Must be in the
    /// format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of workflow configs to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListWorkflowConfigs` call.
    /// Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to `ListWorkflowConfigs`,
    /// with the exception of `page_size`, must match the call that provided the
    /// page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowConfigsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkflowConfigsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkflowConfigsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkflowConfigsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkflowConfigsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkflowConfigsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowConfigsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowConfigsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowConfigsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowConfigsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowConfigsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListWorkflowConfigs` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowConfigsResponse {
    /// List of workflow configs.
    pub workflow_configs: std::vec::Vec<crate::model::WorkflowConfig>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowConfigsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workflow_configs][crate::model::ListWorkflowConfigsResponse::workflow_configs].
    pub fn set_workflow_configs<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowConfig>,
    {
        use std::iter::Iterator;
        self.workflow_configs = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkflowConfigsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkflowConfigsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkflowConfigsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkflowConfigsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkflowConfigsResponse {
    type PageItem = crate::model::WorkflowConfig;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workflow_configs
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowConfigsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workflow_configs,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowConfigsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workflowConfigs" => Ok(__FieldTag::__workflow_configs),
                            "workflow_configs" => Ok(__FieldTag::__workflow_configs),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowConfigsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowConfigsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workflow_configs => {
                            if !fields.insert(__FieldTag::__workflow_configs) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_configs",
                                ));
                            }
                            result.workflow_configs =
                                map.next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkflowConfig>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowConfigsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workflow_configs.is_empty() {
            state.serialize_entry("workflowConfigs", &self.workflow_configs)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetWorkflowConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkflowConfigRequest {
    /// Required. The workflow config's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkflowConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkflowConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkflowConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetWorkflowConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkflowConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkflowConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkflowConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkflowConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkflowConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateWorkflowConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkflowConfigRequest {
    /// Required. The repository in which to create the workflow config. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Required. The workflow config to create.
    pub workflow_config: std::option::Option<crate::model::WorkflowConfig>,

    /// Required. The ID to use for the workflow config, which will become the
    /// final component of the workflow config's resource name.
    pub workflow_config_id: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkflowConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkflowConfigRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workflow_config][crate::model::CreateWorkflowConfigRequest::workflow_config].
    pub fn set_workflow_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowConfig>,
    {
        self.workflow_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workflow_config][crate::model::CreateWorkflowConfigRequest::workflow_config].
    pub fn set_or_clear_workflow_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowConfig>,
    {
        self.workflow_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workflow_config_id][crate::model::CreateWorkflowConfigRequest::workflow_config_id].
    pub fn set_workflow_config_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.workflow_config_id = v.into();
        self
    }
}

impl wkt::message::Message for CreateWorkflowConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateWorkflowConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkflowConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workflow_config,
            __workflow_config_id,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkflowConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workflowConfig" => Ok(__FieldTag::__workflow_config),
                            "workflow_config" => Ok(__FieldTag::__workflow_config),
                            "workflowConfigId" => Ok(__FieldTag::__workflow_config_id),
                            "workflow_config_id" => Ok(__FieldTag::__workflow_config_id),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkflowConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkflowConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workflow_config => {
                            if !fields.insert(__FieldTag::__workflow_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_config",
                                ));
                            }
                            result.workflow_config = map
                                .next_value::<std::option::Option<crate::model::WorkflowConfig>>(
                                )?;
                        }
                        __FieldTag::__workflow_config_id => {
                            if !fields.insert(__FieldTag::__workflow_config_id) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_config_id",
                                ));
                            }
                            result.workflow_config_id = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkflowConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.workflow_config.is_some() {
            state.serialize_entry("workflowConfig", &self.workflow_config)?;
        }
        if !self.workflow_config_id.is_empty() {
            state.serialize_entry("workflowConfigId", &self.workflow_config_id)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `UpdateWorkflowConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateWorkflowConfigRequest {
    /// Optional. Specifies the fields to be updated in the workflow config. If
    /// left unset, all fields will be updated.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The workflow config to update.
    pub workflow_config: std::option::Option<crate::model::WorkflowConfig>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateWorkflowConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateWorkflowConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateWorkflowConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [workflow_config][crate::model::UpdateWorkflowConfigRequest::workflow_config].
    pub fn set_workflow_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowConfig>,
    {
        self.workflow_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workflow_config][crate::model::UpdateWorkflowConfigRequest::workflow_config].
    pub fn set_or_clear_workflow_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowConfig>,
    {
        self.workflow_config = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateWorkflowConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.UpdateWorkflowConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateWorkflowConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __update_mask,
            __workflow_config,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateWorkflowConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            "workflowConfig" => Ok(__FieldTag::__workflow_config),
                            "workflow_config" => Ok(__FieldTag::__workflow_config),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateWorkflowConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateWorkflowConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::__workflow_config => {
                            if !fields.insert(__FieldTag::__workflow_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_config",
                                ));
                            }
                            result.workflow_config = map
                                .next_value::<std::option::Option<crate::model::WorkflowConfig>>(
                                )?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateWorkflowConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if self.workflow_config.is_some() {
            state.serialize_entry("workflowConfig", &self.workflow_config)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `DeleteWorkflowConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkflowConfigRequest {
    /// Required. The workflow config's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkflowConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkflowConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkflowConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DeleteWorkflowConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkflowConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkflowConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkflowConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkflowConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkflowConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single invocation of a compilation result.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowInvocation {
    /// Output only. The workflow invocation's name.
    pub name: std::string::String,

    /// Immutable. If left unset, a default InvocationConfig will be used.
    pub invocation_config: std::option::Option<crate::model::InvocationConfig>,

    /// Output only. This workflow invocation's current state.
    pub state: crate::model::workflow_invocation::State,

    /// Output only. This workflow invocation's timing details.
    pub invocation_timing: std::option::Option<gtype::model::Interval>,

    /// Output only. The resolved compilation result that was used to create this
    /// invocation. Will be in the format
    /// `projects/*/locations/*/repositories/*/compilationResults/*`.
    pub resolved_compilation_result: std::string::String,

    /// Output only. Only set if the repository has a KMS Key.
    pub data_encryption_state: std::option::Option<crate::model::DataEncryptionState>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    /// The source of the compilation result to use for this invocation.
    pub compilation_source:
        std::option::Option<crate::model::workflow_invocation::CompilationSource>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowInvocation {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::WorkflowInvocation::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [invocation_config][crate::model::WorkflowInvocation::invocation_config].
    pub fn set_invocation_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InvocationConfig>,
    {
        self.invocation_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation_config][crate::model::WorkflowInvocation::invocation_config].
    pub fn set_or_clear_invocation_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InvocationConfig>,
    {
        self.invocation_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::WorkflowInvocation::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_invocation::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [invocation_timing][crate::model::WorkflowInvocation::invocation_timing].
    pub fn set_invocation_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.invocation_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation_timing][crate::model::WorkflowInvocation::invocation_timing].
    pub fn set_or_clear_invocation_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.invocation_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [resolved_compilation_result][crate::model::WorkflowInvocation::resolved_compilation_result].
    pub fn set_resolved_compilation_result<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.resolved_compilation_result = v.into();
        self
    }

    /// Sets the value of [data_encryption_state][crate::model::WorkflowInvocation::data_encryption_state].
    pub fn set_data_encryption_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [data_encryption_state][crate::model::WorkflowInvocation::data_encryption_state].
    pub fn set_or_clear_data_encryption_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::DataEncryptionState>,
    {
        self.data_encryption_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::WorkflowInvocation::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::WorkflowInvocation::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [compilation_source][crate::model::WorkflowInvocation::compilation_source].
    ///
    /// Note that all the setters affecting `compilation_source` are mutually
    /// exclusive.
    pub fn set_compilation_source<
        T: std::convert::Into<
                std::option::Option<crate::model::workflow_invocation::CompilationSource>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.compilation_source = v.into();
        self
    }

    /// The value of [compilation_source][crate::model::WorkflowInvocation::compilation_source]
    /// if it holds a `CompilationResult`, `None` if the field is not set or
    /// holds a different branch.
    pub fn compilation_result(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.compilation_source.as_ref().and_then(|v| match v {
            crate::model::workflow_invocation::CompilationSource::CompilationResult(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compilation_source][crate::model::WorkflowInvocation::compilation_source]
    /// to hold a `CompilationResult`.
    ///
    /// Note that all the setters affecting `compilation_source` are
    /// mutually exclusive.
    pub fn set_compilation_result<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.compilation_source = std::option::Option::Some(
            crate::model::workflow_invocation::CompilationSource::CompilationResult(v.into()),
        );
        self
    }

    /// The value of [compilation_source][crate::model::WorkflowInvocation::compilation_source]
    /// if it holds a `WorkflowConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn workflow_config(&self) -> std::option::Option<&std::string::String> {
        #[allow(unreachable_patterns)]
        self.compilation_source.as_ref().and_then(|v| match v {
            crate::model::workflow_invocation::CompilationSource::WorkflowConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [compilation_source][crate::model::WorkflowInvocation::compilation_source]
    /// to hold a `WorkflowConfig`.
    ///
    /// Note that all the setters affecting `compilation_source` are
    /// mutually exclusive.
    pub fn set_workflow_config<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.compilation_source = std::option::Option::Some(
            crate::model::workflow_invocation::CompilationSource::WorkflowConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkflowInvocation {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocation"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowInvocation {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __compilation_result,
            __workflow_config,
            __name,
            __invocation_config,
            __state,
            __invocation_timing,
            __resolved_compilation_result,
            __data_encryption_state,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowInvocation")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "compilationResult" => Ok(__FieldTag::__compilation_result),
                            "compilation_result" => Ok(__FieldTag::__compilation_result),
                            "workflowConfig" => Ok(__FieldTag::__workflow_config),
                            "workflow_config" => Ok(__FieldTag::__workflow_config),
                            "name" => Ok(__FieldTag::__name),
                            "invocationConfig" => Ok(__FieldTag::__invocation_config),
                            "invocation_config" => Ok(__FieldTag::__invocation_config),
                            "state" => Ok(__FieldTag::__state),
                            "invocationTiming" => Ok(__FieldTag::__invocation_timing),
                            "invocation_timing" => Ok(__FieldTag::__invocation_timing),
                            "resolvedCompilationResult" => {
                                Ok(__FieldTag::__resolved_compilation_result)
                            }
                            "resolved_compilation_result" => {
                                Ok(__FieldTag::__resolved_compilation_result)
                            }
                            "dataEncryptionState" => Ok(__FieldTag::__data_encryption_state),
                            "data_encryption_state" => Ok(__FieldTag::__data_encryption_state),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowInvocation;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowInvocation")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__compilation_result => {
                            if !fields.insert(__FieldTag::__compilation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for compilation_result",
                                ));
                            }
                            if result.compilation_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compilation_source`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocation.compilation_result, latest field was compilationResult",
                                ));
                            }
                            result.compilation_source = std::option::Option::Some(
                                crate::model::workflow_invocation::CompilationSource::CompilationResult(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__workflow_config => {
                            if !fields.insert(__FieldTag::__workflow_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_config",
                                ));
                            }
                            if result.compilation_source.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `compilation_source`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocation.workflow_config, latest field was workflowConfig",
                                ));
                            }
                            result.compilation_source = std::option::Option::Some(
                                crate::model::workflow_invocation::CompilationSource::WorkflowConfig(
                                    map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation_config => {
                            if !fields.insert(__FieldTag::__invocation_config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_config",
                                ));
                            }
                            result.invocation_config = map
                                .next_value::<std::option::Option<crate::model::InvocationConfig>>(
                                )?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map.next_value::<std::option::Option<crate::model::workflow_invocation::State>>()?.unwrap_or_default();
                        }
                        __FieldTag::__invocation_timing => {
                            if !fields.insert(__FieldTag::__invocation_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_timing",
                                ));
                            }
                            result.invocation_timing =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::__resolved_compilation_result => {
                            if !fields.insert(__FieldTag::__resolved_compilation_result) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for resolved_compilation_result",
                                ));
                            }
                            result.resolved_compilation_result = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__data_encryption_state => {
                            if !fields.insert(__FieldTag::__data_encryption_state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_encryption_state",
                                ));
                            }
                            result.data_encryption_state = map.next_value::<std::option::Option<crate::model::DataEncryptionState>>()?
                                ;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowInvocation {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.compilation_result() {
            state.serialize_entry("compilationResult", value)?;
        }
        if let Some(value) = self.workflow_config() {
            state.serialize_entry("workflowConfig", value)?;
        }
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if self.invocation_config.is_some() {
            state.serialize_entry("invocationConfig", &self.invocation_config)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if self.invocation_timing.is_some() {
            state.serialize_entry("invocationTiming", &self.invocation_timing)?;
        }
        if !self.resolved_compilation_result.is_empty() {
            state.serialize_entry(
                "resolvedCompilationResult",
                &self.resolved_compilation_result,
            )?;
        }
        if self.data_encryption_state.is_some() {
            state.serialize_entry("dataEncryptionState", &self.data_encryption_state)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowInvocation].
pub mod workflow_invocation {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the current state of a workflow invocation.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// Default value. This value is unused.
        Unspecified,
        /// The workflow invocation is currently running.
        Running,
        /// The workflow invocation succeeded. A terminal state.
        Succeeded,
        /// The workflow invocation was cancelled. A terminal state.
        Cancelled,
        /// The workflow invocation failed. A terminal state.
        Failed,
        /// The workflow invocation is being cancelled, but some actions are still
        /// running.
        Canceling,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Succeeded => std::option::Option::Some(2),
                Self::Cancelled => std::option::Option::Some(3),
                Self::Failed => std::option::Option::Some(4),
                Self::Canceling => std::option::Option::Some(5),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STATE_UNSPECIFIED"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::Canceling => std::option::Option::Some("CANCELING"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Running,
                2 => Self::Succeeded,
                3 => Self::Cancelled,
                4 => Self::Failed,
                5 => Self::Canceling,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STATE_UNSPECIFIED" => Self::Unspecified,
                "RUNNING" => Self::Running,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                "CANCELING" => Self::Canceling,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Succeeded => serializer.serialize_i32(2),
                Self::Cancelled => serializer.serialize_i32(3),
                Self::Failed => serializer.serialize_i32(4),
                Self::Canceling => serializer.serialize_i32(5),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataform.v1.WorkflowInvocation.State",
            ))
        }
    }

    /// The source of the compilation result to use for this invocation.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum CompilationSource {
        /// Immutable. The name of the compilation result to use for this invocation.
        /// Must be in the format
        /// `projects/*/locations/*/repositories/*/compilationResults/*`.
        CompilationResult(std::string::String),
        /// Immutable. The name of the workflow config to invoke. Must be in the
        /// format `projects/*/locations/*/repositories/*/workflowConfigs/*`.
        WorkflowConfig(std::string::String),
    }
}

/// `ListWorkflowInvocations` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowInvocationsRequest {
    /// Required. The parent resource of the WorkflowInvocation type. Must be in
    /// the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Optional. Maximum number of workflow invocations to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous `ListWorkflowInvocations`
    /// call. Provide this to retrieve the subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `ListWorkflowInvocations`, with the exception of `page_size`, must match
    /// the call that provided the page token.
    pub page_token: std::string::String,

    /// Optional. This field only supports ordering by `name`. If unspecified, the
    /// server will choose the ordering. If specified, the default order is
    /// ascending for the `name` field.
    pub order_by: std::string::String,

    /// Optional. Filter for the returned list.
    pub filter: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowInvocationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListWorkflowInvocationsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListWorkflowInvocationsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListWorkflowInvocationsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListWorkflowInvocationsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListWorkflowInvocationsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }
}

impl wkt::message::Message for ListWorkflowInvocationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkflowInvocationsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowInvocationsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __page_size,
            __page_token,
            __order_by,
            __filter,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowInvocationsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            "orderBy" => Ok(__FieldTag::__order_by),
                            "order_by" => Ok(__FieldTag::__order_by),
                            "filter" => Ok(__FieldTag::__filter),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowInvocationsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowInvocationsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__order_by => {
                            if !fields.insert(__FieldTag::__order_by) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for order_by",
                                ));
                            }
                            result.order_by = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__filter => {
                            if !fields.insert(__FieldTag::__filter) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for filter",
                                ));
                            }
                            result.filter = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowInvocationsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self.order_by.is_empty() {
            state.serialize_entry("orderBy", &self.order_by)?;
        }
        if !self.filter.is_empty() {
            state.serialize_entry("filter", &self.filter)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `ListWorkflowInvocations` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct ListWorkflowInvocationsResponse {
    /// List of workflow invocations.
    pub workflow_invocations: std::vec::Vec<crate::model::WorkflowInvocation>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    /// Locations which could not be reached.
    pub unreachable: std::vec::Vec<std::string::String>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListWorkflowInvocationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workflow_invocations][crate::model::ListWorkflowInvocationsResponse::workflow_invocations].
    pub fn set_workflow_invocations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowInvocation>,
    {
        use std::iter::Iterator;
        self.workflow_invocations = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListWorkflowInvocationsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListWorkflowInvocationsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListWorkflowInvocationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.ListWorkflowInvocationsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListWorkflowInvocationsResponse {
    type PageItem = crate::model::WorkflowInvocation;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workflow_invocations
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for ListWorkflowInvocationsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workflow_invocations,
            __next_page_token,
            __unreachable,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for ListWorkflowInvocationsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workflowInvocations" => Ok(__FieldTag::__workflow_invocations),
                            "workflow_invocations" => Ok(__FieldTag::__workflow_invocations),
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            "unreachable" => Ok(__FieldTag::__unreachable),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = ListWorkflowInvocationsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct ListWorkflowInvocationsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workflow_invocations => {
                            if !fields.insert(__FieldTag::__workflow_invocations) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_invocations",
                                ));
                            }
                            result.workflow_invocations = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkflowInvocation>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__unreachable => {
                            if !fields.insert(__FieldTag::__unreachable) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for unreachable",
                                ));
                            }
                            result.unreachable = map.next_value::<std::option::Option<std::vec::Vec<std::string::String>>>()?.unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for ListWorkflowInvocationsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workflow_invocations.is_empty() {
            state.serialize_entry("workflowInvocations", &self.workflow_invocations)?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self.unreachable.is_empty() {
            state.serialize_entry("unreachable", &self.unreachable)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetWorkflowInvocation` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetWorkflowInvocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetWorkflowInvocationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetWorkflowInvocationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetWorkflowInvocationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetWorkflowInvocationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetWorkflowInvocationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetWorkflowInvocationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetWorkflowInvocationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetWorkflowInvocationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CreateWorkflowInvocation` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CreateWorkflowInvocationRequest {
    /// Required. The repository in which to create the workflow invocation. Must
    /// be in the format `projects/*/locations/*/repositories/*`.
    pub parent: std::string::String,

    /// Required. The workflow invocation resource to create.
    pub workflow_invocation: std::option::Option<crate::model::WorkflowInvocation>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateWorkflowInvocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateWorkflowInvocationRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [workflow_invocation][crate::model::CreateWorkflowInvocationRequest::workflow_invocation].
    pub fn set_workflow_invocation<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowInvocation>,
    {
        self.workflow_invocation = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [workflow_invocation][crate::model::CreateWorkflowInvocationRequest::workflow_invocation].
    pub fn set_or_clear_workflow_invocation<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::WorkflowInvocation>,
    {
        self.workflow_invocation = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for CreateWorkflowInvocationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CreateWorkflowInvocationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CreateWorkflowInvocationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __parent,
            __workflow_invocation,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CreateWorkflowInvocationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "parent" => Ok(__FieldTag::__parent),
                            "workflowInvocation" => Ok(__FieldTag::__workflow_invocation),
                            "workflow_invocation" => Ok(__FieldTag::__workflow_invocation),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CreateWorkflowInvocationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CreateWorkflowInvocationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__parent => {
                            if !fields.insert(__FieldTag::__parent) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for parent",
                                ));
                            }
                            result.parent = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__workflow_invocation => {
                            if !fields.insert(__FieldTag::__workflow_invocation) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_invocation",
                                ));
                            }
                            result.workflow_invocation = map.next_value::<std::option::Option<crate::model::WorkflowInvocation>>()?
                                ;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CreateWorkflowInvocationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.parent.is_empty() {
            state.serialize_entry("parent", &self.parent)?;
        }
        if self.workflow_invocation.is_some() {
            state.serialize_entry("workflowInvocation", &self.workflow_invocation)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `DeleteWorkflowInvocation` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct DeleteWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteWorkflowInvocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteWorkflowInvocationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for DeleteWorkflowInvocationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.DeleteWorkflowInvocationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for DeleteWorkflowInvocationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for DeleteWorkflowInvocationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = DeleteWorkflowInvocationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct DeleteWorkflowInvocationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for DeleteWorkflowInvocationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CancelWorkflowInvocation` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelWorkflowInvocationRequest {
    /// Required. The workflow invocation resource's name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelWorkflowInvocationRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::CancelWorkflowInvocationRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for CancelWorkflowInvocationRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CancelWorkflowInvocationRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelWorkflowInvocationRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelWorkflowInvocationRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelWorkflowInvocationRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelWorkflowInvocationRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelWorkflowInvocationRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `CancelWorkflowInvocation` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct CancelWorkflowInvocationResponse {
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CancelWorkflowInvocationResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }
}

impl wkt::message::Message for CancelWorkflowInvocationResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.CancelWorkflowInvocationResponse"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for CancelWorkflowInvocationResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for CancelWorkflowInvocationResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        Ok(__FieldTag::Unknown(value.to_string()))
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = CancelWorkflowInvocationResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct CancelWorkflowInvocationResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for CancelWorkflowInvocationResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Represents a single action in a workflow invocation.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct WorkflowInvocationAction {
    /// Output only. This action's identifier. Unique within the workflow
    /// invocation.
    pub target: std::option::Option<crate::model::Target>,

    /// Output only. The action's identifier if the project had been compiled
    /// without any overrides configured. Unique within the compilation result.
    pub canonical_target: std::option::Option<crate::model::Target>,

    /// Output only. This action's current state.
    pub state: crate::model::workflow_invocation_action::State,

    /// Output only. If and only if action's state is FAILED a failure reason is
    /// set.
    pub failure_reason: std::string::String,

    /// Output only. This action's timing details.
    /// `start_time` will be set if the action is in [RUNNING, SUCCEEDED,
    /// CANCELLED, FAILED] state.
    /// `end_time` will be set if the action is in [SUCCEEDED, CANCELLED, FAILED]
    /// state.
    pub invocation_timing: std::option::Option<gtype::model::Interval>,

    /// Output only. All the metadata information that is used internally to serve
    /// the resource. For example: timestamps, flags, status fields, etc. The
    /// format of this field is a JSON string.
    pub internal_metadata: std::option::Option<std::string::String>,

    /// The action's details.
    pub action: std::option::Option<crate::model::workflow_invocation_action::Action>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl WorkflowInvocationAction {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [target][crate::model::WorkflowInvocationAction::target].
    pub fn set_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [target][crate::model::WorkflowInvocationAction::target].
    pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [canonical_target][crate::model::WorkflowInvocationAction::canonical_target].
    pub fn set_canonical_target<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.canonical_target = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [canonical_target][crate::model::WorkflowInvocationAction::canonical_target].
    pub fn set_or_clear_canonical_target<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Target>,
    {
        self.canonical_target = v.map(|x| x.into());
        self
    }

    /// Sets the value of [state][crate::model::WorkflowInvocationAction::state].
    pub fn set_state<T: std::convert::Into<crate::model::workflow_invocation_action::State>>(
        mut self,
        v: T,
    ) -> Self {
        self.state = v.into();
        self
    }

    /// Sets the value of [failure_reason][crate::model::WorkflowInvocationAction::failure_reason].
    pub fn set_failure_reason<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.failure_reason = v.into();
        self
    }

    /// Sets the value of [invocation_timing][crate::model::WorkflowInvocationAction::invocation_timing].
    pub fn set_invocation_timing<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.invocation_timing = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [invocation_timing][crate::model::WorkflowInvocationAction::invocation_timing].
    pub fn set_or_clear_invocation_timing<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<gtype::model::Interval>,
    {
        self.invocation_timing = v.map(|x| x.into());
        self
    }

    /// Sets the value of [internal_metadata][crate::model::WorkflowInvocationAction::internal_metadata].
    pub fn set_internal_metadata<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [internal_metadata][crate::model::WorkflowInvocationAction::internal_metadata].
    pub fn set_or_clear_internal_metadata<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<std::string::String>,
    {
        self.internal_metadata = v.map(|x| x.into());
        self
    }

    /// Sets the value of [action][crate::model::WorkflowInvocationAction::action].
    ///
    /// Note that all the setters affecting `action` are mutually
    /// exclusive.
    pub fn set_action<
        T: std::convert::Into<std::option::Option<crate::model::workflow_invocation_action::Action>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = v.into();
        self
    }

    /// The value of [action][crate::model::WorkflowInvocationAction::action]
    /// if it holds a `BigqueryAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn bigquery_action(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::workflow_invocation_action::BigQueryAction>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::workflow_invocation_action::Action::BigqueryAction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::WorkflowInvocationAction::action]
    /// to hold a `BigqueryAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_bigquery_action<
        T: std::convert::Into<
                std::boxed::Box<crate::model::workflow_invocation_action::BigQueryAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::workflow_invocation_action::Action::BigqueryAction(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::WorkflowInvocationAction::action]
    /// if it holds a `NotebookAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn notebook_action(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::workflow_invocation_action::NotebookAction>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::workflow_invocation_action::Action::NotebookAction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::WorkflowInvocationAction::action]
    /// to hold a `NotebookAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_notebook_action<
        T: std::convert::Into<
                std::boxed::Box<crate::model::workflow_invocation_action::NotebookAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::workflow_invocation_action::Action::NotebookAction(v.into()),
        );
        self
    }

    /// The value of [action][crate::model::WorkflowInvocationAction::action]
    /// if it holds a `DataPreparationAction`, `None` if the field is not set or
    /// holds a different branch.
    pub fn data_preparation_action(
        &self,
    ) -> std::option::Option<
        &std::boxed::Box<crate::model::workflow_invocation_action::DataPreparationAction>,
    > {
        #[allow(unreachable_patterns)]
        self.action.as_ref().and_then(|v| match v {
            crate::model::workflow_invocation_action::Action::DataPreparationAction(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [action][crate::model::WorkflowInvocationAction::action]
    /// to hold a `DataPreparationAction`.
    ///
    /// Note that all the setters affecting `action` are
    /// mutually exclusive.
    pub fn set_data_preparation_action<
        T: std::convert::Into<
                std::boxed::Box<crate::model::workflow_invocation_action::DataPreparationAction>,
            >,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.action = std::option::Option::Some(
            crate::model::workflow_invocation_action::Action::DataPreparationAction(v.into()),
        );
        self
    }
}

impl wkt::message::Message for WorkflowInvocationAction {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for WorkflowInvocationAction {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __bigquery_action,
            __notebook_action,
            __data_preparation_action,
            __target,
            __canonical_target,
            __state,
            __failure_reason,
            __invocation_timing,
            __internal_metadata,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for WorkflowInvocationAction")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "bigqueryAction" => Ok(__FieldTag::__bigquery_action),
                            "bigquery_action" => Ok(__FieldTag::__bigquery_action),
                            "notebookAction" => Ok(__FieldTag::__notebook_action),
                            "notebook_action" => Ok(__FieldTag::__notebook_action),
                            "dataPreparationAction" => Ok(__FieldTag::__data_preparation_action),
                            "data_preparation_action" => Ok(__FieldTag::__data_preparation_action),
                            "target" => Ok(__FieldTag::__target),
                            "canonicalTarget" => Ok(__FieldTag::__canonical_target),
                            "canonical_target" => Ok(__FieldTag::__canonical_target),
                            "state" => Ok(__FieldTag::__state),
                            "failureReason" => Ok(__FieldTag::__failure_reason),
                            "failure_reason" => Ok(__FieldTag::__failure_reason),
                            "invocationTiming" => Ok(__FieldTag::__invocation_timing),
                            "invocation_timing" => Ok(__FieldTag::__invocation_timing),
                            "internalMetadata" => Ok(__FieldTag::__internal_metadata),
                            "internal_metadata" => Ok(__FieldTag::__internal_metadata),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = WorkflowInvocationAction;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct WorkflowInvocationAction")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__bigquery_action => {
                            if !fields.insert(__FieldTag::__bigquery_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for bigquery_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.bigquery_action, latest field was bigqueryAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::workflow_invocation_action::Action::BigqueryAction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::BigQueryAction>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__notebook_action => {
                            if !fields.insert(__FieldTag::__notebook_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for notebook_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.notebook_action, latest field was notebookAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::workflow_invocation_action::Action::NotebookAction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::NotebookAction>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__data_preparation_action => {
                            if !fields.insert(__FieldTag::__data_preparation_action) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for data_preparation_action",
                                ));
                            }
                            if result.action.is_some() {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for `action`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.data_preparation_action, latest field was dataPreparationAction",
                                ));
                            }
                            result.action = std::option::Option::Some(
                                crate::model::workflow_invocation_action::Action::DataPreparationAction(
                                    map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::DataPreparationAction>>>()?.unwrap_or_default()
                                ),
                            );
                        }
                        __FieldTag::__target => {
                            if !fields.insert(__FieldTag::__target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for target",
                                ));
                            }
                            result.target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__canonical_target => {
                            if !fields.insert(__FieldTag::__canonical_target) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for canonical_target",
                                ));
                            }
                            result.canonical_target =
                                map.next_value::<std::option::Option<crate::model::Target>>()?;
                        }
                        __FieldTag::__state => {
                            if !fields.insert(__FieldTag::__state) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for state",
                                ));
                            }
                            result.state = map
                                .next_value::<std::option::Option<
                                    crate::model::workflow_invocation_action::State,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__failure_reason => {
                            if !fields.insert(__FieldTag::__failure_reason) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for failure_reason",
                                ));
                            }
                            result.failure_reason = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__invocation_timing => {
                            if !fields.insert(__FieldTag::__invocation_timing) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for invocation_timing",
                                ));
                            }
                            result.invocation_timing =
                                map.next_value::<std::option::Option<gtype::model::Interval>>()?;
                        }
                        __FieldTag::__internal_metadata => {
                            if !fields.insert(__FieldTag::__internal_metadata) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for internal_metadata",
                                ));
                            }
                            result.internal_metadata =
                                map.next_value::<std::option::Option<std::string::String>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for WorkflowInvocationAction {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if let Some(value) = self.bigquery_action() {
            state.serialize_entry("bigqueryAction", value)?;
        }
        if let Some(value) = self.notebook_action() {
            state.serialize_entry("notebookAction", value)?;
        }
        if let Some(value) = self.data_preparation_action() {
            state.serialize_entry("dataPreparationAction", value)?;
        }
        if self.target.is_some() {
            state.serialize_entry("target", &self.target)?;
        }
        if self.canonical_target.is_some() {
            state.serialize_entry("canonicalTarget", &self.canonical_target)?;
        }
        if !wkt::internal::is_default(&self.state) {
            state.serialize_entry("state", &self.state)?;
        }
        if !self.failure_reason.is_empty() {
            state.serialize_entry("failureReason", &self.failure_reason)?;
        }
        if self.invocation_timing.is_some() {
            state.serialize_entry("invocationTiming", &self.invocation_timing)?;
        }
        if self.internal_metadata.is_some() {
            state.serialize_entry("internalMetadata", &self.internal_metadata)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Defines additional types related to [WorkflowInvocationAction].
pub mod workflow_invocation_action {
    #[allow(unused_imports)]
    use super::*;

    /// Represents a workflow action that will run against BigQuery.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct BigQueryAction {
        /// Output only. The generated BigQuery SQL script that will be executed.
        pub sql_script: std::string::String,

        /// Output only. The ID of the BigQuery job that executed the SQL in
        /// sql_script. Only set once the job has started to run.
        pub job_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl BigQueryAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [sql_script][crate::model::workflow_invocation_action::BigQueryAction::sql_script].
        pub fn set_sql_script<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.sql_script = v.into();
            self
        }

        /// Sets the value of [job_id][crate::model::workflow_invocation_action::BigQueryAction::job_id].
        pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job_id = v.into();
            self
        }
    }

    impl wkt::message::Message for BigQueryAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.BigQueryAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for BigQueryAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __sql_script,
                __job_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for BigQueryAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "sqlScript" => Ok(__FieldTag::__sql_script),
                                "sql_script" => Ok(__FieldTag::__sql_script),
                                "jobId" => Ok(__FieldTag::__job_id),
                                "job_id" => Ok(__FieldTag::__job_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = BigQueryAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct BigQueryAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__sql_script => {
                                if !fields.insert(__FieldTag::__sql_script) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for sql_script",
                                    ));
                                }
                                result.sql_script = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__job_id => {
                                if !fields.insert(__FieldTag::__job_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_id",
                                    ));
                                }
                                result.job_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for BigQueryAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.sql_script.is_empty() {
                state.serialize_entry("sqlScript", &self.sql_script)?;
            }
            if !self.job_id.is_empty() {
                state.serialize_entry("jobId", &self.job_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a workflow action that will run against a Notebook runtime.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct NotebookAction {
        /// Output only. The code contents of a Notebook to be run.
        pub contents: std::string::String,

        /// Output only. The ID of the Vertex job that executed the notebook in
        /// contents and also the ID used for the outputs created in Google Cloud
        /// Storage buckets. Only set once the job has started to run.
        pub job_id: std::string::String,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl NotebookAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [contents][crate::model::workflow_invocation_action::NotebookAction::contents].
        pub fn set_contents<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.contents = v.into();
            self
        }

        /// Sets the value of [job_id][crate::model::workflow_invocation_action::NotebookAction::job_id].
        pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job_id = v.into();
            self
        }
    }

    impl wkt::message::Message for NotebookAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.NotebookAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for NotebookAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __contents,
                __job_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for NotebookAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "contents" => Ok(__FieldTag::__contents),
                                "jobId" => Ok(__FieldTag::__job_id),
                                "job_id" => Ok(__FieldTag::__job_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = NotebookAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct NotebookAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__contents => {
                                if !fields.insert(__FieldTag::__contents) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents",
                                    ));
                                }
                                result.contents = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__job_id => {
                                if !fields.insert(__FieldTag::__job_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_id",
                                    ));
                                }
                                result.job_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for NotebookAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if !self.contents.is_empty() {
                state.serialize_entry("contents", &self.contents)?;
            }
            if !self.job_id.is_empty() {
                state.serialize_entry("jobId", &self.job_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Represents a workflow action that will run a Data Preparation.
    #[derive(Clone, Debug, Default, PartialEq)]
    #[non_exhaustive]
    pub struct DataPreparationAction {
        /// Output only. The generated BigQuery SQL script that will be executed. For
        /// reference only.
        pub generated_sql: std::string::String,

        /// Output only. The ID of the BigQuery job that executed the SQL in
        /// sql_script. Only set once the job has started to run.
        pub job_id: std::string::String,

        /// The definition for the data preparation.
        pub definition: std::option::Option<
            crate::model::workflow_invocation_action::data_preparation_action::Definition,
        >,

        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl DataPreparationAction {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [generated_sql][crate::model::workflow_invocation_action::DataPreparationAction::generated_sql].
        pub fn set_generated_sql<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.generated_sql = v.into();
            self
        }

        /// Sets the value of [job_id][crate::model::workflow_invocation_action::DataPreparationAction::job_id].
        pub fn set_job_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.job_id = v.into();
            self
        }

        /// Sets the value of [definition][crate::model::workflow_invocation_action::DataPreparationAction::definition].
        ///
        /// Note that all the setters affecting `definition` are mutually
        /// exclusive.
        pub fn set_definition<T: std::convert::Into<std::option::Option<crate::model::workflow_invocation_action::data_preparation_action::Definition>>>(mut self, v: T) -> Self
        {
            self.definition = v.into();
            self
        }

        /// The value of [definition][crate::model::workflow_invocation_action::DataPreparationAction::definition]
        /// if it holds a `ContentsYaml`, `None` if the field is not set or
        /// holds a different branch.
        pub fn contents_yaml(&self) -> std::option::Option<&std::string::String> {
            #[allow(unreachable_patterns)]
            self.definition.as_ref().and_then(|v| match v {
                crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsYaml(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [definition][crate::model::workflow_invocation_action::DataPreparationAction::definition]
        /// to hold a `ContentsYaml`.
        ///
        /// Note that all the setters affecting `definition` are
        /// mutually exclusive.
        pub fn set_contents_yaml<T: std::convert::Into<std::string::String>>(
            mut self,
            v: T,
        ) -> Self {
            self.definition = std::option::Option::Some(
                crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsYaml(
                    v.into()
                )
            );
            self
        }

        /// The value of [definition][crate::model::workflow_invocation_action::DataPreparationAction::definition]
        /// if it holds a `ContentsSql`, `None` if the field is not set or
        /// holds a different branch.
        pub fn contents_sql(&self) -> std::option::Option<&std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition>>{
            #[allow(unreachable_patterns)]
            self.definition.as_ref().and_then(|v| match v {
                crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsSql(v) => std::option::Option::Some(v),
                _ => std::option::Option::None,
            })
        }

        /// Sets the value of [definition][crate::model::workflow_invocation_action::DataPreparationAction::definition]
        /// to hold a `ContentsSql`.
        ///
        /// Note that all the setters affecting `definition` are
        /// mutually exclusive.
        pub fn set_contents_sql<T: std::convert::Into<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition>>>(mut self, v: T) -> Self{
            self.definition = std::option::Option::Some(
                crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsSql(
                    v.into()
                )
            );
            self
        }
    }

    impl wkt::message::Message for DataPreparationAction {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction"
        }
    }

    #[doc(hidden)]
    impl<'de> serde::de::Deserialize<'de> for DataPreparationAction {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            #[allow(non_camel_case_types)]
            #[doc(hidden)]
            #[derive(PartialEq, Eq, Hash)]
            enum __FieldTag {
                __contents_yaml,
                __contents_sql,
                __generated_sql,
                __job_id,
                Unknown(std::string::String),
            }
            impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                where
                    D: serde::Deserializer<'de>,
                {
                    struct Visitor;
                    impl<'de> serde::de::Visitor<'de> for Visitor {
                        type Value = __FieldTag;
                        fn expecting(
                            &self,
                            formatter: &mut std::fmt::Formatter,
                        ) -> std::fmt::Result {
                            formatter.write_str("a field name for DataPreparationAction")
                        }
                        fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                        where
                            E: serde::de::Error,
                        {
                            use std::result::Result::Ok;
                            use std::string::ToString;
                            match value {
                                "contentsYaml" => Ok(__FieldTag::__contents_yaml),
                                "contents_yaml" => Ok(__FieldTag::__contents_yaml),
                                "contentsSql" => Ok(__FieldTag::__contents_sql),
                                "contents_sql" => Ok(__FieldTag::__contents_sql),
                                "generatedSql" => Ok(__FieldTag::__generated_sql),
                                "generated_sql" => Ok(__FieldTag::__generated_sql),
                                "jobId" => Ok(__FieldTag::__job_id),
                                "job_id" => Ok(__FieldTag::__job_id),
                                _ => Ok(__FieldTag::Unknown(value.to_string())),
                            }
                        }
                    }
                    deserializer.deserialize_identifier(Visitor)
                }
            }
            struct Visitor;
            impl<'de> serde::de::Visitor<'de> for Visitor {
                type Value = DataPreparationAction;
                fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                    formatter.write_str("struct DataPreparationAction")
                }
                fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                where
                    A: serde::de::MapAccess<'de>,
                {
                    #[allow(unused_imports)]
                    use serde::de::Error;
                    use std::option::Option::Some;
                    let mut fields = std::collections::HashSet::new();
                    let mut result = Self::Value::new();
                    while let Some(tag) = map.next_key::<__FieldTag>()? {
                        #[allow(clippy::match_single_binding)]
                        match tag {
                            __FieldTag::__contents_yaml => {
                                if !fields.insert(__FieldTag::__contents_yaml) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents_yaml",
                                    ));
                                }
                                if result.definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `definition`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.contents_yaml, latest field was contentsYaml",
                                    ));
                                }
                                result.definition = std::option::Option::Some(
                                    crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsYaml(
                                        map.next_value::<std::option::Option<std::string::String>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__contents_sql => {
                                if !fields.insert(__FieldTag::__contents_sql) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for contents_sql",
                                    ));
                                }
                                if result.definition.is_some() {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for `definition`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.contents_sql, latest field was contentsSql",
                                    ));
                                }
                                result.definition = std::option::Option::Some(
                                    crate::model::workflow_invocation_action::data_preparation_action::Definition::ContentsSql(
                                        map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition>>>()?.unwrap_or_default()
                                    ),
                                );
                            }
                            __FieldTag::__generated_sql => {
                                if !fields.insert(__FieldTag::__generated_sql) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for generated_sql",
                                    ));
                                }
                                result.generated_sql = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::__job_id => {
                                if !fields.insert(__FieldTag::__job_id) {
                                    return std::result::Result::Err(A::Error::duplicate_field(
                                        "multiple values for job_id",
                                    ));
                                }
                                result.job_id = map
                                    .next_value::<std::option::Option<std::string::String>>()?
                                    .unwrap_or_default();
                            }
                            __FieldTag::Unknown(key) => {
                                let value = map.next_value::<serde_json::Value>()?;
                                result._unknown_fields.insert(key, value);
                            }
                        }
                    }
                    std::result::Result::Ok(result)
                }
            }
            deserializer.deserialize_any(Visitor)
        }
    }

    #[doc(hidden)]
    impl serde::ser::Serialize for DataPreparationAction {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::ser::Serializer,
        {
            use serde::ser::SerializeMap;
            #[allow(unused_imports)]
            use std::option::Option::Some;
            let mut state = serializer.serialize_map(std::option::Option::None)?;
            if let Some(value) = self.contents_yaml() {
                state.serialize_entry("contentsYaml", value)?;
            }
            if let Some(value) = self.contents_sql() {
                state.serialize_entry("contentsSql", value)?;
            }
            if !self.generated_sql.is_empty() {
                state.serialize_entry("generatedSql", &self.generated_sql)?;
            }
            if !self.job_id.is_empty() {
                state.serialize_entry("jobId", &self.job_id)?;
            }
            if !self._unknown_fields.is_empty() {
                for (key, value) in self._unknown_fields.iter() {
                    state.serialize_entry(key, &value)?;
                }
            }
            state.end()
        }
    }

    /// Defines additional types related to [DataPreparationAction].
    pub mod data_preparation_action {
        #[allow(unused_imports)]
        use super::*;

        /// Definition of a SQL Data Preparation
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ActionSqlDefinition {
            /// The SQL query representing the data preparation steps. Formatted as a
            /// Pipe SQL query statement.
            pub query: std::string::String,

            /// Error table configuration,
            pub error_table: std::option::Option<
                crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable,
            >,

            /// Load configuration.
            pub load_config: std::option::Option<
                crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig,
            >,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ActionSqlDefinition {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [query][crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition::query].
            pub fn set_query<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.query = v.into();
                self
            }

            /// Sets the value of [error_table][crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition::error_table].
            pub fn set_error_table<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable>
            {
                self.error_table = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [error_table][crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition::error_table].
            pub fn set_or_clear_error_table<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable>
            {
                self.error_table = v.map(|x| x.into());
                self
            }

            /// Sets the value of [load_config][crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition::load_config].
            pub fn set_load_config<T>(mut self, v: T) -> Self
            where T: std::convert::Into<crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig>
            {
                self.load_config = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [load_config][crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition::load_config].
            pub fn set_or_clear_load_config<T>(mut self, v: std::option::Option<T>) -> Self
            where T: std::convert::Into<crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig>
            {
                self.load_config = v.map(|x| x.into());
                self
            }
        }

        impl wkt::message::Message for ActionSqlDefinition {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionSqlDefinition"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ActionSqlDefinition {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __query,
                    __error_table,
                    __load_config,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ActionSqlDefinition")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "query" => Ok(__FieldTag::__query),
                                    "errorTable" => Ok(__FieldTag::__error_table),
                                    "error_table" => Ok(__FieldTag::__error_table),
                                    "loadConfig" => Ok(__FieldTag::__load_config),
                                    "load_config" => Ok(__FieldTag::__load_config),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ActionSqlDefinition;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ActionSqlDefinition")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__query => {
                                    if !fields.insert(__FieldTag::__query) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for query"),
                                        );
                                    }
                                    result.query = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::__error_table => {
                                    if !fields.insert(__FieldTag::__error_table) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for error_table",
                                            ),
                                        );
                                    }
                                    result.error_table = map.next_value::<std::option::Option<crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable>>()?
                                        ;
                                }
                                __FieldTag::__load_config => {
                                    if !fields.insert(__FieldTag::__load_config) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for load_config",
                                            ),
                                        );
                                    }
                                    result.load_config = map.next_value::<std::option::Option<crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig>>()?
                                        ;
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ActionSqlDefinition {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.query.is_empty() {
                    state.serialize_entry("query", &self.query)?;
                }
                if self.error_table.is_some() {
                    state.serialize_entry("errorTable", &self.error_table)?;
                }
                if self.load_config.is_some() {
                    state.serialize_entry("loadConfig", &self.load_config)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Error table information, used to write error data into a BigQuery
        /// table.
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ActionErrorTable {
            /// Error Table target.
            pub target: std::option::Option<crate::model::Target>,

            /// Error table partition expiration in days. Only positive values are
            /// allowed.
            pub retention_days: i32,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ActionErrorTable {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [target][crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable::target].
            pub fn set_target<T>(mut self, v: T) -> Self
            where
                T: std::convert::Into<crate::model::Target>,
            {
                self.target = std::option::Option::Some(v.into());
                self
            }

            /// Sets or clears the value of [target][crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable::target].
            pub fn set_or_clear_target<T>(mut self, v: std::option::Option<T>) -> Self
            where
                T: std::convert::Into<crate::model::Target>,
            {
                self.target = v.map(|x| x.into());
                self
            }

            /// Sets the value of [retention_days][crate::model::workflow_invocation_action::data_preparation_action::ActionErrorTable::retention_days].
            pub fn set_retention_days<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
                self.retention_days = v.into();
                self
            }
        }

        impl wkt::message::Message for ActionErrorTable {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionErrorTable"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ActionErrorTable {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __target,
                    __retention_days,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ActionErrorTable")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "target" => Ok(__FieldTag::__target),
                                    "retentionDays" => Ok(__FieldTag::__retention_days),
                                    "retention_days" => Ok(__FieldTag::__retention_days),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ActionErrorTable;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ActionErrorTable")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__target => {
                                    if !fields.insert(__FieldTag::__target) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for target"),
                                        );
                                    }
                                    result.target = map
                                        .next_value::<std::option::Option<crate::model::Target>>(
                                        )?;
                                }
                                __FieldTag::__retention_days => {
                                    if !fields.insert(__FieldTag::__retention_days) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for retention_days",
                                            ),
                                        );
                                    }
                                    struct __With(std::option::Option<i32>);
                                    impl<'de> serde::de::Deserialize<'de> for __With {
                                        fn deserialize<D>(
                                            deserializer: D,
                                        ) -> std::result::Result<Self, D::Error>
                                        where
                                            D: serde::de::Deserializer<'de>,
                                        {
                                            serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                        }
                                    }
                                    result.retention_days =
                                        map.next_value::<__With>()?.0.unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ActionErrorTable {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if self.target.is_some() {
                    state.serialize_entry("target", &self.target)?;
                }
                if !wkt::internal::is_default(&self.retention_days) {
                    struct __With<'a>(&'a i32);
                    impl<'a> serde::ser::Serialize for __With<'a> {
                        fn serialize<S>(
                            &self,
                            serializer: S,
                        ) -> std::result::Result<S::Ok, S::Error>
                        where
                            S: serde::ser::Serializer,
                        {
                            serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                        }
                    }
                    state.serialize_entry("retentionDays", &__With(&self.retention_days))?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Simplified load configuration for actions
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ActionLoadConfig {

            /// Load mode
            pub mode: std::option::Option<crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode>,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ActionLoadConfig {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode].
            ///
            /// Note that all the setters affecting `mode` are mutually
            /// exclusive.
            pub fn set_mode<T: std::convert::Into<std::option::Option<crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode>>>(mut self, v: T) -> Self
            {
                self.mode = v.into();
                self
            }

            /// The value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// if it holds a `Replace`, `None` if the field is not set or
            /// holds a different branch.
            pub fn replace(&self) -> std::option::Option<&std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>{
                #[allow(unreachable_patterns)]
                self.mode.as_ref().and_then(|v| match v {
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Replace(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// to hold a `Replace`.
            ///
            /// Note that all the setters affecting `mode` are
            /// mutually exclusive.
            pub fn set_replace<T: std::convert::Into<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>>(mut self, v: T) -> Self{
                self.mode = std::option::Option::Some(
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Replace(
                        v.into()
                    )
                );
                self
            }

            /// The value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// if it holds a `Append`, `None` if the field is not set or
            /// holds a different branch.
            pub fn append(&self) -> std::option::Option<&std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>{
                #[allow(unreachable_patterns)]
                self.mode.as_ref().and_then(|v| match v {
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Append(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// to hold a `Append`.
            ///
            /// Note that all the setters affecting `mode` are
            /// mutually exclusive.
            pub fn set_append<T: std::convert::Into<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>>(mut self, v: T) -> Self{
                self.mode = std::option::Option::Some(
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Append(
                        v.into()
                    )
                );
                self
            }

            /// The value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// if it holds a `Maximum`, `None` if the field is not set or
            /// holds a different branch.
            pub fn maximum(&self) -> std::option::Option<&std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>{
                #[allow(unreachable_patterns)]
                self.mode.as_ref().and_then(|v| match v {
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Maximum(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// to hold a `Maximum`.
            ///
            /// Note that all the setters affecting `mode` are
            /// mutually exclusive.
            pub fn set_maximum<T: std::convert::Into<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>>(mut self, v: T) -> Self{
                self.mode = std::option::Option::Some(
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Maximum(
                        v.into()
                    )
                );
                self
            }

            /// The value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// if it holds a `Unique`, `None` if the field is not set or
            /// holds a different branch.
            pub fn unique(&self) -> std::option::Option<&std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>{
                #[allow(unreachable_patterns)]
                self.mode.as_ref().and_then(|v| match v {
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Unique(v) => std::option::Option::Some(v),
                    _ => std::option::Option::None,
                })
            }

            /// Sets the value of [mode][crate::model::workflow_invocation_action::data_preparation_action::ActionLoadConfig::mode]
            /// to hold a `Unique`.
            ///
            /// Note that all the setters affecting `mode` are
            /// mutually exclusive.
            pub fn set_unique<T: std::convert::Into<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>>(mut self, v: T) -> Self{
                self.mode = std::option::Option::Some(
                    crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Unique(
                        v.into()
                    )
                );
                self
            }
        }

        impl wkt::message::Message for ActionLoadConfig {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionLoadConfig"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ActionLoadConfig {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __replace,
                    __append,
                    __maximum,
                    __unique,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ActionLoadConfig")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "replace" => Ok(__FieldTag::__replace),
                                    "append" => Ok(__FieldTag::__append),
                                    "maximum" => Ok(__FieldTag::__maximum),
                                    "unique" => Ok(__FieldTag::__unique),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ActionLoadConfig;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ActionLoadConfig")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__replace => {
                                    if !fields.insert(__FieldTag::__replace) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for replace",
                                            ),
                                        );
                                    }
                                    if result.mode.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionLoadConfig.replace, latest field was replace",
                                            ),
                                        );
                                    }
                                    result.mode = std::option::Option::Some(
                                        crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Replace(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__append => {
                                    if !fields.insert(__FieldTag::__append) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for append"),
                                        );
                                    }
                                    if result.mode.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionLoadConfig.append, latest field was append",
                                            ),
                                        );
                                    }
                                    result.mode = std::option::Option::Some(
                                        crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Append(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__maximum => {
                                    if !fields.insert(__FieldTag::__maximum) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for maximum",
                                            ),
                                        );
                                    }
                                    if result.mode.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionLoadConfig.maximum, latest field was maximum",
                                            ),
                                        );
                                    }
                                    result.mode = std::option::Option::Some(
                                        crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Maximum(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::__unique => {
                                    if !fields.insert(__FieldTag::__unique) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for unique"),
                                        );
                                    }
                                    if result.mode.is_some() {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field(
                                                "multiple values for `mode`, a oneof with full ID .google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionLoadConfig.unique, latest field was unique",
                                            ),
                                        );
                                    }
                                    result.mode = std::option::Option::Some(
                                        crate::model::workflow_invocation_action::data_preparation_action::action_load_config::Mode::Unique(
                                            map.next_value::<std::option::Option<std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>>>()?.unwrap_or_default()
                                        ),
                                    );
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ActionLoadConfig {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if let Some(value) = self.replace() {
                    state.serialize_entry("replace", value)?;
                }
                if let Some(value) = self.append() {
                    state.serialize_entry("append", value)?;
                }
                if let Some(value) = self.maximum() {
                    state.serialize_entry("maximum", value)?;
                }
                if let Some(value) = self.unique() {
                    state.serialize_entry("unique", value)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Defines additional types related to [ActionLoadConfig].
        pub mod action_load_config {
            #[allow(unused_imports)]
            use super::*;

            /// Load mode
            #[derive(Clone, Debug, PartialEq)]
            #[non_exhaustive]
            pub enum Mode {
                /// Replace destination table
                Replace(std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>),
                /// Append into destination table
                Append(std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSimpleLoadMode>),
                /// Insert records where the value exceeds the previous maximum value for
                /// a column in the destination table
                Maximum(std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>),
                /// Insert records where the value of a column is not already present in
                /// the destination table
                Unique(std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode>),
            }
        }

        /// Simple load definition
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ActionSimpleLoadMode {
            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ActionSimpleLoadMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }
        }

        impl wkt::message::Message for ActionSimpleLoadMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionSimpleLoadMode"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ActionSimpleLoadMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ActionSimpleLoadMode")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                Ok(__FieldTag::Unknown(value.to_string()))
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ActionSimpleLoadMode;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ActionSimpleLoadMode")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ActionSimpleLoadMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// Load definition for incremental load modes
        #[derive(Clone, Debug, Default, PartialEq)]
        #[non_exhaustive]
        pub struct ActionIncrementalLoadMode {
            /// Column name for incremental load modes
            pub column: std::string::String,

            _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
        }

        impl ActionIncrementalLoadMode {
            pub fn new() -> Self {
                std::default::Default::default()
            }

            /// Sets the value of [column][crate::model::workflow_invocation_action::data_preparation_action::ActionIncrementalLoadMode::column].
            pub fn set_column<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
                self.column = v.into();
                self
            }
        }

        impl wkt::message::Message for ActionIncrementalLoadMode {
            fn typename() -> &'static str {
                "type.googleapis.com/google.cloud.dataform.v1.WorkflowInvocationAction.DataPreparationAction.ActionIncrementalLoadMode"
            }
        }

        #[doc(hidden)]
        impl<'de> serde::de::Deserialize<'de> for ActionIncrementalLoadMode {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                #[allow(non_camel_case_types)]
                #[doc(hidden)]
                #[derive(PartialEq, Eq, Hash)]
                enum __FieldTag {
                    __column,
                    Unknown(std::string::String),
                }
                impl<'de> serde::de::Deserialize<'de> for __FieldTag {
                    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
                    where
                        D: serde::Deserializer<'de>,
                    {
                        struct Visitor;
                        impl<'de> serde::de::Visitor<'de> for Visitor {
                            type Value = __FieldTag;
                            fn expecting(
                                &self,
                                formatter: &mut std::fmt::Formatter,
                            ) -> std::fmt::Result {
                                formatter.write_str("a field name for ActionIncrementalLoadMode")
                            }
                            fn visit_str<E>(
                                self,
                                value: &str,
                            ) -> std::result::Result<Self::Value, E>
                            where
                                E: serde::de::Error,
                            {
                                use std::result::Result::Ok;
                                use std::string::ToString;
                                match value {
                                    "column" => Ok(__FieldTag::__column),
                                    _ => Ok(__FieldTag::Unknown(value.to_string())),
                                }
                            }
                        }
                        deserializer.deserialize_identifier(Visitor)
                    }
                }
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = ActionIncrementalLoadMode;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("struct ActionIncrementalLoadMode")
                    }
                    fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
                    where
                        A: serde::de::MapAccess<'de>,
                    {
                        #[allow(unused_imports)]
                        use serde::de::Error;
                        use std::option::Option::Some;
                        let mut fields = std::collections::HashSet::new();
                        let mut result = Self::Value::new();
                        while let Some(tag) = map.next_key::<__FieldTag>()? {
                            #[allow(clippy::match_single_binding)]
                            match tag {
                                __FieldTag::__column => {
                                    if !fields.insert(__FieldTag::__column) {
                                        return std::result::Result::Err(
                                            A::Error::duplicate_field("multiple values for column"),
                                        );
                                    }
                                    result.column = map
                                        .next_value::<std::option::Option<std::string::String>>()?
                                        .unwrap_or_default();
                                }
                                __FieldTag::Unknown(key) => {
                                    let value = map.next_value::<serde_json::Value>()?;
                                    result._unknown_fields.insert(key, value);
                                }
                            }
                        }
                        std::result::Result::Ok(result)
                    }
                }
                deserializer.deserialize_any(Visitor)
            }
        }

        #[doc(hidden)]
        impl serde::ser::Serialize for ActionIncrementalLoadMode {
            fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
            where
                S: serde::ser::Serializer,
            {
                use serde::ser::SerializeMap;
                #[allow(unused_imports)]
                use std::option::Option::Some;
                let mut state = serializer.serialize_map(std::option::Option::None)?;
                if !self.column.is_empty() {
                    state.serialize_entry("column", &self.column)?;
                }
                if !self._unknown_fields.is_empty() {
                    for (key, value) in self._unknown_fields.iter() {
                        state.serialize_entry(key, &value)?;
                    }
                }
                state.end()
            }
        }

        /// The definition for the data preparation.
        #[derive(Clone, Debug, PartialEq)]
        #[non_exhaustive]
        pub enum Definition {
            /// Output only. YAML representing the contents of the data preparation.
            /// Can be used to show the customer what the input was to their workflow.
            ContentsYaml(std::string::String),
            /// SQL definition for a Data Preparation. Contains a SQL query and
            /// additional context information.
            ContentsSql(std::boxed::Box<crate::model::workflow_invocation_action::data_preparation_action::ActionSqlDefinition>),
        }
    }

    /// Represents the current state of a workflow invocation action.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum State {
        /// The action has not yet been considered for invocation.
        Pending,
        /// The action is currently running.
        Running,
        /// Execution of the action was skipped because upstream dependencies did not
        /// all complete successfully. A terminal state.
        Skipped,
        /// Execution of the action was disabled as per the configuration of the
        /// corresponding compilation result action. A terminal state.
        Disabled,
        /// The action succeeded. A terminal state.
        Succeeded,
        /// The action was cancelled. A terminal state.
        Cancelled,
        /// The action failed. A terminal state.
        Failed,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [State::value] or
        /// [State::name].
        UnknownValue(state::UnknownValue),
    }

    #[doc(hidden)]
    pub mod state {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl State {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Pending => std::option::Option::Some(0),
                Self::Running => std::option::Option::Some(1),
                Self::Skipped => std::option::Option::Some(2),
                Self::Disabled => std::option::Option::Some(3),
                Self::Succeeded => std::option::Option::Some(4),
                Self::Cancelled => std::option::Option::Some(5),
                Self::Failed => std::option::Option::Some(6),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Pending => std::option::Option::Some("PENDING"),
                Self::Running => std::option::Option::Some("RUNNING"),
                Self::Skipped => std::option::Option::Some("SKIPPED"),
                Self::Disabled => std::option::Option::Some("DISABLED"),
                Self::Succeeded => std::option::Option::Some("SUCCEEDED"),
                Self::Cancelled => std::option::Option::Some("CANCELLED"),
                Self::Failed => std::option::Option::Some("FAILED"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for State {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for State {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for State {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Pending,
                1 => Self::Running,
                2 => Self::Skipped,
                3 => Self::Disabled,
                4 => Self::Succeeded,
                5 => Self::Cancelled,
                6 => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for State {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "PENDING" => Self::Pending,
                "RUNNING" => Self::Running,
                "SKIPPED" => Self::Skipped,
                "DISABLED" => Self::Disabled,
                "SUCCEEDED" => Self::Succeeded,
                "CANCELLED" => Self::Cancelled,
                "FAILED" => Self::Failed,
                _ => Self::UnknownValue(state::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for State {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Pending => serializer.serialize_i32(0),
                Self::Running => serializer.serialize_i32(1),
                Self::Skipped => serializer.serialize_i32(2),
                Self::Disabled => serializer.serialize_i32(3),
                Self::Succeeded => serializer.serialize_i32(4),
                Self::Cancelled => serializer.serialize_i32(5),
                Self::Failed => serializer.serialize_i32(6),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for State {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<State>::new(
                ".google.cloud.dataform.v1.WorkflowInvocationAction.State",
            ))
        }
    }

    /// The action's details.
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Action {
        /// Output only. The workflow action's bigquery action details.
        BigqueryAction(std::boxed::Box<crate::model::workflow_invocation_action::BigQueryAction>),
        /// Output only. The workflow action's notebook action details.
        NotebookAction(std::boxed::Box<crate::model::workflow_invocation_action::NotebookAction>),
        /// Output only. The workflow action's data preparation action details.
        DataPreparationAction(
            std::boxed::Box<crate::model::workflow_invocation_action::DataPreparationAction>,
        ),
    }
}

/// `QueryWorkflowInvocationActions` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryWorkflowInvocationActionsRequest {
    /// Required. The workflow invocation's name.
    pub name: std::string::String,

    /// Optional. Maximum number of workflow invocations to return. The server may
    /// return fewer items than requested. If unspecified, the server will pick an
    /// appropriate default.
    pub page_size: i32,

    /// Optional. Page token received from a previous
    /// `QueryWorkflowInvocationActions` call. Provide this to retrieve the
    /// subsequent page.
    ///
    /// When paginating, all other parameters provided to
    /// `QueryWorkflowInvocationActions`, with the exception of `page_size`, must
    /// match the call that provided the page token.
    pub page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryWorkflowInvocationActionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::QueryWorkflowInvocationActionsRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::QueryWorkflowInvocationActionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::QueryWorkflowInvocationActionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryWorkflowInvocationActionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryWorkflowInvocationActionsRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryWorkflowInvocationActionsRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __page_size,
            __page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for QueryWorkflowInvocationActionsRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "pageSize" => Ok(__FieldTag::__page_size),
                            "page_size" => Ok(__FieldTag::__page_size),
                            "pageToken" => Ok(__FieldTag::__page_token),
                            "page_token" => Ok(__FieldTag::__page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryWorkflowInvocationActionsRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryWorkflowInvocationActionsRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__page_size => {
                            if !fields.insert(__FieldTag::__page_size) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_size",
                                ));
                            }
                            struct __With(std::option::Option<i32>);
                            impl<'de> serde::de::Deserialize<'de> for __With {
                                fn deserialize<D>(
                                    deserializer: D,
                                ) -> std::result::Result<Self, D::Error>
                                where
                                    D: serde::de::Deserializer<'de>,
                                {
                                    serde_with::As::< std::option::Option<wkt::internal::I32> >::deserialize(deserializer).map(__With)
                                }
                            }
                            result.page_size = map.next_value::<__With>()?.0.unwrap_or_default();
                        }
                        __FieldTag::__page_token => {
                            if !fields.insert(__FieldTag::__page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for page_token",
                                ));
                            }
                            result.page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryWorkflowInvocationActionsRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !wkt::internal::is_default(&self.page_size) {
            struct __With<'a>(&'a i32);
            impl<'a> serde::ser::Serialize for __With<'a> {
                fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
                where
                    S: serde::ser::Serializer,
                {
                    serde_with::As::<wkt::internal::I32>::serialize(self.0, serializer)
                }
            }
            state.serialize_entry("pageSize", &__With(&self.page_size))?;
        }
        if !self.page_token.is_empty() {
            state.serialize_entry("pageToken", &self.page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `QueryWorkflowInvocationActions` response message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct QueryWorkflowInvocationActionsResponse {
    /// List of workflow invocation actions.
    pub workflow_invocation_actions: std::vec::Vec<crate::model::WorkflowInvocationAction>,

    /// A token, which can be sent as `page_token` to retrieve the next page.
    /// If this field is omitted, there are no subsequent pages.
    pub next_page_token: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl QueryWorkflowInvocationActionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [workflow_invocation_actions][crate::model::QueryWorkflowInvocationActionsResponse::workflow_invocation_actions].
    pub fn set_workflow_invocation_actions<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::WorkflowInvocationAction>,
    {
        use std::iter::Iterator;
        self.workflow_invocation_actions = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::QueryWorkflowInvocationActionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for QueryWorkflowInvocationActionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.QueryWorkflowInvocationActionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for QueryWorkflowInvocationActionsResponse {
    type PageItem = crate::model::WorkflowInvocationAction;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.workflow_invocation_actions
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for QueryWorkflowInvocationActionsResponse {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __workflow_invocation_actions,
            __next_page_token,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter
                            .write_str("a field name for QueryWorkflowInvocationActionsResponse")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "workflowInvocationActions" => {
                                Ok(__FieldTag::__workflow_invocation_actions)
                            }
                            "workflow_invocation_actions" => {
                                Ok(__FieldTag::__workflow_invocation_actions)
                            }
                            "nextPageToken" => Ok(__FieldTag::__next_page_token),
                            "next_page_token" => Ok(__FieldTag::__next_page_token),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = QueryWorkflowInvocationActionsResponse;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct QueryWorkflowInvocationActionsResponse")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__workflow_invocation_actions => {
                            if !fields.insert(__FieldTag::__workflow_invocation_actions) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for workflow_invocation_actions",
                                ));
                            }
                            result.workflow_invocation_actions = map
                                .next_value::<std::option::Option<
                                    std::vec::Vec<crate::model::WorkflowInvocationAction>,
                                >>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__next_page_token => {
                            if !fields.insert(__FieldTag::__next_page_token) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for next_page_token",
                                ));
                            }
                            result.next_page_token = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for QueryWorkflowInvocationActionsResponse {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.workflow_invocation_actions.is_empty() {
            state.serialize_entry(
                "workflowInvocationActions",
                &self.workflow_invocation_actions,
            )?;
        }
        if !self.next_page_token.is_empty() {
            state.serialize_entry("nextPageToken", &self.next_page_token)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// Config for all repositories in a given project and location.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct Config {
    /// Identifier. The config name.
    pub name: std::string::String,

    /// Optional. The default KMS key that is used if no encryption key is provided
    /// when a repository is created.
    pub default_kms_key_name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Config {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Config::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [default_kms_key_name][crate::model::Config::default_kms_key_name].
    pub fn set_default_kms_key_name<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.default_kms_key_name = v.into();
        self
    }
}

impl wkt::message::Message for Config {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.Config"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for Config {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            __default_kms_key_name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for Config")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            "defaultKmsKeyName" => Ok(__FieldTag::__default_kms_key_name),
                            "default_kms_key_name" => Ok(__FieldTag::__default_kms_key_name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = Config;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct Config")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::__default_kms_key_name => {
                            if !fields.insert(__FieldTag::__default_kms_key_name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for default_kms_key_name",
                                ));
                            }
                            result.default_kms_key_name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for Config {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self.default_kms_key_name.is_empty() {
            state.serialize_entry("defaultKmsKeyName", &self.default_kms_key_name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `GetConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct GetConfigRequest {
    /// Required. The config name.
    pub name: std::string::String,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConfigRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.GetConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for GetConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __name,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for GetConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "name" => Ok(__FieldTag::__name),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = GetConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct GetConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__name => {
                            if !fields.insert(__FieldTag::__name) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for name",
                                ));
                            }
                            result.name = map
                                .next_value::<std::option::Option<std::string::String>>()?
                                .unwrap_or_default();
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for GetConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if !self.name.is_empty() {
            state.serialize_entry("name", &self.name)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}

/// `UpdateConfig` request message.
#[derive(Clone, Debug, Default, PartialEq)]
#[non_exhaustive]
pub struct UpdateConfigRequest {
    /// Required. The config to update.
    pub config: std::option::Option<crate::model::Config>,

    /// Optional. Specifies the fields to be updated in the config.
    pub update_mask: std::option::Option<wkt::FieldMask>,

    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConfigRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [config][crate::model::UpdateConfigRequest::config].
    pub fn set_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Config>,
    {
        self.config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [config][crate::model::UpdateConfigRequest::config].
    pub fn set_or_clear_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Config>,
    {
        self.config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_mask][crate::model::UpdateConfigRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConfigRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for UpdateConfigRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.dataform.v1.UpdateConfigRequest"
    }
}

#[doc(hidden)]
impl<'de> serde::de::Deserialize<'de> for UpdateConfigRequest {
    fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
    where
        D: serde::Deserializer<'de>,
    {
        #[allow(non_camel_case_types)]
        #[doc(hidden)]
        #[derive(PartialEq, Eq, Hash)]
        enum __FieldTag {
            __config,
            __update_mask,
            Unknown(std::string::String),
        }
        impl<'de> serde::de::Deserialize<'de> for __FieldTag {
            fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
            where
                D: serde::Deserializer<'de>,
            {
                struct Visitor;
                impl<'de> serde::de::Visitor<'de> for Visitor {
                    type Value = __FieldTag;
                    fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                        formatter.write_str("a field name for UpdateConfigRequest")
                    }
                    fn visit_str<E>(self, value: &str) -> std::result::Result<Self::Value, E>
                    where
                        E: serde::de::Error,
                    {
                        use std::result::Result::Ok;
                        use std::string::ToString;
                        match value {
                            "config" => Ok(__FieldTag::__config),
                            "updateMask" => Ok(__FieldTag::__update_mask),
                            "update_mask" => Ok(__FieldTag::__update_mask),
                            _ => Ok(__FieldTag::Unknown(value.to_string())),
                        }
                    }
                }
                deserializer.deserialize_identifier(Visitor)
            }
        }
        struct Visitor;
        impl<'de> serde::de::Visitor<'de> for Visitor {
            type Value = UpdateConfigRequest;
            fn expecting(&self, formatter: &mut std::fmt::Formatter) -> std::fmt::Result {
                formatter.write_str("struct UpdateConfigRequest")
            }
            fn visit_map<A>(self, mut map: A) -> std::result::Result<Self::Value, A::Error>
            where
                A: serde::de::MapAccess<'de>,
            {
                #[allow(unused_imports)]
                use serde::de::Error;
                use std::option::Option::Some;
                let mut fields = std::collections::HashSet::new();
                let mut result = Self::Value::new();
                while let Some(tag) = map.next_key::<__FieldTag>()? {
                    #[allow(clippy::match_single_binding)]
                    match tag {
                        __FieldTag::__config => {
                            if !fields.insert(__FieldTag::__config) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for config",
                                ));
                            }
                            result.config =
                                map.next_value::<std::option::Option<crate::model::Config>>()?;
                        }
                        __FieldTag::__update_mask => {
                            if !fields.insert(__FieldTag::__update_mask) {
                                return std::result::Result::Err(A::Error::duplicate_field(
                                    "multiple values for update_mask",
                                ));
                            }
                            result.update_mask =
                                map.next_value::<std::option::Option<wkt::FieldMask>>()?;
                        }
                        __FieldTag::Unknown(key) => {
                            let value = map.next_value::<serde_json::Value>()?;
                            result._unknown_fields.insert(key, value);
                        }
                    }
                }
                std::result::Result::Ok(result)
            }
        }
        deserializer.deserialize_any(Visitor)
    }
}

#[doc(hidden)]
impl serde::ser::Serialize for UpdateConfigRequest {
    fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
    where
        S: serde::ser::Serializer,
    {
        use serde::ser::SerializeMap;
        #[allow(unused_imports)]
        use std::option::Option::Some;
        let mut state = serializer.serialize_map(std::option::Option::None)?;
        if self.config.is_some() {
            state.serialize_entry("config", &self.config)?;
        }
        if self.update_mask.is_some() {
            state.serialize_entry("updateMask", &self.update_mask)?;
        }
        if !self._unknown_fields.is_empty() {
            for (key, value) in self._unknown_fields.iter() {
                state.serialize_entry(key, &value)?;
            }
        }
        state.end()
    }
}
