// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#[allow(unused_imports)]
use super::*;

impl std::fmt::Debug for super::ListUsersRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsersRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListUsersResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListUsersResponse");
        debug_struct.field("users", &self.users);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::Connection {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Connection");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("installation_state", &self.installation_state);
        debug_struct.field("disabled", &self.disabled);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("crypto_key_config", &self.crypto_key_config);
        debug_struct.field("git_proxy_config", &self.git_proxy_config);
        debug_struct.field("connection_config", &self.connection_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}



impl std::fmt::Debug for super::CryptoKeyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CryptoKeyConfig");
        debug_struct.field("key_reference", &self.key_reference);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitProxyConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitProxyConfig");
        debug_struct.field("enabled", &self.enabled);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InstallationState {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InstallationState");
        debug_struct.field("stage", &self.stage);
        debug_struct.field("message", &self.message);
        debug_struct.field("action_uri", &self.action_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitHubConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubConfig");
        debug_struct.field("github_app", &self.github_app);
        debug_struct.field("authorizer_credential", &self.authorizer_credential);
        debug_struct.field("app_installation_id", &self.app_installation_id);
        debug_struct.field("installation_uri", &self.installation_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitHubEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitHubEnterpriseConfig");
        debug_struct.field("host_uri", &self.host_uri);
        debug_struct.field("app_id", &self.app_id);
        debug_struct.field("app_slug", &self.app_slug);
        debug_struct.field("private_key_secret_version", &self.private_key_secret_version);
        debug_struct.field("webhook_secret_secret_version", &self.webhook_secret_secret_version);
        debug_struct.field("app_installation_id", &self.app_installation_id);
        debug_struct.field("installation_uri", &self.installation_uri);
        debug_struct.field("service_directory_config", &self.service_directory_config);
        debug_struct.field("server_version", &self.server_version);
        debug_struct.field("ssl_ca_certificate", &self.ssl_ca_certificate);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ServiceDirectoryConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ServiceDirectoryConfig");
        debug_struct.field("service", &self.service);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OAuthCredential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OAuthCredential");
        debug_struct.field("oauth_token_secret_version", &self.oauth_token_secret_version);
        debug_struct.field("username", &self.username);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitLabConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitLabConfig");
        debug_struct.field("webhook_secret_secret_version", &self.webhook_secret_secret_version);
        debug_struct.field("read_authorizer_credential", &self.read_authorizer_credential);
        debug_struct.field("authorizer_credential", &self.authorizer_credential);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UserCredential {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UserCredential");
        debug_struct.field("user_token_secret_version", &self.user_token_secret_version);
        debug_struct.field("username", &self.username);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitLabEnterpriseConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitLabEnterpriseConfig");
        debug_struct.field("host_uri", &self.host_uri);
        debug_struct.field("webhook_secret_secret_version", &self.webhook_secret_secret_version);
        debug_struct.field("read_authorizer_credential", &self.read_authorizer_credential);
        debug_struct.field("authorizer_credential", &self.authorizer_credential);
        debug_struct.field("service_directory_config", &self.service_directory_config);
        debug_struct.field("ssl_ca_certificate", &self.ssl_ca_certificate);
        debug_struct.field("server_version", &self.server_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BitbucketDataCenterConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BitbucketDataCenterConfig");
        debug_struct.field("host_uri", &self.host_uri);
        debug_struct.field("webhook_secret_secret_version", &self.webhook_secret_secret_version);
        debug_struct.field("read_authorizer_credential", &self.read_authorizer_credential);
        debug_struct.field("authorizer_credential", &self.authorizer_credential);
        debug_struct.field("service_directory_config", &self.service_directory_config);
        debug_struct.field("ssl_ca_certificate", &self.ssl_ca_certificate);
        debug_struct.field("server_version", &self.server_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::BitbucketCloudConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("BitbucketCloudConfig");
        debug_struct.field("workspace", &self.workspace);
        debug_struct.field("webhook_secret_secret_version", &self.webhook_secret_secret_version);
        debug_struct.field("read_authorizer_credential", &self.read_authorizer_credential);
        debug_struct.field("authorizer_credential", &self.authorizer_credential);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListConnectionsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListConnectionsResponse");
        debug_struct.field("connections", &self.connections);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetConnectionRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateConnectionRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("connection_id", &self.connection_id);
        debug_struct.field("connection", &self.connection);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateConnectionRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("connection", &self.connection);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteConnectionRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteConnectionRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAccountConnectorsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAccountConnectorsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListAccountConnectorsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListAccountConnectorsResponse");
        debug_struct.field("account_connectors", &self.account_connectors);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetAccountConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetAccountConnectorRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateAccountConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateAccountConnectorRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("account_connector_id", &self.account_connector_id);
        debug_struct.field("account_connector", &self.account_connector);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateAccountConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateAccountConnectorRequest");
        debug_struct.field("update_mask", &self.update_mask);
        debug_struct.field("account_connector", &self.account_connector);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteAccountConnectorRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteAccountConnectorRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("force", &self.force);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteUserRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteUserRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::OperationMetadata {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("OperationMetadata");
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("end_time", &self.end_time);
        debug_struct.field("target", &self.target);
        debug_struct.field("verb", &self.verb);
        debug_struct.field("status_message", &self.status_message);
        debug_struct.field("requested_cancellation", &self.requested_cancellation);
        debug_struct.field("api_version", &self.api_version);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchSelfRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchSelfRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteSelfRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteSelfRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchAccessTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchAccessTokenRequest");
        debug_struct.field("account_connector", &self.account_connector);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchAccessTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchAccessTokenResponse");
        debug_struct.field("token", &self.token);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("scopes", &self.scopes);
        debug_struct.field("exchange_error", &self.exchange_error);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ExchangeError {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ExchangeError");
        debug_struct.field("code", &self.code);
        debug_struct.field("description", &self.description);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GitRepositoryLink {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GitRepositoryLink");
        debug_struct.field("name", &self.name);
        debug_struct.field("clone_uri", &self.clone_uri);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("delete_time", &self.delete_time);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("uid", &self.uid);
        debug_struct.field("webhook_id", &self.webhook_id);
        debug_struct.field("git_proxy_uri", &self.git_proxy_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateGitRepositoryLinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateGitRepositoryLinkRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("git_repository_link", &self.git_repository_link);
        debug_struct.field("git_repository_link_id", &self.git_repository_link_id);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteGitRepositoryLinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteGitRepositoryLinkRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListGitRepositoryLinksRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGitRepositoryLinksRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListGitRepositoryLinksResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListGitRepositoryLinksResponse");
        debug_struct.field("git_repository_links", &self.git_repository_links);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetGitRepositoryLinkRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetGitRepositoryLinkRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchReadWriteTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchReadWriteTokenRequest");
        debug_struct.field("git_repository_link", &self.git_repository_link);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchReadTokenRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchReadTokenRequest");
        debug_struct.field("git_repository_link", &self.git_repository_link);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchReadTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchReadTokenResponse");
        debug_struct.field("token", &self.token);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("git_username", &self.git_username);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchReadWriteTokenResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchReadWriteTokenResponse");
        debug_struct.field("token", &self.token);
        debug_struct.field("expiration_time", &self.expiration_time);
        debug_struct.field("git_username", &self.git_username);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchLinkableGitRepositoriesRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchLinkableGitRepositoriesRequest");
        debug_struct.field("connection", &self.connection);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchLinkableGitRepositoriesResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchLinkableGitRepositoriesResponse");
        debug_struct.field("linkable_git_repositories", &self.linkable_git_repositories);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::LinkableGitRepository {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("LinkableGitRepository");
        debug_struct.field("clone_uri", &self.clone_uri);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchGitHubInstallationsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchGitHubInstallationsRequest");
        debug_struct.field("connection", &self.connection);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchGitHubInstallationsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchGitHubInstallationsResponse");
        debug_struct.field("installations", &self.installations);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::fetch_git_hub_installations_response::Installation {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("Installation");
        debug_struct.field("id", &self.id);
        debug_struct.field("name", &self.name);
        debug_struct.field("r#type", &self.r#type);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchGitRefsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchGitRefsRequest");
        debug_struct.field("git_repository_link", &self.git_repository_link);
        debug_struct.field("ref_type", &self.ref_type);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::FetchGitRefsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("FetchGitRefsResponse");
        debug_struct.field("ref_names", &self.ref_names);
        debug_struct.field("next_page_token", &self.next_page_token);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AccountConnector {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AccountConnector");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("etag", &self.etag);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("oauth_start_uri", &self.oauth_start_uri);
        debug_struct.field("account_connector_config", &self.account_connector_config);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}



impl std::fmt::Debug for super::User {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("User");
        debug_struct.field("name", &self.name);
        debug_struct.field("display_name", &self.display_name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("last_token_request_time", &self.last_token_request_time);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ProviderOAuthConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ProviderOAuthConfig");
        debug_struct.field("scopes", &self.scopes);
        debug_struct.field("oauth_provider_id", &self.oauth_provider_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::InsightsConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("InsightsConfig");
        debug_struct.field("name", &self.name);
        debug_struct.field("create_time", &self.create_time);
        debug_struct.field("update_time", &self.update_time);
        debug_struct.field("runtime_configs", &self.runtime_configs);
        debug_struct.field("artifact_configs", &self.artifact_configs);
        debug_struct.field("state", &self.state);
        debug_struct.field("annotations", &self.annotations);
        debug_struct.field("labels", &self.labels);
        debug_struct.field("reconciling", &self.reconciling);
        debug_struct.field("errors", &self.errors);
        debug_struct.field("insights_config_context", &self.insights_config_context);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}



impl std::fmt::Debug for super::RuntimeConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("RuntimeConfig");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("state", &self.state);
        debug_struct.field("runtime", &self.runtime);
        debug_struct.field("derived_from", &self.derived_from);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GKEWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GKEWorkload");
        debug_struct.field("cluster", &self.cluster);
        debug_struct.field("deployment", &self.deployment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::AppHubWorkload {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("AppHubWorkload");
        debug_struct.field("workload", &self.workload);
        debug_struct.field("criticality", &self.criticality);
        debug_struct.field("environment", &self.environment);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ArtifactConfig {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ArtifactConfig");
        debug_struct.field("uri", &self.uri);
        debug_struct.field("artifact_storage", &self.artifact_storage);
        debug_struct.field("artifact_metadata_storage", &self.artifact_metadata_storage);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GoogleArtifactAnalysis {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleArtifactAnalysis");
        debug_struct.field("project_id", &self.project_id);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GoogleArtifactRegistry {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GoogleArtifactRegistry");
        debug_struct.field("project_id", &self.project_id);
        debug_struct.field("artifact_registry_package", &self.artifact_registry_package);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::CreateInsightsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("CreateInsightsConfigRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("insights_config_id", &self.insights_config_id);
        debug_struct.field("insights_config", &self.insights_config);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::GetInsightsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("GetInsightsConfigRequest");
        debug_struct.field("name", &self.name);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInsightsConfigsRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInsightsConfigsRequest");
        debug_struct.field("parent", &self.parent);
        debug_struct.field("page_size", &self.page_size);
        debug_struct.field("page_token", &self.page_token);
        debug_struct.field("filter", &self.filter);
        debug_struct.field("order_by", &self.order_by);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::ListInsightsConfigsResponse {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("ListInsightsConfigsResponse");
        debug_struct.field("insights_configs", &self.insights_configs);
        debug_struct.field("next_page_token", &self.next_page_token);
        debug_struct.field("unreachable", &self.unreachable);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::DeleteInsightsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("DeleteInsightsConfigRequest");
        debug_struct.field("name", &self.name);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("validate_only", &self.validate_only);
        debug_struct.field("etag", &self.etag);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}

impl std::fmt::Debug for super::UpdateInsightsConfigRequest {
    fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
        let mut debug_struct = f.debug_struct("UpdateInsightsConfigRequest");
        debug_struct.field("insights_config", &self.insights_config);
        debug_struct.field("request_id", &self.request_id);
        debug_struct.field("allow_missing", &self.allow_missing);
        debug_struct.field("validate_only", &self.validate_only);
        if !self._unknown_fields.is_empty() {
            debug_struct.field("_unknown_fields", &self._unknown_fields);
        }
        debug_struct.finish()
    }
}
