// Copyright 2025 Google LLC
//
// Licensed under the Apache License, Version 2.0 (the "License");
// you may not use this file except in compliance with the License.
// You may obtain a copy of the License at
//
//     https://www.apache.org/licenses/LICENSE-2.0
//
// Unless required by applicable law or agreed to in writing, software
// distributed under the License is distributed on an "AS IS" BASIS,
// WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied.
// See the License for the specific language governing permissions and
// limitations under the License.
//
// Code generated by sidekick. DO NOT EDIT.

#![allow(rustdoc::redundant_explicit_links)]
#![allow(rustdoc::broken_intra_doc_links)]
#![no_implicit_prelude]
extern crate async_trait;
extern crate bytes;
extern crate gax;
extern crate gaxi;
extern crate lazy_static;
extern crate location;
extern crate longrunning;
extern crate lro;
extern crate reqwest;
extern crate serde;
extern crate serde_json;
extern crate serde_with;
extern crate std;
extern crate tracing;
extern crate wkt;

/// Message describing Connection object
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct Connection {
    /// Identifier. The resource name of the connection, in the format
    /// `projects/{project}/locations/{location}/connections/{connection_id}`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Output only. [Output only] Create timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Delete timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. Installation state of the Connection.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub installation_state: std::option::Option<crate::model::InstallationState>,

    /// Optional. If disabled is set to true, functionality is disabled for this
    /// connection. Repository based API methods and webhooks processing for
    /// repositories in this connection will be disabled.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub disabled: bool,

    /// Output only. Set to true when the connection is being set up or updated in
    /// the background.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Optional. Allows clients to store small amounts of arbitrary data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. A system-assigned unique identifier for a the
    /// GitRepositoryLink.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Optional. The crypto key configuration. This field is used by the
    /// Customer-Managed Encryption Keys (CMEK) feature.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub crypto_key_config: std::option::Option<crate::model::CryptoKeyConfig>,

    /// Configuration for the connection depending on the type of provider.
    #[serde(flatten, skip_serializing_if = "std::option::Option::is_none")]
    pub connection_config: std::option::Option<crate::model::connection::ConnectionConfig>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl Connection {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::Connection::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::Connection::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::Connection::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::Connection::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::Connection::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::Connection::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::Connection::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::Connection::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [installation_state][crate::model::Connection::installation_state].
    pub fn set_installation_state<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::InstallationState>,
    {
        self.installation_state = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [installation_state][crate::model::Connection::installation_state].
    pub fn set_or_clear_installation_state<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::InstallationState>,
    {
        self.installation_state = v.map(|x| x.into());
        self
    }

    /// Sets the value of [disabled][crate::model::Connection::disabled].
    pub fn set_disabled<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.disabled = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::Connection::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::Connection::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::Connection::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [uid][crate::model::Connection::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [crypto_key_config][crate::model::Connection::crypto_key_config].
    pub fn set_crypto_key_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyConfig>,
    {
        self.crypto_key_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [crypto_key_config][crate::model::Connection::crypto_key_config].
    pub fn set_or_clear_crypto_key_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::CryptoKeyConfig>,
    {
        self.crypto_key_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config].
    ///
    /// Note that all the setters affecting `connection_config` are mutually
    /// exclusive.
    pub fn set_connection_config<
        T: std::convert::Into<std::option::Option<crate::model::connection::ConnectionConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = v.into();
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_config<T: std::convert::Into<std::boxed::Box<crate::model::GitHubConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GithubEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn github_enterprise_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitHubEnterpriseConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GithubEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_github_enterprise_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GitHubEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GithubEnterpriseConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GitlabConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gitlab_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitLabConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GitlabConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GitlabConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_gitlab_config<T: std::convert::Into<std::boxed::Box<crate::model::GitLabConfig>>>(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GitlabConfig(v.into()),
        );
        self
    }

    /// The value of [connection_config][crate::model::Connection::connection_config]
    /// if it holds a `GitlabEnterpriseConfig`, `None` if the field is not set or
    /// holds a different branch.
    pub fn gitlab_enterprise_config(
        &self,
    ) -> std::option::Option<&std::boxed::Box<crate::model::GitLabEnterpriseConfig>> {
        #[allow(unreachable_patterns)]
        self.connection_config.as_ref().and_then(|v| match v {
            crate::model::connection::ConnectionConfig::GitlabEnterpriseConfig(v) => {
                std::option::Option::Some(v)
            }
            _ => std::option::Option::None,
        })
    }

    /// Sets the value of [connection_config][crate::model::Connection::connection_config]
    /// to hold a `GitlabEnterpriseConfig`.
    ///
    /// Note that all the setters affecting `connection_config` are
    /// mutually exclusive.
    pub fn set_gitlab_enterprise_config<
        T: std::convert::Into<std::boxed::Box<crate::model::GitLabEnterpriseConfig>>,
    >(
        mut self,
        v: T,
    ) -> Self {
        self.connection_config = std::option::Option::Some(
            crate::model::connection::ConnectionConfig::GitlabEnterpriseConfig(v.into()),
        );
        self
    }
}

impl wkt::message::Message for Connection {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.Connection"
    }
}

/// Defines additional types related to [Connection].
pub mod connection {
    #[allow(unused_imports)]
    use super::*;

    /// Configuration for the connection depending on the type of provider.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(rename_all = "camelCase")]
    #[non_exhaustive]
    pub enum ConnectionConfig {
        /// Configuration for connections to github.com.
        GithubConfig(std::boxed::Box<crate::model::GitHubConfig>),
        /// Configuration for connections to an instance of GitHub Enterprise.
        GithubEnterpriseConfig(std::boxed::Box<crate::model::GitHubEnterpriseConfig>),
        /// Configuration for connections to gitlab.com.
        GitlabConfig(std::boxed::Box<crate::model::GitLabConfig>),
        /// Configuration for connections to an instance of GitLab Enterprise.
        GitlabEnterpriseConfig(std::boxed::Box<crate::model::GitLabEnterpriseConfig>),
    }
}

/// The crypto key configuration. This field is used by the Customer-managed
/// encryption keys (CMEK) feature.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CryptoKeyConfig {
    /// Required. The name of the key which is used to encrypt/decrypt customer
    /// data. For key in Cloud KMS, the key should be in the format of
    /// `projects/*/locations/*/keyRings/*/cryptoKeys/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub key_reference: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CryptoKeyConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [key_reference][crate::model::CryptoKeyConfig::key_reference].
    pub fn set_key_reference<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.key_reference = v.into();
        self
    }
}

impl wkt::message::Message for CryptoKeyConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CryptoKeyConfig"
    }
}

/// Describes stage and necessary actions to be taken by the
/// user to complete the installation. Used for GitHub and GitHub Enterprise
/// based connections.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct InstallationState {
    /// Output only. Current step of the installation process.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub stage: crate::model::installation_state::Stage,

    /// Output only. Message of what the user should do next to continue the
    /// installation. Empty string if the installation is already complete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub message: std::string::String,

    /// Output only. Link to follow for next action. Empty string if the
    /// installation is already complete.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub action_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl InstallationState {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [stage][crate::model::InstallationState::stage].
    pub fn set_stage<T: std::convert::Into<crate::model::installation_state::Stage>>(
        mut self,
        v: T,
    ) -> Self {
        self.stage = v.into();
        self
    }

    /// Sets the value of [message][crate::model::InstallationState::message].
    pub fn set_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.message = v.into();
        self
    }

    /// Sets the value of [action_uri][crate::model::InstallationState::action_uri].
    pub fn set_action_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.action_uri = v.into();
        self
    }
}

impl wkt::message::Message for InstallationState {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.InstallationState"
    }
}

/// Defines additional types related to [InstallationState].
pub mod installation_state {
    #[allow(unused_imports)]
    use super::*;

    /// Stage of the installation process.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum Stage {
        /// No stage specified.
        Unspecified,
        /// Only for GitHub Enterprise. An App creation has been requested.
        /// The user needs to confirm the creation in their GitHub enterprise host.
        PendingCreateApp,
        /// User needs to authorize the GitHub (or Enterprise) App via OAuth.
        PendingUserOauth,
        /// User needs to follow the link to install the GitHub (or Enterprise) App.
        PendingInstallApp,
        /// Installation process has been completed.
        Complete,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [Stage::value] or
        /// [Stage::name].
        UnknownValue(stage::UnknownValue),
    }

    #[doc(hidden)]
    pub mod stage {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl Stage {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::PendingCreateApp => std::option::Option::Some(1),
                Self::PendingUserOauth => std::option::Option::Some(2),
                Self::PendingInstallApp => std::option::Option::Some(3),
                Self::Complete => std::option::Option::Some(10),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("STAGE_UNSPECIFIED"),
                Self::PendingCreateApp => std::option::Option::Some("PENDING_CREATE_APP"),
                Self::PendingUserOauth => std::option::Option::Some("PENDING_USER_OAUTH"),
                Self::PendingInstallApp => std::option::Option::Some("PENDING_INSTALL_APP"),
                Self::Complete => std::option::Option::Some("COMPLETE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for Stage {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for Stage {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for Stage {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::PendingCreateApp,
                2 => Self::PendingUserOauth,
                3 => Self::PendingInstallApp,
                10 => Self::Complete,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for Stage {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "STAGE_UNSPECIFIED" => Self::Unspecified,
                "PENDING_CREATE_APP" => Self::PendingCreateApp,
                "PENDING_USER_OAUTH" => Self::PendingUserOauth,
                "PENDING_INSTALL_APP" => Self::PendingInstallApp,
                "COMPLETE" => Self::Complete,
                _ => Self::UnknownValue(stage::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for Stage {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::PendingCreateApp => serializer.serialize_i32(1),
                Self::PendingUserOauth => serializer.serialize_i32(2),
                Self::PendingInstallApp => serializer.serialize_i32(3),
                Self::Complete => serializer.serialize_i32(10),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for Stage {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<Stage>::new(
                ".google.cloud.developerconnect.v1.InstallationState.Stage",
            ))
        }
    }
}

/// Configuration for connections to github.com.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubConfig {
    /// Required. Immutable. The GitHub Application that was installed to the
    /// GitHub user or organization.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub github_app: crate::model::git_hub_config::GitHubApp,

    /// Optional. OAuth credential of the account that authorized the GitHub App.
    /// It is recommended to use a robot account instead of a human user account.
    /// The OAuth token must be tied to the GitHub App of this config.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::OAuthCredential>,

    /// Optional. GitHub App installation id.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub app_installation_id: i64,

    /// Output only. The URI to navigate to in order to manage the installation
    /// associated with this GitHubConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub installation_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [github_app][crate::model::GitHubConfig::github_app].
    pub fn set_github_app<T: std::convert::Into<crate::model::git_hub_config::GitHubApp>>(
        mut self,
        v: T,
    ) -> Self {
        self.github_app = v.into();
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitHubConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::OAuthCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitHubConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::OAuthCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }

    /// Sets the value of [installation_uri][crate::model::GitHubConfig::installation_uri].
    pub fn set_installation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.installation_uri = v.into();
        self
    }
}

impl wkt::message::Message for GitHubConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitHubConfig"
    }
}

/// Defines additional types related to [GitHubConfig].
pub mod git_hub_config {
    #[allow(unused_imports)]
    use super::*;

    /// Represents the various GitHub Applications that can be installed to a
    /// GitHub user or organization and used with Developer Connect.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum GitHubApp {
        /// GitHub App not specified.
        Unspecified,
        /// The Developer Connect GitHub Application.
        DeveloperConnect,
        /// The Firebase GitHub Application.
        Firebase,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [GitHubApp::value] or
        /// [GitHubApp::name].
        UnknownValue(git_hub_app::UnknownValue),
    }

    #[doc(hidden)]
    pub mod git_hub_app {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl GitHubApp {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::DeveloperConnect => std::option::Option::Some(1),
                Self::Firebase => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("GIT_HUB_APP_UNSPECIFIED"),
                Self::DeveloperConnect => std::option::Option::Some("DEVELOPER_CONNECT"),
                Self::Firebase => std::option::Option::Some("FIREBASE"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for GitHubApp {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for GitHubApp {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for GitHubApp {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::DeveloperConnect,
                2 => Self::Firebase,
                _ => Self::UnknownValue(git_hub_app::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for GitHubApp {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "GIT_HUB_APP_UNSPECIFIED" => Self::Unspecified,
                "DEVELOPER_CONNECT" => Self::DeveloperConnect,
                "FIREBASE" => Self::Firebase,
                _ => Self::UnknownValue(git_hub_app::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for GitHubApp {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::DeveloperConnect => serializer.serialize_i32(1),
                Self::Firebase => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for GitHubApp {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<GitHubApp>::new(
                ".google.cloud.developerconnect.v1.GitHubConfig.GitHubApp",
            ))
        }
    }
}

/// Configuration for connections to an instance of GitHub Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitHubEnterpriseConfig {
    /// Required. The URI of the GitHub Enterprise host this connection is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// Optional. ID of the GitHub App created from the manifest.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub app_id: i64,

    /// Output only. The URL-friendly name of the GitHub App.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub app_slug: std::string::String,

    /// Optional. SecretManager resource containing the private key of the GitHub
    /// App, formatted as `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub private_key_secret_version: std::string::String,

    /// Optional. SecretManager resource containing the webhook secret of the
    /// GitHub App, formatted as `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Optional. ID of the installation of the GitHub App.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I64")]
    pub app_installation_id: i64,

    /// Output only. The URI to navigate to in order to manage the installation
    /// associated with this GitHubEnterpriseConfig.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub installation_uri: std::string::String,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a GitHub Enterprise server. This should only be set if the GitHub
    /// Enterprise server is hosted on-premises and not reachable by public
    /// internet. If this field is left empty, calls to the GitHub Enterprise
    /// server will be made over the public internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Output only. GitHub Enterprise version installed at the host_uri.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_version: std::string::String,

    /// Optional. SSL certificate to use for requests to GitHub Enterprise.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca_certificate: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitHubEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitHubEnterpriseConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [app_id][crate::model::GitHubEnterpriseConfig::app_id].
    pub fn set_app_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_id = v.into();
        self
    }

    /// Sets the value of [app_slug][crate::model::GitHubEnterpriseConfig::app_slug].
    pub fn set_app_slug<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.app_slug = v.into();
        self
    }

    /// Sets the value of [private_key_secret_version][crate::model::GitHubEnterpriseConfig::private_key_secret_version].
    pub fn set_private_key_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.private_key_secret_version = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitHubEnterpriseConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [app_installation_id][crate::model::GitHubEnterpriseConfig::app_installation_id].
    pub fn set_app_installation_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
        self.app_installation_id = v.into();
        self
    }

    /// Sets the value of [installation_uri][crate::model::GitHubEnterpriseConfig::installation_uri].
    pub fn set_installation_uri<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.installation_uri = v.into();
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitHubEnterpriseConfig::service_directory_config].
    pub fn set_service_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_directory_config][crate::model::GitHubEnterpriseConfig::service_directory_config].
    pub fn set_or_clear_service_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [server_version][crate::model::GitHubEnterpriseConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }

    /// Sets the value of [ssl_ca_certificate][crate::model::GitHubEnterpriseConfig::ssl_ca_certificate].
    pub fn set_ssl_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_ca_certificate = v.into();
        self
    }
}

impl wkt::message::Message for GitHubEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitHubEnterpriseConfig"
    }
}

/// ServiceDirectoryConfig represents Service Directory configuration for a
/// connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ServiceDirectoryConfig {
    /// Required. The Service Directory service name.
    /// Format:
    /// projects/{project}/locations/{location}/namespaces/{namespace}/services/{service}.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub service: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ServiceDirectoryConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [service][crate::model::ServiceDirectoryConfig::service].
    pub fn set_service<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.service = v.into();
        self
    }
}

impl wkt::message::Message for ServiceDirectoryConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ServiceDirectoryConfig"
    }
}

/// Represents an OAuth token of the account that authorized the Connection,
/// and associated metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OAuthCredential {
    /// Required. A SecretManager resource containing the OAuth token that
    /// authorizes the connection. Format: `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub oauth_token_secret_version: std::string::String,

    /// Output only. The username associated with this token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OAuthCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [oauth_token_secret_version][crate::model::OAuthCredential::oauth_token_secret_version].
    pub fn set_oauth_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.oauth_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::OAuthCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for OAuthCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.OAuthCredential"
    }
}

/// Configuration for connections to gitlab.com.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitLabConfig {
    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// of a GitLab project, formatted as `projects/*/secrets/*/versions/*`. This
    /// is used to validate webhooks.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A GitLab personal access token with the minimum `read_api` scope
    /// access and a minimum role of `reporter`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A GitLab personal access token with the minimum `api` scope
    /// access and a minimum role of `maintainer`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitLabConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitLabConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::GitLabConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::GitLabConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitLabConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitLabConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }
}

impl wkt::message::Message for GitLabConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitLabConfig"
    }
}

/// Represents a personal access token that authorized the Connection,
/// and associated metadata.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UserCredential {
    /// Required. A SecretManager resource containing the user token that
    /// authorizes the Developer Connect connection. Format:
    /// `projects/*/secrets/*/versions/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub user_token_secret_version: std::string::String,

    /// Output only. The username associated with this token.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UserCredential {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [user_token_secret_version][crate::model::UserCredential::user_token_secret_version].
    pub fn set_user_token_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.user_token_secret_version = v.into();
        self
    }

    /// Sets the value of [username][crate::model::UserCredential::username].
    pub fn set_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.username = v.into();
        self
    }
}

impl wkt::message::Message for UserCredential {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UserCredential"
    }
}

/// Configuration for connections to an instance of GitLab Enterprise.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitLabEnterpriseConfig {
    /// Required. The URI of the GitLab Enterprise host this connection is for.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub host_uri: std::string::String,

    /// Required. Immutable. SecretManager resource containing the webhook secret
    /// of a GitLab project, formatted as `projects/*/secrets/*/versions/*`. This
    /// is used to validate webhooks.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_secret_secret_version: std::string::String,

    /// Required. A GitLab personal access token with the minimum `read_api` scope
    /// access and a minimum role of `reporter`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub read_authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Required. A GitLab personal access token with the minimum `api` scope
    /// access and a minimum role of `maintainer`. The GitLab Projects visible to
    /// this Personal Access Token will control which Projects Developer Connect
    /// has access to.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub authorizer_credential: std::option::Option<crate::model::UserCredential>,

    /// Optional. Configuration for using Service Directory to privately connect to
    /// a GitLab Enterprise instance. This should only be set if the GitLab
    /// Enterprise server is hosted on-premises and not reachable by public
    /// internet. If this field is left empty, calls to the GitLab Enterprise
    /// server will be made over the public internet.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub service_directory_config: std::option::Option<crate::model::ServiceDirectoryConfig>,

    /// Optional. SSL Certificate Authority certificate to use for requests to
    /// GitLab Enterprise instance.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub ssl_ca_certificate: std::string::String,

    /// Output only. Version of the GitLab Enterprise server running on the
    /// `host_uri`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub server_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitLabEnterpriseConfig {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [host_uri][crate::model::GitLabEnterpriseConfig::host_uri].
    pub fn set_host_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.host_uri = v.into();
        self
    }

    /// Sets the value of [webhook_secret_secret_version][crate::model::GitLabEnterpriseConfig::webhook_secret_secret_version].
    pub fn set_webhook_secret_secret_version<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.webhook_secret_secret_version = v.into();
        self
    }

    /// Sets the value of [read_authorizer_credential][crate::model::GitLabEnterpriseConfig::read_authorizer_credential].
    pub fn set_read_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [read_authorizer_credential][crate::model::GitLabEnterpriseConfig::read_authorizer_credential].
    pub fn set_or_clear_read_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.read_authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [authorizer_credential][crate::model::GitLabEnterpriseConfig::authorizer_credential].
    pub fn set_authorizer_credential<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [authorizer_credential][crate::model::GitLabEnterpriseConfig::authorizer_credential].
    pub fn set_or_clear_authorizer_credential<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::UserCredential>,
    {
        self.authorizer_credential = v.map(|x| x.into());
        self
    }

    /// Sets the value of [service_directory_config][crate::model::GitLabEnterpriseConfig::service_directory_config].
    pub fn set_service_directory_config<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [service_directory_config][crate::model::GitLabEnterpriseConfig::service_directory_config].
    pub fn set_or_clear_service_directory_config<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::ServiceDirectoryConfig>,
    {
        self.service_directory_config = v.map(|x| x.into());
        self
    }

    /// Sets the value of [ssl_ca_certificate][crate::model::GitLabEnterpriseConfig::ssl_ca_certificate].
    pub fn set_ssl_ca_certificate<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.ssl_ca_certificate = v.into();
        self
    }

    /// Sets the value of [server_version][crate::model::GitLabEnterpriseConfig::server_version].
    pub fn set_server_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.server_version = v.into();
        self
    }
}

impl wkt::message::Message for GitLabEnterpriseConfig {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitLabEnterpriseConfig"
    }
}

/// Message for requesting list of Connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsRequest {
    /// Required. Parent value for ListConnectionsRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListConnectionsRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListConnectionsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListConnectionsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListConnectionsRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListConnectionsRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListConnectionsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListConnectionsRequest"
    }
}

/// Message for response to listing Connections
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListConnectionsResponse {
    /// The list of Connection
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub connections: std::vec::Vec<crate::model::Connection>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListConnectionsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connections][crate::model::ListConnectionsResponse::connections].
    pub fn set_connections<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::Connection>,
    {
        use std::iter::Iterator;
        self.connections = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListConnectionsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListConnectionsResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListConnectionsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListConnectionsResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListConnectionsResponse {
    type PageItem = crate::model::Connection;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.connections
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a Connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetConnectionRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetConnectionRequest"
    }
}

/// Message for creating a Connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateConnectionRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. Id of the requesting object
    /// If auto-generating Id server-side, remove this field and
    /// connection_id from the method_signature of Create RPC
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection_id: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateConnectionRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [connection_id][crate::model::CreateConnectionRequest::connection_id].
    pub fn set_connection_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection_id = v.into();
        self
    }

    /// Sets the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::CreateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::CreateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateConnectionRequest"
    }
}

/// Message for updating a Connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct UpdateConnectionRequest {
    /// Required. Field mask is used to specify the fields to be overwritten in the
    /// Connection resource by the update.
    /// The fields specified in the update_mask are relative to the resource, not
    /// the full request. A field will be overwritten if it is in the mask. If the
    /// user does not provide a mask then all fields will be overwritten.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_mask: std::option::Option<wkt::FieldMask>,

    /// Required. The resource being updated
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub connection: std::option::Option<crate::model::Connection>,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set to true, and the connection is not found a new connection
    /// will be created. In this situation `update_mask` is ignored.
    /// The creation will succeed only if the input connection has all the
    /// necessary information (e.g a github_config with both  user_oauth_token and
    /// installation_id properties).
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub allow_missing: bool,

    /// Optional. If set, validate the request, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl UpdateConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_update_mask<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_mask][crate::model::UpdateConnectionRequest::update_mask].
    pub fn set_or_clear_update_mask<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::FieldMask>,
    {
        self.update_mask = v.map(|x| x.into());
        self
    }

    /// Sets the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_connection<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [connection][crate::model::UpdateConnectionRequest::connection].
    pub fn set_or_clear_connection<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::Connection>,
    {
        self.connection = v.map(|x| x.into());
        self
    }

    /// Sets the value of [request_id][crate::model::UpdateConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [allow_missing][crate::model::UpdateConnectionRequest::allow_missing].
    pub fn set_allow_missing<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.allow_missing = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::UpdateConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for UpdateConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.UpdateConnectionRequest"
    }
}

/// Message for deleting a Connection
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteConnectionRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. The current etag of the Connection.
    /// If an etag is provided and does not match the current etag of the
    /// Connection, deletion will be blocked and an ABORTED error will be returned.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteConnectionRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteConnectionRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteConnectionRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteConnectionRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteConnectionRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteConnectionRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteConnectionRequest"
    }
}

/// Represents the metadata of the long-running operation.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct OperationMetadata {
    /// Output only. The time the operation was created.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. The time the operation finished running.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub end_time: std::option::Option<wkt::Timestamp>,

    /// Output only. Server-defined resource path for the target of the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub target: std::string::String,

    /// Output only. Name of the verb executed by the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub verb: std::string::String,

    /// Output only. Human-readable status of the operation, if any.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub status_message: std::string::String,

    /// Output only. Identifies whether the user has requested cancellation
    /// of the operation. Operations that have been cancelled successfully
    /// have
    /// [google.longrunning.Operation.error][google.longrunning.Operation.error]
    /// value with a [google.rpc.Status.code][google.rpc.Status.code] of 1,
    /// corresponding to `Code.CANCELLED`.
    ///
    /// [google.longrunning.Operation.error]: longrunning::model::Operation::result
    /// [google.rpc.Status.code]: rpc::model::Status::code
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub requested_cancellation: bool,

    /// Output only. API version used to start the operation.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub api_version: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl OperationMetadata {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::OperationMetadata::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_end_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [end_time][crate::model::OperationMetadata::end_time].
    pub fn set_or_clear_end_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.end_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [target][crate::model::OperationMetadata::target].
    pub fn set_target<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.target = v.into();
        self
    }

    /// Sets the value of [verb][crate::model::OperationMetadata::verb].
    pub fn set_verb<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.verb = v.into();
        self
    }

    /// Sets the value of [status_message][crate::model::OperationMetadata::status_message].
    pub fn set_status_message<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.status_message = v.into();
        self
    }

    /// Sets the value of [requested_cancellation][crate::model::OperationMetadata::requested_cancellation].
    pub fn set_requested_cancellation<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.requested_cancellation = v.into();
        self
    }

    /// Sets the value of [api_version][crate::model::OperationMetadata::api_version].
    pub fn set_api_version<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.api_version = v.into();
        self
    }
}

impl wkt::message::Message for OperationMetadata {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.OperationMetadata"
    }
}

/// Message describing the GitRepositoryLink object
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GitRepositoryLink {
    /// Identifier. Resource name of the repository, in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Required. Git Clone URI.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub clone_uri: std::string::String,

    /// Output only. [Output only] Create timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub create_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Update timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub update_time: std::option::Option<wkt::Timestamp>,

    /// Output only. [Output only] Delete timestamp
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub delete_time: std::option::Option<wkt::Timestamp>,

    /// Optional. Labels as key value pairs
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub labels: std::collections::HashMap<std::string::String, std::string::String>,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    /// Output only. Set to true when the connection is being set up or updated in
    /// the background.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub reconciling: bool,

    /// Optional. Allows clients to store small amounts of arbitrary data.
    #[serde(skip_serializing_if = "std::collections::HashMap::is_empty")]
    pub annotations: std::collections::HashMap<std::string::String, std::string::String>,

    /// Output only. A system-assigned unique identifier for a the
    /// GitRepositoryLink.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub uid: std::string::String,

    /// Output only. External ID of the webhook created for the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub webhook_id: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GitRepositoryLink {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GitRepositoryLink::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [clone_uri][crate::model::GitRepositoryLink::clone_uri].
    pub fn set_clone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_uri = v.into();
        self
    }

    /// Sets the value of [create_time][crate::model::GitRepositoryLink::create_time].
    pub fn set_create_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [create_time][crate::model::GitRepositoryLink::create_time].
    pub fn set_or_clear_create_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.create_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [update_time][crate::model::GitRepositoryLink::update_time].
    pub fn set_update_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [update_time][crate::model::GitRepositoryLink::update_time].
    pub fn set_or_clear_update_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.update_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [delete_time][crate::model::GitRepositoryLink::delete_time].
    pub fn set_delete_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [delete_time][crate::model::GitRepositoryLink::delete_time].
    pub fn set_or_clear_delete_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.delete_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [labels][crate::model::GitRepositoryLink::labels].
    pub fn set_labels<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.labels = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [etag][crate::model::GitRepositoryLink::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }

    /// Sets the value of [reconciling][crate::model::GitRepositoryLink::reconciling].
    pub fn set_reconciling<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.reconciling = v.into();
        self
    }

    /// Sets the value of [annotations][crate::model::GitRepositoryLink::annotations].
    pub fn set_annotations<T, K, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = (K, V)>,
        K: std::convert::Into<std::string::String>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.annotations = v.into_iter().map(|(k, v)| (k.into(), v.into())).collect();
        self
    }

    /// Sets the value of [uid][crate::model::GitRepositoryLink::uid].
    pub fn set_uid<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.uid = v.into();
        self
    }

    /// Sets the value of [webhook_id][crate::model::GitRepositoryLink::webhook_id].
    pub fn set_webhook_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.webhook_id = v.into();
        self
    }
}

impl wkt::message::Message for GitRepositoryLink {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GitRepositoryLink"
    }
}

/// Message for creating a GitRepositoryLink
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct CreateGitRepositoryLinkRequest {
    /// Required. Value for parent.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Required. The resource being created
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub git_repository_link: std::option::Option<crate::model::GitRepositoryLink>,

    /// Required. The ID to use for the repository, which will become the final
    /// component of the repository's resource name. This ID should be unique in
    /// the connection. Allows alphanumeric characters and any of
    /// -._~%!$&'()*+,;=@.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_repository_link_id: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes since the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl CreateGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::CreateGitRepositoryLinkRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [git_repository_link][crate::model::CreateGitRepositoryLinkRequest::git_repository_link].
    pub fn set_git_repository_link<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        self.git_repository_link = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [git_repository_link][crate::model::CreateGitRepositoryLinkRequest::git_repository_link].
    pub fn set_or_clear_git_repository_link<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        self.git_repository_link = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_repository_link_id][crate::model::CreateGitRepositoryLinkRequest::git_repository_link_id].
    pub fn set_git_repository_link_id<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link_id = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::CreateGitRepositoryLinkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::CreateGitRepositoryLinkRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }
}

impl wkt::message::Message for CreateGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.CreateGitRepositoryLinkRequest"
    }
}

/// Message for deleting a GitRepositoryLink
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct DeleteGitRepositoryLinkRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    /// Optional. An optional request ID to identify requests. Specify a unique
    /// request ID so that if you must retry your request, the server will know to
    /// ignore the request if it has already been completed. The server will
    /// guarantee that for at least 60 minutes after the first request.
    ///
    /// For example, consider a situation where you make an initial request and the
    /// request times out. If you make the request again with the same request
    /// ID, the server can check if original operation with the same request ID
    /// was received, and if so, will ignore the second request. This prevents
    /// clients from accidentally creating duplicate commitments.
    ///
    /// The request ID must be a valid UUID with the exception that zero UUID is
    /// not supported (00000000-0000-0000-0000-000000000000).
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub request_id: std::string::String,

    /// Optional. If set, validate the request, but do not actually post it.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub validate_only: bool,

    /// Optional. This checksum is computed by the server based on the value of
    /// other fields, and may be sent on update and delete requests to ensure the
    /// client has an up-to-date value before proceeding.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub etag: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl DeleteGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::DeleteGitRepositoryLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }

    /// Sets the value of [request_id][crate::model::DeleteGitRepositoryLinkRequest::request_id].
    pub fn set_request_id<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.request_id = v.into();
        self
    }

    /// Sets the value of [validate_only][crate::model::DeleteGitRepositoryLinkRequest::validate_only].
    pub fn set_validate_only<T: std::convert::Into<bool>>(mut self, v: T) -> Self {
        self.validate_only = v.into();
        self
    }

    /// Sets the value of [etag][crate::model::DeleteGitRepositoryLinkRequest::etag].
    pub fn set_etag<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.etag = v.into();
        self
    }
}

impl wkt::message::Message for DeleteGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.DeleteGitRepositoryLinkRequest"
    }
}

/// Message for requesting a list of GitRepositoryLinks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGitRepositoryLinksRequest {
    /// Required. Parent value for ListGitRepositoryLinksRequest
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub parent: std::string::String,

    /// Optional. Requested page size. Server may return fewer items than
    /// requested. If unspecified, server will pick an appropriate default.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    /// Optional. Filtering results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub filter: std::string::String,

    /// Optional. Hint for how to order the results
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub order_by: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGitRepositoryLinksRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [parent][crate::model::ListGitRepositoryLinksRequest::parent].
    pub fn set_parent<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.parent = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::ListGitRepositoryLinksRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::ListGitRepositoryLinksRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }

    /// Sets the value of [filter][crate::model::ListGitRepositoryLinksRequest::filter].
    pub fn set_filter<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.filter = v.into();
        self
    }

    /// Sets the value of [order_by][crate::model::ListGitRepositoryLinksRequest::order_by].
    pub fn set_order_by<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.order_by = v.into();
        self
    }
}

impl wkt::message::Message for ListGitRepositoryLinksRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListGitRepositoryLinksRequest"
    }
}

/// Message for response to listing GitRepositoryLinks
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct ListGitRepositoryLinksResponse {
    /// The list of GitRepositoryLinks
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub git_repository_links: std::vec::Vec<crate::model::GitRepositoryLink>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    /// Locations that could not be reached.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub unreachable: std::vec::Vec<std::string::String>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl ListGitRepositoryLinksResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_links][crate::model::ListGitRepositoryLinksResponse::git_repository_links].
    pub fn set_git_repository_links<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::GitRepositoryLink>,
    {
        use std::iter::Iterator;
        self.git_repository_links = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::ListGitRepositoryLinksResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }

    /// Sets the value of [unreachable][crate::model::ListGitRepositoryLinksResponse::unreachable].
    pub fn set_unreachable<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.unreachable = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for ListGitRepositoryLinksResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.ListGitRepositoryLinksResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for ListGitRepositoryLinksResponse {
    type PageItem = crate::model::GitRepositoryLink;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.git_repository_links
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// Message for getting a GitRepositoryLink
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct GetGitRepositoryLinkRequest {
    /// Required. Name of the resource
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub name: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl GetGitRepositoryLinkRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [name][crate::model::GetGitRepositoryLinkRequest::name].
    pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.name = v.into();
        self
    }
}

impl wkt::message::Message for GetGitRepositoryLinkRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.GetGitRepositoryLinkRequest"
    }
}

/// Message for fetching SCM read/write token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadWriteTokenRequest {
    /// Required. The resource name of the gitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_repository_link: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchReadWriteTokenRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadWriteTokenRequest"
    }
}

/// Message for fetching SCM read token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadTokenRequest {
    /// Required. The resource name of the gitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_repository_link: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchReadTokenRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadTokenRequest"
    }
}

/// Message for responding to get read token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadTokenResponse {
    /// The token content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The git_username to specify when making a git clone with the
    /// token. For example, for GitHub GitRepositoryLinks, this would be
    /// "x-access-token"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::FetchReadTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_username][crate::model::FetchReadTokenResponse::git_username].
    pub fn set_git_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_username = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadTokenResponse"
    }
}

/// Message for responding to get read/write token.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchReadWriteTokenResponse {
    /// The token content.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub token: std::string::String,

    /// Expiration timestamp. Can be empty if unknown or non-expiring.
    #[serde(skip_serializing_if = "std::option::Option::is_none")]
    pub expiration_time: std::option::Option<wkt::Timestamp>,

    /// The git_username to specify when making a git clone with the
    /// token. For example, for GitHub GitRepositoryLinks, this would be
    /// "x-access-token"
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_username: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchReadWriteTokenResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [token][crate::model::FetchReadWriteTokenResponse::token].
    pub fn set_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.token = v.into();
        self
    }

    /// Sets the value of [expiration_time][crate::model::FetchReadWriteTokenResponse::expiration_time].
    pub fn set_expiration_time<T>(mut self, v: T) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = std::option::Option::Some(v.into());
        self
    }

    /// Sets or clears the value of [expiration_time][crate::model::FetchReadWriteTokenResponse::expiration_time].
    pub fn set_or_clear_expiration_time<T>(mut self, v: std::option::Option<T>) -> Self
    where
        T: std::convert::Into<wkt::Timestamp>,
    {
        self.expiration_time = v.map(|x| x.into());
        self
    }

    /// Sets the value of [git_username][crate::model::FetchReadWriteTokenResponse::git_username].
    pub fn set_git_username<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.git_username = v.into();
        self
    }
}

impl wkt::message::Message for FetchReadWriteTokenResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchReadWriteTokenResponse"
    }
}

/// Request message for FetchLinkableGitRepositoriesRequest.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchLinkableGitRepositoriesRequest {
    /// Required. The name of the Connection.
    /// Format: `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,

    /// Optional. Number of results to return in the list. Defaults to 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. Page start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableGitRepositoriesRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::FetchLinkableGitRepositoriesRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchLinkableGitRepositoriesRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchLinkableGitRepositoriesRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchLinkableGitRepositoriesRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchLinkableGitRepositoriesRequest"
    }
}

/// Response message for FetchLinkableGitRepositories.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchLinkableGitRepositoriesResponse {
    /// The git repositories that can be linked to the connection.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub linkable_git_repositories: std::vec::Vec<crate::model::LinkableGitRepository>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchLinkableGitRepositoriesResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [linkable_git_repositories][crate::model::FetchLinkableGitRepositoriesResponse::linkable_git_repositories].
    pub fn set_linkable_git_repositories<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::LinkableGitRepository>,
    {
        use std::iter::Iterator;
        self.linkable_git_repositories = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchLinkableGitRepositoriesResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchLinkableGitRepositoriesResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchLinkableGitRepositoriesResponse"
    }
}

#[doc(hidden)]
impl gax::paginator::internal::PageableResponse for FetchLinkableGitRepositoriesResponse {
    type PageItem = crate::model::LinkableGitRepository;

    fn items(self) -> std::vec::Vec<Self::PageItem> {
        self.linkable_git_repositories
    }

    fn next_page_token(&self) -> std::string::String {
        use std::clone::Clone;
        self.next_page_token.clone()
    }
}

/// LinkableGitRepository represents a git repository that can be linked to a
/// connection.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct LinkableGitRepository {
    /// The clone uri of the repository.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub clone_uri: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl LinkableGitRepository {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [clone_uri][crate::model::LinkableGitRepository::clone_uri].
    pub fn set_clone_uri<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.clone_uri = v.into();
        self
    }
}

impl wkt::message::Message for LinkableGitRepository {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.LinkableGitRepository"
    }
}

/// Request for fetching github installations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitHubInstallationsRequest {
    /// Required. The resource name of the connection in the format
    /// `projects/*/locations/*/connections/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub connection: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitHubInstallationsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [connection][crate::model::FetchGitHubInstallationsRequest::connection].
    pub fn set_connection<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.connection = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitHubInstallationsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsRequest"
    }
}

/// Response of fetching github installations.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitHubInstallationsResponse {
    /// List of installations available to the OAuth user (for github.com)
    /// or all the installations (for GitHub enterprise).
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub installations:
        std::vec::Vec<crate::model::fetch_git_hub_installations_response::Installation>,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitHubInstallationsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [installations][crate::model::FetchGitHubInstallationsResponse::installations].
    pub fn set_installations<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<crate::model::fetch_git_hub_installations_response::Installation>,
    {
        use std::iter::Iterator;
        self.installations = v.into_iter().map(|i| i.into()).collect();
        self
    }
}

impl wkt::message::Message for FetchGitHubInstallationsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsResponse"
    }
}

/// Defines additional types related to [FetchGitHubInstallationsResponse].
pub mod fetch_git_hub_installations_response {
    #[allow(unused_imports)]
    use super::*;

    /// Represents an installation of the GitHub App.
    #[serde_with::serde_as]
    #[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
    #[serde(default, rename_all = "camelCase")]
    #[non_exhaustive]
    pub struct Installation {
        /// ID of the installation in GitHub.
        #[serde(skip_serializing_if = "wkt::internal::is_default")]
        #[serde_as(as = "wkt::internal::I64")]
        pub id: i64,

        /// Name of the GitHub user or organization that owns this installation.
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub name: std::string::String,

        /// Either "user" or "organization".
        #[serde(rename = "type")]
        #[serde(skip_serializing_if = "std::string::String::is_empty")]
        pub r#type: std::string::String,

        #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
        _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
    }

    impl Installation {
        pub fn new() -> Self {
            std::default::Default::default()
        }

        /// Sets the value of [id][crate::model::fetch_git_hub_installations_response::Installation::id].
        pub fn set_id<T: std::convert::Into<i64>>(mut self, v: T) -> Self {
            self.id = v.into();
            self
        }

        /// Sets the value of [name][crate::model::fetch_git_hub_installations_response::Installation::name].
        pub fn set_name<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.name = v.into();
            self
        }

        /// Sets the value of [r#type][crate::model::fetch_git_hub_installations_response::Installation::type].
        pub fn set_type<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
            self.r#type = v.into();
            self
        }
    }

    impl wkt::message::Message for Installation {
        fn typename() -> &'static str {
            "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitHubInstallationsResponse.Installation"
        }
    }
}

/// Request for fetching git refs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitRefsRequest {
    /// Required. The resource name of GitRepositoryLink in the format
    /// `projects/*/locations/*/connections/*/gitRepositoryLinks/*`.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub git_repository_link: std::string::String,

    /// Required. Type of refs to fetch.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    pub ref_type: crate::model::fetch_git_refs_request::RefType,

    /// Optional. Number of results to return in the list. Default to 20.
    #[serde(skip_serializing_if = "wkt::internal::is_default")]
    #[serde_as(as = "wkt::internal::I32")]
    pub page_size: i32,

    /// Optional. Page start.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsRequest {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [git_repository_link][crate::model::FetchGitRefsRequest::git_repository_link].
    pub fn set_git_repository_link<T: std::convert::Into<std::string::String>>(
        mut self,
        v: T,
    ) -> Self {
        self.git_repository_link = v.into();
        self
    }

    /// Sets the value of [ref_type][crate::model::FetchGitRefsRequest::ref_type].
    pub fn set_ref_type<T: std::convert::Into<crate::model::fetch_git_refs_request::RefType>>(
        mut self,
        v: T,
    ) -> Self {
        self.ref_type = v.into();
        self
    }

    /// Sets the value of [page_size][crate::model::FetchGitRefsRequest::page_size].
    pub fn set_page_size<T: std::convert::Into<i32>>(mut self, v: T) -> Self {
        self.page_size = v.into();
        self
    }

    /// Sets the value of [page_token][crate::model::FetchGitRefsRequest::page_token].
    pub fn set_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitRefsRequest {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitRefsRequest"
    }
}

/// Defines additional types related to [FetchGitRefsRequest].
pub mod fetch_git_refs_request {
    #[allow(unused_imports)]
    use super::*;

    /// Type of refs.
    ///
    /// # Working with unknown values
    ///
    /// This enum is defined as `#[non_exhaustive]` because Google Cloud may add
    /// additional enum variants at any time. Adding new variants is not considered
    /// a breaking change. Applications should write their code in anticipation of:
    ///
    /// - New values appearing in future releases of the client library, **and**
    /// - New values received dynamically, without application changes.
    ///
    /// Please consult the [Working with enums] section in the user guide for some
    /// guidelines.
    ///
    /// [Working with enums]: https://google-cloud-rust.github.io/working_with_enums.html
    #[derive(Clone, Debug, PartialEq)]
    #[non_exhaustive]
    pub enum RefType {
        /// No type specified.
        Unspecified,
        /// To fetch tags.
        Tag,
        /// To fetch branches.
        Branch,
        /// If set, the enum was initialized with an unknown value.
        ///
        /// Applications can examine the value using [RefType::value] or
        /// [RefType::name].
        UnknownValue(ref_type::UnknownValue),
    }

    #[doc(hidden)]
    pub mod ref_type {
        #[allow(unused_imports)]
        use super::*;
        #[derive(Clone, Debug, PartialEq)]
        pub struct UnknownValue(pub(crate) wkt::internal::UnknownEnumValue);
    }

    impl RefType {
        /// Gets the enum value.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the string representation of enums.
        pub fn value(&self) -> std::option::Option<i32> {
            match self {
                Self::Unspecified => std::option::Option::Some(0),
                Self::Tag => std::option::Option::Some(1),
                Self::Branch => std::option::Option::Some(2),
                Self::UnknownValue(u) => u.0.value(),
            }
        }

        /// Gets the enum value as a string.
        ///
        /// Returns `None` if the enum contains an unknown value deserialized from
        /// the integer representation of enums.
        pub fn name(&self) -> std::option::Option<&str> {
            match self {
                Self::Unspecified => std::option::Option::Some("REF_TYPE_UNSPECIFIED"),
                Self::Tag => std::option::Option::Some("TAG"),
                Self::Branch => std::option::Option::Some("BRANCH"),
                Self::UnknownValue(u) => u.0.name(),
            }
        }
    }

    impl std::default::Default for RefType {
        fn default() -> Self {
            use std::convert::From;
            Self::from(0)
        }
    }

    impl std::fmt::Display for RefType {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::result::Result<(), std::fmt::Error> {
            wkt::internal::display_enum(f, self.name(), self.value())
        }
    }

    impl std::convert::From<i32> for RefType {
        fn from(value: i32) -> Self {
            match value {
                0 => Self::Unspecified,
                1 => Self::Tag,
                2 => Self::Branch,
                _ => Self::UnknownValue(ref_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::Integer(value),
                )),
            }
        }
    }

    impl std::convert::From<&str> for RefType {
        fn from(value: &str) -> Self {
            use std::string::ToString;
            match value {
                "REF_TYPE_UNSPECIFIED" => Self::Unspecified,
                "TAG" => Self::Tag,
                "BRANCH" => Self::Branch,
                _ => Self::UnknownValue(ref_type::UnknownValue(
                    wkt::internal::UnknownEnumValue::String(value.to_string()),
                )),
            }
        }
    }

    impl serde::ser::Serialize for RefType {
        fn serialize<S>(&self, serializer: S) -> std::result::Result<S::Ok, S::Error>
        where
            S: serde::Serializer,
        {
            match self {
                Self::Unspecified => serializer.serialize_i32(0),
                Self::Tag => serializer.serialize_i32(1),
                Self::Branch => serializer.serialize_i32(2),
                Self::UnknownValue(u) => u.0.serialize(serializer),
            }
        }
    }

    impl<'de> serde::de::Deserialize<'de> for RefType {
        fn deserialize<D>(deserializer: D) -> std::result::Result<Self, D::Error>
        where
            D: serde::Deserializer<'de>,
        {
            deserializer.deserialize_any(wkt::internal::EnumVisitor::<RefType>::new(
                ".google.cloud.developerconnect.v1.FetchGitRefsRequest.RefType",
            ))
        }
    }
}

/// Response for fetching git refs.
#[serde_with::serde_as]
#[derive(Clone, Debug, Default, PartialEq, serde::Deserialize, serde::Serialize)]
#[serde(default, rename_all = "camelCase")]
#[non_exhaustive]
pub struct FetchGitRefsResponse {
    /// Name of the refs fetched.
    #[serde(skip_serializing_if = "std::vec::Vec::is_empty")]
    pub ref_names: std::vec::Vec<std::string::String>,

    /// A token identifying a page of results the server should return.
    #[serde(skip_serializing_if = "std::string::String::is_empty")]
    pub next_page_token: std::string::String,

    #[serde(flatten, skip_serializing_if = "serde_json::Map::is_empty")]
    _unknown_fields: serde_json::Map<std::string::String, serde_json::Value>,
}

impl FetchGitRefsResponse {
    pub fn new() -> Self {
        std::default::Default::default()
    }

    /// Sets the value of [ref_names][crate::model::FetchGitRefsResponse::ref_names].
    pub fn set_ref_names<T, V>(mut self, v: T) -> Self
    where
        T: std::iter::IntoIterator<Item = V>,
        V: std::convert::Into<std::string::String>,
    {
        use std::iter::Iterator;
        self.ref_names = v.into_iter().map(|i| i.into()).collect();
        self
    }

    /// Sets the value of [next_page_token][crate::model::FetchGitRefsResponse::next_page_token].
    pub fn set_next_page_token<T: std::convert::Into<std::string::String>>(mut self, v: T) -> Self {
        self.next_page_token = v.into();
        self
    }
}

impl wkt::message::Message for FetchGitRefsResponse {
    fn typename() -> &'static str {
        "type.googleapis.com/google.cloud.developerconnect.v1.FetchGitRefsResponse"
    }
}
